<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>Enhanced C#: Loyc.Collections.FVList&lt; T &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Enhanced C#
   </div>
   <div id="projectbrief">Language of your choice: library documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Events</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceLoyc.html">Loyc</a></li><li class="navelem"><a class="el" href="namespaceLoyc_1_1Collections.html">Collections</a></li><li class="navelem"><a class="el" href="structLoyc_1_1Collections_1_1FVList_3_01T_01_4.html">FVList< T ></a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Nested classes</a> &#124;
<a href="#pub-static-attribs">Public static fields</a> &#124;
<a href="#properties">Properties</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="structLoyc_1_1Collections_1_1FVList_3_01T_01_4-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Loyc.Collections.FVList&lt; T &gt; Struct Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A reference to a FVList, a so-called persistent list data structure.  
 <a href="structLoyc_1_1Collections_1_1FVList_3_01T_01_4.html#details">More...</a></p>
<hr/><b>Source file</b>:<ul>
<li><a href='https://github.com/qwertie/ecsharp/tree/master/Core/Loyc.Collections/VLists/FVList.cs'>/Core/Loyc.Collections/VLists/FVList.cs</a></li>
</ul>
<div class="dynheader">
Inheritance diagram for Loyc.Collections.FVList&lt; T &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="structLoyc_1_1Collections_1_1FVList_3_01T_01_4.png" usemap="#Loyc.Collections.FVList&lt; T &gt;_map" alt=""/>
  <map id="Loyc.Collections.FVList&lt; T &gt;_map" name="Loyc.Collections.FVList&lt; T &gt;_map">
<area href="interfaceLoyc_1_1Collections_1_1IListAndListSource_3_01T_01_4.html" title="This interface combines the original IList{T} interface with its "source" (read-only) component inter..." alt="Loyc.Collections.IListAndListSource&lt; T &gt;" shape="rect" coords="289,112,568,136"/>
<area href="interfaceLoyc_1_1ICloneable_3_01out_01T_01_4.html" title="Interface for types that can duplicate themselves." alt="Loyc.ICloneable&lt; out T &gt;" shape="rect" coords="578,112,857,136"/>
<area href="interfaceLoyc_1_1Collections_1_1IListSource_3_01out_01T_01_4.html" title="A read-only list indexed by an integer." alt="Loyc.Collections.IListSource&lt; out T &gt;" shape="rect" coords="289,56,568,80"/>
<area href="interfaceLoyc_1_1Collections_1_1ICollectionAndReadOnly_3_01T_01_4.html" title="This interface combines the original ICollection{T} with IReadOnlyCollection{T}. It exists for the sa..." alt="Loyc.Collections.ICollectionAndReadOnly&lt; T &gt;" shape="rect" coords="722,56,1001,80"/>
<area href="structLoyc_1_1Collections_1_1FVList_3_01T_01_4_1_1Enumerator.html" title="Enumerator for FVList; also used by FWList." alt="Loyc.Collections.FVList&lt; T &gt;.Enumerator" shape="rect" coords="578,224,857,248"/>
</map>
 </div></div>
<a name="details" id="details"></a><h2 class="groupheader">Remarks</h2>
<div class="textblock"><p>A reference to a FVList, a so-called persistent list data structure. </p>
<p>An <a href="http://www.codeproject.com/Articles/26171/VList-data-structures-in-C">article</a> is available online about the VList data types. </p>
<p>See the remarks of VListBlock{T} for more information about VLists. Items are normally added to, and removed from, the front of a FVList or to the back of a VList; adding, removing or changing items at any other position is inefficient. You can call <a class="el" href="structLoyc_1_1Collections_1_1FVList_3_01T_01_4.html#ad9765e79b00f47377c2d63a1d81206ca" title="Returns this list as a VList, which effectively reverses the order of the elements.">ToVList()</a> to convert a FVList to its equivalent VList, which is a reverse-order view of the same list that shares the same memory. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Nested classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1FVList_3_01T_01_4_1_1Enumerator.html">Enumerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structLoyc_1_1Collections_1_1FVList_3_01T_01_4_1_1Enumerator.html" title="Enumerator for FVList; also used by FWList.">Enumerator</a> for FVList; also used by FWList. <a href="structLoyc_1_1Collections_1_1FVList_3_01T_01_4_1_1Enumerator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Public static fields</h2></td></tr>
<tr class="memitem:ae4553fe189d6ec2080e0402433e24955"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae4553fe189d6ec2080e0402433e24955"></a>
static readonly FVList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Empty</b> = new FVList&lt;T&gt;()</td></tr>
<tr class="separator:ae4553fe189d6ec2080e0402433e24955"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:ab7eb2243f167627d926419681db9d5cb"><td class="memItemLeft" align="right" valign="top">FVList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1FVList_3_01T_01_4.html#ab7eb2243f167627d926419681db9d5cb">Tail</a><code> [get]</code></td></tr>
<tr class="memdesc:ab7eb2243f167627d926419681db9d5cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list without the first item. If the list is empty, an empty list is retured. <a href="#ab7eb2243f167627d926419681db9d5cb">More...</a><br /></td></tr>
<tr class="separator:ab7eb2243f167627d926419681db9d5cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6399dc2254a262ef444a9512cfe11e19"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1FVList_3_01T_01_4.html#a6399dc2254a262ef444a9512cfe11e19">First</a><code> [get]</code></td></tr>
<tr class="memdesc:a6399dc2254a262ef444a9512cfe11e19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the front item of the list (at index 0), which is the head of the list. <a href="#a6399dc2254a262ef444a9512cfe11e19">More...</a><br /></td></tr>
<tr class="separator:a6399dc2254a262ef444a9512cfe11e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed428649930a337a249cadfc9e007508"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed428649930a337a249cadfc9e007508"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsEmpty</b><code> [get]</code></td></tr>
<tr class="separator:aed428649930a337a249cadfc9e007508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad21d8b12c6ff3f55096e9e7e91ac39bc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1FVList_3_01T_01_4.html#ad21d8b12c6ff3f55096e9e7e91ac39bc">BlockChainLength</a><code> [get]</code></td></tr>
<tr class="memdesc:ad21d8b12c6ff3f55096e9e7e91ac39bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of blocks used by this list. <a href="#ad21d8b12c6ff3f55096e9e7e91ac39bc">More...</a><br /></td></tr>
<tr class="separator:ad21d8b12c6ff3f55096e9e7e91ac39bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19c45f68840c2797a740fe260b220cc9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a19c45f68840c2797a740fe260b220cc9"></a>
T&#160;</td><td class="memItemRight" valign="bottom"><b>this[int index]</b><code> [get, set]</code></td></tr>
<tr class="separator:a19c45f68840c2797a740fe260b220cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6926ff321711b9fb6089192415274ed8"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1FVList_3_01T_01_4.html#a6926ff321711b9fb6089192415274ed8">this[int index, T defaultValue]</a><code> [get]</code></td></tr>
<tr class="memdesc:a6926ff321711b9fb6089192415274ed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an item from the list at the specified index; returns defaultValue if the index is not valid. <a href="#a6926ff321711b9fb6089192415274ed8">More...</a><br /></td></tr>
<tr class="separator:a6926ff321711b9fb6089192415274ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a29af6dcdcb4f63d6d5f8666a207976"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a29af6dcdcb4f63d6d5f8666a207976"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>Count</b><code> [get]</code></td></tr>
<tr class="separator:a7a29af6dcdcb4f63d6d5f8666a207976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a086df98a07dd24a85b2f6d6b697339fd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a086df98a07dd24a85b2f6d6b697339fd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsReadOnly</b><code> [get]</code></td></tr>
<tr class="separator:a086df98a07dd24a85b2f6d6b697339fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6a29bcaeb6792e151858863b97e2c4de"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a29bcaeb6792e151858863b97e2c4de"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>FVList</b> (T firstItem)</td></tr>
<tr class="separator:a6a29bcaeb6792e151858863b97e2c4de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2ebfff4066cc38d04af40f6666427d3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac2ebfff4066cc38d04af40f6666427d3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>FVList</b> (T itemZero, T itemOne)</td></tr>
<tr class="separator:ac2ebfff4066cc38d04af40f6666427d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae17f7162e7ebd8e7c84cfc218b74e88f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae17f7162e7ebd8e7c84cfc218b74e88f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>FVList</b> (T[] array)</td></tr>
<tr class="separator:ae17f7162e7ebd8e7c84cfc218b74e88f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97804870dab5871587c391cd1a9088a1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a97804870dab5871587c391cd1a9088a1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>FVList</b> (IList&lt; T &gt; list)</td></tr>
<tr class="separator:a97804870dab5871587c391cd1a9088a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29aefb2d5570d6d4ccfe52d35892bdaa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a29aefb2d5570d6d4ccfe52d35892bdaa"></a>
FVList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>WithoutFirst</b> (int offset)</td></tr>
<tr class="separator:a29aefb2d5570d6d4ccfe52d35892bdaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e10c54dbadbd3a03b4b28b69047156d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e10c54dbadbd3a03b4b28b69047156d"></a>
FVList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>PreviousIn</b> (FVList&lt; T &gt; largerList)</td></tr>
<tr class="separator:a0e10c54dbadbd3a03b4b28b69047156d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a526b421ae51666f42b1a266f872fc302"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a526b421ae51666f42b1a266f872fc302"></a>
FVList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Last</b> (int count)</td></tr>
<tr class="separator:a526b421ae51666f42b1a266f872fc302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a060d6f48ababe01b2e32c455c2e25dab"><td class="memItemLeft" align="right" valign="top">override bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1FVList_3_01T_01_4.html#a060d6f48ababe01b2e32c455c2e25dab">Equals</a> (object rhs_)</td></tr>
<tr class="memdesc:a060d6f48ababe01b2e32c455c2e25dab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the two list references are the same. Does not compare the contents of the lists. <a href="#a060d6f48ababe01b2e32c455c2e25dab">More...</a><br /></td></tr>
<tr class="separator:a060d6f48ababe01b2e32c455c2e25dab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad6531fc53c5875e3f08725babbea009"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad6531fc53c5875e3f08725babbea009"></a>
override int&#160;</td><td class="memItemRight" valign="bottom"><b>GetHashCode</b> ()</td></tr>
<tr class="separator:aad6531fc53c5875e3f08725babbea009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa76af99fcc3a79a87d48384975a8c8d8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa76af99fcc3a79a87d48384975a8c8d8"></a>
FVList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>AddRange</b> (FVList&lt; T &gt; list)</td></tr>
<tr class="separator:aa76af99fcc3a79a87d48384975a8c8d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e592a869c8b2e4e4f9bd8a97634d948"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e592a869c8b2e4e4f9bd8a97634d948"></a>
FVList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>AddRange</b> (FVList&lt; T &gt; list, FVList&lt; T &gt; excludeSubList)</td></tr>
<tr class="separator:a3e592a869c8b2e4e4f9bd8a97634d948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aef1c7e08de479159e86c0b78cc6e7e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7aef1c7e08de479159e86c0b78cc6e7e"></a>
FVList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>AddRange</b> (IList&lt; T &gt; list)</td></tr>
<tr class="separator:a7aef1c7e08de479159e86c0b78cc6e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fbe5c3ec2b96e5b29ef689a65e3e6bf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7fbe5c3ec2b96e5b29ef689a65e3e6bf"></a>
FVList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>InsertRange</b> (int index, IList&lt; T &gt; list)</td></tr>
<tr class="separator:a7fbe5c3ec2b96e5b29ef689a65e3e6bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac162aa15ae727906e91df203c51b118a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac162aa15ae727906e91df203c51b118a"></a>
FVList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>RemoveRange</b> (int index, int count)</td></tr>
<tr class="separator:ac162aa15ae727906e91df203c51b118a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17f037fe233581f06847af5350b93747"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1FVList_3_01T_01_4.html#a17f037fe233581f06847af5350b93747">Pop</a> ()</td></tr>
<tr class="memdesc:a17f037fe233581f06847af5350b93747"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the front item (at index 0) from the list and returns it. <a href="#a17f037fe233581f06847af5350b93747">More...</a><br /></td></tr>
<tr class="separator:a17f037fe233581f06847af5350b93747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae40ace421e465ad45217b7ccc0027809"><td class="memItemLeft" align="right" valign="top">FVList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1FVList_3_01T_01_4.html#ae40ace421e465ad45217b7ccc0027809">Push</a> (T item)</td></tr>
<tr class="memdesc:ae40ace421e465ad45217b7ccc0027809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym for <a class="el" href="structLoyc_1_1Collections_1_1FVList_3_01T_01_4.html#a9060ebd876553a443e2ab3f893eb2c47" title="Inserts an item at the front (index 0) of the FVList.">Add()</a>; adds an item to the front of the list. <a href="#ae40ace421e465ad45217b7ccc0027809">More...</a><br /></td></tr>
<tr class="separator:ae40ace421e465ad45217b7ccc0027809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9765e79b00f47377c2d63a1d81206ca"><td class="memItemLeft" align="right" valign="top">VList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1FVList_3_01T_01_4.html#ad9765e79b00f47377c2d63a1d81206ca">ToVList</a> ()</td></tr>
<tr class="memdesc:ad9765e79b00f47377c2d63a1d81206ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this list as a VList, which effectively reverses the order of the elements. <a href="#ad9765e79b00f47377c2d63a1d81206ca">More...</a><br /></td></tr>
<tr class="separator:ad9765e79b00f47377c2d63a1d81206ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d36956fe52b034192e9485087d1b039"><td class="memItemLeft" align="right" valign="top">FWList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1FVList_3_01T_01_4.html#a6d36956fe52b034192e9485087d1b039">ToFWList</a> ()</td></tr>
<tr class="memdesc:a6d36956fe52b034192e9485087d1b039"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this list as a FWList. <a href="#a6d36956fe52b034192e9485087d1b039">More...</a><br /></td></tr>
<tr class="separator:a6d36956fe52b034192e9485087d1b039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f6a93dca2f799f4810a4650774daa11"><td class="memItemLeft" align="right" valign="top">WList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1FVList_3_01T_01_4.html#a0f6a93dca2f799f4810a4650774daa11">ToWList</a> ()</td></tr>
<tr class="memdesc:a0f6a93dca2f799f4810a4650774daa11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this list as a WList, which effectively reverses the order of the elements. <a href="#a0f6a93dca2f799f4810a4650774daa11">More...</a><br /></td></tr>
<tr class="separator:a0f6a93dca2f799f4810a4650774daa11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c32c209034d4bd151898ad0e89a985"><td class="memItemLeft" align="right" valign="top">T[]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1FVList_3_01T_01_4.html#a32c32c209034d4bd151898ad0e89a985">ToArray</a> ()</td></tr>
<tr class="memdesc:a32c32c209034d4bd151898ad0e89a985"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the FVList converted to an array. <a href="#a32c32c209034d4bd151898ad0e89a985">More...</a><br /></td></tr>
<tr class="separator:a32c32c209034d4bd151898ad0e89a985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5375ba02c633e8dec38cc6eb4133f46"><td class="memItemLeft" align="right" valign="top">FVList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1FVList_3_01T_01_4.html#ac5375ba02c633e8dec38cc6eb4133f46">SmartAdd</a> (T item, FVList&lt; T &gt; original)</td></tr>
<tr class="memdesc:ac5375ba02c633e8dec38cc6eb4133f46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the specified item to the list, or original.WithoutFirst(original.Count - Count - 1) if doing so is equivalent. <a href="#ac5375ba02c633e8dec38cc6eb4133f46">More...</a><br /></td></tr>
<tr class="separator:ac5375ba02c633e8dec38cc6eb4133f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05972ac24f4a564cbb1e62031af2913d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a05972ac24f4a564cbb1e62031af2913d"></a>
FVList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>SmartAdd</b> (T item, ref FVList&lt; T &gt; original)</td></tr>
<tr class="separator:a05972ac24f4a564cbb1e62031af2913d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a685d01d82768d13c6b739d6395a883c0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1FVList_3_01T_01_4.html#a685d01d82768d13c6b739d6395a883c0">IndexOf</a> (T item)</td></tr>
<tr class="memdesc:a685d01d82768d13c6b739d6395a883c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for the specified object and returns the zero-based index of the first occurrence (lowest index) within the entire FVList. <a href="#a685d01d82768d13c6b739d6395a883c0">More...</a><br /></td></tr>
<tr class="separator:a685d01d82768d13c6b739d6395a883c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d0dde621d6c18153c541347d20e75e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a64d0dde621d6c18153c541347d20e75e"></a>
<a class="el" href="structLoyc_1_1void.html">void</a> IList&lt; T &gt;.&#160;</td><td class="memItemRight" valign="bottom"><b>Insert</b> (int index, T item)</td></tr>
<tr class="separator:a64d0dde621d6c18153c541347d20e75e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf481d2c3c6c57366c41c00bf7fae493"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf481d2c3c6c57366c41c00bf7fae493"></a>
FVList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Insert</b> (int index, T item)</td></tr>
<tr class="separator:adf481d2c3c6c57366c41c00bf7fae493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94aaa7918e4aacb4d1a945b839378dee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94aaa7918e4aacb4d1a945b839378dee"></a>
<a class="el" href="structLoyc_1_1void.html">void</a> IList&lt; T &gt;.&#160;</td><td class="memItemRight" valign="bottom"><b>RemoveAt</b> (int index)</td></tr>
<tr class="separator:a94aaa7918e4aacb4d1a945b839378dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa193494efddb1fbf05f42987d889f381"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa193494efddb1fbf05f42987d889f381"></a>
FVList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>RemoveAt</b> (int index)</td></tr>
<tr class="separator:aa193494efddb1fbf05f42987d889f381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9060ebd876553a443e2ab3f893eb2c47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1void.html">void</a> ICollection&lt; T &gt;.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1FVList_3_01T_01_4.html#a9060ebd876553a443e2ab3f893eb2c47">Add</a> (T item)</td></tr>
<tr class="memdesc:a9060ebd876553a443e2ab3f893eb2c47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an item at the front (index 0) of the FVList. <a href="#a9060ebd876553a443e2ab3f893eb2c47">More...</a><br /></td></tr>
<tr class="separator:a9060ebd876553a443e2ab3f893eb2c47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba55150453b13d7bd2e262bf2fac248c"><td class="memItemLeft" align="right" valign="top">FVList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1FVList_3_01T_01_4.html#aba55150453b13d7bd2e262bf2fac248c">Add</a> (T item)</td></tr>
<tr class="memdesc:aba55150453b13d7bd2e262bf2fac248c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an item at the front (index 0) of the FVList. <a href="#aba55150453b13d7bd2e262bf2fac248c">More...</a><br /></td></tr>
<tr class="separator:aba55150453b13d7bd2e262bf2fac248c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4fd1dd32ee074a62ad323e9a68fa614"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab4fd1dd32ee074a62ad323e9a68fa614"></a>
<a class="el" href="structLoyc_1_1void.html">void</a> ICollection&lt; T &gt;.&#160;</td><td class="memItemRight" valign="bottom"><b>Clear</b> ()</td></tr>
<tr class="separator:ab4fd1dd32ee074a62ad323e9a68fa614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01a3b0a43407d0d851dd97cf24f895c4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01a3b0a43407d0d851dd97cf24f895c4"></a>
FVList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Clear</b> ()</td></tr>
<tr class="separator:a01a3b0a43407d0d851dd97cf24f895c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a432a02750f1886f53bcf1cbab3b173f8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a432a02750f1886f53bcf1cbab3b173f8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Contains</b> (T item)</td></tr>
<tr class="separator:a432a02750f1886f53bcf1cbab3b173f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a269debac9dc052ca7fd2b460ba984cdf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a269debac9dc052ca7fd2b460ba984cdf"></a>
<a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CopyTo</b> (T[] array, int arrayIndex)</td></tr>
<tr class="separator:a269debac9dc052ca7fd2b460ba984cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a0b8f69776243e94e3639a68d656455"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a0b8f69776243e94e3639a68d656455"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Remove</b> (T item)</td></tr>
<tr class="separator:a6a0b8f69776243e94e3639a68d656455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affbbde38bf767097f97ba4a2fbc89849"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="affbbde38bf767097f97ba4a2fbc89849"></a>
Enumerator&#160;</td><td class="memItemRight" valign="bottom"><b>GetEnumerator</b> ()</td></tr>
<tr class="separator:affbbde38bf767097f97ba4a2fbc89849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e115cd6d3804a2fbf9fdd0c39cd9c1b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e115cd6d3804a2fbf9fdd0c39cd9c1b"></a>
IEnumerator&lt; T &gt; IEnumerable&lt; T &gt;.&#160;</td><td class="memItemRight" valign="bottom"><b>GetEnumerator</b> ()</td></tr>
<tr class="separator:a0e115cd6d3804a2fbf9fdd0c39cd9c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa7c64a343250e5424672eccca7ad45e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa7c64a343250e5424672eccca7ad45e"></a>
System.Collections.IEnumerator <br class="typebreak" />
System.Collections.IEnumerable.&#160;</td><td class="memItemRight" valign="bottom"><b>GetEnumerator</b> ()</td></tr>
<tr class="separator:aaa7c64a343250e5424672eccca7ad45e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33c70e2d1121f34587b305cf69b43102"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1FVList_3_01T_01_4.html#a33c70e2d1121f34587b305cf69b43102">TryGet</a> (int index, out bool fail)</td></tr>
<tr class="memdesc:a33c70e2d1121f34587b305cf69b43102"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the item at the specified index, and does not throw an exception on failure. <a href="#a33c70e2d1121f34587b305cf69b43102">More...</a><br /></td></tr>
<tr class="separator:a33c70e2d1121f34587b305cf69b43102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff5a2a576a48f72daf41a13c65137ce3"><td class="memItemLeft" align="right" valign="top">IRange&lt; T &gt; IListSource&lt; T &gt;.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1FVList_3_01T_01_4.html#aff5a2a576a48f72daf41a13c65137ce3">Slice</a> (int start, int count)</td></tr>
<tr class="memdesc:aff5a2a576a48f72daf41a13c65137ce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a sub-range of this list. <a href="#aff5a2a576a48f72daf41a13c65137ce3">More...</a><br /></td></tr>
<tr class="separator:aff5a2a576a48f72daf41a13c65137ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9d32de098b082a296ec36d857488b5"><td class="memItemLeft" align="right" valign="top">Slice_&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1FVList_3_01T_01_4.html#aca9d32de098b082a296ec36d857488b5">Slice</a> (int start, int count=int.MaxValue)</td></tr>
<tr class="memdesc:aca9d32de098b082a296ec36d857488b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a sub-range of this list. <a href="#aca9d32de098b082a296ec36d857488b5">More...</a><br /></td></tr>
<tr class="separator:aca9d32de098b082a296ec36d857488b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace07bc34add9da293c4fb6427f61cf8f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace07bc34add9da293c4fb6427f61cf8f"></a>
FVList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Clone</b> ()</td></tr>
<tr class="separator:ace07bc34add9da293c4fb6427f61cf8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2be2bf9506eb37cdd5205a82e47250fc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2be2bf9506eb37cdd5205a82e47250fc"></a>
object ICloneable.&#160;</td><td class="memItemRight" valign="bottom"><b>Clone</b> ()</td></tr>
<tr class="separator:a2be2bf9506eb37cdd5205a82e47250fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a461e85a96247ea4922803a499e7a6a33"><td class="memItemLeft" align="right" valign="top">FVList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1FVList_3_01T_01_4.html#a461e85a96247ea4922803a499e7a6a33">Where</a> (Predicate&lt; T &gt; filter)</td></tr>
<tr class="memdesc:a461e85a96247ea4922803a499e7a6a33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a filter to a list, to exclude zero or more items. <a href="#a461e85a96247ea4922803a499e7a6a33">More...</a><br /></td></tr>
<tr class="separator:a461e85a96247ea4922803a499e7a6a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cddbf313a0c80e34e8d24d13ae14aaf"><td class="memItemLeft" align="right" valign="top">FVList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1FVList_3_01T_01_4.html#a1cddbf313a0c80e34e8d24d13ae14aaf">WhereSelect</a> (Func&lt; T, <a class="el" href="classLoyc_1_1Maybe.html">Maybe</a>&lt; T &gt;&gt; filter)</td></tr>
<tr class="memdesc:a1cddbf313a0c80e34e8d24d13ae14aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters and maps a list with a user-defined function. <a href="#a1cddbf313a0c80e34e8d24d13ae14aaf">More...</a><br /></td></tr>
<tr class="separator:a1cddbf313a0c80e34e8d24d13ae14aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0f5fec404f3e8233235190ca6e42c44"><td class="memItemLeft" align="right" valign="top">FVList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1FVList_3_01T_01_4.html#ac0f5fec404f3e8233235190ca6e42c44">SmartSelect</a> (Func&lt; T, T &gt; map)</td></tr>
<tr class="memdesc:ac0f5fec404f3e8233235190ca6e42c44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a list to another list of the same length. <a href="#ac0f5fec404f3e8233235190ca6e42c44">More...</a><br /></td></tr>
<tr class="separator:ac0f5fec404f3e8233235190ca6e42c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f96eb744be41cec9850a1f7cc6677bf"><td class="memItemLeft" align="right" valign="top">FVList&lt; Out &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1FVList_3_01T_01_4.html#a3f96eb744be41cec9850a1f7cc6677bf">Select&lt; Out &gt;</a> (Func&lt; T, Out &gt; map)</td></tr>
<tr class="memdesc:a3f96eb744be41cec9850a1f7cc6677bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a list to another list of the same length. <a href="#a3f96eb744be41cec9850a1f7cc6677bf">More...</a><br /></td></tr>
<tr class="separator:a3f96eb744be41cec9850a1f7cc6677bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00aaff73e8bd2e48b545a53d9dbc8047"><td class="memItemLeft" align="right" valign="top">FVList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1FVList_3_01T_01_4.html#a00aaff73e8bd2e48b545a53d9dbc8047">Transform</a> (VListTransformer&lt; T &gt; x)</td></tr>
<tr class="memdesc:a00aaff73e8bd2e48b545a53d9dbc8047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a list (combines filtering with selection and more). <a href="#a00aaff73e8bd2e48b545a53d9dbc8047">More...</a><br /></td></tr>
<tr class="separator:a00aaff73e8bd2e48b545a53d9dbc8047"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a88e70e42e09d14f5cb6529cbb8f16f03"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1FVList_3_01T_01_4.html#a88e70e42e09d14f5cb6529cbb8f16f03">operator==</a> (FVList&lt; T &gt; lhs, FVList&lt; T &gt; rhs)</td></tr>
<tr class="memdesc:a88e70e42e09d14f5cb6529cbb8f16f03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the two list references are the same. Does not compare the contents of the lists. <a href="#a88e70e42e09d14f5cb6529cbb8f16f03">More...</a><br /></td></tr>
<tr class="separator:a88e70e42e09d14f5cb6529cbb8f16f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5526e04b2e646564a3b861f4e62f18b1"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1FVList_3_01T_01_4.html#a5526e04b2e646564a3b861f4e62f18b1">operator!=</a> (FVList&lt; T &gt; lhs, FVList&lt; T &gt; rhs)</td></tr>
<tr class="memdesc:a5526e04b2e646564a3b861f4e62f18b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the two list references are different. Does not compare the contents of the lists. <a href="#a5526e04b2e646564a3b861f4e62f18b1">More...</a><br /></td></tr>
<tr class="separator:a5526e04b2e646564a3b861f4e62f18b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a012fb0e5dd9d9a750cfba1344c2afde3"><td class="memItemLeft" align="right" valign="top">static&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1FVList_3_01T_01_4.html#a012fb0e5dd9d9a750cfba1344c2afde3">operator VList&lt; T &gt;</a> (FVList&lt; T &gt; list)</td></tr>
<tr class="memdesc:a012fb0e5dd9d9a750cfba1344c2afde3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this list as a VList, which effectively reverses the order of the elements. <a href="#a012fb0e5dd9d9a750cfba1344c2afde3">More...</a><br /></td></tr>
<tr class="separator:a012fb0e5dd9d9a750cfba1344c2afde3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57f8fd1f27782ec90b2c49e5746e865"><td class="memItemLeft" align="right" valign="top">static&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1FVList_3_01T_01_4.html#ab57f8fd1f27782ec90b2c49e5746e865">operator FWList&lt; T &gt;</a> (FVList&lt; T &gt; list)</td></tr>
<tr class="memdesc:ab57f8fd1f27782ec90b2c49e5746e865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this list as a FWList. <a href="#ab57f8fd1f27782ec90b2c49e5746e865">More...</a><br /></td></tr>
<tr class="separator:ab57f8fd1f27782ec90b2c49e5746e865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7649fd2ea7ff0c5c8cfad4a4fde566e"><td class="memItemLeft" align="right" valign="top">static&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1FVList_3_01T_01_4.html#ac7649fd2ea7ff0c5c8cfad4a4fde566e">operator WList&lt; T &gt;</a> (FVList&lt; T &gt; list)</td></tr>
<tr class="memdesc:ac7649fd2ea7ff0c5c8cfad4a4fde566e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this list as a WList, which effectively reverses the order of the elements. <a href="#ac7649fd2ea7ff0c5c8cfad4a4fde566e">More...</a><br /></td></tr>
<tr class="separator:ac7649fd2ea7ff0c5c8cfad4a4fde566e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a9060ebd876553a443e2ab3f893eb2c47"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1void.html">void</a> ICollection&lt;T&gt;. Loyc.Collections.FVList&lt; T &gt;.Add </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts an item at the front (index 0) of the FVList.</p>

<p>References <a class="el" href="structLoyc_1_1Collections_1_1FVList_3_01T_01_4.html#a9060ebd876553a443e2ab3f893eb2c47">Loyc.Collections.FVList&lt; T &gt;.Add()</a>.</p>

<p>Referenced by <a class="el" href="structLoyc_1_1Collections_1_1FVList_3_01T_01_4.html#a9060ebd876553a443e2ab3f893eb2c47">Loyc.Collections.FVList&lt; T &gt;.Add()</a>.</p>

</div>
</div>
<a class="anchor" id="aba55150453b13d7bd2e262bf2fac248c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FVList&lt;T&gt; Loyc.Collections.FVList&lt; T &gt;.Add </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts an item at the front (index 0) of the FVList.</p>

</div>
</div>
<a class="anchor" id="a060d6f48ababe01b2e32c455c2e25dab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">override bool Loyc.Collections.FVList&lt; T &gt;.Equals </td>
          <td>(</td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>rhs_</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the two list references are the same. Does not compare the contents of the lists.</p>

</div>
</div>
<a class="anchor" id="a685d01d82768d13c6b739d6395a883c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Loyc.Collections.FVList&lt; T &gt;.IndexOf </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for the specified object and returns the zero-based index of the first occurrence (lowest index) within the entire FVList.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>Item to locate (can be null if T can be null)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index of the item, or -1 if it was not found.</dd></dl>
<p>This method determines equality using the default equality comparer EqualityComparer.Default for T, the type of values in the list.</p>
<p>This method performs a linear search; therefore, this method is an O(n) operation, where n is Count. </p>

</div>
</div>
<a class="anchor" id="ab57f8fd1f27782ec90b2c49e5746e865"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Loyc.Collections.FVList&lt; T &gt;.operator FWList&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">FVList&lt; T &gt;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns this list as a FWList.</p>
<p>The list contents are not copied until you modify the FWList.</p>

</div>
</div>
<a class="anchor" id="a012fb0e5dd9d9a750cfba1344c2afde3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Loyc.Collections.FVList&lt; T &gt;.operator VList&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">FVList&lt; T &gt;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns this list as a VList, which effectively reverses the order of the elements.</p>
<p>This is a trivial operation; the VList shares the same memory.</p>

</div>
</div>
<a class="anchor" id="ac7649fd2ea7ff0c5c8cfad4a4fde566e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Loyc.Collections.FVList&lt; T &gt;.operator WList&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">FVList&lt; T &gt;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns this list as a WList, which effectively reverses the order of the elements.</p>
<p>The list contents are not copied until you modify the WList.</p>

</div>
</div>
<a class="anchor" id="a5526e04b2e646564a3b861f4e62f18b1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Loyc.Collections.FVList&lt; T &gt;.operator!= </td>
          <td>(</td>
          <td class="paramtype">FVList&lt; T &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FVList&lt; T &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the two list references are different. Does not compare the contents of the lists.</p>

</div>
</div>
<a class="anchor" id="a88e70e42e09d14f5cb6529cbb8f16f03"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Loyc.Collections.FVList&lt; T &gt;.operator== </td>
          <td>(</td>
          <td class="paramtype">FVList&lt; T &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FVList&lt; T &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the two list references are the same. Does not compare the contents of the lists.</p>

</div>
</div>
<a class="anchor" id="a17f037fe233581f06847af5350b93747"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Loyc.Collections.FVList&lt; T &gt;.Pop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the front item (at index 0) from the list and returns it.</p>

</div>
</div>
<a class="anchor" id="ae40ace421e465ad45217b7ccc0027809"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FVList&lt;T&gt; Loyc.Collections.FVList&lt; T &gt;.Push </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Synonym for <a class="el" href="structLoyc_1_1Collections_1_1FVList_3_01T_01_4.html#a9060ebd876553a443e2ab3f893eb2c47" title="Inserts an item at the front (index 0) of the FVList.">Add()</a>; adds an item to the front of the list.</p>

<p>References <a class="el" href="namespaceLoyc_1_1Collections.html#ab3f241a3b553681db7ce9ce14147e4eeaec211f7c20af43e742bf2570c3cb84f9">Loyc.Collections.Add</a>.</p>

</div>
</div>
<a class="anchor" id="a3f96eb744be41cec9850a1f7cc6677bf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FVList&lt;Out&gt; Loyc.Collections.FVList&lt; T &gt;.Select&lt; Out &gt; </td>
          <td>(</td>
          <td class="paramtype">Func&lt; T, Out &gt;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps a list to another list of the same length.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>A function that transforms each item in the list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The list after the map function is applied to each item. The original FVList structure is not modified.</dd></dl>

</div>
</div>
<a class="anchor" id="aff5a2a576a48f72daf41a13c65137ce3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IRange&lt;T&gt; IListSource&lt;T&gt;. Loyc.Collections.FVList&lt; T &gt;.Slice </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a sub-range of this list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>The new range will start at this index in the current list (this location will be index [0] in the new range).</td></tr>
    <tr><td class="paramname">count</td><td>The desired number of elements in the new range, or int.MaxValue to get all elements until the end of the list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a sub-range of this range.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentException</td><td>The start index was below zero.</td></tr>
  </table>
  </dd>
</dl>
<p>The (start, count) range is allowed to be invalid, as long as start is zero or above. </p><ul>
<li>
If count is below zero, or if start is above the original Count, the Count of the new slice is set to zero. </li>
<li>
if (start + count) is above the original Count, the Count of the new slice is reduced to <code>this.Count - start</code>. Implementation note: do not compute (start + count) because it may overflow. Instead, test whether (count &gt; this.Count - start). </li>
</ul>
<p>Most collections should use the following implementation: </p><pre>
IRange&lt;T&gt; IListSource&lt;T&gt;.<a class="el" href="structLoyc_1_1Collections_1_1FVList_3_01T_01_4.html#aff5a2a576a48f72daf41a13c65137ce3" title="Returns a sub-range of this list.">Slice(int start, int count)</a> { return Slice(start, count); }
public Slice_&lt;T&gt; <a class="el" href="structLoyc_1_1Collections_1_1FVList_3_01T_01_4.html#aff5a2a576a48f72daf41a13c65137ce3" title="Returns a sub-range of this list.">Slice(int start, int count)</a> { return new Slice_&lt;T&gt;(this, start, count); }
</pre> 
<p>Implements <a class="el" href="interfaceLoyc_1_1Collections_1_1IListSource_3_01out_01T_01_4.html#a49a212d9cf49315abb46c5c276521351">Loyc.Collections.IListSource&lt; out T &gt;</a>.</p>

<p>References <a class="el" href="structLoyc_1_1Collections_1_1FVList_3_01T_01_4.html#aff5a2a576a48f72daf41a13c65137ce3">Loyc.Collections.FVList&lt; T &gt;.Slice()</a>.</p>

<p>Referenced by <a class="el" href="structLoyc_1_1Collections_1_1FVList_3_01T_01_4.html#aff5a2a576a48f72daf41a13c65137ce3">Loyc.Collections.FVList&lt; T &gt;.Slice()</a>.</p>

</div>
</div>
<a class="anchor" id="aca9d32de098b082a296ec36d857488b5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Slice_&lt;T&gt; Loyc.Collections.FVList&lt; T &gt;.Slice </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em> = <code>int.MaxValue</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a sub-range of this list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>The new range will start at this index in the current list (this location will be index [0] in the new range).</td></tr>
    <tr><td class="paramname">count</td><td>The desired number of elements in the new range, or int.MaxValue to get all elements until the end of the list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a sub-range of this range.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentException</td><td>The start index was below zero.</td></tr>
  </table>
  </dd>
</dl>
<p>The (start, count) range is allowed to be invalid, as long as start is zero or above. </p><ul>
<li>
If count is below zero, or if start is above the original Count, the Count of the new slice is set to zero. </li>
<li>
if (start + count) is above the original Count, the Count of the new slice is reduced to <code>this.Count - start</code>. Implementation note: do not compute (start + count) because it may overflow. Instead, test whether (count &gt; this.Count - start). </li>
</ul>
<p>Most collections should use the following implementation: </p><pre>
IRange&lt;T&gt; IListSource&lt;T&gt;.<a class="el" href="structLoyc_1_1Collections_1_1FVList_3_01T_01_4.html#aff5a2a576a48f72daf41a13c65137ce3" title="Returns a sub-range of this list.">Slice(int start, int count)</a> { return Slice(start, count); }
public Slice_&lt;T&gt; <a class="el" href="structLoyc_1_1Collections_1_1FVList_3_01T_01_4.html#aff5a2a576a48f72daf41a13c65137ce3" title="Returns a sub-range of this list.">Slice(int start, int count)</a> { return new Slice_&lt;T&gt;(this, start, count); }
</pre> 
<p>Implements <a class="el" href="interfaceLoyc_1_1Collections_1_1IListSource_3_01out_01T_01_4.html#a49a212d9cf49315abb46c5c276521351">Loyc.Collections.IListSource&lt; out T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ac5375ba02c633e8dec38cc6eb4133f46"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FVList&lt;T&gt; Loyc.Collections.FVList&lt; T &gt;.SmartAdd </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FVList&lt; T &gt;&#160;</td>
          <td class="paramname"><em>original</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the specified item to the list, or original.WithoutFirst(original.Count - Count - 1) if doing so is equivalent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>Item to add</td></tr>
    <tr><td class="paramname">original</td><td>An old version of the list</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns this.</dd></dl>
<p>This method helps write functional code in which you process an input list and produce an output list that may or may not be the same as the input list. In case the output list is identical, you would prefer to return the original input list rather than wasting memory on a new list. <a class="el" href="structLoyc_1_1Collections_1_1FVList_3_01T_01_4.html#ac5375ba02c633e8dec38cc6eb4133f46" title="Adds the specified item to the list, or original.WithoutFirst(original.Count - Count - 1) if doing so...">SmartAdd()</a> helps you do this. The following method demonstrates <a class="el" href="structLoyc_1_1Collections_1_1FVList_3_01T_01_4.html#ac5375ba02c633e8dec38cc6eb4133f46" title="Adds the specified item to the list, or original.WithoutFirst(original.Count - Count - 1) if doing so...">SmartAdd()</a> by removing all negative numbers from a list:  FVList&lt;int&gt; RemoveNegative(FVList&lt;int&gt; input) { var output = FVList&lt;int&gt;.Empty; // Enumerate tail-to-head foreach (int n in (VList&lt;int&gt;)input) if (n &gt;= 0) output.SmartAdd(n, input); return output; } </p>
<p>You could also do the same thing with input.Filter(delegate(int i) { return i; } &gt;= 0) </p>

</div>
</div>
<a class="anchor" id="ac0f5fec404f3e8233235190ca6e42c44"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FVList&lt;T&gt; Loyc.Collections.FVList&lt; T &gt;.SmartSelect </td>
          <td>(</td>
          <td class="paramtype">Func&lt; T, T &gt;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps a list to another list of the same length.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>A function that transforms each item in the list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The list after the map function is applied to each item. The original FVList structure is not modified.</dd></dl>
<p>This method is called "Smart" because of what happens if the map doesn't do anything. If the map function returns the first N items unmodified, those N items are typically not copied, but shared between the existing list and the new one. This is useful for functional code that sometimes processes a list without modifying it at all. </p>

</div>
</div>
<a class="anchor" id="a32c32c209034d4bd151898ad0e89a985"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T [] Loyc.Collections.FVList&lt; T &gt;.ToArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the FVList converted to an array.</p>

</div>
</div>
<a class="anchor" id="a6d36956fe52b034192e9485087d1b039"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FWList&lt;T&gt; Loyc.Collections.FVList&lt; T &gt;.ToFWList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns this list as a FWList.</p>
<p>The list contents are not copied until you modify the FWList.</p>

</div>
</div>
<a class="anchor" id="ad9765e79b00f47377c2d63a1d81206ca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VList&lt;T&gt; Loyc.Collections.FVList&lt; T &gt;.ToVList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns this list as a VList, which effectively reverses the order of the elements.</p>
<dl class="section return"><dt>Returns</dt><dd>This is a trivial operation; the VList shares the same memory.</dd></dl>

</div>
</div>
<a class="anchor" id="a0f6a93dca2f799f4810a4650774daa11"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">WList&lt;T&gt; Loyc.Collections.FVList&lt; T &gt;.ToWList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns this list as a WList, which effectively reverses the order of the elements.</p>
<p>The list contents are not copied until you modify the WList.</p>

</div>
</div>
<a class="anchor" id="a00aaff73e8bd2e48b545a53d9dbc8047"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FVList&lt;T&gt; Loyc.Collections.FVList&lt; T &gt;.Transform </td>
          <td>(</td>
          <td class="paramtype">VListTransformer&lt; T &gt;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transforms a list (combines filtering with selection and more).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Method to apply to each item in the list</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list formed from transforming all items in the list</dd></dl>
<p>This is my attempt to make an optimized multi-purpose routine for transforming a FVList or VList. It is slightly cumbersome to use, but allows you to do several common operations in one transformer method. </p>
<p>The VListTransformer method takes two arguments: an item and its index in the FVList or VList. It can modify the item if desired, and then it returns a XfAction value, which indicates the action to take. Most often you will return XfAction.Drop, XfAction.Keep, XfAction.Change, which, repectively, drop the item from the output list, copy the item to the output list unchanged (even if you modified the item), and copy the item to the output list (assuming you changed it). </p>
<p><a class="el" href="structLoyc_1_1Collections_1_1FVList_3_01T_01_4.html#a00aaff73e8bd2e48b545a53d9dbc8047" title="Transforms a list (combines filtering with selection and more).">Transform()</a> needs to know if the item changed, at least at first, because if the first items are kept without changes, then the output list can share a common tail with the input list. If the transformer method returns XfAction.Keep for every element, then the output list is exactly the same (operator== returns true). </p>
<p>Of course, it would have been simpler just to return a boolean indicating whether to keep the item, and the Transform method itself could check whether the item changed. But checking for equality is a tad slow in the .NET framework, because there is no bitwise equality operator in .NET, so a virtual function would have to be called instead to test equality, which is especially slow if T is a value type that does not implement IEquatable(of T). </p>
<p>The final possible action, XfAction.Repeat, is like XfAction.Change except that <a class="el" href="structLoyc_1_1Collections_1_1FVList_3_01T_01_4.html#a00aaff73e8bd2e48b545a53d9dbc8047" title="Transforms a list (combines filtering with selection and more).">Transform()</a> calls the VListTransformer again. The second call has the form x(~i, ref item), where ~i is the bitwise NOT of the index i, and item is the same item that x returned the first time it was called. On the second call, x() can return XfAction.Change again to get a third call, if it wants. </p>
<p>XfAction.Repeat is best explained by example. In the following examples, assume "list" is a VList holding the numbers (1, 2, 3):  output = list.Transform((i, ref n) =&gt; { // This example produces (1, 1, 2, 2, 3, 3) return i &gt;= 0 ? XfAction.Repeat : XfAction.Keep; });</p>
<p>output = list.Transform((i, ref n) =&gt; { // This example produces (1, 10, 2, 20, 3, 30) if (i &gt;= 0) return XfAction.Repeat; n *= 10; return XfAction.Change; });</p>
<p>output = list.Transform((i, ref n) =&gt; { // This example produces (10, 1, 20, 2, 30, 3) if (i &gt;= 0) { n *= 10; return XfAction.Repeat; } return XfAction.Keep; });</p>
<p>output = list.Transform((i, ref n) =&gt; { // This example produces (10, 100, 1000, 20, 200, 30, 300) n *= 10; if (n &gt; 1000) return XfAction.Drop; return XfAction.Repeat; }); </p>
<p>And now for some examples using XfAction.Keep, XfAction.Drop and XfAction.Change. Assume list is a VList holding the following integers: (-1, 2, -2, 13, 5, 8, 9)  output = list.Transform((i, ref n) =&gt; { // Keep every second item: (2, 13, 8) return (i % 2) == 1 ? XfAction.Keep : XfAction.Drop; });</p>
<p>output = list.Transform((i, ref n) =&gt; { // Keep odd numbers: (-1, 13, 5, 9) return (n % 2) != 0 ? XfAction.Keep : XfAction.Drop; });</p>
<p>output = list.Transform((i, ref n) =&gt; { // Keep and square all odd numbers: (1, 169, 25, 81) if ((n % 2) != 0) { n *= n; return XfAction.Change; } else return XfAction.Drop; });</p>
<p>output = list.Transform((i, ref n) =&gt; { // Increase each item by its index: (-1, 3, 0, 16, 9, 13, 15) n += i; return i == 0 ? XfAction.Keep : XfAction.Change; }); </p>

</div>
</div>
<a class="anchor" id="a33c70e2d1121f34587b305cf69b43102"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Loyc.Collections.FVList&lt; T &gt;.TryGet </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out bool&#160;</td>
          <td class="paramname"><em>fail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the item at the specified index, and does not throw an exception on failure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>An index in the range 0 to Count-1.</td></tr>
    <tr><td class="paramname">fail</td><td>A flag that is set on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element at the specified index, or default(T) if the index is not valid.</dd></dl>
<p>In my original design, the caller could provide a value to return on failure, but this would not allow T to be marked as "out" in C# 4. For the same reason, we cannot have a ref/out T parameter. Instead, the following extension methods are provided: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code" href="structLoyc_1_1Collections_1_1FVList_3_01T_01_4.html#a33c70e2d1121f34587b305cf69b43102">TryGet</a>(<span class="keywordtype">int</span> index, ref T value);</div>
<div class="line">T <a class="code" href="structLoyc_1_1Collections_1_1FVList_3_01T_01_4.html#a33c70e2d1121f34587b305cf69b43102">TryGet</a>(<span class="keywordtype">int</span>, T defaultValue);</div>
</div><!-- fragment --> 
<p>Implements <a class="el" href="interfaceLoyc_1_1Collections_1_1IListSource_3_01out_01T_01_4.html#a8e7cf6ebac5f60e3eefbd1a75bcad672">Loyc.Collections.IListSource&lt; out T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a461e85a96247ea4922803a499e7a6a33"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FVList&lt;T&gt; Loyc.Collections.FVList&lt; T &gt;.Where </td>
          <td>(</td>
          <td class="paramtype">Predicate&lt; T &gt;&#160;</td>
          <td class="paramname"><em>filter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a filter to a list, to exclude zero or more items.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filter</td><td>A function that chooses which items to include (exclude items by returning false).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The list after filtering has been applied. The original list structure is not modified.</dd></dl>
<p>If the predicate keeps the first N items it is passed (which are the last items in a FVList), those N items are typically not copied, but shared between the existing list and the new one. </p>

</div>
</div>
<a class="anchor" id="a1cddbf313a0c80e34e8d24d13ae14aaf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FVList&lt;T&gt; Loyc.Collections.FVList&lt; T &gt;.WhereSelect </td>
          <td>(</td>
          <td class="paramtype">Func&lt; T, <a class="el" href="classLoyc_1_1Maybe.html">Maybe</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>filter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Filters and maps a list with a user-defined function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filter</td><td>A function that chooses which items to include in a new list, and what to change them to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The list after filtering has been applied. The original list structure is not modified.</dd></dl>
<p>This is a smart function. If the filter does not modify the first N items it is passed (which are the last items in a FVList), those N items are typically not copied, but shared between the existing list and the new one. </p>

</div>
</div>
<h2 class="groupheader">Property Documentation</h2>
<a class="anchor" id="ad21d8b12c6ff3f55096e9e7e91ac39bc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Loyc.Collections.FVList&lt; T &gt;.BlockChainLength</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of blocks used by this list.</p>
<p>You might look at this property when optimizing your program, because the runtime of some operations increases as the chain length increases. This property runs in O(BlockChainLength) time. Ideally, BlockChainLength is proportional to log_2(Count), but certain FVList usage patterns can produce long chains.</p>

</div>
</div>
<a class="anchor" id="a6399dc2254a262ef444a9512cfe11e19"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Loyc.Collections.FVList&lt; T &gt;.First</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the front item of the list (at index 0), which is the head of the list.</p>

<p>Referenced by <a class="el" href="classLoyc_1_1Collections_1_1VListBlock_3_01T_01_4.html#aef7e8a64c57b78e58573a0e5ec0b3c2e">Loyc.Collections.VListBlock&lt; T &gt;.AddRange()</a>.</p>

</div>
</div>
<a class="anchor" id="ab7eb2243f167627d926419681db9d5cb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FVList&lt;T&gt; Loyc.Collections.FVList&lt; T &gt;.Tail</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a list without the first item. If the list is empty, an empty list is retured.</p>

</div>
</div>
<a class="anchor" id="a6926ff321711b9fb6089192415274ed8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Loyc.Collections.FVList&lt; T &gt;.this[int index, T defaultValue]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an item from the list at the specified index; returns defaultValue if the index is not valid.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Mar 24 2016 09:04:49 for Enhanced C# by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
