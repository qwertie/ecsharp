<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Enhanced C#: Loyc.Collections.VList&lt; T &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Enhanced C#
   </div>
   <div id="projectbrief">Language of your choice: library documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceLoyc.html">Loyc</a></li><li class="navelem"><a class="el" href="namespaceLoyc_1_1Collections.html">Collections</a></li><li class="navelem"><a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Nested classes</a> &#124;
<a href="#pub-static-attribs">Public static fields</a> &#124;
<a href="#properties">Properties</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="structLoyc_1_1Collections_1_1VList-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Loyc.Collections.VList&lt; T &gt; Struct Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList. ">VList</a> represents a reference to a reverse-order <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a>.  
 <a href="structLoyc_1_1Collections_1_1VList.html#details">More...</a></p>
<hr/><b>Source file</b>:<ul>
<li><a href='https://github.com/qwertie/ecsharp/tree/master/Core/Loyc.Collections/VLists/VList.cs'>/Core/Loyc.Collections/VLists/VList.cs</a></li>
</ul>
<div class="dynheader">
Inheritance diagram for Loyc.Collections.VList&lt; T &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="structLoyc_1_1Collections_1_1VList.png" usemap="#Loyc.Collections.VList_3C_20T_20_3E_map" alt=""/>
  <map id="Loyc.Collections.VList_3C_20T_20_3E_map" name="Loyc.Collections.VList&lt; T &gt;_map">
<area href="interfaceLoyc_1_1Collections_1_1IListAndListSource.html" title="This interface combines the original IList&lt;T&gt; interface with its &quot;source&quot; (read-only) component inter..." alt="Loyc.Collections.IListAndListSource&lt; T &gt;" shape="rect" coords="293,112,576,136"/>
<area href="interfaceLoyc_1_1ICloneable.html" title="Interface for types that can duplicate themselves." alt="Loyc.ICloneable&lt; out out T &gt;" shape="rect" coords="879,112,1162,136"/>
<area href="interfaceLoyc_1_1Collections_1_1IListSource.html" alt="Loyc.Collections.IListSource&lt; T &gt;" shape="rect" coords="293,56,576,80"/>
<area href="interfaceLoyc_1_1Collections_1_1ICollectionAndReadOnly.html" title="This interface combines the original ICollection&lt;T&gt; with IReadOnlyCollection&lt;T&gt;. It exists for the sa..." alt="Loyc.Collections.ICollectionAndReadOnly&lt; T &gt;" shape="rect" coords="586,56,869,80"/>
</map>
 </div></div>
<a name="details" id="details"></a><h2 class="groupheader">Remarks</h2>
<div class="textblock"><p><a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList. ">VList</a> represents a reference to a reverse-order <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a>. </p>
<p>An <a href="http://www.codeproject.com/Articles/26171/VList-data-structures-in-C">article</a> is available online about the <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList. ">VList</a> data types. </p>
<p>The <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList. ">VList</a> is a persistent list data structure described in Phil Bagwell's 2002 paper "Fast Functional Lists, Hash-Lists, Deques and Variable Length
Arrays". Originally, this type was called RVList because it works in the reverse order to the original <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList. ">VList</a> type: new items are normally added at the <em>beginning</em> of a <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList. ">VList</a>, which is normal in functional languages, but <em>this</em> <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList. ">VList</a> acts like a normal .NET list, so it is optimized for new items to be added at the end. The name "RVList" is ugly, though, since it misleadingly appears to be related to Recreational Vehicles. So as of <a class="el" href="namespaceLeMP.html" title="The lexical macro processor. Main classes: LeMP.Compiler and LeMP.MacroProcessor.">LeMP</a> 1.5, it's called simply <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList. ">VList</a>. </p>
<p>In contrast, the FVList&lt;T&gt; type acts like the original <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList. ">VList</a>; its Add method puts new items at the beginning (index 0). </p>
<p>See the remarks of VListBlock&lt;T&gt; for a more detailed description. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Nested classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList_1_1Enumerator.html">Enumerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerates through a <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList. ">VList</a> from index 0 up to index Count-1.  <a href="structLoyc_1_1Collections_1_1VList_1_1Enumerator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Public static fields</h2></td></tr>
<tr class="memitem:abc7f0c354f5dd93a19544fb2789457c1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc7f0c354f5dd93a19544fb2789457c1"></a>
static readonly <a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Empty</b> = new <a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt;T&gt;()</td></tr>
<tr class="separator:abc7f0c354f5dd93a19544fb2789457c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:a9c25e96b43013e9eee3ac4cf0b974abf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList.html#a9c25e96b43013e9eee3ac4cf0b974abf">Tail</a><code> [get]</code></td></tr>
<tr class="memdesc:a9c25e96b43013e9eee3ac4cf0b974abf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list without the last item. If the list is empty, an empty list is retured. <a href="#a9c25e96b43013e9eee3ac4cf0b974abf">More...</a><br /></td></tr>
<tr class="separator:a9c25e96b43013e9eee3ac4cf0b974abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab429ef27c6d66520883bc8402d8e7653"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList.html#ab429ef27c6d66520883bc8402d8e7653">Last</a><code> [get]</code></td></tr>
<tr class="memdesc:ab429ef27c6d66520883bc8402d8e7653"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last item of the list (at index Count-1), which is the head of the list. <a href="#ab429ef27c6d66520883bc8402d8e7653">More...</a><br /></td></tr>
<tr class="separator:ab429ef27c6d66520883bc8402d8e7653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9956cbc7b7e2f3a61a8c79f426c7fd16"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9956cbc7b7e2f3a61a8c79f426c7fd16"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsEmpty</b><code> [get]</code></td></tr>
<tr class="separator:a9956cbc7b7e2f3a61a8c79f426c7fd16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8dd2d71b3e33709014c1bf2b27a115c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList.html#ae8dd2d71b3e33709014c1bf2b27a115c">BlockChainLength</a><code> [get]</code></td></tr>
<tr class="memdesc:ae8dd2d71b3e33709014c1bf2b27a115c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of blocks used by this list. <a href="#ae8dd2d71b3e33709014c1bf2b27a115c">More...</a><br /></td></tr>
<tr class="separator:ae8dd2d71b3e33709014c1bf2b27a115c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2509357ad130fd1ff4d68ff29dee0e02"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2509357ad130fd1ff4d68ff29dee0e02"></a>
T&#160;</td><td class="memItemRight" valign="bottom"><b>this[int index]</b><code> [get, set]</code></td></tr>
<tr class="separator:a2509357ad130fd1ff4d68ff29dee0e02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab55e9bfa5eef58ad18ed164a699a2826"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList.html#ab55e9bfa5eef58ad18ed164a699a2826">this[int index, T defaultValue]</a><code> [get]</code></td></tr>
<tr class="memdesc:ab55e9bfa5eef58ad18ed164a699a2826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an item from the list at the specified index; returns defaultValue if the index is not valid. <a href="#ab55e9bfa5eef58ad18ed164a699a2826">More...</a><br /></td></tr>
<tr class="separator:ab55e9bfa5eef58ad18ed164a699a2826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a006234308f4535503c6967b8c5c854f2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a006234308f4535503c6967b8c5c854f2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>Count</b><code> [get]</code></td></tr>
<tr class="separator:a006234308f4535503c6967b8c5c854f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac50502d8f75972a9293cd6dbff7161e3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac50502d8f75972a9293cd6dbff7161e3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsReadOnly</b><code> [get]</code></td></tr>
<tr class="separator:ac50502d8f75972a9293cd6dbff7161e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5693af4d4b3bd0e56ca7c7f32ce1c306"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5693af4d4b3bd0e56ca7c7f32ce1c306"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>VList</b> (T firstItem)</td></tr>
<tr class="separator:a5693af4d4b3bd0e56ca7c7f32ce1c306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6287c4d9f68723fe1956096accf082ff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6287c4d9f68723fe1956096accf082ff"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>VList</b> (T itemZero, T itemOne)</td></tr>
<tr class="separator:a6287c4d9f68723fe1956096accf082ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc48194e27d26b1b5ae4be9eb24449a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8bc48194e27d26b1b5ae4be9eb24449a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>VList</b> (T[] array)</td></tr>
<tr class="separator:a8bc48194e27d26b1b5ae4be9eb24449a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1af0454542f853c16d4232c0b6c5fe76"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1af0454542f853c16d4232c0b6c5fe76"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>VList</b> (IEnumerable&lt; T &gt; list)</td></tr>
<tr class="separator:a1af0454542f853c16d4232c0b6c5fe76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ea59126e5d402d669787636120328a2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ea59126e5d402d669787636120328a2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>VList</b> (<a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt; list)</td></tr>
<tr class="separator:a5ea59126e5d402d669787636120328a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0899349e78497c6ddb833ebad4d1bd08"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0899349e78497c6ddb833ebad4d1bd08"></a>
<a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>WithoutLast</b> (int offset)</td></tr>
<tr class="separator:a0899349e78497c6ddb833ebad4d1bd08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad96940de9beecfbbcab6623faffbb020"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad96940de9beecfbbcab6623faffbb020"></a>
<a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>NextIn</b> (<a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt; largerList)</td></tr>
<tr class="separator:ad96940de9beecfbbcab6623faffbb020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f1dedb0ba93cd276ad45a793b5b1e39"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f1dedb0ba93cd276ad45a793b5b1e39"></a>
<a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>First</b> (int count)</td></tr>
<tr class="separator:a0f1dedb0ba93cd276ad45a793b5b1e39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab03b31527812c8eff3e9b2cd8187734b"><td class="memItemLeft" align="right" valign="top">override bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList.html#ab03b31527812c8eff3e9b2cd8187734b">Equals</a> (object rhs_)</td></tr>
<tr class="memdesc:ab03b31527812c8eff3e9b2cd8187734b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the two list references are the same. Does not compare the contents of the lists. <a href="#ab03b31527812c8eff3e9b2cd8187734b">More...</a><br /></td></tr>
<tr class="separator:ab03b31527812c8eff3e9b2cd8187734b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3030763f880cb7812641c6f672c0279"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab3030763f880cb7812641c6f672c0279"></a>
override int&#160;</td><td class="memItemRight" valign="bottom"><b>GetHashCode</b> ()</td></tr>
<tr class="separator:ab3030763f880cb7812641c6f672c0279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7bf480c11b01b35a8e4794aa1be143f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa7bf480c11b01b35a8e4794aa1be143f"></a>
<a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>AddRange</b> (<a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt; list)</td></tr>
<tr class="separator:aa7bf480c11b01b35a8e4794aa1be143f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb1e3987e527c215cbb0d00191d79253"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb1e3987e527c215cbb0d00191d79253"></a>
<a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>AddRange</b> (<a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt; list, <a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt; excludeSubList)</td></tr>
<tr class="separator:afb1e3987e527c215cbb0d00191d79253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae84491e016b4280fadb21a6f194451c7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae84491e016b4280fadb21a6f194451c7"></a>
<a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>AddRange</b> (IList&lt; T &gt; list)</td></tr>
<tr class="separator:ae84491e016b4280fadb21a6f194451c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab535df73b58a212cbdd98de0fbbd7d2f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab535df73b58a212cbdd98de0fbbd7d2f"></a>
<a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>AddRange</b> (IEnumerable&lt; T &gt; list)</td></tr>
<tr class="separator:ab535df73b58a212cbdd98de0fbbd7d2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d36690c919cc215921ab8a26122ff41"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d36690c919cc215921ab8a26122ff41"></a>
<a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>InsertRange</b> (int index, IList&lt; T &gt; list)</td></tr>
<tr class="separator:a3d36690c919cc215921ab8a26122ff41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5973a0a7f688b8711bcbb1641f1ff96"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae5973a0a7f688b8711bcbb1641f1ff96"></a>
<a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>RemoveRange</b> (int index, int count)</td></tr>
<tr class="separator:ae5973a0a7f688b8711bcbb1641f1ff96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a436ad98f6f524870b45ece96733ffcf8"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList.html#a436ad98f6f524870b45ece96733ffcf8">Pop</a> ()</td></tr>
<tr class="memdesc:a436ad98f6f524870b45ece96733ffcf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the last item (at index Count-1) from the list and returns it. <a href="#a436ad98f6f524870b45ece96733ffcf8">More...</a><br /></td></tr>
<tr class="separator:a436ad98f6f524870b45ece96733ffcf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb01b7f5cdbb7f1b933fe8a051c19318"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList.html#adb01b7f5cdbb7f1b933fe8a051c19318">Push</a> (T item)</td></tr>
<tr class="memdesc:adb01b7f5cdbb7f1b933fe8a051c19318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym for <a class="el" href="structLoyc_1_1Collections_1_1VList.html#a2899333f96298ded3387aab12021b349" title="Inserts an item at the back (index Count) of the VList.">Add()</a>; adds an item to the front of the list. <a href="#adb01b7f5cdbb7f1b933fe8a051c19318">More...</a><br /></td></tr>
<tr class="separator:adb01b7f5cdbb7f1b933fe8a051c19318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95dbf9520695ec0b6cf4d90993c668c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1Collections_1_1FVList.html">FVList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList.html#a95dbf9520695ec0b6cf4d90993c668c1">ToFVList</a> ()</td></tr>
<tr class="memdesc:a95dbf9520695ec0b6cf4d90993c668c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this list as a <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a>, which effectively reverses the order of the elements. <a href="#a95dbf9520695ec0b6cf4d90993c668c1">More...</a><br /></td></tr>
<tr class="separator:a95dbf9520695ec0b6cf4d90993c668c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d4385955fa9d1be7981ddc252d6f8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLoyc_1_1Collections_1_1FWList.html">FWList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList.html#a49d4385955fa9d1be7981ddc252d6f8e">ToFWList</a> ()</td></tr>
<tr class="memdesc:a49d4385955fa9d1be7981ddc252d6f8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this list as a <a class="el" href="classLoyc_1_1Collections_1_1FWList.html" title="FWList is the mutable variant of the FVList data structure. ">FWList</a>, which effectively reverses the order of the elements. <a href="#a49d4385955fa9d1be7981ddc252d6f8e">More...</a><br /></td></tr>
<tr class="separator:a49d4385955fa9d1be7981ddc252d6f8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad66059b968b4840ebd52c7fb53fd6b1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLoyc_1_1Collections_1_1WList.html">WList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList.html#ad66059b968b4840ebd52c7fb53fd6b1e">ToWList</a> ()</td></tr>
<tr class="memdesc:ad66059b968b4840ebd52c7fb53fd6b1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this list as an <a class="el" href="classLoyc_1_1Collections_1_1WList.html" title="WList is the mutable variant of the VList data structure. ">WList</a>. <a href="#ad66059b968b4840ebd52c7fb53fd6b1e">More...</a><br /></td></tr>
<tr class="separator:ad66059b968b4840ebd52c7fb53fd6b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1afb6082c7800d527b48570c2b37389"><td class="memItemLeft" align="right" valign="top">T[]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList.html#ab1afb6082c7800d527b48570c2b37389">ToArray</a> ()</td></tr>
<tr class="memdesc:ab1afb6082c7800d527b48570c2b37389"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList. ">VList</a> converted to an array. <a href="#ab1afb6082c7800d527b48570c2b37389">More...</a><br /></td></tr>
<tr class="separator:ab1afb6082c7800d527b48570c2b37389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c80ebfc94685daacd87c4c483aff72"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList.html#ac9c80ebfc94685daacd87c4c483aff72">IndexOf</a> (T item)</td></tr>
<tr class="memdesc:ac9c80ebfc94685daacd87c4c483aff72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for the specified object and returns the zero-based index of the first occurrence (lowest index) within the entire <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList. ">VList</a>. <a href="#ac9c80ebfc94685daacd87c4c483aff72">More...</a><br /></td></tr>
<tr class="separator:ac9c80ebfc94685daacd87c4c483aff72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4290cc3bc5b8af2cb2a017b60879fa2c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4290cc3bc5b8af2cb2a017b60879fa2c"></a>
<a class="el" href="structLoyc_1_1void.html">void</a> IList&lt; T &gt;.&#160;</td><td class="memItemRight" valign="bottom"><b>Insert</b> (int index, T item)</td></tr>
<tr class="separator:a4290cc3bc5b8af2cb2a017b60879fa2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d0f5fc125aa70a87a5a51500f77a52"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a14d0f5fc125aa70a87a5a51500f77a52"></a>
<a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Insert</b> (int index, T item)</td></tr>
<tr class="separator:a14d0f5fc125aa70a87a5a51500f77a52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19115167d1db0e6e97887e4b55377def"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a19115167d1db0e6e97887e4b55377def"></a>
<a class="el" href="structLoyc_1_1void.html">void</a> IList&lt; T &gt;.&#160;</td><td class="memItemRight" valign="bottom"><b>RemoveAt</b> (int index)</td></tr>
<tr class="separator:a19115167d1db0e6e97887e4b55377def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5414401fdf86784dfb8b43d8cf7e4af1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5414401fdf86784dfb8b43d8cf7e4af1"></a>
<a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>RemoveAt</b> (int index)</td></tr>
<tr class="separator:a5414401fdf86784dfb8b43d8cf7e4af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2899333f96298ded3387aab12021b349"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1void.html">void</a> ICollection&lt; T &gt;.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList.html#a2899333f96298ded3387aab12021b349">Add</a> (T item)</td></tr>
<tr class="memdesc:a2899333f96298ded3387aab12021b349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an item at the back (index Count) of the <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList. ">VList</a>. <a href="#a2899333f96298ded3387aab12021b349">More...</a><br /></td></tr>
<tr class="separator:a2899333f96298ded3387aab12021b349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fdd1ee9e7d7ab4ebac20749a046f5f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList.html#a1fdd1ee9e7d7ab4ebac20749a046f5f9">Add</a> (T item)</td></tr>
<tr class="memdesc:a1fdd1ee9e7d7ab4ebac20749a046f5f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an item at the back (index Count) of the <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList. ">VList</a>. <a href="#a1fdd1ee9e7d7ab4ebac20749a046f5f9">More...</a><br /></td></tr>
<tr class="separator:a1fdd1ee9e7d7ab4ebac20749a046f5f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e0676836fa05195947074c6e887fdcf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e0676836fa05195947074c6e887fdcf"></a>
<a class="el" href="structLoyc_1_1void.html">void</a> ICollection&lt; T &gt;.&#160;</td><td class="memItemRight" valign="bottom"><b>Clear</b> ()</td></tr>
<tr class="separator:a6e0676836fa05195947074c6e887fdcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56dc2d69cd93de24d0e548622684578a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a56dc2d69cd93de24d0e548622684578a"></a>
<a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Clear</b> ()</td></tr>
<tr class="separator:a56dc2d69cd93de24d0e548622684578a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a664b39c0a7a4a4aafb61a0a24e1e45a9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a664b39c0a7a4a4aafb61a0a24e1e45a9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Contains</b> (T item)</td></tr>
<tr class="separator:a664b39c0a7a4a4aafb61a0a24e1e45a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8364d8d0aa2632224c542d63f1a75ad8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8364d8d0aa2632224c542d63f1a75ad8"></a>
<a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CopyTo</b> (T[] array, int arrayIndex)</td></tr>
<tr class="separator:a8364d8d0aa2632224c542d63f1a75ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c6bdb8ef56811f23148a205597402c1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c6bdb8ef56811f23148a205597402c1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Remove</b> (T item)</td></tr>
<tr class="separator:a2c6bdb8ef56811f23148a205597402c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02dfe871f006cd1e207666a48b5a8539"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a02dfe871f006cd1e207666a48b5a8539"></a>
<a class="el" href="structLoyc_1_1Collections_1_1VList_1_1Enumerator.html">Enumerator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetEnumerator</b> ()</td></tr>
<tr class="separator:a02dfe871f006cd1e207666a48b5a8539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa5901c96c9e13a2ffcca24862c3294"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9fa5901c96c9e13a2ffcca24862c3294"></a>
IEnumerator&lt; T &gt; IEnumerable&lt; T &gt;.&#160;</td><td class="memItemRight" valign="bottom"><b>GetEnumerator</b> ()</td></tr>
<tr class="separator:a9fa5901c96c9e13a2ffcca24862c3294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2882c1acee7b83d59e53425194038761"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2882c1acee7b83d59e53425194038761"></a>
System.Collections.IEnumerator System.Collections.IEnumerable.&#160;</td><td class="memItemRight" valign="bottom"><b>GetEnumerator</b> ()</td></tr>
<tr class="separator:a2882c1acee7b83d59e53425194038761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43d397c93e83cadbc2b4a9b63838bff3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a43d397c93e83cadbc2b4a9b63838bff3"></a>
T&#160;</td><td class="memItemRight" valign="bottom"><b>TryGet</b> (int index, out bool fail)</td></tr>
<tr class="separator:a43d397c93e83cadbc2b4a9b63838bff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b073e9a68a581e95ef5214558a96eb4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b073e9a68a581e95ef5214558a96eb4"></a>
<a class="el" href="interfaceLoyc_1_1Collections_1_1IRange.html">IRange</a>&lt; T &gt; <a class="el" href="interfaceLoyc_1_1Collections_1_1IListSource.html">IListSource</a>&lt; T &gt;.&#160;</td><td class="memItemRight" valign="bottom"><b>Slice</b> (int start, int count)</td></tr>
<tr class="separator:a3b073e9a68a581e95ef5214558a96eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f7386cfc2ca334af863b0a4144db35"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa1f7386cfc2ca334af863b0a4144db35"></a>
<a class="el" href="structLoyc_1_1Collections_1_1Slice__.html">Slice_</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Slice</b> (int start, int count=int.MaxValue)</td></tr>
<tr class="separator:aa1f7386cfc2ca334af863b0a4144db35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f8a9a57799a100c0f92d765b047175"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94f8a9a57799a100c0f92d765b047175"></a>
<a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Clone</b> ()</td></tr>
<tr class="separator:a94f8a9a57799a100c0f92d765b047175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3da7a26a9b10f031b9c5f27f34bf3c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b3da7a26a9b10f031b9c5f27f34bf3c"></a>
object ICloneable.&#160;</td><td class="memItemRight" valign="bottom"><b>Clone</b> ()</td></tr>
<tr class="separator:a2b3da7a26a9b10f031b9c5f27f34bf3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a866e9f0ea9f9c84da69cd5b567aa78a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList.html#a866e9f0ea9f9c84da69cd5b567aa78a4">SmartWhere</a> (Func&lt; T, bool &gt; keep)</td></tr>
<tr class="memdesc:a866e9f0ea9f9c84da69cd5b567aa78a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a filter to a list, to exclude zero or more items. <a href="#a866e9f0ea9f9c84da69cd5b567aa78a4">More...</a><br /></td></tr>
<tr class="separator:a866e9f0ea9f9c84da69cd5b567aa78a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3751829c3359ff56319fe6d93b6be40a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList.html#a3751829c3359ff56319fe6d93b6be40a">WhereSelect</a> (Func&lt; T, <a class="el" href="classLoyc_1_1Maybe.html">Maybe</a>&lt; T &gt;&gt; filter)</td></tr>
<tr class="memdesc:a3751829c3359ff56319fe6d93b6be40a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters and maps a list with a user-defined function. <a href="#a3751829c3359ff56319fe6d93b6be40a">More...</a><br /></td></tr>
<tr class="separator:a3751829c3359ff56319fe6d93b6be40a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67946c8c8878afaa9f282b37849a0769"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList.html#a67946c8c8878afaa9f282b37849a0769">SmartSelect</a> (Func&lt; T, T &gt; map)</td></tr>
<tr class="memdesc:a67946c8c8878afaa9f282b37849a0769"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a list to another list of the same length. <a href="#a67946c8c8878afaa9f282b37849a0769">More...</a><br /></td></tr>
<tr class="separator:a67946c8c8878afaa9f282b37849a0769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd2e8766cb1c2ceeab21158402330c57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList.html#acd2e8766cb1c2ceeab21158402330c57">SmartSelectMany</a> (Func&lt; T, IList&lt; T &gt;&gt; map)</td></tr>
<tr class="memdesc:acd2e8766cb1c2ceeab21158402330c57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a list to another list by concatenating the outputs of a mapping function. <a href="#acd2e8766cb1c2ceeab21158402330c57">More...</a><br /></td></tr>
<tr class="separator:acd2e8766cb1c2ceeab21158402330c57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97ff56cf4b4c97f4449e1ccb4bfcd1c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList.html#a97ff56cf4b4c97f4449e1ccb4bfcd1c4">Transform</a> (VListTransformer&lt; T &gt; x)</td></tr>
<tr class="memdesc:a97ff56cf4b4c97f4449e1ccb4bfcd1c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a list (combines filtering with selection and more). <a href="#a97ff56cf4b4c97f4449e1ccb4bfcd1c4">More...</a><br /></td></tr>
<tr class="separator:a97ff56cf4b4c97f4449e1ccb4bfcd1c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_interfaceLoyc_1_1Collections_1_1IListSource"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_interfaceLoyc_1_1Collections_1_1IListSource')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="interfaceLoyc_1_1Collections_1_1IListSource.html">Loyc.Collections.IListSource&lt; T &gt;</a></td></tr>
<tr class="memitem:a19a865ed54cfef48cd244d1343ff83b6 inherit pub_methods_interfaceLoyc_1_1Collections_1_1IListSource"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1Collections_1_1IListSource.html#a19a865ed54cfef48cd244d1343ff83b6">TryGet</a> (int index, out bool fail)</td></tr>
<tr class="memdesc:a19a865ed54cfef48cd244d1343ff83b6 inherit pub_methods_interfaceLoyc_1_1Collections_1_1IListSource"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the item at the specified index, and does not throw an exception on failure. <a href="#a19a865ed54cfef48cd244d1343ff83b6">More...</a><br /></td></tr>
<tr class="separator:a19a865ed54cfef48cd244d1343ff83b6 inherit pub_methods_interfaceLoyc_1_1Collections_1_1IListSource"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52cf4d93658771ea9539ed905d2d91bf inherit pub_methods_interfaceLoyc_1_1Collections_1_1IListSource"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceLoyc_1_1Collections_1_1IRange.html">IRange</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1Collections_1_1IListSource.html#a52cf4d93658771ea9539ed905d2d91bf">Slice</a> (int start, int count=int.MaxValue)</td></tr>
<tr class="memdesc:a52cf4d93658771ea9539ed905d2d91bf inherit pub_methods_interfaceLoyc_1_1Collections_1_1IListSource"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a sub-range of this list. <a href="#a52cf4d93658771ea9539ed905d2d91bf">More...</a><br /></td></tr>
<tr class="separator:a52cf4d93658771ea9539ed905d2d91bf inherit pub_methods_interfaceLoyc_1_1Collections_1_1IListSource"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a629e2c08d382f795462be991062f2709"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList.html#a629e2c08d382f795462be991062f2709">operator==</a> (<a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt; lhs, <a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt; rhs)</td></tr>
<tr class="memdesc:a629e2c08d382f795462be991062f2709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the two list references are the same. Does not compare the contents of the lists. <a href="#a629e2c08d382f795462be991062f2709">More...</a><br /></td></tr>
<tr class="separator:a629e2c08d382f795462be991062f2709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9c3c67c05c68deaf8f9f80243bcd494"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList.html#aa9c3c67c05c68deaf8f9f80243bcd494">operator!=</a> (<a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt; lhs, <a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt; rhs)</td></tr>
<tr class="memdesc:aa9c3c67c05c68deaf8f9f80243bcd494"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the two list references are different. Does not compare the contents of the lists. <a href="#aa9c3c67c05c68deaf8f9f80243bcd494">More...</a><br /></td></tr>
<tr class="separator:aa9c3c67c05c68deaf8f9f80243bcd494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae7bf6afcf7052a323ca885cde5aebc9"><td class="memItemLeft" align="right" valign="top">static&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList.html#aae7bf6afcf7052a323ca885cde5aebc9">operator FVList&lt; T &gt;</a> (<a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt; list)</td></tr>
<tr class="memdesc:aae7bf6afcf7052a323ca885cde5aebc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this list as a <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a>, which effectively reverses the order of the elements. <a href="#aae7bf6afcf7052a323ca885cde5aebc9">More...</a><br /></td></tr>
<tr class="separator:aae7bf6afcf7052a323ca885cde5aebc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7bcc8c1a69531930fa7edbe17c7ca59"><td class="memItemLeft" align="right" valign="top">static&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList.html#ad7bcc8c1a69531930fa7edbe17c7ca59">operator FWList&lt; T &gt;</a> (<a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt; list)</td></tr>
<tr class="memdesc:ad7bcc8c1a69531930fa7edbe17c7ca59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this list as a <a class="el" href="classLoyc_1_1Collections_1_1FWList.html" title="FWList is the mutable variant of the FVList data structure. ">FWList</a>, which effectively reverses the order of the elements. <a href="#ad7bcc8c1a69531930fa7edbe17c7ca59">More...</a><br /></td></tr>
<tr class="separator:ad7bcc8c1a69531930fa7edbe17c7ca59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5456c2d4ea6fd3409f700d5891b32b97"><td class="memItemLeft" align="right" valign="top">static&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList.html#a5456c2d4ea6fd3409f700d5891b32b97">operator WList&lt; T &gt;</a> (<a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt; list)</td></tr>
<tr class="memdesc:a5456c2d4ea6fd3409f700d5891b32b97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this list as an <a class="el" href="classLoyc_1_1Collections_1_1WList.html" title="WList is the mutable variant of the VList data structure. ">WList</a>. <a href="#a5456c2d4ea6fd3409f700d5891b32b97">More...</a><br /></td></tr>
<tr class="separator:a5456c2d4ea6fd3409f700d5891b32b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a2899333f96298ded3387aab12021b349"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1void.html">void</a> ICollection&lt;T&gt;. <a class="el" href="structLoyc_1_1Collections_1_1VList.html">Loyc.Collections.VList</a>&lt; T &gt;.Add </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts an item at the back (index Count) of the <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList. ">VList</a>.</p>

<p>Referenced by <a class="el" href="structLoyc_1_1Collections_1_1VList.html#a2899333f96298ded3387aab12021b349">Loyc.Collections.VList&lt; Loyc.Syntax.LNode &gt;.Add()</a>, <a class="el" href="classLoyc_1_1Syntax_1_1LNodeExt.html#a12a4590905ffa883fd102e47f9b2bf2a">Loyc.Syntax.LNodeExt.AsLNode()</a>, <a class="el" href="classLoyc_1_1LLParserGenerator_1_1Rule.html#a4ada4acb7780613d399da5fa1b250429">Loyc.LLParserGenerator.Rule.CreateMethod()</a>, <a class="el" href="classLoyc_1_1Collections_1_1WList.html#a8eb0140372c610b6de934231f494aa25">Loyc.Collections.WList&lt; Loyc.Syntax.LNode &gt;.Resize()</a>, and <a class="el" href="structLoyc_1_1Collections_1_1VList.html#a97ff56cf4b4c97f4449e1ccb4bfcd1c4">Loyc.Collections.VList&lt; Loyc.Syntax.LNode &gt;.Transform()</a>.</p>

</div>
</div>
<a class="anchor" id="a1fdd1ee9e7d7ab4ebac20749a046f5f9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt;T&gt; <a class="el" href="structLoyc_1_1Collections_1_1VList.html">Loyc.Collections.VList</a>&lt; T &gt;.Add </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts an item at the back (index Count) of the <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList. ">VList</a>.</p>

</div>
</div>
<a class="anchor" id="ab03b31527812c8eff3e9b2cd8187734b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">override bool <a class="el" href="structLoyc_1_1Collections_1_1VList.html">Loyc.Collections.VList</a>&lt; T &gt;.Equals </td>
          <td>(</td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>rhs_</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the two list references are the same. Does not compare the contents of the lists.</p>

<p>Referenced by <a class="el" href="structLoyc_1_1Collections_1_1VList.html#a97ff56cf4b4c97f4449e1ccb4bfcd1c4">Loyc.Collections.VList&lt; Loyc.Syntax.LNode &gt;.Transform()</a>.</p>

</div>
</div>
<a class="anchor" id="ac9c80ebfc94685daacd87c4c483aff72"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="structLoyc_1_1Collections_1_1VList.html">Loyc.Collections.VList</a>&lt; T &gt;.IndexOf </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for the specified object and returns the zero-based index of the first occurrence (lowest index) within the entire <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList. ">VList</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>Item to locate (can be null if T can be null)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index of the item, or -1 if it was not found.</dd></dl>
<p>This method determines equality using the default equality comparer EqualityComparer.Default for T, the type of values in the list.</p>
<p>This method performs a linear search, and is typically an O(n) operation, where n is Count. However, because the list is searched upward from index 0 to Count-1, if the list's blocks do not increase in size exponentially (due to the way that the list has been modified in the past), the search can have worse performance; the (unlikely) worst case is O(n^2). FVList(of T).<a class="el" href="structLoyc_1_1Collections_1_1VList.html#ac9c80ebfc94685daacd87c4c483aff72" title="Searches for the specified object and returns the zero-based index of the first occurrence (lowest in...">IndexOf()</a> doesn't have this problem. </p>

</div>
</div>
<a class="anchor" id="aae7bf6afcf7052a323ca885cde5aebc9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structLoyc_1_1Collections_1_1VList.html">Loyc.Collections.VList</a>&lt; T &gt;.operator <a class="el" href="structLoyc_1_1Collections_1_1FVList.html">FVList</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns this list as a <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a>, which effectively reverses the order of the elements.</p>
<p>This is a trivial operation; the <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a> shares the same memory.</p>

</div>
</div>
<a class="anchor" id="ad7bcc8c1a69531930fa7edbe17c7ca59"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structLoyc_1_1Collections_1_1VList.html">Loyc.Collections.VList</a>&lt; T &gt;.operator <a class="el" href="classLoyc_1_1Collections_1_1FWList.html">FWList</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns this list as a <a class="el" href="classLoyc_1_1Collections_1_1FWList.html" title="FWList is the mutable variant of the FVList data structure. ">FWList</a>, which effectively reverses the order of the elements.</p>
<p>The list contents are not copied until you modify the <a class="el" href="classLoyc_1_1Collections_1_1FWList.html" title="FWList is the mutable variant of the FVList data structure. ">FWList</a>.</p>

</div>
</div>
<a class="anchor" id="a5456c2d4ea6fd3409f700d5891b32b97"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structLoyc_1_1Collections_1_1VList.html">Loyc.Collections.VList</a>&lt; T &gt;.operator <a class="el" href="classLoyc_1_1Collections_1_1WList.html">WList</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns this list as an <a class="el" href="classLoyc_1_1Collections_1_1WList.html" title="WList is the mutable variant of the VList data structure. ">WList</a>.</p>
<p>The list contents are not copied until you modify the <a class="el" href="classLoyc_1_1Collections_1_1WList.html" title="WList is the mutable variant of the VList data structure. ">WList</a>.</p>

</div>
</div>
<a class="anchor" id="aa9c3c67c05c68deaf8f9f80243bcd494"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="structLoyc_1_1Collections_1_1VList.html">Loyc.Collections.VList</a>&lt; T &gt;.operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the two list references are different. Does not compare the contents of the lists.</p>

</div>
</div>
<a class="anchor" id="a629e2c08d382f795462be991062f2709"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="structLoyc_1_1Collections_1_1VList.html">Loyc.Collections.VList</a>&lt; T &gt;.operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the two list references are the same. Does not compare the contents of the lists.</p>

</div>
</div>
<a class="anchor" id="a436ad98f6f524870b45ece96733ffcf8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="structLoyc_1_1Collections_1_1VList.html">Loyc.Collections.VList</a>&lt; T &gt;.Pop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the last item (at index Count-1) from the list and returns it.</p>

<p>Referenced by <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#abf6a7f1abe7b71318de17bdecb402517">Loyc.Syntax.LNode.Equals()</a>, and <a class="el" href="structLoyc_1_1Collections_1_1VList.html#a97ff56cf4b4c97f4449e1ccb4bfcd1c4">Loyc.Collections.VList&lt; Loyc.Syntax.LNode &gt;.Transform()</a>.</p>

</div>
</div>
<a class="anchor" id="adb01b7f5cdbb7f1b933fe8a051c19318"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt;T&gt; <a class="el" href="structLoyc_1_1Collections_1_1VList.html">Loyc.Collections.VList</a>&lt; T &gt;.Push </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Synonym for <a class="el" href="structLoyc_1_1Collections_1_1VList.html#a2899333f96298ded3387aab12021b349" title="Inserts an item at the back (index Count) of the VList.">Add()</a>; adds an item to the front of the list.</p>

<p>Referenced by <a class="el" href="classLoyc_1_1Collections_1_1WList.html#a8eb0140372c610b6de934231f494aa25">Loyc.Collections.WList&lt; Loyc.Syntax.LNode &gt;.Resize()</a>.</p>

</div>
</div>
<a class="anchor" id="a67946c8c8878afaa9f282b37849a0769"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt;T&gt; <a class="el" href="structLoyc_1_1Collections_1_1VList.html">Loyc.Collections.VList</a>&lt; T &gt;.SmartSelect </td>
          <td>(</td>
          <td class="paramtype">Func&lt; T, T &gt;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps a list to another list of the same length.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>A function that transforms each item in the list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The list after the map function is applied to each item. The original <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList. ">VList</a> structure is not modified.</dd></dl>
<p>This method is called "Smart" because of what happens if the map doesn't do anything. If the map function returns the first N items unmodified, those N items are typically not copied, but shared between the existing list and the new one. This is useful for functional code that often processes a list without modifying it at all. </p>

<p>Referenced by <a class="el" href="classLoyc_1_1LLParserGenerator_1_1CodeGenHelperBase.html#ade5d7f86e64b287a2ddf7f669f4e114c">Loyc.LLParserGenerator.CodeGenHelperBase.CreateTryWrapperForRecognizer()</a>, <a class="el" href="classLoyc_1_1LLPG_1_1Macros.html#ab27ccc42e5eaa88f4bed8f10a87e4e2a">Loyc.LLPG.Macros.LllpgMacro()</a>, and <a class="el" href="structLoyc_1_1Collections_1_1VList.html#a97ff56cf4b4c97f4449e1ccb4bfcd1c4">Loyc.Collections.VList&lt; Loyc.Syntax.LNode &gt;.Transform()</a>.</p>

</div>
</div>
<a class="anchor" id="acd2e8766cb1c2ceeab21158402330c57"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt;T&gt; <a class="el" href="structLoyc_1_1Collections_1_1VList.html">Loyc.Collections.VList</a>&lt; T &gt;.SmartSelectMany </td>
          <td>(</td>
          <td class="paramtype">Func&lt; T, IList&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps a list to another list by concatenating the outputs of a mapping function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>A function that transforms each item in the list to a list of items.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list that contains all the items returned from <code>map</code>.</dd></dl>
<p>This method is called "Smart" because of what happens if the map doesn't do anything. If, for the first N items, the <code>map</code> returns a list of length 1, and that one item is the same item that was passed in, then those N items are typically not copied, but shared between the existing list and the new one. This is useful for functional code that often processes a list without modifying it at all. </p>

<p>Referenced by <a class="el" href="structLoyc_1_1Collections_1_1VList.html#a97ff56cf4b4c97f4449e1ccb4bfcd1c4">Loyc.Collections.VList&lt; Loyc.Syntax.LNode &gt;.Transform()</a>.</p>

</div>
</div>
<a class="anchor" id="a866e9f0ea9f9c84da69cd5b567aa78a4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt;T&gt; <a class="el" href="structLoyc_1_1Collections_1_1VList.html">Loyc.Collections.VList</a>&lt; T &gt;.SmartWhere </td>
          <td>(</td>
          <td class="paramtype">Func&lt; T, bool &gt;&#160;</td>
          <td class="paramname"><em>keep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a filter to a list, to exclude zero or more items.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keep</td><td>A function that chooses which items to include (exclude items by returning false).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The list after filtering has been applied. The original list structure is not modified.</dd></dl>
<p>If the predicate keeps the first N items it is passed, those N items are typically not copied, but shared between the existing list and the new one. </p>

<p>Referenced by <a class="el" href="structLoyc_1_1Collections_1_1VList.html#a97ff56cf4b4c97f4449e1ccb4bfcd1c4">Loyc.Collections.VList&lt; Loyc.Syntax.LNode &gt;.Transform()</a>.</p>

</div>
</div>
<a class="anchor" id="ab1afb6082c7800d527b48570c2b37389"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T [] <a class="el" href="structLoyc_1_1Collections_1_1VList.html">Loyc.Collections.VList</a>&lt; T &gt;.ToArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList. ">VList</a> converted to an array.</p>

<p>Referenced by <a class="el" href="structLoyc_1_1Collections_1_1VList.html#a97ff56cf4b4c97f4449e1ccb4bfcd1c4">Loyc.Collections.VList&lt; Loyc.Syntax.LNode &gt;.Transform()</a>.</p>

</div>
</div>
<a class="anchor" id="a95dbf9520695ec0b6cf4d90993c668c1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1Collections_1_1FVList.html">FVList</a>&lt;T&gt; <a class="el" href="structLoyc_1_1Collections_1_1VList.html">Loyc.Collections.VList</a>&lt; T &gt;.ToFVList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns this list as a <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a>, which effectively reverses the order of the elements.</p>
<dl class="section return"><dt>Returns</dt><dd>This is a trivial operation; the <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a> shares the same memory.</dd></dl>

<p>Referenced by <a class="el" href="classLoyc_1_1Syntax_1_1LNodeExt.html#a12a4590905ffa883fd102e47f9b2bf2a">Loyc.Syntax.LNodeExt.AsLNode()</a>, and <a class="el" href="structLoyc_1_1Collections_1_1VList.html#ab03b31527812c8eff3e9b2cd8187734b">Loyc.Collections.VList&lt; Loyc.Syntax.LNode &gt;.Equals()</a>.</p>

</div>
</div>
<a class="anchor" id="a49d4385955fa9d1be7981ddc252d6f8e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLoyc_1_1Collections_1_1FWList.html">FWList</a>&lt;T&gt; <a class="el" href="structLoyc_1_1Collections_1_1VList.html">Loyc.Collections.VList</a>&lt; T &gt;.ToFWList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns this list as a <a class="el" href="classLoyc_1_1Collections_1_1FWList.html" title="FWList is the mutable variant of the FVList data structure. ">FWList</a>, which effectively reverses the order of the elements.</p>
<p>The list contents are not copied until you modify the <a class="el" href="classLoyc_1_1Collections_1_1FWList.html" title="FWList is the mutable variant of the FVList data structure. ">FWList</a>.</p>

</div>
</div>
<a class="anchor" id="ad66059b968b4840ebd52c7fb53fd6b1e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLoyc_1_1Collections_1_1WList.html">WList</a>&lt;T&gt; <a class="el" href="structLoyc_1_1Collections_1_1VList.html">Loyc.Collections.VList</a>&lt; T &gt;.ToWList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns this list as an <a class="el" href="classLoyc_1_1Collections_1_1WList.html" title="WList is the mutable variant of the VList data structure. ">WList</a>.</p>
<p>The list contents are not copied until you modify the <a class="el" href="classLoyc_1_1Collections_1_1WList.html" title="WList is the mutable variant of the VList data structure. ">WList</a>.</p>

<p>Referenced by <a class="el" href="classLoyc_1_1LLParserGenerator_1_1Rule.html#a4ada4acb7780613d399da5fa1b250429">Loyc.LLParserGenerator.Rule.CreateMethod()</a>, and <a class="el" href="classLoyc_1_1Collections_1_1WList.html#a8eb0140372c610b6de934231f494aa25">Loyc.Collections.WList&lt; Loyc.Syntax.LNode &gt;.Resize()</a>.</p>

</div>
</div>
<a class="anchor" id="a97ff56cf4b4c97f4449e1ccb4bfcd1c4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt;T&gt; <a class="el" href="structLoyc_1_1Collections_1_1VList.html">Loyc.Collections.VList</a>&lt; T &gt;.Transform </td>
          <td>(</td>
          <td class="paramtype">VListTransformer&lt; T &gt;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transforms a list (combines filtering with selection and more).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Method to apply to each item in the list</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list formed from transforming all items in the list</dd></dl>
<p>See the documentation of <a class="el" href="structLoyc_1_1Collections_1_1FVList.html#a00aaff73e8bd2e48b545a53d9dbc8047" title="Transforms a list (combines filtering with selection and more).">FVList.Transform()</a> for more information.</p>

<p>Referenced by <a class="el" href="structLoyc_1_1Collections_1_1VList.html#a97ff56cf4b4c97f4449e1ccb4bfcd1c4">Loyc.Collections.VList&lt; Loyc.Syntax.LNode &gt;.Transform()</a>.</p>

</div>
</div>
<a class="anchor" id="a3751829c3359ff56319fe6d93b6be40a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt;T&gt; <a class="el" href="structLoyc_1_1Collections_1_1VList.html">Loyc.Collections.VList</a>&lt; T &gt;.WhereSelect </td>
          <td>(</td>
          <td class="paramtype">Func&lt; T, <a class="el" href="classLoyc_1_1Maybe.html">Maybe</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>filter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Filters and maps a list with a user-defined function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filter</td><td>A function that chooses which items to include in a new list, and what to change them to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The list after filtering has been applied. The original list structure is not modified.</dd></dl>
<p>This is a smart function. If the filter keeps the first N items it is passed, those N items are typically not copied, but shared between the existing list and the new one. </p>

<p>Referenced by <a class="el" href="classLoyc_1_1Syntax_1_1CallNode.html#acda83c0c4d8f443aedd6c256357dd1d3">Loyc.Syntax.CallNode.HasSimpleHeadWithoutPAttrs()</a>.</p>

</div>
</div>
<h2 class="groupheader">Property Documentation</h2>
<a class="anchor" id="ae8dd2d71b3e33709014c1bf2b27a115c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="structLoyc_1_1Collections_1_1VList.html">Loyc.Collections.VList</a>&lt; T &gt;.BlockChainLength</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of blocks used by this list.</p>
<p>You might look at this property when optimizing your program, because the runtime of some operations increases as the chain length increases. This property runs in O(BlockChainLength) time. Ideally, BlockChainLength is proportional to log_2(Count), but certain <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList. ">VList</a> usage patterns can produce long chains.</p>

<p>Referenced by <a class="el" href="classLoyc_1_1Collections_1_1WList.html#a8eb0140372c610b6de934231f494aa25">Loyc.Collections.WList&lt; Loyc.Syntax.LNode &gt;.Resize()</a>.</p>

</div>
</div>
<a class="anchor" id="ab429ef27c6d66520883bc8402d8e7653"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="structLoyc_1_1Collections_1_1VList.html">Loyc.Collections.VList</a>&lt; T &gt;.Last</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the last item of the list (at index Count-1), which is the head of the list.</p>

<p>Referenced by <a class="el" href="classLoyc_1_1Syntax_1_1LNodeExt.html#a12a4590905ffa883fd102e47f9b2bf2a">Loyc.Syntax.LNodeExt.AsLNode()</a>, <a class="el" href="classLeMP_1_1MacroContext.html#a1536a9346e03f3adc67d822deaf99ace">LeMP.MacroContext.GetOptions()</a>, <a class="el" href="classLoyc_1_1Ecs_1_1EcsValidators.html#a26006ff95c953dff4e4e9768eb5c5863">Loyc.Ecs.EcsValidators.KeyNameComponentOf()</a>, <a class="el" href="classLoyc_1_1LLPG_1_1Macros.html#ab27ccc42e5eaa88f4bed8f10a87e4e2a">Loyc.LLPG.Macros.LllpgMacro()</a>, <a class="el" href="classLoyc_1_1Syntax_1_1LNodeExt.html#ad20bab0fd1ed507bf5fce0650168d303">Loyc.Syntax.LNodeExt.MatchesPattern()</a>, and <a class="el" href="structLoyc_1_1Collections_1_1VList.html#a97ff56cf4b4c97f4449e1ccb4bfcd1c4">Loyc.Collections.VList&lt; Loyc.Syntax.LNode &gt;.Transform()</a>.</p>

</div>
</div>
<a class="anchor" id="a9c25e96b43013e9eee3ac4cf0b974abf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt;T&gt; <a class="el" href="structLoyc_1_1Collections_1_1VList.html">Loyc.Collections.VList</a>&lt; T &gt;.Tail</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a list without the last item. If the list is empty, an empty list is retured.</p>

<p>Referenced by <a class="el" href="structLoyc_1_1Collections_1_1VList.html#a97ff56cf4b4c97f4449e1ccb4bfcd1c4">Loyc.Collections.VList&lt; Loyc.Syntax.LNode &gt;.Transform()</a>.</p>

</div>
</div>
<a class="anchor" id="ab55e9bfa5eef58ad18ed164a699a2826"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="structLoyc_1_1Collections_1_1VList.html">Loyc.Collections.VList</a>&lt; T &gt;.this[int index, T defaultValue]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an item from the list at the specified index; returns defaultValue if the index is not valid.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 12 2016 15:49:32 for Enhanced C# by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
