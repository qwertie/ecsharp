<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>Loyc: Loyc.Collections.Impl.AListNode&lt; K, T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Loyc
   </div>
   <div id="projectbrief">Language of your choice: library documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Events</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceLoyc.html">Loyc</a></li><li class="navelem"><a class="el" href="namespaceLoyc_1_1Collections.html">Collections</a></li><li class="navelem"><a class="el" href="namespaceLoyc_1_1Collections_1_1Impl.html">Impl</a></li><li class="navelem"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListNode_3_01K_00_01T_01_4.html">AListNode< K, T ></a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#properties">Properties</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected fields</a> &#124;
<a href="classLoyc_1_1Collections_1_1Impl_1_1AListNode_3_01K_00_01T_01_4-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Loyc.Collections.Impl.AListNode&lt; K, T &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Internal implementation class. Base class for tree nodes in a list class derived from AListBase{T}. These nodes basically form an in-memory B+tree, not necessarily sorted, but structured like a B+tree. That means there are two node types: leaf and inner (internal) nodes.  
 <a href="classLoyc_1_1Collections_1_1Impl_1_1AListNode_3_01K_00_01T_01_4.html#details">More...</a></p>
<hr/><b>Source file</b>:<ul>
<li><a href='https://github.com/qwertie/Loyc/tree/master/Core/Loyc.Collections/ALists/AListNode.cs'>/Core/Loyc.Collections/ALists/AListNode.cs</a></li>
</ul>
<div class="dynheader">
Inheritance diagram for Loyc.Collections.Impl.AListNode&lt; K, T &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classLoyc_1_1Collections_1_1Impl_1_1AListNode_3_01K_00_01T_01_4.png" usemap="#Loyc.Collections.Impl.AListNode&lt; K, T &gt;_map" alt=""/>
  <map id="Loyc.Collections.Impl.AListNode&lt; K, T &gt;_map" name="Loyc.Collections.Impl.AListNode&lt; K, T &gt;_map">
<area href="classLoyc_1_1Collections_1_1Impl_1_1AListInnerBase_3_01K_00_01T_01_4.html" title="Internal implementation class. Shared base class of internal nodes for AList{T}, SparseAList{T}, BList{T}, BMultiMap{K,V} and BDictionary{K,V}." alt="Loyc.Collections.Impl.AListInnerBase&lt; K, T &gt;" shape="rect" coords="0,56,269,80"/>
<area href="classLoyc_1_1Collections_1_1Impl_1_1AListLeaf_3_01K_00_01T_01_4.html" title="Internal implementation class. Shared code of non-sparse AList leaf nodes." alt="Loyc.Collections.Impl.AListLeaf&lt; K, T &gt;" shape="rect" coords="279,56,548,80"/>
<area href="classLoyc_1_1Collections_1_1Impl_1_1SparseAListLeaf_3_01T_01_4.html" title="Internal implementation class. Leaf node of SparseAList{T}." alt="Loyc.Collections.Impl.SparseAListLeaf&lt; T &gt;" shape="rect" coords="558,56,827,80"/>
<area href="classLoyc_1_1Collections_1_1Impl_1_1BListLeaf_3_01K_00_01T_01_4.html" title="Internal implementation class. Leaf node of BList{T} and BDictionary{K,V}." alt="Loyc.Collections.Impl.BListLeaf&lt; K, T &gt;" shape="rect" coords="279,112,548,136"/>
</map>
 </div></div>
<a name="details" id="details"></a><h2 class="groupheader">Remarks</h2>
<div class="textblock"><p>Internal implementation class. Base class for tree nodes in a list class derived from AListBase{T}. These nodes basically form an in-memory B+tree, not necessarily sorted, but structured like a B+tree. That means there are two node types: leaf and inner (internal) nodes. </p>
<p>Indexes that are passed to methods such as Index, this[] and RemoveAt are not range-checked except by assertion. The caller (AList or BList) is expected to ensure indexes are valid. </p>
<p>At the root node level, indexes have the same meaning as they do in AListBase itself. However, below the root node, each node has a "base 
index" that is subtracted from any index passed to the node. For example, if the root node has two leaf children, and the left one has 20 items, then the right child's base index is 20. When accessing item 23, the subindex 3 is passed to the right child. Note that the right child is not aware of its own base index (the parent node manages the base index); as far as each node is concerned, it manages a collection of items numbered 0 to TotalCount-1. </p>
<p>Indexes are expressed with a uint so that nodes are capable of holding up to uint.MaxValue-1 elements. AList itself doesn't support sizes over int.MaxValue, since it assumes indexes are signed (some protected methods in AList take unsigned indexes, however). It should be possible to support oversize lists in 64-bit machines by writing a derived class based on "uint" or "long" indexes; 32-bit processes, however, don't have enough address space to even hold int.MaxValue bytes. </p>
<p>Before calling any method that modifies a node, it is necessary to call <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListNode_3_01K_00_01T_01_4.html#a1d2b9e6c5bc98d045b1128c2ca8cceec" title="Checks whether &#39;node&#39; is frozen and if so, replaces it with an unfrozen copy.">AutoClone()</a> to check if the node is frozen and clone it if necessary. TakeFromRight and TakeFromLeft can be called when one or both nodes are frozen, but will have no effect. </p>
<p>Philosophical note: the kinds of features I'd like to see in Enhanced C# would make it easier to create the AList series of data structures. Each kind of AList is similar yet different and many of the operations of an AList are similar yet different and C# doesn't, I think, provide enough flexibility to handle this variety without smooshing a bunch of different things clumsily into a single class hierarchy and without having to write methods that are in charge of several different operations (e.g. DoSingleOperation). Traits and D-style templates would help make the cod of the AList family of types cleaner and faster. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:ad1e7b9139e8a22a968477764d4c954e2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad1e7b9139e8a22a968477764d4c954e2"></a>
abstract bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsLeaf</b><code> [get]</code></td></tr>
<tr class="separator:ad1e7b9139e8a22a968477764d4c954e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cc6cb074720b087c76e3ec3d9d2e0ed"><td class="memItemLeft" align="right" valign="top">abstract uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListNode_3_01K_00_01T_01_4.html#a6cc6cb074720b087c76e3ec3d9d2e0ed">TotalCount</a><code> [get]</code></td></tr>
<tr class="memdesc:a6cc6cb074720b087c76e3ec3d9d2e0ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the total number of (T) items in this node and all children <a href="#a6cc6cb074720b087c76e3ec3d9d2e0ed">More...</a><br /></td></tr>
<tr class="separator:a6cc6cb074720b087c76e3ec3d9d2e0ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81a903ee7cc50a9bd6f253eb8418568f"><td class="memItemLeft" align="right" valign="top">abstract int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListNode_3_01K_00_01T_01_4.html#a81a903ee7cc50a9bd6f253eb8418568f">LocalCount</a><code> [get]</code></td></tr>
<tr class="memdesc:a81a903ee7cc50a9bd6f253eb8418568f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of items (slots) used this node only. <a href="#a81a903ee7cc50a9bd6f253eb8418568f">More...</a><br /></td></tr>
<tr class="separator:a81a903ee7cc50a9bd6f253eb8418568f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fae05f4b3bd4aca2041ac50e36bf7dc"><td class="memItemLeft" align="right" valign="top">abstract bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListNode_3_01K_00_01T_01_4.html#a9fae05f4b3bd4aca2041ac50e36bf7dc">IsFullLeaf</a><code> [get]</code></td></tr>
<tr class="memdesc:a9fae05f4b3bd4aca2041ac50e36bf7dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the node is full and is a leaf node. <a href="#a9fae05f4b3bd4aca2041ac50e36bf7dc">More...</a><br /></td></tr>
<tr class="separator:a9fae05f4b3bd4aca2041ac50e36bf7dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93383671ee4e6f34f6c910009002363e"><td class="memItemLeft" align="right" valign="top">abstract bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListNode_3_01K_00_01T_01_4.html#a93383671ee4e6f34f6c910009002363e">IsUndersized</a><code> [get]</code></td></tr>
<tr class="memdesc:a93383671ee4e6f34f6c910009002363e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the node is undersized, meaning it would prefer to have more immediate children. <a href="#a93383671ee4e6f34f6c910009002363e">More...</a><br /></td></tr>
<tr class="separator:a93383671ee4e6f34f6c910009002363e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b21bfb21059a585c0a39d5978f6b04b"><td class="memItemLeft" align="right" valign="top">abstract T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListNode_3_01K_00_01T_01_4.html#a0b21bfb21059a585c0a39d5978f6b04b">this[uint index]</a><code> [get]</code></td></tr>
<tr class="memdesc:a0b21bfb21059a585c0a39d5978f6b04b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an item at the specified sub-index. <a href="#a0b21bfb21059a585c0a39d5978f6b04b">More...</a><br /></td></tr>
<tr class="separator:a0b21bfb21059a585c0a39d5978f6b04b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae04a7beea231561fc3e630ce8223deb0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListNode_3_01K_00_01T_01_4.html#ae04a7beea231561fc3e630ce8223deb0">IsFrozen</a><code> [get]</code></td></tr>
<tr class="memdesc:ae04a7beea231561fc3e630ce8223deb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the node is explicitly marked read-only. Conceptually, the node can still be changed, but when any change needs to be made, a clone of the node is created and modified instead. <a href="#ae04a7beea231561fc3e630ce8223deb0">More...</a><br /></td></tr>
<tr class="separator:ae04a7beea231561fc3e630ce8223deb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9f3a27aeca65bf744c6279b64618964"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af9f3a27aeca65bf744c6279b64618964"></a>
abstract int&#160;</td><td class="memItemRight" valign="bottom"><b>CapacityLeft</b><code> [get]</code></td></tr>
<tr class="separator:af9f3a27aeca65bf744c6279b64618964"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5132343b0095131a391bd3e26be790b2"><td class="memItemLeft" align="right" valign="top">virtual AListNode&lt; K, T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListNode_3_01K_00_01T_01_4.html#a5132343b0095131a391bd3e26be790b2">Insert</a> (uint index, T item, out AListNode&lt; K, T &gt; splitRight, IAListTreeObserver&lt; K, T &gt; tob)</td></tr>
<tr class="memdesc:a5132343b0095131a391bd3e26be790b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an item at the specified index. This method can only be called for ALists, since other tree types don't allow insertion at a specific index. <a href="#a5132343b0095131a391bd3e26be790b2">More...</a><br /></td></tr>
<tr class="separator:a5132343b0095131a391bd3e26be790b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af13714f40db692e2280940eddb8f4628"><td class="memItemLeft" align="right" valign="top">virtual AListNode&lt; K, T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListNode_3_01K_00_01T_01_4.html#af13714f40db692e2280940eddb8f4628">InsertRange</a> (uint index, IListSource&lt; T &gt; source, ref int sourceIndex, out AListNode&lt; K, T &gt; splitRight, IAListTreeObserver&lt; K, T &gt; tob)</td></tr>
<tr class="memdesc:af13714f40db692e2280940eddb8f4628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a list of items at the specified index. This method may not insert all items at once, so there is a sourceIndex parameter which points to the next item to be inserted. When sourceIndex reaches source.Count, the insertion is complete. <a href="#af13714f40db692e2280940eddb8f4628">More...</a><br /></td></tr>
<tr class="separator:af13714f40db692e2280940eddb8f4628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a092056ac4b87554536876f292ab84c11"><td class="memItemLeft" align="right" valign="top">abstract T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListNode_3_01K_00_01T_01_4.html#a092056ac4b87554536876f292ab84c11">GetLastItem</a> ()</td></tr>
<tr class="memdesc:a092056ac4b87554536876f292ab84c11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the last item in the last leaf node (needed by B+ trees, but is also called by AListBase{K,T}.Last). <a href="#a092056ac4b87554536876f292ab84c11">More...</a><br /></td></tr>
<tr class="separator:a092056ac4b87554536876f292ab84c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc74e107bcbc829a07fa46860503ffc2"><td class="memItemLeft" align="right" valign="top">abstract <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListNode_3_01K_00_01T_01_4.html#acc74e107bcbc829a07fa46860503ffc2">SetAt</a> (uint index, T item, IAListTreeObserver&lt; K, T &gt; tob)</td></tr>
<tr class="memdesc:acc74e107bcbc829a07fa46860503ffc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an item at the specified sub-index. <a href="#acc74e107bcbc829a07fa46860503ffc2">More...</a><br /></td></tr>
<tr class="separator:acc74e107bcbc829a07fa46860503ffc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0908e4cc7de2059fb0d8fc9e67f230d3"><td class="memItemLeft" align="right" valign="top">abstract bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListNode_3_01K_00_01T_01_4.html#a0908e4cc7de2059fb0d8fc9e67f230d3">RemoveAt</a> (uint index, uint count, IAListTreeObserver&lt; K, T &gt; tob)</td></tr>
<tr class="memdesc:a0908e4cc7de2059fb0d8fc9e67f230d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an item at the specified index. <a href="#a0908e4cc7de2059fb0d8fc9e67f230d3">More...</a><br /></td></tr>
<tr class="separator:a0908e4cc7de2059fb0d8fc9e67f230d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfd40117a5d527dc37fd36f61710e902"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acfd40117a5d527dc37fd36f61710e902"></a>
abstract <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Freeze</b> ()</td></tr>
<tr class="separator:acfd40117a5d527dc37fd36f61710e902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aada73c62defe2d4c45dab0f6a5d81a4d"><td class="memItemLeft" align="right" valign="top">abstract AListNode&lt; K, T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListNode_3_01K_00_01T_01_4.html#aada73c62defe2d4c45dab0f6a5d81a4d">DetachedClone</a> ()</td></tr>
<tr class="memdesc:aada73c62defe2d4c45dab0f6a5d81a4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an unfrozen shallow duplicate copy of this node. The child nodes (if this is an inner node) are frozen so that they will require duplication if they are to be modified. The name "DetachedClone" is intended to emphasize that the AListNodeObserver (if any) is not notified, and the clone is effectively independent of the list that it came from. <a href="#aada73c62defe2d4c45dab0f6a5d81a4d">More...</a><br /></td></tr>
<tr class="separator:aada73c62defe2d4c45dab0f6a5d81a4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a3e1250388c01525d3efaf9c8406431"><td class="memItemLeft" align="right" valign="top">abstract AListNode&lt; K, T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListNode_3_01K_00_01T_01_4.html#a3a3e1250388c01525d3efaf9c8406431">CopySection</a> (uint index, uint count, AListBase&lt; K, T &gt; list)</td></tr>
<tr class="memdesc:a3a3e1250388c01525d3efaf9c8406431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts and returns, as fast as possible, a subrange of the list that this node represents. <a href="#a3a3e1250388c01525d3efaf9c8406431">More...</a><br /></td></tr>
<tr class="separator:a3a3e1250388c01525d3efaf9c8406431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92fbc388482fdb1aefbc809f36fa25ec"><td class="memItemLeft" align="right" valign="top">abstract uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListNode_3_01K_00_01T_01_4.html#a92fbc388482fdb1aefbc809f36fa25ec">GetImmutableCount</a> (bool excludeSparse)</td></tr>
<tr class="memdesc:a92fbc388482fdb1aefbc809f36fa25ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Diagnostic method. See AListBase{K,T}.GetImmutableCount(). <a href="#a92fbc388482fdb1aefbc809f36fa25ec">More...</a><br /></td></tr>
<tr class="separator:a92fbc388482fdb1aefbc809f36fa25ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d118c9bb03a6cd6208f2994107a36c1"><td class="memItemLeft" align="right" valign="top">virtual uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListNode_3_01K_00_01T_01_4.html#a0d118c9bb03a6cd6208f2994107a36c1">GetRealItemCount</a> ()</td></tr>
<tr class="memdesc:a0d118c9bb03a6cd6208f2994107a36c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">For sparse lists: counts the number of non-sparse items. <a href="#a0d118c9bb03a6cd6208f2994107a36c1">More...</a><br /></td></tr>
<tr class="separator:a0d118c9bb03a6cd6208f2994107a36c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a1d2b9e6c5bc98d045b1128c2ca8cceec"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListNode_3_01K_00_01T_01_4.html#a1d2b9e6c5bc98d045b1128c2ca8cceec">AutoClone</a> (ref AListNode&lt; K, T &gt; node, AListInnerBase&lt; K, T &gt; parent, IAListTreeObserver&lt; K, T &gt; tob)</td></tr>
<tr class="memdesc:a1d2b9e6c5bc98d045b1128c2ca8cceec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether 'node' is frozen and if so, replaces it with an unfrozen copy. <a href="#a1d2b9e6c5bc98d045b1128c2ca8cceec">More...</a><br /></td></tr>
<tr class="separator:a1d2b9e6c5bc98d045b1128c2ca8cceec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a6b5f62bf38aebf0a04f924f90a1e2d45"><td class="memItemLeft" align="right" valign="top">IAListTreeObserver&lt; K, T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListNode_3_01K_00_01T_01_4.html#a6b5f62bf38aebf0a04f924f90a1e2d45">GetObserver</a> (AListBase&lt; K, T &gt; tree)</td></tr>
<tr class="memdesc:a6b5f62bf38aebf0a04f924f90a1e2d45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows derived classes of AListNode to access AListBase._observer. <a href="#a6b5f62bf38aebf0a04f924f90a1e2d45">More...</a><br /></td></tr>
<tr class="separator:a6b5f62bf38aebf0a04f924f90a1e2d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67d4aeddc04cdb8052e9e09eb3fd4b87"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListNode_3_01K_00_01T_01_4.html#a67d4aeddc04cdb8052e9e09eb3fd4b87">HasListChanging</a> (AListBase&lt; K, T &gt; tree)</td></tr>
<tr class="memdesc:a67d4aeddc04cdb8052e9e09eb3fd4b87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows derived classes of AListNode to fire the AListBase.ListChanging event. <a href="#a67d4aeddc04cdb8052e9e09eb3fd4b87">More...</a><br /></td></tr>
<tr class="separator:a67d4aeddc04cdb8052e9e09eb3fd4b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc8d3a8df0d066e8bfa632203f001d65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListNode_3_01K_00_01T_01_4.html#adc8d3a8df0d066e8bfa632203f001d65">CallListChanging</a> (AListBase&lt; K, T &gt; tree, ListChangeInfo&lt; T &gt; listChangeInfo)</td></tr>
<tr class="memdesc:adc8d3a8df0d066e8bfa632203f001d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows derived classes of AListNode to fire the AListBase.ListChanging event properly. <a href="#adc8d3a8df0d066e8bfa632203f001d65">More...</a><br /></td></tr>
<tr class="separator:adc8d3a8df0d066e8bfa632203f001d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a90604f1a4068d2548486ad00220eca02"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListNode_3_01K_00_01T_01_4.html#a90604f1a4068d2548486ad00220eca02">Verify</a> (bool condition)</td></tr>
<tr class="memdesc:a90604f1a4068d2548486ad00220eca02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as Assert(), except that the condition expression can have side-effects because it is evaluated even in Release builds. <a href="#a90604f1a4068d2548486ad00220eca02">More...</a><br /></td></tr>
<tr class="separator:a90604f1a4068d2548486ad00220eca02"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected fields</h2></td></tr>
<tr class="memitem:a9d2b4503ed721b25b806622a79e8edc6"><td class="memItemLeft" align="right" valign="top">ushort&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListNode_3_01K_00_01T_01_4.html#a9d2b4503ed721b25b806622a79e8edc6">_maxNodeSize</a></td></tr>
<tr class="memdesc:a9d2b4503ed721b25b806622a79e8edc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of slots in this node <a href="#a9d2b4503ed721b25b806622a79e8edc6">More...</a><br /></td></tr>
<tr class="separator:a9d2b4503ed721b25b806622a79e8edc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6995d02e3d7f430f2a21bfd47bd6d0e3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListNode_3_01K_00_01T_01_4.html#a6995d02e3d7f430f2a21bfd47bd6d0e3">_isFrozen</a></td></tr>
<tr class="memdesc:a6995d02e3d7f430f2a21bfd47bd6d0e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the node is knowingly cloned an therefore frozen. <a href="#a6995d02e3d7f430f2a21bfd47bd6d0e3">More...</a><br /></td></tr>
<tr class="separator:a6995d02e3d7f430f2a21bfd47bd6d0e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7efb1f66090765df0594ddeab39fbbb"><td class="memItemLeft" align="right" valign="top">byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListNode_3_01K_00_01T_01_4.html#aa7efb1f66090765df0594ddeab39fbbb">_childCount</a></td></tr>
<tr class="memdesc:aa7efb1f66090765df0594ddeab39fbbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of children, if this is an inner node. <a href="#aa7efb1f66090765df0594ddeab39fbbb">More...</a><br /></td></tr>
<tr class="separator:aa7efb1f66090765df0594ddeab39fbbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a1d2b9e6c5bc98d045b1128c2ca8cceec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Loyc.Collections.Impl.AListNode&lt; K, T &gt;.AutoClone </td>
          <td>(</td>
          <td class="paramtype">ref AListNode&lt; K, T &gt;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AListInnerBase&lt; K, T &gt;&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IAListTreeObserver&lt; K, T &gt;&#160;</td>
          <td class="paramname"><em>tob</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether 'node' is frozen and if so, replaces it with an unfrozen copy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>A node that the caller needs to be unfrozen</td></tr>
    <tr><td class="paramname">parent</td><td>Parent node (used by tob)</td></tr>
    <tr><td class="paramname">tob</td><td>Tree observer (null if none)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the node was unfrozen</dd></dl>

</div>
</div>
<a class="anchor" id="adc8d3a8df0d066e8bfa632203f001d65"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1void.html">void</a> Loyc.Collections.Impl.AListNode&lt; K, T &gt;.CallListChanging </td>
          <td>(</td>
          <td class="paramtype">AListBase&lt; K, T &gt;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ListChangeInfo&lt; T &gt;&#160;</td>
          <td class="paramname"><em>listChangeInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows derived classes of AListNode to fire the AListBase.ListChanging event properly.</p>

</div>
</div>
<a class="anchor" id="a3a3e1250388c01525d3efaf9c8406431"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract AListNode&lt;K, T&gt; Loyc.Collections.Impl.AListNode&lt; K, T &gt;.CopySection </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AListBase&lt; K, T &gt;&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts and returns, as fast as possible, a subrange of the list that this node represents.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index to start copying</td></tr>
    <tr><td class="paramname">count</td><td>Number of Ts to copy (must be greater than zero).</td></tr>
    <tr><td class="paramname">list</td><td>List that is making the request. This parameter may be needed by organized trees that need to call list.GetKey().</td></tr>
  </table>
  </dd>
</dl>
<p>This method may return a size-one inner node that the caller must replace with its child. It will fast-clone any nodes that can be copied in their entirety, including this node itself.</p>

<p>Implemented in <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1BListLeaf_3_01K_00_01T_01_4.html#afd087df7675ab5c75985deab5cf7cf1e">Loyc.Collections.Impl.BListLeaf&lt; K, T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aada73c62defe2d4c45dab0f6a5d81a4d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract AListNode&lt;K, T&gt; Loyc.Collections.Impl.AListNode&lt; K, T &gt;.DetachedClone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an unfrozen shallow duplicate copy of this node. The child nodes (if this is an inner node) are frozen so that they will require duplication if they are to be modified. The name "DetachedClone" is intended to emphasize that the AListNodeObserver (if any) is not notified, and the clone is effectively independent of the list that it came from.</p>

<p>Implemented in <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1SparseAListLeaf_3_01T_01_4.html#a95934239c298592b06e1a22951a805fe">Loyc.Collections.Impl.SparseAListLeaf&lt; T &gt;</a>, and <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1BListLeaf_3_01K_00_01T_01_4.html#aa5f791650ecab4d85487e3b735c20cf5">Loyc.Collections.Impl.BListLeaf&lt; K, T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a92fbc388482fdb1aefbc809f36fa25ec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract uint Loyc.Collections.Impl.AListNode&lt; K, T &gt;.GetImmutableCount </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>excludeSparse</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Diagnostic method. See AListBase{K,T}.GetImmutableCount().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">excludeSparse</td><td>Should be false for normal ALists. If true, the count is of real items only.</td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListInnerBase_3_01K_00_01T_01_4.html#a119f3dd3e65165774e0325052f701381">Loyc.Collections.Impl.AListInnerBase&lt; K, T &gt;</a>, <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1SparseAListLeaf_3_01T_01_4.html#a4df2805a6c19ba2a78c7859dcbab41ec">Loyc.Collections.Impl.SparseAListLeaf&lt; T &gt;</a>, and <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListLeaf_3_01K_00_01T_01_4.html#a06d344a2889649e324e43e1c4bdacc85">Loyc.Collections.Impl.AListLeaf&lt; K, T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a092056ac4b87554536876f292ab84c11"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract T Loyc.Collections.Impl.AListNode&lt; K, T &gt;.GetLastItem </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the last item in the last leaf node (needed by B+ trees, but is also called by AListBase{K,T}.Last).</p>

<p>Implemented in <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListInnerBase_3_01K_00_01T_01_4.html#ae33ed22d37c2a56e4a3927d83fb772ce">Loyc.Collections.Impl.AListInnerBase&lt; K, T &gt;</a>, <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListLeaf_3_01K_00_01T_01_4.html#a50cee36b155263e5065da9e5c9ad0e70">Loyc.Collections.Impl.AListLeaf&lt; K, T &gt;</a>, and <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1SparseAListLeaf_3_01T_01_4.html#ad08c940d524f6f1eb4509bdba58dbe5c">Loyc.Collections.Impl.SparseAListLeaf&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a6b5f62bf38aebf0a04f924f90a1e2d45"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IAListTreeObserver&lt;K, T&gt; Loyc.Collections.Impl.AListNode&lt; K, T &gt;.GetObserver </td>
          <td>(</td>
          <td class="paramtype">AListBase&lt; K, T &gt;&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows derived classes of AListNode to access AListBase._observer.</p>

</div>
</div>
<a class="anchor" id="a0d118c9bb03a6cd6208f2994107a36c1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint Loyc.Collections.Impl.AListNode&lt; K, T &gt;.GetRealItemCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For sparse lists: counts the number of non-sparse items.</p>

<p>Reimplemented in <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1SparseAListLeaf_3_01T_01_4.html#a0ffbdf8b68f33f718d2efaa398e773ee">Loyc.Collections.Impl.SparseAListLeaf&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a67d4aeddc04cdb8052e9e09eb3fd4b87"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Loyc.Collections.Impl.AListNode&lt; K, T &gt;.HasListChanging </td>
          <td>(</td>
          <td class="paramtype">AListBase&lt; K, T &gt;&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows derived classes of AListNode to fire the AListBase.ListChanging event.</p>

</div>
</div>
<a class="anchor" id="a5132343b0095131a391bd3e26be790b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual AListNode&lt;K, T&gt; Loyc.Collections.Impl.AListNode&lt; K, T &gt;.Insert </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out AListNode&lt; K, T &gt;&#160;</td>
          <td class="paramname"><em>splitRight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IAListTreeObserver&lt; K, T &gt;&#160;</td>
          <td class="paramname"><em>tob</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts an item at the specified index. This method can only be called for ALists, since other tree types don't allow insertion at a specific index.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns null if the insert completed normally. If the node split in half, the return value is the left side, and splitRight is set to the right side.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">NotSupportedException</td><td>This node does not allow insertion at an arbitrary location (e.g. BList node).</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af13714f40db692e2280940eddb8f4628"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual AListNode&lt;K, T&gt; Loyc.Collections.Impl.AListNode&lt; K, T &gt;.InsertRange </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IListSource&lt; T &gt;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref int&#160;</td>
          <td class="paramname"><em>sourceIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out AListNode&lt; K, T &gt;&#160;</td>
          <td class="paramname"><em>splitRight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IAListTreeObserver&lt; K, T &gt;&#160;</td>
          <td class="paramname"><em>tob</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a list of items at the specified index. This method may not insert all items at once, so there is a sourceIndex parameter which points to the next item to be inserted. When sourceIndex reaches source.Count, the insertion is complete.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index at which to insert the contents of source. Important: if sourceIndex &gt; 0, insertion of the remaining items starts at [index + sourceIndex].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns non-null if the node is split, as explained in the documentation of <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListNode_3_01K_00_01T_01_4.html#a5132343b0095131a391bd3e26be790b2" title="Inserts an item at the specified index. This method can only be called for ALists, since other tree types don&#39;t allow insertion at a specific index.">Insert</a>.</dd></dl>
<p>This method can only be called for ALists, since other tree types don't allow insertion at a specific index.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">NotSupportedException</td><td>This node does not allow insertion at an arbitrary location (e.g. BList node).</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0908e4cc7de2059fb0d8fc9e67f230d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract bool Loyc.Collections.Impl.AListNode&lt; K, T &gt;.RemoveAt </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IAListTreeObserver&lt; K, T &gt;&#160;</td>
          <td class="paramname"><em>tob</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes an item at the specified index.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the node is undersized after the removal, or if this is an organized tree and the removal caused the aggregate key (highest key in a B+tree) to change.</dd></dl>
<p>When the node is undersized, but is not the root node, the parent will shift an item from a sibling, or discard the node and redistribute its children among existing nodes. If it is the root node, it is only discarded if it is an inner node with a single child (the child becomes the new root node), or it is a leaf node with no children. </p>

<p>Implemented in <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListInnerBase_3_01K_00_01T_01_4.html#a3b4566d4be91fa5289c1146c5141640e">Loyc.Collections.Impl.AListInnerBase&lt; K, T &gt;</a>, <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1BListLeaf_3_01K_00_01T_01_4.html#a10f6ec8a637b4312222852099e5c8071">Loyc.Collections.Impl.BListLeaf&lt; K, T &gt;</a>, and <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListLeaf_3_01K_00_01T_01_4.html#a53e6cf27844b3da4a9f5cd1caa63a6b8">Loyc.Collections.Impl.AListLeaf&lt; K, T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="acc74e107bcbc829a07fa46860503ffc2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract <a class="el" href="structLoyc_1_1void.html">void</a> Loyc.Collections.Impl.AListNode&lt; K, T &gt;.SetAt </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IAListTreeObserver&lt; K, T &gt;&#160;</td>
          <td class="paramname"><em>tob</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets an item at the specified sub-index.</p>
<p>Currently, this method can be called for all tree types, even though improper use could break the tree invariant (e.g. sorted order of BList). </p>

<p>Implemented in <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListInnerBase_3_01K_00_01T_01_4.html#a313c1d981a5e4c889d3282c08725bdbf">Loyc.Collections.Impl.AListInnerBase&lt; K, T &gt;</a>, and <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListLeaf_3_01K_00_01T_01_4.html#aecec9a240779613ab204941f879d50c4">Loyc.Collections.Impl.AListLeaf&lt; K, T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a90604f1a4068d2548486ad00220eca02"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structLoyc_1_1void.html">void</a> Loyc.Collections.Impl.AListNode&lt; K, T &gt;.Verify </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>condition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as Assert(), except that the condition expression can have side-effects because it is evaluated even in Release builds.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="aa7efb1f66090765df0594ddeab39fbbb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">byte Loyc.Collections.Impl.AListNode&lt; K, T &gt;._childCount</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of children, if this is an inner node.</p>
<p>Since AListLeaf{T} uses DListInternal, a separate item count is not needed and this counter is always zero. This field logically belongs in AListInnerBase{K,T} but is defined here to ensure that inner nodes are not 4 bytes larger than necessary. This field is "free" if it is declared in the base class, since class sizes are rounded up to the nearest multiple of 4 bytes (8 bytes in 64-bit). The fact that this field is a byte, however, does limit inner node sizes to 255. </p>

</div>
</div>
<a class="anchor" id="a6995d02e3d7f430f2a21bfd47bd6d0e3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Loyc.Collections.Impl.AListNode&lt; K, T &gt;._isFrozen</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the node is knowingly cloned an therefore frozen.</p>

</div>
</div>
<a class="anchor" id="a9d2b4503ed721b25b806622a79e8edc6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ushort Loyc.Collections.Impl.AListNode&lt; K, T &gt;._maxNodeSize</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum number of slots in this node</p>

</div>
</div>
<h2 class="groupheader">Property Documentation</h2>
<a class="anchor" id="ae04a7beea231561fc3e630ce8223deb0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Loyc.Collections.Impl.AListNode&lt; K, T &gt;.IsFrozen</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the node is explicitly marked read-only. Conceptually, the node can still be changed, but when any change needs to be made, a clone of the node is created and modified instead.</p>
<p>When an inner node is frozen, all its children are implicitly frozen, but not actually marked as frozen until the parent is cloned. This allows instantaneous cloning, since only the root node is marked frozen in the beginning.</p>

</div>
</div>
<a class="anchor" id="a9fae05f4b3bd4aca2041ac50e36bf7dc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract bool Loyc.Collections.Impl.AListNode&lt; K, T &gt;.IsFullLeaf</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the node is full and is a leaf node.</p>

</div>
</div>
<a class="anchor" id="a93383671ee4e6f34f6c910009002363e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract bool Loyc.Collections.Impl.AListNode&lt; K, T &gt;.IsUndersized</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the node is undersized, meaning it would prefer to have more immediate children.</p>

<p>Referenced by <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListInnerBase_3_01K_00_01T_01_4.html#a782f53c1b0884e1ba5ebc86b74fd6cf3">Loyc.Collections.Impl.AListInnerBase&lt; K, T &gt;.HandleUndersized()</a>.</p>

</div>
</div>
<a class="anchor" id="a81a903ee7cc50a9bd6f253eb8418568f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract int Loyc.Collections.Impl.AListNode&lt; K, T &gt;.LocalCount</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of items (slots) used this node only.</p>

<p>Referenced by <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListInnerBase_3_01K_00_01T_01_4.html#a782f53c1b0884e1ba5ebc86b74fd6cf3">Loyc.Collections.Impl.AListInnerBase&lt; K, T &gt;.HandleUndersized()</a>.</p>

</div>
</div>
<a class="anchor" id="a0b21bfb21059a585c0a39d5978f6b04b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract T Loyc.Collections.Impl.AListNode&lt; K, T &gt;.this[uint index]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an item at the specified sub-index.</p>

</div>
</div>
<a class="anchor" id="a6cc6cb074720b087c76e3ec3d9d2e0ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract uint Loyc.Collections.Impl.AListNode&lt; K, T &gt;.TotalCount</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the total number of (T) items in this node and all children</p>

<p>Referenced by <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListInnerBase_3_01K_00_01T_01_4.html#a782f53c1b0884e1ba5ebc86b74fd6cf3">Loyc.Collections.Impl.AListInnerBase&lt; K, T &gt;.HandleUndersized()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Mar 2 2016 19:16:54 for Loyc by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
