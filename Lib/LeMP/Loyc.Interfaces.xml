<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Loyc.Interfaces</name>
    </assembly>
    <members>
        <member name="T:Loyc.Collections.ICharSource">
            <summary>A read-only list of characters plus a <see cref="M:Loyc.Collections.ICharSource.Slice(System.Int32,System.Int32)"/> method.</summary>
            <remarks>
            To get an instance of this interface from a string, write
            <c>new StringSlice("string")</c> or <c>(UString)"string"</c>.
            <para/>
            This is the standard interface for lexers to use as a source of 
            characters; is it defined in Loyc.Essentials rather than Loyc.Syntax
            so that <see cref="T:Loyc.UString"/> can implement it, and because it might
            be useful in other contexts.
            <para/>
            This interface was created to read characters more efficiently. 
            Although a lexer could read characters one-at-a-time from 
            IReadOnlyList{char} or IListSource{char}, it requires dynamic interface 
            dispatch for every character. On the other hand, if lexers avoid this 
            overhead by requiring the entire file in the form of a string, it becomes 
            necessary to hold the entire file in memory at once, in a very specific 
            format (a string).
            <para/>
            Slice() allows the lexer to request small pieces of the file that
            it can read without dynamic dispatch. Typically a lexer will be
            derived from Loyc.Syntax.Lexing.BaseLexer, which requests somewhat
            small chunks; the ICharSource implementation is is free to read 
            larger blocks at once, since the return type, <see cref="T:Loyc.UString"/>,
            can be a slice of a larger string.
            <para/>
            This interface provides good efficiency when reading from strings, 
            or from data structures composed of large strings (most notably, 
            this interface could efficiently return sections of a gap buffer),
            but unlike String itself, it is flexible, and does not require
            the entire file to be held in memory as a single contiguous block.
            <para/>
            It's unfortunate that .NET treats strings as something completely 
            different than arrays. Otherwise, this interface could support not
            just substrings, but subarrays of any element type, which would be
            useful any time you want to optimize your code by reducing dynamic 
            dispatch.
            <para/>
            Note about Count: if ICharSource represents to a file or other Stream,
            reading Count forces the entire stream to be scanned in order to determine
            the number of characters in the file (which may be different from the number 
            of bytes). Rather than do a test like <c>if (index >= charSource.Count)</c>
            it is better to use <c>if (Slice(index, 1).Count == 0)</c>, or better yet,
            <c>TryGet(index, out fail)</c>.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.ICharSource.Slice(System.Int32,System.Int32)">
            <summary>
            Returns a substring from the character source. If some of the
            requested characters are past the end of the stream, the string
            is truncated to the available number of characters.
            </summary>
            <param name="startIndex">Index of first character to return. If startIndex >= Count, an empty string is returned.</param>
            <param name="length">Number of characters desired.</param>
            <exception cref="T:System.ArgumentException">Thrown if startIndex or length are negative.</exception>
        </member>
        <member name="T:Loyc.Collections.Impl.DictionaryBase`2">
            <summary>A base class for user-defined dictionaries that want to implement 
            both <c>IDictionary(K,V)</c> and <c>IReadOnlyDictionary(K, V)</c>.</summary>
            <remarks>Modified version of source: datavault project. License: Apache License 2.0.</remarks>
        </member>
        <member name="M:Loyc.Collections.Impl.DictionaryBase`2.SetValue(`0,`1)">
            <summary>Implementation of the setter for this[].</summary>
            <remarks>The setter alone (without the getter) is not allowed to be virtual 
            in C# so a separate method is required.</remarks>
        </member>
        <member name="T:Loyc.Collections.EnumerationException">
            <summary>An exception thrown by an enumerator when it detects that the collection
            was modified after enumeration started but before it finished.</summary>
        </member>
        <member name="T:Loyc.Collections.KeyAlreadyExistsException">
            <summary>An exception thrown by dictionary objects when they are asked to
            "add" a key-value pair that already exists.</summary>
        </member>
        <member name="T:Loyc.Collections.EmptySequenceException">
            <summary>An exception thrown by methods or properties that require a non-empty
            sequence but were provided with an empty sequence.</summary>
        </member>
        <member name="T:Loyc.Collections.KeyCollection`2">
            <summary>Adapter: this is a read-only collection of Keys read from a 
            generic IDictionary. It is a modified version of 
            Dictionary{TKey, TValue}.KeyCollection from the Mono project, changed 
            to use IDictionary instead of Dictionary.</summary>
        </member>
        <member name="T:Loyc.Collections.ListChangeInfo`1">
            <summary>Contains information about how a collection is about to change.</summary>
            <typeparam name="T">Type of element in the collection</typeparam>
            <remarks>
            In contrast to <see cref="T:System.Collections.Specialized.NotifyCollectionChangedEventArgs"/>, this object
            represents changes that are about to happen, not changes that have happened
            already.
            </remarks>
            <seealso cref="T:Loyc.Collections.INotifyListChanging`1"/>
        </member>
        <member name="M:Loyc.Collections.ListChangeInfo`1.#ctor(System.Collections.Specialized.NotifyCollectionChangedAction,System.Int32,System.Int32,Loyc.Collections.IListSource{`0})">
            <summary>Initializes the members of <see cref="T:Loyc.Collections.ListChangeInfo`1"/>.</summary>
        </member>
        <member name="F:Loyc.Collections.ListChangeInfo`1.Action">
            <summary>Gets a value that indicates the type of change being made to 
            the collection.</summary>
        </member>
        <member name="F:Loyc.Collections.ListChangeInfo`1.Index">
            <summary>Gets the index at which the add, remove, or change operation starts.</summary>
        </member>
        <member name="F:Loyc.Collections.ListChangeInfo`1.SizeChange">
            <summary>Gets the amount by which the collection size changes. When 
            items are being added, this is positive, and when items are being
            removed, this is negative. This is 0 when existing items are only being 
            replaced.</summary>
        </member>
        <member name="F:Loyc.Collections.ListChangeInfo`1.NewItems">
            <summary>Represents either new items that are being added to the 
            collection, or items that are about to replace existing items in 
            the collection. This member is null or empty when items are being 
            removed.</summary>
        </member>
        <member name="T:Loyc.Collections.RangeEnumerator`2">
            <summary>Helper struct: enumerates through a forward range (<see cref="T:Loyc.Collections.IFRange`1"/>), 
            calling the range methods through R instead of through <see cref="T:Loyc.Collections.IFRange`1"/>.
            </summary>
        </member>
        <member name="M:Loyc.Collections.RangeEnumerator`2.R_Clone``1(``0)">
            <summary>Since R implements IFRange{T} which includes ICloneable{IFRange{T}},
            we cannot invoke ICloneable{R}.Clone because the compiler complains that 
            Clone() is ambiguous. I used to think it was necessary to cast the range to <see 
            cref="T:Loyc.ICloneable`1"/> just to clone it; if R is a value type then it is
            boxed, hurting performance. But then I thought of doing this.</summary>
        </member>
        <member name="T:Loyc.Collections.ValueCollection`2">
            <summary>Adapter: this is a read-only collection of Values read from a 
            generic IDictionary. It is a modified version of <c>Dictionary{TKey, TValue}.ValueCollection</c>
            from the Mono project, changed to use IDictionary instead of Dictionary.
            </summary>
        </member>
        <member name="T:Loyc.Collections.ValueCollection`2.Enumerator">
            <summary>Return type of <see cref="M:Loyc.Collections.ValueCollection`2.GetEnumerator"/>.</summary>
        </member>
        <member name="T:Loyc.Collections.WeakValueDictionary`2">
            <summary>
            A dictionary in which the values are weak. When a value has been garbage-
            collected, the dictionary acts as if the key is not present (except the
            Remove() method, which saves time by not checking whether the value is 
            dead.)
            </summary>
            <remarks>
            This is implemented on top of a standard Dictionary. In order to allow the 
            dictionary to be read safely while it is being enumerated, cleanup 
            operations (to remove entries whose value has been garbage-collected) do 
            not occur automatically during read operations. You can allow cleanups
            by calling AutoCleanup().
            </remarks>
        </member>
        <member name="M:Loyc.Collections.WeakValueDictionary`2.AutoCleanup">
            <summary>Periodically removes entries with garbage-collected values from the dictionary</summary>
        </member>
        <member name="M:Loyc.Collections.WeakValueDictionary`2.Cleanup">
            <summary>Removes entries with garbage-collected values from the dictionary.</summary>
        </member>
        <member name="P:Loyc.Collections.WeakValueDictionary`2.Count">
            <summary>Returns the number of dictionary entries. This value may be
            greater than the number of elements that are still alive.</summary>
        </member>
        <member name="T:Loyc.Collections.ISparseListSource`1">
            <summary>Represents a read-only indexed list in which parts of the index 
            space may be unused or "clear".</summary>
            <remarks>
            This interface should be implemented by "sparse" data structures that are 
            optimized for lists that have large gaps in them; for example, a sparse 
            data structure with <c>Count == 1000000</c> might really contain only a 
            few elements, or it could even be completely empty. The <c>Count</c> of a 
            sparse list tells you the range of valid indexes that you are allowed to 
            read, but since any or all of the space might be empty, it only gives an 
            upper bound, not a lower bound, of the true size of the list.
            <para/>
            When you read <c>list[i]</c>, and <c>i</c> is within an empty area of the 
            sparse list, a default value is returned, which is normally <c>default(T)</c>.
            <para/>
            As an example, <c>SortedDictionary&lt;int, T></c> could be viewed as a sparse
            list. Assuming the dictionary has no negative integers, you could create a 
            wrapper around <c>SortedDictionary&lt;int, T></c> that implements this 
            interface as follows:
            <ul>
            <li><c>Count</c> returns <c>int.MaxValue</c>,</li>
            <li><see cref="M:Loyc.Collections.ISparseListSource`1.NextHigherItem(System.Nullable{System.Int32}@)"/> and <see cref="M:Loyc.Collections.ISparseListSource`1.NextLowerItem(System.Nullable{System.Int32}@)"/> do a linear scan 
            to find the next higher or lower key that exists.</li>
            <li><see cref="M:Loyc.Collections.ISparseListSource`1.IsSet(System.Int32)"/> returns the result of <see cref="M:System.Collections.Generic.SortedDictionary`2.ContainsKey(`0)"/>, and</li>
            <li><see cref="!:IListSource&lt;T&gt;.TryGet(int, out bool)"/> returns the value 
            retrieved by <see cref="M:System.Collections.Generic.SortedDictionary`2.TryGetValue(`0,`1@)"/>, setting 'fail'
            only if the index is negative.</li>
            </ul>
            <c>SortedDictionary</c> is not a very useful example in practise, though,
            because it does not provide a way for <see cref="M:Loyc.Collections.ISparseListSource`1.NextHigherItem(System.Nullable{System.Int32}@)"/> and
            <see cref="M:Loyc.Collections.ISparseListSource`1.NextLowerItem(System.Nullable{System.Int32}@)"/> to work efficiently, and it cannot efficiently 
            support the <see cref="T:Loyc.Collections.ISparseList`1"/> interface. A more useful example
            is SparseAList{T} in Loyc.Collections.dll, which efficiently implements 
            this interface and <see cref="T:Loyc.Collections.ISparseList`1"/>.
            </remarks>
            <seealso cref="!:LCExt.AsSparse"/>
        </member>
        <member name="M:Loyc.Collections.ISparseListSource`1.NextHigherItem(System.Nullable{System.Int32}@)">
            <summary>Increases <c>index</c> by at least one to reach the next index
            that is not classified as empty space, and returns the item at that 
            index.</summary>
            <param name="index">This parameter is increased by at least one, and
            perhaps more than one so that it refers to an index where there is a
            value. If <c>index</c> is null upon entering this method, the first 
            non-empty space in the list is found. If there are no values at higher 
            indexes, if the list is empty or if <c>index + 1 >= Count</c>, 
            <c>index</c> is <c>null</c> when the method returns.</param>
            <remarks>This method must skip over all indexes i for which 
            <c>IsSet(i)</c> returns false, and return the next index for which
            <c>IsSet(i)</c> returns true. This method must accept any integer as 
            input, including invalid indexes.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.ISparseListSource`1.NextLowerItem(System.Nullable{System.Int32}@)">
            <summary>Decreases <c>index</c> by at least one to reach the next index
            that is not classified as empty space, and returns the item at that 
            index.</summary>
            <param name="index">This parameter is increased by at least one, and
            perhaps more than one so that it refers to an index where there is a
            value. If <c>index</c> is null upon entering this method, the last
            non-empty space in the list is found. If there are no values at lower
            indexes, if the list is empty or if <c>index</c> is 0 or less, 
            <c>index</c> is <c>null</c> when the method returns.</param>
            <remarks>This method must skip over all indexes i for which 
            <c>IsSet(i)</c> returns false, and return the next index for which
            <c>IsSet(i)</c> returns true. This method must accept any integer as 
            input, including invalid indexes.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.ISparseListSource`1.IsSet(System.Int32)">
            <summary>Determines whether a value exists at the specified index.</summary>
            <param name="index"></param>
            <returns>true if a value is assigned at the specified index, or false
            if index is part of an empty space, or is outside the range of indexes
            that exist.</returns>
        </member>
        <member name="T:Loyc.Collections.LCInterfaces">
            <summary>
            This class contains extension methods that are provided as part of various 
            Loyc.Collections interfaces. For example, it provides methods such as IndexOf(),
            Contains() and CopyTo(), that the traditional <see cref="T:System.Collections.Generic.ICollection`1"/> 
            and <see cref="T:System.Collections.Generic.IList`1"/> interfaces require the author to write himself.
            </summary>
            <remarks>
            For covariant collections such as <see cref="T:System.Collections.Generic.IReadOnlyCollection`1"/> and <see 
            cref="T:Loyc.Collections.IListSource`1"/>, the CLR actually prohibits methods such as 
            Contains(T) and IndexOf(T), because T is not allowed in "input" positions. 
            Therefore, these extension methods must be used to fill the gap. Even
            methods such as <i>bool TryGet(int, out T)</i> are prohibited, so TryGet()
            has the signature <i>T TryGet(ref bool failed)</i> instead, and extension
            methods provide the original version of the method in addition.
            </remarks>
            <summary>Extension methods for Loyc collection interfaces</summary>
        </member>
        <member name="M:Loyc.Collections.LCInterfaces.NextHigherIndex``1(Loyc.Collections.ISparseListSource{``0},System.Nullable{System.Int32})">
            <summary>Gets the next higher index that is not classified as an
            empty space, or null if there are no non-blank higher indexes.</summary>
            <remarks>This extension method works by calling <c>NextHigherItem()</c>.</remarks>
        </member>
        <member name="M:Loyc.Collections.LCInterfaces.NextLowerIndex``1(Loyc.Collections.ISparseListSource{``0},System.Nullable{System.Int32})">
            <summary>Gets the next lower index that is not classified as an
            empty space, or null if there are no non-blank lower indexes.</summary>
            <remarks>This extension method works by calling <c>NextHigherItem()</c>.</remarks>
        </member>
        <member name="M:Loyc.Collections.LCInterfaces.Items``1(Loyc.Collections.ISparseListSource{``0})">
            <summary>Returns the non-cleared items in the sparse list, along with 
            their indexes, sorted by index.</summary>
            <remarks>
            The returned sequence should exactly match the set of indexes for which 
            <c>list.IsSet(Key)</c> returns true.</remarks>
        </member>
        <member name="M:Loyc.Collections.LCInterfaces.Any(Loyc.Collections.ICount)">
            <summary>Returns true if the collection contains any elements.</summary>
        </member>
        <member name="M:Loyc.Collections.LCInterfaces.GetAndEdit``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1@,Loyc.Collections.DictEditMode)">
            <summary>Default implementation of <see cref="M:Loyc.Collections.IDictionaryEx`2.GetAndEdit(`0@,`1@,Loyc.Collections.DictEditMode)"/>.</summary>
        </member>
        <member name="M:Loyc.Collections.LCInterfaces.AddIfNotPresent``2(Loyc.Collections.IDictionaryEx{``0,``1},``0,``1)">
            <summary>Adds a key/value pair to the dictionary if the key is not present. If the 
            key is already present, this method has no effect.</summary>
            <returns>True if the pair was added, false if not.</returns>
        </member>
        <member name="M:Loyc.Collections.LCInterfaces.GetOrAdd``2(Loyc.Collections.IDictionaryEx{``0,``1},``0,``1)">
            <summary>Adds a key/value pair to the dictionary if the key is not already present,
            and returns the existing or new value.</summary>
            <returns>The existing value (if the key already existed) or the new value.</returns>
        </member>
        <member name="M:Loyc.Collections.LCInterfaces.AddOrGetExisting``2(Loyc.Collections.IDictionaryEx{``0,``1},``0,``1)">
            <summary>Adds a new key/value pair if the key was not present, or gets the existing 
            value if the key was present.</summary>
            <returns>The existing value. If a new pair was added, the result has no value.</returns>
            <seealso cref="M:Loyc.Collections.LCInterfaces.GetOrAdd``2(Loyc.Collections.IDictionaryEx{``0,``1},``0,``1)"/>
        </member>
        <member name="M:Loyc.Collections.LCInterfaces.ReplaceIfPresent``2(Loyc.Collections.IDictionaryEx{``0,``1},``0,``1)">
            <summary>Replaces an item in the map if the key was already present.
            If the key was not already present, this method has no effect.</summary>
            <returns>True if a value existed and was replaced, false if not.</returns>
        </member>
        <member name="M:Loyc.Collections.LCInterfaces.SwapIfPresent``2(Loyc.Collections.IDictionaryEx{``0,``1},``0,``1)">
            <summary>Replaces an item in the map if the key was already present.
            If the key was not already present, this method has no effect.</summary>
            <returns>The old value if a value was replaced, or an empty value of <see cref="T:Loyc.Maybe`1"/> otherwise.</returns>
        </member>
        <member name="M:Loyc.Collections.LCInterfaces.GetAndSet``2(Loyc.Collections.IDictionaryEx{``0,``1},``0,``1)">
            <summary>Associates a key with a value in the dictionary, and gets the old value
            if the key was already present.</summary>
            <returns>The old value associated with the same key. If a new pair was added,
            the result has no value.</returns>
        </member>
        <member name="M:Loyc.Collections.LCInterfaces.TryGet``1(Loyc.Collections.IListSource{``0},System.Int32,``0@)">
            <summary>Tries to get a value from the list at the specified index.</summary>
            <param name="index">The index to access. Valid indexes are between 0 and Count-1.</param>
            <param name="value">A variable that will be changed to the retrieved value. If the index is not valid, this variable is left unmodified.</param>
            <returns>True on success, or false if the index was not valid.</returns>
        </member>
        <member name="M:Loyc.Collections.LCInterfaces.TryGet``1(Loyc.Collections.IListSource{``0},System.Int32,``0)">
            <summary>Tries to get a value from the list at the specified index.</summary>
            <param name="index">The index to access. Valid indexes are between 0 and Count-1.</param>
            <param name="defaultValue">A value to return if the index is not valid.</param>
        </member>
        <member name="M:Loyc.Collections.LCInterfaces.HasIndex``1(Loyc.Collections.IListSource{``0},System.Int32)">
            <summary>Uses list.TryGet(index) to find out if the specified index is valid.</summary>
            <returns>true if the specified index is valid, false if not.</returns>
        </member>
        <member name="M:Loyc.Collections.LCInterfaces.FirstIndexOf``1(System.Collections.Generic.IReadOnlyList{``0},``0)">
            <summary>Determines the index of a specific value.</summary>
            <returns>The index of the value, if found, or null if it was not found.</returns>
        </member>
        <member name="M:Loyc.Collections.LCInterfaces.IndexOf``1(System.Collections.Generic.IReadOnlyList{``0},``0)">
            <summary>Determines the index of a specific value.</summary>
            <returns>The index of the value, if found, or -1 if it was not found.</returns>
        </member>
        <member name="M:Loyc.Collections.LCInterfaces.FirstIndexWhere``1(System.Collections.Generic.IReadOnlyList{``0},System.Func{``0,System.Boolean})">
            <summary>Gets the lowest index at which a condition is true, or null if nowhere.</summary>
        </member>
        <member name="M:Loyc.Collections.LCInterfaces.IndexWhere``1(System.Collections.Generic.IReadOnlyList{``0},System.Func{``0,System.Boolean})">
            <summary>Gets the lowest index at which a condition is true, or -1 if nowhere.</summary>
        </member>
        <member name="M:Loyc.Collections.LCInterfaces.FinalIndexWhere``1(System.Collections.Generic.IReadOnlyList{``0},System.Func{``0,System.Boolean})">
            <summary>Gets the highest index at which a condition is true, or null if nowhere.</summary>
        </member>
        <member name="M:Loyc.Collections.LCInterfaces.LastIndexWhere``1(System.Collections.Generic.IReadOnlyList{``0},System.Func{``0,System.Boolean})">
            <summary>Gets the highest index at which a condition is true, or -1 if nowhere.</summary>
        </member>
        <member name="M:Loyc.Collections.LCInterfaces.TryGet``1(Loyc.Collections.INegListSource{``0},System.Int32,``0@)">
            <summary>Tries to get a value from the list at the specified index.</summary>
            <param name="index">The index to access. Valid indexes are between Min and Max.</param>
            <param name="value">A variable that will be changed to the retrieved value. If the index is not valid, this variable is left unmodified.</param>
            <returns>True on success, or false if the index was not valid.</returns>
        </member>
        <member name="M:Loyc.Collections.LCInterfaces.IndexOf``1(Loyc.Collections.INegListSource{``0},``0)">
            <summary>Determines the index of a specific value.</summary>
            <returns>The index of the value, if found, or null if it was not found.</returns>
            <remarks>
            At first, this method was a member of IListSource itself, just in 
            case the source might have some kind of fast lookup logic (e.g. binary 
            search) or custom comparer. However, since the item to find is an "in" 
            argument, it would prevent IListSource from being marked covariant when
            I upgrade to C# 4.
            </remarks>
        </member>
        <member name="T:Loyc.Collections.ISparseList`1">
            <summary>Represents a sparse list that allows insertion and removal of items
            and empty spaces. In a sparse list, some spaces can be "clear" meaning that 
            they have no value.</summary>
            <typeparam name="T"></typeparam>
            <remarks>
            Classes that implement this interface should be designed so that large empty 
            spaces in the list consume no memory, or very little memory. Furthermore,
            insertions and removals at random indexes should take no more than O(M) 
            amortized time to complete, where M is the number of elements actually set
            (non-empty spaces), and Count >= M. (Sparse lists do not have to keep track
            of M itself, though, so there is no property to retrieve this value).
            <para/>
            This interface has special methods for creating empty spaces: 
            <see cref="M:Loyc.Collections.ISparseList`1.ClearSpace(System.Int32,System.Int32)"/> and <see cref="M:Loyc.Collections.ISparseList`1.InsertSpace(System.Int32,System.Int32)"/>.
            The implementation can treat all other insertions and changes as non-empty
            values; for example, given code like
            <code>
            ISparseList&lt;T> list = ...;
            foreach (int i in Enumerable.Range(1000))
                list.Add(default(T));
            </code>
            A sparse list is allowed to treat the last 1000 items as "clear" (saving 
            memory) or "set" (allocating memory) depending on how it is implemented. 
            Since the .NET framework does not allow fast bitwise comparisons of a 
            generic T (in other words, there is no fast, generic way to compare a T 
            value with default(T)), implementations will typically treat the last 1000 
            items as "set" and unnecessarily allocate memory for them. Blame Microsoft.
            <para/>
            This interface has no method to insert another sparse list into the current 
            one, but <see cref="T:Loyc.Collections.ISparseListEx`1"/> does.
            <para/>
            A sparse list is allowed to behave like <see cref="T:Loyc.Collections.IAutoSizeArray`1"/> when 
            setting an invalid non-negative index. When you set <c>this[i]</c> where 
            i >= 0, the <c>Count</c> may automatically increase to <c>i + 1</c> if 
            necessary, <i>or</i> the setter may throw <see cref="T:System.ArgumentOutOfRangeException"/>.
            Even if the setter succeeds, the getter of <c>this[i]</c> may still throw 
            <see cref="T:System.ArgumentOutOfRangeException"/> when <c>i</c> is an invalid index.
            <para/>
            The indexer (<c>this[i]</c>) returns a default value, typically 
            <c>default(T)</c>, when the specified index is valid but clear.
            <para/>
            Sparse list implementations do <i>not</i> have to perfectly track which 
            spaces are clear and which spaces are set; in particular, implementations
            are allowed to return <c>true</c> from <c>IsSet</c> for any valid index.
            <ul>
            <li>If the default value is <c>t</c> and you set <c>this[i] = t</c>, a 
            sparse list is allowed to return true or false from <c>IsSet(i)</c>.</li>
            <li>After you call <c>Clear(i)</c>, a sparse list is still allowed to 
            return true from <c>IsSet(i)</c>.</li>
            <li>After you set <c>this[i] = v</c> where <c>v</c> is not the default 
            value, <c>IsSet(i)</c> <i>must</i> return true.</li>
            </ul>
            The purpose of this freedom is to permit implementations that use arrays
            of T[] for regions that are mostly filled. For example, if 95 out of 100
            indexes in a certain region are filled, an implementation may decide it 
            is more efficient to use an array that discards information about the 
            empty spaces.
            <para/>
            On the other hand, some implementations are precise, and will always 
            report that <c>IsSet(i)==false</c> after you call <c>Clear(i)</c> or
            <c>InsertSpace(i)</c>.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.ISparseList`1.ClearSpace(System.Int32,System.Int32)">
            <summary>Unsets the range of indices <c>index</c> to <c>index+count-1</c> inclusive.
            If <c>index + count > Count</c>, the sparse list shall enlarge <c>Count</c>
            to be equal to <c>index + count</c>.</summary>
            <exception cref="T:System.ArgumentOutOfRangeException"><c>index</c> or <c>count</c> was negative.</exception>
            <exception cref="T:System.OverflowException"><c>index + count</c> overflowed.</exception>
        </member>
        <member name="M:Loyc.Collections.ISparseList`1.InsertSpace(System.Int32,System.Int32)">
            <summary>Inserts empty space starting at the specified index.</summary>
            <exception cref="T:System.OverflowException"><c>index + count</c> overflowed.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><c>index</c> or <c>count</c>
            was negative. If <c>index > Count</c>, this method may throw: if, for 
            this kind of list, setting this[i] for some invalid i>=0 throws 
            <c>ArgumentOutOfRangeException</c>, then so too does this method throw.
            If you want the list to be enlarged instead, call <c>Clear(index, 0)</c> 
            first, since the contract of Clear() requires it not to throw in the 
            same situation.</exception>
        </member>
        <member name="T:Loyc.Collections.ISparseListEx`1">
            <summary>A sparse list that supports additional methods including 
            <see cref="M:Loyc.Collections.ISparseListEx`1.InsertRange(System.Int32,Loyc.Collections.ISparseListSource{`0})"/>.</summary>
            <seealso cref="T:Loyc.Collections.ISparseList`1"/>
        </member>
        <member name="M:Loyc.Collections.ISparseListEx`1.InsertRange(System.Int32,Loyc.Collections.ISparseListSource{`0})">
            <summary>Inserts another sparse list into this one.</summary>
        </member>
        <member name="T:Loyc.Collections.IBinumerator`1">
            <summary>Extends the "enumerator" concept to allow backward enumeration.</summary>
            <remarks>
            When MoveNext() returns false, indicating that there are no more elements,
            you can still call MovePrev() to go back to the previous element.
            </remarks>
        </member>
        <member name="T:Loyc.Collections.IMEnumerator`1">
            <summary>A mutable enumerator interface. Provides a "Remove" method like
            Java iterators have, and allows you to modify the current item.</summary>
            <remarks>Please note, not all collections will support "Remove".</remarks>
        </member>
        <member name="P:Loyc.Collections.IMEnumerator`1.Current">
            <summary>Gets or sets the value of the current item.</summary>
        </member>
        <member name="M:Loyc.Collections.IMEnumerator`1.Remove">
            <summary>Removes the current item and moves to the next one. Remember
            NOT to call MoveNext() immediately after Remove().</summary>
            <returns>True if there is a next item after this one, 
            false if the removed item was the last one.</returns>
            <exception cref="T:System.NotSupportedException">The collection does not permit
            this operation.</exception>
        </member>
        <member name="T:Loyc.Collections.IMBinumerator`1">
            <summary>A mutable bidirectional enumerator interface. Please note that
            the "Remove" method always moves to the next item, even though the 
            Binumerator is capable of moving backward.</summary>
        </member>
        <member name="T:Loyc.Collections.IBinumerable`1">
            <summary>Interface for a collection that can return <see cref="T:Loyc.Collections.IBinumerator`1"/>s 
            pointing to the beginning and end of the collection.</summary>
        </member>
        <member name="M:Loyc.Collections.IBinumerable`1.Begin">
            <summary>Returns a binumerator that points before the beginning of the current collection.</summary>
        </member>
        <member name="M:Loyc.Collections.IBinumerable`1.End">
            <summary>Returns a binumerator that points after the end of the current collection.</summary>
        </member>
        <member name="T:Loyc.Collections.IFRange`1">
            <summary>A forward range. Allows you to read the first element from the 
            range or skip it. The forward range lays the foundation for
            <see cref="T:Loyc.Collections.IBRange`1"/> and <see cref="T:Loyc.Collections.IRange`1"/>.</summary>
            <remarks>
            Ranges are a concept I first saw formalized in the D programming language.
            They are generally more useful than .NET enumerators because there are 
            more kinds of them:
            <ul>
            <li>A forward range (<see cref="T:Loyc.Collections.IFRange`1"/>) is a sequence of values 
            accessed starting with the first, like <see cref="T:System.Collections.Generic.IEnumerator`1"/>. A 
            forward range is like IEnumerator, except that it can be cloned, so you 
            can restart from the same place later. This is more powerful than 
            <see cref="T:System.Collections.Generic.IEnumerable`1"/>, which can only restart from the beginning.</li>
            <li>A bidirectional range inherits from the forward range, and provides
            access to the back of the sequence as well as the front. A bidirectional
            iterators may, for example, represent a linked list, or a UTF-8 string 
            that provides access to the first and last 32-bit code point (note that
            random access by character index is not really possible in UTF-8 data,
            since the size of N characters is unknown).</li>
            <li>A random-access range is a sequence that provides array-like access
            to a section of a list. A section of a list is called a "slice".</li>
            </ul>
            A range is read-only by default, but has a writable variant marked
            with the letter M, meaning "Mutable": <see cref="T:Loyc.Collections.IMFRange`1"/>, 
            <see cref="T:Loyc.Collections.IMBRange`1"/>, <see cref="T:Loyc.Collections.IMRange`1"/>.
            <para/>
            It is fair to ask why IFRange exists--since it behaves like an enumerator,
            why not simply use IEnumerator directly? Well, this interface serves as 
            the base interface for the other ranges, so its interface needs to make
            sense in that context. IEnumerator has "Current" and "MoveNext" methods,
            but in a bidirectional or random-access range, there is no single 
            "Current" or "Next" item.
            <para/>
            Also, when used through an interface, IFRange is potentially more 
            efficient than IEnumerator: you only need to call a single method, 
            PopFirst(), to get the next item, unlike IEnumerator which requires two 
            interface calls per iteration. That can improve performance, since 
            interface calls cannot be inlined. It is a bit inconvenient to use
            <see cref="M:Loyc.Collections.IFRange`1.PopFirst(System.Boolean@)"/> because of its "out" argument, and 
            more convenient extension methods would have been provided if C# 
            supported "ref Type this", which would be needed since ranges are
            often value types.
            <para/>
            Ranges are useful for implementing algorithms; they are comparable to
            the concept of "iterators" in C++, except that a range represents a 
            pair of iterators instead of a single iterator. And like C++ iterators,
            they are a useful starting point for writing generic algorithms.
            <para/>
            When using a range that is not typed <see cref="T:Loyc.Collections.IFRange`1"/>, you need to
            be careful how you use it because the range could be a struct type. Much 
            like an enumerator, a range is often a small wrapper around a larger data
            structure; therefore, it often makes sense to implement a range as a 
            struct. When a range is a struct, normally you are making a copy of it 
            whenever you assign it to a different variable, or pass it to another 
            method:
            <code>
                Range b = a;
                a.PopFirst(); // may not affect b if Range is a struct
            </code>
            In fact, a range should not be copied this way because assignment may or
            may not create a copy. You should avoid simple assignment, and use 
            Clone() to copy a range instead:
            <code>
                Range b = a.Clone();
                a.PopFirst(); // will not affect b, and you can be sure of it
            </code>
            However, if a range is a reference type or a reference to IFRange, you 
            are not making a copy of it when you assign it or pass it to another 
            method:
            <code>
                IFRange&lt;T> a = ...;
                IFRange&lt;T> b = a;
                a.PopFirst(); // The item was popped from b also
            </code>
            When writing generic code, you may want to use range types directly, as in:
            <code>
                void DoSomethingWithRange&lt;R,T>(R range) where R : IRange&lt;T> {...}
            </code>
            Using a range type directly can improve performance if R happens to be 
            a struct type, since there is no need to box the range when passing it 
            to this method. However, it is very important to keep in mind that "R" 
            may be a struct or a class. If this method is not intended to modify the 
            range from the perspective of the caller, the method must start by cloning 
            the range, in case R is a class or interface type:
            <code>
                void DoSomethingWithRange&lt;R,T>(R range) where R : IBRange&lt;T> {
                    range = range.Clone();
                    ...
                }
            </code>
            On the other hand, if this method <i>wants</i> the caller to see the 
            changes to the range, R must be passed by reference, in case it is a
            struct type:
            <code>
                void DoSomethingWithRange&lt;R,T>(ref R range) where R : IBRange&lt;T> {
                    ...
                }
            </code>
            To avoid these subtle difficulties, you can access the range through
            the <see cref="T:Loyc.Collections.IFRange`1"/> interface; just remember to Clone() the 
            range when necessary.
            <para/>
            Remember that a range is an alias for some underlying data structure.
            If the original data structure is modified, a range will "see" those
            changes. For instance, suppose that a range provides a slice from 
            indexes 5 to 12 inclusive within an <see cref="T:System.Collections.Generic.IList`1"/> object 
            that contains 15 items:
            <pre>
                IList  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 
                       a  b  c  d  e  f  g  h  i  j  k  l  m  n  o 
                IRange                0  1  2  3  4  5  6  7
            </pre>
            Thus, [0] in the range corresponds to item [5] in the list, "f". Now, 
            if the first three items in the list are removed, then [0] in the range 
            will still correspond to item [5] in the list, but the item at this 
            location, marked "i", used to be at index [8]:
            <pre>
                IList  0  1  2  3  4  5  6  7  8  9 10 11
                       d  e  f  g  h  i  j  k  l  m  n  o
                IRange                0  1  2  3  4  5  6  7
            </pre>
            The exact behavior of the range at this point is implementation-dependent.
            The <c>Count</c> property may remain at 8, or it may drop to 7; perhaps the
            range will return default(T) when you read index [7], or perhaps it will
            throw <see cref="T:System.IndexOutOfRangeException"/>. Because of this lack of
            predictability, you should avoid keeping a range that points to a list whose
            size is decreasing. If individual elements are modified but not the list 
            size, the range is safe to use and will see the changes. If new elements 
            are added to the end of the list, the range may or may not continue working 
            as expected, depending on how the collection works and how the range works.
            In most cases the range will be unaffected, in contrast to common C++ 
            containers such as <c>std::vector</c>, in which iterators are "invalidated" 
            by any size change, and when an invalid iterator is accessed, it may return 
            bad data or crash the program.
            <para/>
            Currently there are no interfaces in Loyc.Essentials that return forward or 
            bidirectional ranges; the only notable method that returns a range is
            <see cref="M:Loyc.Collections.IListSource`1.Slice(System.Int32,System.Int32)"/>, which returns a random-access range.
            Since a random-access range is also a bidirectional range, you can begin
            writing algorithms that accept forward and bidirectional ranges (for read 
            access). Any collection that implements <see cref="T:Loyc.Collections.IListSource`1"/> can 
            be treated as a range using the <see cref="!:ListExt.AsRange&lt;T&gt;(IListSource&lt;T&gt;)"/> 
            extension method, which is like calling <c>Slice(0)</c>.
            <para/>
            The design philosophy of Loyc.Essentials is that potentially useful 
            interfaces should be included even if there are no implementations of the 
            interface. That's why there are interfaces like <see cref="T:Loyc.Collections.IMFRange`1"/>
            that are not implemented by any classes. Why offer unused interfaces?
            Because this library is designed to be extended by third parties, who 
            might want to implement the interface, e.g. if someone else creates 
            mutable data structures such as the B+ tree, the doubly-linked list or 
            the trie, they should offer implementations of <see cref="T:Loyc.Collections.IMBRange`1"/> 
            and/or <see cref="T:Loyc.Collections.IMBinumerator`1"/>.
            <para/>
            Implementors note: <see cref="T:Loyc.Collections.IFRange`1"/> includes <see cref="T:System.Collections.Generic.IEnumerable`1"/>, 
            and you can use the following implementation of IEnumerable provided 
            that your range type <c>R</c> implements <see cref="T:Loyc.ICloneable`1"/>:
            <code>
                IEnumerator System.Collections.IEnumerable.GetEnumerator() { return GetEnumerator(); }
                IEnumerator&lt;T> IEnumerable&lt;T>.GetEnumerator() { return GetEnumerator(); }
                public RangeEnumerator&lt;R,T> GetEnumerator()
                {
                    return new RangeEnumerator&lt;R,T>(this);
                }
            </code>
            TODO: write RangeBinumerator for IBRange{T},
                        RangeMBinumerator for IMBRange{T},
                    and RangeMEnumerator for IMEnumerator{T}.
            </remarks>
        </member>
        <member name="P:Loyc.Collections.IFRange`1.First">
            <summary>Returns the first value in the range, without popping it.</summary>
            <exception cref="T:Loyc.Collections.EmptySequenceException">The sequence is empty.</exception>
            <remarks>
            A possible default implementation:
            <pre>
            T First { get { return Range.PopFirst(Clone()); } }
            </pre>
            </remarks>
        </member>
        <member name="M:Loyc.Collections.IFRange`1.PopFirst(System.Boolean@)">
            <summary>Removes the first item from the range and returns it.</summary>
            <param name="fail">Receives the current value of <see cref="P:Loyc.Collections.IIsEmpty.IsEmpty"/>.</param>
            <returns>The first item of the range, or default(T) if IsEmpty.</returns>
            <remarks>This method is a little unweildy in plain C#, but in EC# it 
            will be a bit more convenient to use via extension methods like 
            <c>T PopFirst(ref this Range range, T defaultValue)</c> and
            <c>T? PopFirst(ref this Range range)</c>, which are illegal in plain C#.
            <para/>
            I wanted to give this method the signature "bool PopFirst(out T first)"
            but the generic parameter "T" is covariant, i.e. it is marked "out T" 
            which, ironically, is not compatible with "out T" parameters, only with 
            return values.
            </remarks>
        </member>
        <member name="T:Loyc.Collections.IMFRange`1">
            <summary>A mutable forward range.</summary>
            <remarks>
            This range lets you change the value of <see cref="P:Loyc.Collections.IMFRange`1.First"/>.
            <para/>
            Please see <see cref="T:Loyc.Collections.IFRange`1"/> for general documentation about ranges.
            <para/>
            The mutable ranges do not include a clone method due to a limitation of C#.
            C# does not support covariance, which means that every time a derived 
            interface supports cloning, the implementing class is required to write a 
            separate clone method. Read-only ranges already have to implement up to 
            four clone methods: ICloneable{IFRange{T}}, ICloneable{IBRange{T}}, 
            ICloneable{IRange{T}}, and ICloneable{IRangeEx{T}}, and that's in addition 
            to the Clone method for the concrete type! If mutable ranges also supported
            cloning, they would add up to three more clone methods, which is really 
            getting out of hand.
            <para/>
            To limit the maximum number of clone methods to something reasonable, only 
            the immutable ranges have a clone method, but if the original range was 
            mutable then the clone will also be mutable; you just have to cast the 
            result:
            <code>
                var r2 = (IMFRange&lt;T>)r.Clone();
            </code>
            </remarks>
        </member>
        <member name="P:Loyc.Collections.IMFRange`1.First">
            <summary>Gets or sets the value of the first item in the range.</summary>
            <exception cref="T:Loyc.Collections.EmptySequenceException">The sequence is empty.</exception>
        </member>
        <member name="T:Loyc.Collections.IBRange`1">
            <summary>A bidirectional range. Allows you to read or remove the first
            or last element in a range.</summary>
            <remarks>
            The bidirectional range interface is useful for supporting
            data structures such as doubly-linked lists that have a front and a
            back but no efficient access to the middle.
            <para/>
            Please see <see cref="T:Loyc.Collections.IFRange`1"/> for general documentation about ranges.
            </remarks>
        </member>
        <member name="P:Loyc.Collections.IBRange`1.Last">
            <summary>Returns the value of the last item in the range.</summary>
            <exception cref="T:Loyc.Collections.EmptySequenceException">The sequence is empty.</exception>
            <remarks>
            A reasonable default implementation:
            <pre>
            T Last { get { return Range.PopLast(Clone()); } }
            </pre>
            </remarks>
        </member>
        <member name="M:Loyc.Collections.IBRange`1.PopLast(System.Boolean@)">
            <summary>Removes the last item from the range and returns it.</summary>
            <param name="fail">Receives the current value of IsEmpty.</param>
            <returns>The first item of the range, or default(T) if IsEmpty.</returns>
            <remarks>The remarks of <see cref="M:Loyc.Collections.IFRange`1.PopFirst(System.Boolean@)"/> apply to this method.</remarks>
        </member>
        <member name="T:Loyc.Collections.IMBRange`1">
            <summary>A mutable bidirectional range.</summary>
            <remarks>This range lets you change the value of <see cref="P:Loyc.Collections.IMFRange`1.First"/> and <see cref="P:Loyc.Collections.IMBRange`1.Last"/>.
            <para/>
            Please see <see cref="T:Loyc.Collections.IFRange`1"/> for general documentation about ranges.
            </remarks>
        </member>
        <member name="P:Loyc.Collections.IMBRange`1.Last">
            <summary>Gets or sets the value of the last item in the range.</summary>
            <exception cref="T:Loyc.Collections.EmptySequenceException">The sequence is empty.</exception>
        </member>
        <member name="T:Loyc.Collections.IRange`1">
            <summary>A random-access range, also known as a "slice". Allows you to 
            narrow down the range like <see cref="T:Loyc.Collections.IBRange`1"/> does, and also 
            provides random access via <see cref="T:Loyc.Collections.IListSource`1"/>.</summary>
            <remarks>
            Please see <see cref="T:Loyc.Collections.IFRange`1"/> for general documentation about ranges.
            </remarks>
        </member>
        <member name="T:Loyc.Collections.IBRangeEx`2">
            <summary>A bidirectional range that can perform operations such as 
            intersection and overlap tests on pairs of ranges of the same type.</summary>
            <typeparam name="R">The type that implements this interface</typeparam>
            <typeparam name="T">The type of elements in the range</typeparam>
        </member>
        <member name="P:Loyc.Collections.IBRangeEx`2.InnerList">
            <summary>Gets the list upon which this range is based.</summary>
            <remarks>The return type is <see cref="T:System.Collections.Generic.IEnumerable`1"/> since the 
            available list interfaces may vary, e.g. it might be 
            <see cref="T:System.Collections.Generic.ICollection`1"/> or <see cref="T:Loyc.Collections.IListSource`1"/>.</remarks>
        </member>
        <member name="P:Loyc.Collections.IBRangeEx`2.SliceStart">
            <summary>Index where this range starts within the <see cref="P:Loyc.Collections.IBRangeEx`2.InnerList"/>.</summary>
        </member>
        <member name="M:Loyc.Collections.IBRangeEx`2.Intersect(`0)">
            <summary>Gets the region of overlap between two ranges.</summary>
            <remarks>If the ranges do not overlap, an empty range is returned with
            <see cref="P:Loyc.Collections.IBRangeEx`2.InnerList"/> set to the same value that this range has.</remarks>
        </member>
        <member name="M:Loyc.Collections.IBRangeEx`2.Union(`0)">
            <summary>Gets a range just large enough to contain both ranges.</summary>
            <exception cref="T:System.InvalidOperationException">The two ranges cannot be 
            combined because they have different <see cref="P:Loyc.Collections.IBRangeEx`2.InnerList"/> values.</exception>
            <remarks>As long as both ranges are based on the same list, this method 
            succeeds. For example, if one range covers 5..6 and the other range 
            covers 10..20, the union covers 5..20.</remarks>
        </member>
        <member name="T:Loyc.Collections.IBRangeEx`1">
            <summary>A bidirectional range that can perform operations such as 
            intersection and overlap tests on pairs of ranges.</summary>
        </member>
        <member name="T:Loyc.Collections.IRangeEx`2">
            <summary>A random-access range that can perform operations such as 
            intersection and overlap tests on pairs of ranges of the same type.</summary>
        </member>
        <member name="T:Loyc.Collections.IRangeEx`1">
            <summary>A random-access range that can perform operations such as 
            intersection and overlap tests on pairs of ranges.</summary>
        </member>
        <member name="T:Loyc.Collections.IMRange`1">
            <summary>A mutable random-access range.</summary>
            <remarks>IMRange models a shrinkable array. You can modify elements or 
            shrink the array, but not add anything new; this is a useful interface 
            for some divide-and-conquer problems, such as the quick sort.
            <para/>
            Please see <see cref="T:Loyc.Collections.IFRange`1"/> for general documentation about ranges.
            </remarks>
        </member>
        <member name="T:Loyc.Collections.ISetTests`1">
            <summary>Set testing operations.</summary>
            <typeparam name="SetT">Type of set that this set can be tested against.</typeparam>
        </member>
        <member name="T:Loyc.Collections.ISetOperations`2">
            <summary>Set-combining operations: With, Without, Union, Intersect, Except, Xor.</summary>
            <typeparam name="T">Type of items in the set.</typeparam>
            <typeparam name="SetT">Type of the set itself.</typeparam>
        </member>
        <member name="T:Loyc.Collections.ISetOperations`3">
            <summary>Set-combining operations: With, Without, Union, Intersect, Except, Xor.</summary>
            <typeparam name="T">Type of items in the set.</typeparam>
            <typeparam name="InSetT">Data type of the input sets that you pass to methods of this interface.</typeparam>
            <typeparam name="OutSetT">Data type of the output sets returned from this interface.</typeparam>
        </member>
        <member name="T:Loyc.Collections.ISetImm`2">
            <summary>An immutable set of type SetT with elements of type T.</summary>
            <typeparam name="SetT">Type of this set.</typeparam>
            <typeparam name="T">Type of items in the set</typeparam>
        </member>
        <member name="P:Loyc.Collections.ISetImm`2.IsInverted">
            <summary>Returns true if the set is inverted, which means that the
            enumerator returns all the items that are <i>not</i> in the set, 
            and the <see cref="P:System.Collections.Generic.IReadOnlyCollection`1.Count"/> returns the number 
            of items that are not in the set.</summary>
            <remarks><see cref="!:Loyc.Collections.InvertibleSet&lt;T&gt;"/> is an example 
            of a set that can be inverted. In most set implementations, this 
            property always returns false.</remarks>
        </member>
        <member name="T:Loyc.Collections.ISetImm`1">
            <summary>An immutable set that supports numerous set operations.</summary>
            <typeparam name="T">Type of items in the set</typeparam>
        </member>
        <member name="T:Loyc.Collections.ICount">
            <summary>Holds the Count property found in nearly all collection interfaces.</summary>
            <remarks>
            Microsoft has made this interface unusable by not defining it themselves in 
            .NET 4.5. Now that I've replaced my original interface 
            <code>
                interface ISource&lt;out T> : IEnumerable&lt;T>, ICount {}
            </code>
            with Microsoft's IReadOnlyCollection(T), the compiler complains constantly about 
            "Ambiguity between IReadOnlyCollection(T).Count and ICount.Count". Eliminating
            ICount from most places seems to be the only solution.
            </remarks>
        </member>
        <member name="P:Loyc.Collections.ICount.Count">
            <summary>Gets the number of items in the collection.</summary>
        </member>
        <member name="T:Loyc.Collections.IIsEmpty">
            <summary>Holds the IsEmpty property that tells you if a collection is empty.</summary>
        </member>
        <member name="T:Loyc.Collections.DictEditMode">
            <summary>Helper enum for <see cref="M:Loyc.Collections.IDictionaryEx`2.GetAndEdit(`0@,`1@,Loyc.Collections.DictEditMode)"/>.</summary>
        </member>
        <member name="F:Loyc.Collections.DictEditMode.Retrieve">
            <summary>Do not change the collection.</summary>
        </member>
        <member name="F:Loyc.Collections.DictEditMode.ReplaceIfPresent">
            <summary>Replace an existing pair if present, or do nothing if no matching key.</summary>
        </member>
        <member name="F:Loyc.Collections.DictEditMode.AddIfNotPresent">
            <summary>Add a new item if the key doesn't match an existing pair, or do nothing if it does.</summary>
        </member>
        <member name="F:Loyc.Collections.DictEditMode.AddOrReplace">
            <summary>Insert a key-value pair, replacing an existing one if the key already exists.</summary>
        </member>
        <member name="T:Loyc.Collections.IDictionaryEx`2">
            <summary>Combines <c>IDictionary</c>, <c>IReadOnlyDictionary</c>, and <c>IDictonarySink</c> 
            with a few additional methods.</summary>
            <remarks>
            This interface also derives from ICloneable for the sake of 
            implementations such as <see cref="!:MMap&lt;K,V&gt;"/> that support fast cloning.
            <c>RemoveRange()</c> is only provided as an extension method because it is
            rare that a dictionary can accelerate bulk removal of an arbitrary sequence.
            <para/>
            Look in <see cref="T:Loyc.Collections.LCInterfaces"/> for default implementations of the extra methods.
            And, as always, <see cref="T:Loyc.Collections.KeyCollection`2"/>, <see cref="T:Loyc.Collections.ValueCollection`2"/> 
            and <see cref="T:Loyc.Collections.Impl.DictionaryBase`2"/>will help you implement dictionary types.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.IDictionaryEx`2.GetAndRemove(`0)">
            <summary>Gets the value associated with the specified key, then
            removes the pair with that key from the dictionary.</summary>
            <param name="key">Key to search for.</param>
            <returns>The value that was removed. If the key is not found, 
            the result has no value (<see cref="P:Loyc.Maybe`1.HasValue"/> is false).</returns>
            <remarks>This method shall not throw when the key is null.</remarks>
        </member>
        <member name="M:Loyc.Collections.IDictionaryEx`2.GetAndEdit(`0@,`1@,Loyc.Collections.DictEditMode)">
            <summary>Combines a get and change operation into a single method call.
            You rarely need to call this method directly; the following extension 
            methods are based on it: <see cref="!:DictionaryExt.SwapIfPresent"/>,
            <see cref="!:DictionaryExt.AddIfNotPresent"/>, <see cref="!:DictionaryExt.AddOrGetExisting"/>,
            <see cref="!:DictionaryExt.ReplaceIfPresent"/>, <see cref="!:DictionaryExt.SetAndGet"/>.</summary>
            <param name="key">Specifies the key that you want to search for in the 
            map. Some implementations will update the key with the version of it
            found in the dictionary (although the new key is "equal" to the old key, 
            it may be a different object); otherwise the key is left unchanged.</param>
            <param name="value">If the key is found, the old value is saved  in this
            parameter. Otherwise, it is left unchanged.</param>
            <param name="mode">The specific behavior of this method depends on this.
            See <see cref="T:Loyc.Collections.DictEditMode"/> to understand its effect.</param>
            <returns>True if the pair's key ALREADY existed, false if not.</returns>
            <remarks>
            This method exists because some collections can optimize certain 
            combinations of operations, avoiding the two traversals through the data 
            structure that would be required by the IDictionary interface.
            <para/>
            This method shall not throw when the key is null, unless the 
            AddIfNotPresent bit is set in <c>mode</c> and the dictionary does not 
            support a null key.
            </remarks>
            <seealso cref="!:DictionaryExt.AddIfNotPresent"/>
        </member>
        <member name="M:Loyc.Collections.IDictionaryEx`2.AddRange(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},Loyc.Collections.DictEditMode)">
            <summary>Merges the contents of the specified sequence into this map.</summary>
            <param name="data">Pairs to merge in. Duplicates are allowed; if the 
            <c>ReplaceIfPresent</c> bit is set in <c>mode</c>, later values take 
            priority over earlier values, otherwise earlier values take priority.</param>
            <param name="mode">Specifies how to combine the collections.</param>
            <returns>The number of pairs that did not already exist in the collection.
            if the AddIfNotPresent bit is set on <c>mode</c>, this is the number of new 
            pairs added.</returns>
            <seealso cref="!:DictionaryExt.AddRange&lt;K, V&gt;(IDictionary&lt;K, V&gt;, IEnumerable&lt;KeyValuePair&lt;K, V&gt;&gt;)"/>
        </member>
        <member name="T:Loyc.Collections.IListSource`1">
            <summary>A read-only list indexed by an integer.</summary>
            <remarks>
            Member list:
            <code>
            public IEnumerator&lt;T> GetEnumerator();  // inherited
            System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator(); // inherited
            public T this[int index] { get; }          // inherited
            public int Count { get; }                  // inherited
            public T TryGet(int index, out bool fail); // inherited
            IRange&lt;T> Slice(int start, int count = int.MaxValue);
            </code>
            The term "source" means a read-only collection, as opposed to a "sink" which
            is a write-only collection.
            <para/>
            IListSource was created before .NET's IReadOnlyList but was later retrofitted 
            so that IListSource implements IReadOnlyList. In addition, IListSource supports
            slices through its Slice() method, and it has <c>TryGet</c> methods to eliminate 
            the need to call <c>Count</c> before reading from the list.
            <para/>
            I have often wanted to access the "next" or "previous" item in a list, e.g.
            during parsing, but it inconvenient if you have to worry about whether the 
            the current item is the first or last. In that case you must check whether
            the array index is valid, which is both inconvenient and wasteful, because
            the list class itself will check the array index a second time, and then the 
            .NET runtime will check the index a third time when reading the internal 
            array. The <c>TryGet(index, defaultValue)</c> extension method can be used 
            to return a default value if the index is not valid, using only one 
            interface call.
            <para/>
            Design footnote: Ideally the return type of TryGet would be <see cref="T:Loyc.Maybe`1"/>,
            but that design would not allow T to be covariant (out T). Therefore, the 
            version of <c>TryGet</c> that returns <see cref="T:Loyc.Maybe`1"/> is an extension 
            method.
            <para/>
            Using <see cref="!:Impl.ListSourceBase&lt;T&gt;"/> as your base class can help you
            implement this interface more quickly.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.IListSource`1.Slice(System.Int32,System.Int32)">
            <summary>Returns a sub-range of this list.</summary>
            <param name="start">The new range will start at this index in the current
            list (this location will be index [0] in the new range).</param>
            <param name="count">The desired number of elements in the new range,
            or int.MaxValue to get all elements until the end of the list.</param>
            <returns>Returns a sub-range of this range.</returns>
            <exception cref="T:System.ArgumentException">The start index was below zero.</exception>
            <remarks>The (start, count) range is allowed to be invalid, as long
            as start is zero or above. 
            <ul>
            <li>If count is below zero, or if start is above the original Count, the
            Count of the new slice is set to zero.</li>
            <li>if (start + count) is above the original Count, the Count of the new
            slice is reduced to <c>this.Count - start</c>. Implementation note:
            do not compute (start + count) because it may overflow. Instead, test
            whether (count > this.Count - start).</li>
            </ul>
            Most collections should use the following implementation:
            <pre>
            IRange&lt;T> IListSource&lt;T>.Slice(int start, int count) { return Slice(start, count); }
            public Slice_&lt;T> Slice(int start, int count) { return new Slice_&lt;T>(this, start, count); }
            </pre>
            </remarks>
        </member>
        <member name="T:Loyc.Collections.INegListSource`1">
            <summary>This interface is the counterpart to <see cref="T:Loyc.Collections.IListSource`1"/> 
            for lists whose minimum index is not (necessarily) zero.</summary>
            <remarks>
            Be careful not to write a loop that relies on <see cref="P:Loyc.Collections.ICount.Count"/> or starts at
            zero! You must always loop from Min to Max, like so:
            <code>
            for (int i = list.Min; i &lt;= list.Max; i++) { ... }
            </code>
            </remarks>
        </member>
        <member name="P:Loyc.Collections.INegListSource`1.Min">
            <summary>Returns the minimum valid index in the collection.</summary>
        </member>
        <member name="P:Loyc.Collections.INegListSource`1.Max">
            <summary>Returns the maximum valid index in the collection.</summary>
            <remarks>Count must equal Max-Min+1. If Count is 0, Max = Min-1</remarks>
        </member>
        <member name="M:Loyc.Collections.INegListSource`1.Slice(System.Int32,System.Int32)">
            <summary>Returns a sub-range of this list.</summary>
        </member>
        <member name="T:Loyc.Collections.INegArray`1">
            <summary>This interface models the capabilities of an array: getting and
            setting elements by index, but not adding or removing elements. This 
            interface is the counterpart to <see cref="T:Loyc.Collections.IListSource`1"/> 
            for lists whose minimum index is not (necessarily) zero.
            </summary>
        </member>
        <member name="P:Loyc.Collections.INegArray`1.Item(System.Int32)">
            <summary>Gets or sets an element of the array-like collection.</summary>
            <returns>The value of the array at the specified index.</returns>
            <remarks>
            A redundant getter is required by C# because C# code is unable to use it
            (from a reference to <see cref="T:Loyc.Collections.INegArray`1"/>) otherwise.
            </remarks>
        </member>
        <member name="T:Loyc.Collections.INegAutoSizeArray`1">
            <summary>An auto-sizing array is a list structure that allows you to modify
            the element at any index, including indexes that don't yet exist; the
            collection automatically adds missing indexes.</summary>
            <typeparam name="T">Data type of each element.</typeparam>
            <remarks>
            This interface allows negative indexes, unlike <see cref="T:Loyc.Collections.IAutoSizeArray`1"/>.
            </remarks>
        </member>
        <member name="T:Loyc.Collections.INegDeque`1">
            <summary>Represents a Deque that supports negative indexes. In this kind of
            Deque, pushing and popping elements does not affect the indexes of the other
            elements in the collection.</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Loyc.Collections.IAutoCreatePool`2">
            <summary>Represents a pool of objects in which an object is
            automatically created when requested by its key.</summary>
            <typeparam name="TKey">Key type.</typeparam>
            <typeparam name="TValue">Value type.</typeparam>
            <remarks>This design assumes that the values in the pool know their own 
            key, so it implements IEnumerable{TValue} rather than 
            IEnumerable{KeyValuePair{TKey,TValue}}.</remarks>
        </member>
        <member name="P:Loyc.Collections.IAutoCreatePool`2.Item(`0)">
            <summary>Gets or creates the value associated with the specified key.</summary>
            <exception cref="T:System.ArgumentOutOfRangeException">The key was not valid
            for this list.</exception>
            <param name="key">A key object.</param>
            <returns>The associated value object, which is created automatically 
            if it does not already exist.</returns>
        </member>
        <member name="M:Loyc.Collections.IAutoCreatePool`2.GetIfExists(`0)">
            <summary>Gets the item with the specified key, if it was created earlier.</summary>
            <returns>The value corresponding to the specified key, or 
            <c>default(TValue)</c> if the value has not been created.</returns>
        </member>
        <member name="T:Loyc.Collections.INotifyListChanging`1">
            <summary>
            Encapsulates the <see cref="E:Loyc.Collections.INotifyListChanging`1.ListChanging"/> event that notifies listeners 
            of dynamic changes to an indexed list, such as when items get added and 
            removed or the whole list is refreshed.
            </summary>
            <typeparam name="T">Type of items in the list</typeparam>
            <remarks>
            This approach to change notification is more lightweight than the standard
            <see cref="T:System.Collections.Specialized.INotifyCollectionChanged"/> interface because that interface
            sends both a list of new items and a list of old items, so many changes
            require a pair of temporary objects to be created that hold the two lists
            of items.
            <para/>
            In contrast, the <see cref="E:Loyc.Collections.INotifyListChanging`1.ListChanging"/> event includes only one list 
            that specifies the set of new items. In the case of Remove events, no change
            list is included. Since the collection has not been modified yet, the user
            handling the event can examine the list to learn which item(s) are being
            removed; if the list is being changed, it can similarly examine the list
            to see the old set of items.
            <para/>
            An optimization is available when only a single item is being added or
            changed. In that case, the collection class should create a lightweight 
            read-only single-item list by calling <see cref="!:ListExt.Single&lt;T&gt;(T)"/>.
            Such a list has less overhead than <see cref="T:System.Collections.Generic.List`1"/> and the same
            overhead as an array of one item.
            </remarks>
        </member>
        <member name="E:Loyc.Collections.INotifyListChanging`1.ListChanging">
            <summary>Occurs when the collection associated with this interface is 
            about to change.</summary>
            <remarks>
            The event handler receives a <see cref="T:Loyc.Collections.ListChangeInfo`1"/> argument,
            which describes the change.
            <para/>
            The event handler is not allowed to modify the list that is changing
            while it is handling the event, but it can read the list.
            <para/>
            IMPORTANT: if the event handler throws an exception, the change does 
            not actually happen. Collections that support this event must ensure
            that the collection is not left in an invalid state in the event that
            a ListChanging event handler throws an exception.
            </remarks>
        </member>
        <member name="T:Loyc.Collections.ListChangingHandler`1">
            <summary>Represents the method that handles the 
            <see cref="E:Loyc.Collections.INotifyListChanging`1.ListChanging"/> event.</summary>
            <param name="sender">The collection that changed.</param>
            <param name="args">Information about the change.</param>
        </member>
        <member name="T:Loyc.Collections.IPush`1">
            <summary>Represents a collection that accepts a sequence of items.</summary>
        </member>
        <member name="T:Loyc.Collections.IPop`1">
            <summary>Represents a collection that produces a sequence of items, and can
            return the next item without popping it (the Peek operation).</summary>
            <remarks>Push/Pop methods that throw an exception on failure, and
            TryPush/TryPop methods that don't require a "ref" argument, are
            available as extension methods.</remarks>
        </member>
        <member name="T:Loyc.Collections.IQueue`1">
            <summary>Represents a FIFO (first-in-first-out) queue (or a priority queue 
            if <see cref="T:Loyc.Collections.IPriorityQueue`1"/> is also implemented).</summary>
            <typeparam name="T">Type of each element</typeparam>
        </member>
        <member name="T:Loyc.Collections.IStack`1">
            <summary>Represents a LIFO (last-in-first-out) stack.</summary>
            <typeparam name="T">Type of each element</typeparam>
        </member>
        <member name="T:Loyc.Collections.IPriorityQueue`1">
            <summary>Represents a priority queue, in which Pop() always returns the largest or smallest item.</summary>
            <typeparam name="T">Type of each element</typeparam>
        </member>
        <member name="T:Loyc.Collections.IDeque`1">
            <summary>Represents a double-ended queue that allows items to be added or
            removed at the beginning or end.</summary>
            <typeparam name="T">Type of each element</typeparam>
        </member>
        <member name="P:Loyc.Collections.IDeque`1.First">
            <summary>Gets the first item in the deque.</summary>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="T:Loyc.Collections.IAdd`1">
            <summary>An interface for depositing items. Includes only an Add(T) method.</summary>
        </member>
        <member name="T:Loyc.Collections.ICollectionSink`1">
            <summary>Represents a write-only collection: you can modify it, but you
            cannot learn what it contains.</summary>
        </member>
        <member name="T:Loyc.Collections.IArraySink`1">
            <summary>Represents a write-only array.</summary>
        </member>
        <member name="T:Loyc.Collections.IListSink`1">
            <summary>Represents a write-only indexable list class.</summary>
        </member>
        <member name="T:Loyc.Collections.IDictionarySink`2">
            <summary>Represents a write-only dictionary class.</summary>
            <remarks>
            The methods here are a subset of the methods of IDictionary, so that a class 
            that already implements IDictionary can support this interface also just by
            adding it to the interface list. However, one of the reasons you might want
            to implement this interface is to provide an asynchronous dictionary writer
            (in which operations are completed at a later time). In this case, the sink
            (dictionary writer) doesn't know whether a given key exists in the dictionary
            at the time <see cref="M:Loyc.Collections.IDictionarySink`2.Add(`0,`1)"/> or <see cref="M:Loyc.Collections.IDictionarySink`2.Remove(`0)"/> is called, so
            it cannot know whether to throw <see cref="T:Loyc.Collections.KeyAlreadyExistsException"/> or 
            return <c>true</c> or <c>false</c>. Such implementations should not throw 
            that exception, and they should return <c>true</c> from <c>Remove</c>. The 
            implementation might also be unable to quickly count the values in the 
            collection, so there is no <c>Count</c> property.
            <para/>
            Due to the above considerations, when <see cref="M:Loyc.Collections.IDictionarySink`2.Remove(`0)"/> returns true, users 
            of this interface should not assume that the collection actually did contain 
            the specified key. However if it returns false, the collection definitely did 
            not contain it.
            <para/>
            This interface does not implement IAdd{KeyValuePair{K, V}} 
            because it would defeat contravariance, because structs do not support variance
            (KeyValuePair is a struct).
            </remarks>
        </member>
        <member name="T:Loyc.Collections.ICollectionAndReadOnly`1">
            <summary>This interface is meant to be implemented by read-only sequence types
            that originally implemented <see cref="T:System.Collections.Generic.ICollection`1"/> and want to now implement 
            <see cref="T:System.Collections.Generic.IReadOnlyCollection`1"/>. It is recommended to implement 
            <see cref="T:Loyc.Collections.ICollectionAndSource`1"/> instead, but the latter requires you to 
            implement a couple of additional methods.</summary>
        </member>
        <member name="T:Loyc.Collections.ICollectionAndSource`1">
            <summary>This interface is to be implemented by read-only sequence types that 
            still want to be compatible with APIs that accept <see cref="T:System.Collections.Generic.ICollection`1"/>.
            (writable collections should implement <see cref="T:Loyc.Collections.ICollectionImpl`1"/> instead.)
            </summary>
            <seealso cref="T:Loyc.Collections.ICollectionAndReadOnly`1"/>
        </member>
        <member name="T:Loyc.Collections.ICollectionImpl`1">
            <summary>This interface is intended to be implemented by editable collection 
            classes that are not indexable lists nor dictionaries. It is recommended to
            implement <see cref="T:Loyc.Collections.ICollectionEx`1"/> instead, but the latter requires more
            effort.</summary>
            <remarks>
            This interface is used in C# for disambiguation (as explained in the description
            of <see cref="T:Loyc.Collections.IListImpl`1"/>.) Variables should not have this type (except in
            disambiguation methods, which immediately cast the variable to another type).
            </remarks>
        </member>
        <member name="T:Loyc.Collections.IListAndReadOnly`1">
            <summary>This interface is meant to be implemented by read-only sequence 
            classes that originally implemented <see cref="T:System.Collections.Generic.IList`1"/> and want to now 
            implement <see cref="T:System.Collections.Generic.IReadOnlyList`1"/> and <see cref="T:System.Collections.Generic.IReadOnlyCollection`1"/>.
            It is recommended to implement <see cref="T:Loyc.Collections.IListAndListSource`1"/> instead, 
            but the latter requires you to implement more methods.
            </summary><remarks>
            This interface is useful in C# for disambiguation (as explained in the description
            of <see cref="T:Loyc.Collections.IListImpl`1"/>.) Variables should not have this type (except in
            disambiguation methods, which immediately cast the variable to another type).
            </remarks>
        </member>
        <member name="T:Loyc.Collections.IListAndListSource`1">
            <summary>This interface is to be used by read-only sequences that 
            nevertheless wish to be compatible with APIs that accept <see cref="T:System.Collections.Generic.IList`1"/>.
            (writable collections should implement <see cref="T:Loyc.Collections.IListImpl`1"/> instead.)
            </summary>
        </member>
        <member name="T:Loyc.Collections.IListImpl`1">
            <summary>This interface is intended to be implemented by all Loyc collections 
            that implement <see cref="T:System.Collections.Generic.IList`1"/>. It combines the original 
            <see cref="T:System.Collections.Generic.IList`1"/> interface with its component interfaces 
            <see cref="T:System.Collections.Generic.IReadOnlyList`1"/> and <see cref="T:Loyc.Collections.IListSink`1"/>, plus 
            a little bit of additional functionality in <see cref="T:Loyc.Collections.IListSource`1"/>.</summary>
            <remarks>
            Unfortunately, as far as the C# compiler is concerned, <see cref="T:System.Collections.Generic.IList`1"/>
            and <see cref="T:System.Collections.Generic.IReadOnlyList`1"/> are unrelated, which causes problems.
            <para/>
            This interface is not meant to be used as a variable type. It exists mainly 
            to avoid ambiguity errors when invoking overloaded methods in plain C#. For 
            example, there is a TryGet() extension method for IList{T} and an identical 
            TryGet() method for <see cref="T:Loyc.Collections.IListSource`1"/>. To prevent the C# compiler 
            from giving an ambiguity error when you try to call TryGet(), 
            <ul>
            <li>The list class must implement this interface (or <see cref="T:Loyc.Collections.IListEx`1"/> or
               <see cref="T:Loyc.Collections.IListAndReadOnly`1"/> or <see cref="T:Loyc.Collections.IListAndListSource`1"/>, and</li>
            <li>There must be a third version of TryGet() that accepts the interface that
                combines <see cref="T:System.Collections.Generic.IList`1"/> with <see cref="T:Loyc.Collections.IListSource`1"/>, namely
                <see cref="T:Loyc.Collections.IListAndListSource`1"/> (if there is an overload that accepts
                IListImpl, it will of course eliminate the ambiguity error when called with
                a class that implements IListImpl, but not when called with a class that
                only implements IListAndListSource.)</li>
            </ul>
            Ironically, however, if you actually try to use the list through this 
            interface you'll tend to get errors. For instance, both <see cref="T:System.Collections.Generic.IList`1"/>
            and <see cref="T:System.Collections.Generic.IReadOnlyList`1"/> have an indexer, so using the indexer in
            this interface is ambiguous. Therefore, variables should not have this type 
            (except parameters to disambiguation methods, in which case the parameter is 
            immediately casted to another type).
            </remarks>
        </member>
        <member name="T:Loyc.Collections.IDictionaryAndReadOnly`2">
            <summary>This interface is meant to be implemented by read-only dictionary
            classes that originally implemented <see cref="T:System.Collections.Generic.IDictionary`2"/> and now want
            to add its read-only version, <see cref="T:System.Collections.Generic.IReadOnlyDictionary`2"/>.</summary>
            <remarks>
            This interface is used in C# for disambiguation (as explained in the description
            of <see cref="T:Loyc.Collections.IListImpl`1"/>.) Variables should not have this type (except in
            disambiguation methods, which immediately cast the variable to another type).
            </remarks>
        </member>
        <member name="T:Loyc.Collections.IDictionaryImpl`2">
            <summary>This interface is intended to be implemented by all Loyc collections 
            that implement <see cref="T:System.Collections.Generic.IDictionary`2"/>. It combines the original 
            <see cref="T:System.Collections.Generic.IDictionary`2"/> interface with its component interfaces 
            <see cref="T:System.Collections.Generic.IReadOnlyDictionary`2"/> and <see cref="T:Loyc.Collections.IDictionarySink`2"/>.</summary>
            <remarks>
            This interface is used in C# for disambiguation (as explained in the description
            of <see cref="T:Loyc.Collections.IListImpl`1"/>.) Variables should not have this type (except in
            disambiguation methods, which immediately cast the variable to another type).
            </remarks>
        </member>
        <member name="T:Loyc.Collections.IAddRange`1">
            <summary>An interface for the AddRange method, part of <see cref="T:Loyc.Collections.IListEx`1"/>
            and <see cref="T:Loyc.Collections.ICollectionEx`1"/>, for collection types that can add multiple 
            items in one method call.</summary>
        </member>
        <member name="T:Loyc.Collections.ICollectionEx`1">
            <summary>This interface is intended to be implemented by editable collection 
            classes that are not indexable lists nor dictionaries.</summary>
            <remarks>
            IReadOnlyCollection(T) and ISinkCollection(T) are subsets of the ICollection(T)
            interface. ICollectionEx adds the following methods that ICollection(T) lacks:
            AddRange() and RemoveAll().
            </remarks>
        </member>
        <member name="T:Loyc.Collections.IListRangeMethods`1">
            <summary>The batch-operation methods of <see cref="T:Loyc.Collections.IListEx`1"/>, mainly
            for collection types that can add or remove multiple items in one method 
            call.</summary>
        </member>
        <member name="T:Loyc.Collections.IListEx`1">
            <summary>
            This interface combines the original IList(T) interface with others -
            IListSource(T), ISinkList(T), IArray(T) - and some additional methods
            (e.g. RemoveAll, InsertRange).
            </summary>
            <remarks>
            <see cref="T:Loyc.Collections.IArray`1"/> (a version of <see cref="T:Loyc.Collections.IListSource`1"/> that adds the 
            writability of an array) and <see cref="T:Loyc.Collections.IListSink`1"/> are largely subsets of the 
            IList(T) interface. IListSource has a couple of methods that IList(T) does not, 
            while <see cref="T:Loyc.Collections.ICollectionEx`1"/> adds RemoveAll and AddRange. Finally,
            <see cref="T:Loyc.Collections.IListRangeMethods`1"/> adds InsertRange and RemoveRange.
            <para/>
            Using <see cref="!:Impl.ListExBase&lt;T&gt;"/> as your base class can help you implement
            this interface more easily.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.IContains`1.Contains(`0)">
            <summary>Returns true if and only if the collection contains the specified 
            item.</summary>
            <param name="item">Data/object whose presence you want to check for. The
            collection decides how to test for equality, but it's most common to use
            <see cref="P:System.Collections.Generic.EqualityComparer`1.Default"/>.</param>
        </member>
        <member name="T:Loyc.Collections.ICollectionSource`1">
            <summary>A variation of IReadOnlyCollection that provides the Contains() and 
            CopyTo() methods from ICollection.</summary>
            <remarks>
            Implementing this interface suggests that the collection may support accelerated
            membership tests (int O(1) or O(log(Count)) time), because if it doesn't, the 
            collection only needs to implement IReadOnlyCollection (relying on extension
            methods for Contains() and CopyTo()).
            <para/>
            The name of this collection fits a pattern: just as IListSource is a variation on
            IReadOnlyList with additional functionality, this interface is a variation on
            IReadOnlyCollection with additional functionality. The word "source" means "data
            comes out"; it is the opposite of a "sink" which means "data goes in".
            </remarks>
        </member>
        <member name="M:Loyc.Collections.ICollectionSource`1.CopyTo(`0[],System.Int32)">
            <summary>Copies the elements of the collection to an Array, starting at a 
            particular array index.</summary>
            <remarks>It's usually more convenient to call the ToArray() extension method, 
            which calls this method for you.
            <para/>
            This method exists for performance reasons (the collection itself can often 
            copy data out faster than an enumerator can).
            </remarks>
            <exception cref="T:System.ArgumentNullException">array is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">arrayIndex is negative.</exception>
            <exception cref="T:System.ArgumentException">The number of elements in the source 
            collection is greater than the available space from arrayIndex to the end of 
            the destination array.</exception>
        </member>
        <member name="M:Loyc.Collections.CollectionSource.ToArray``1(Loyc.Collections.ICollectionSource{``0})">
            <summary>Converts the collection to an array.</summary>
        </member>
        <member name="T:Loyc.Collections.IArray`1">
            <summary>This interface models the capabilities of an array: getting and
            setting elements by index, but not adding or removing elements.</summary>
            <remarks>
            Member list:
            <code>
            public T this[int index] { get; set; }
            public T TryGet(int index, ref bool fail);
            public Iterator&lt;T> GetIterator();
            public int Count { get; }
            public IEnumerator&lt;T> GetEnumerator();
            System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
            </code>
            </remarks>
        </member>
        <member name="P:Loyc.Collections.IArray`1.Item(System.Int32)">
            <summary>Gets or sets an element of the array-like collection.</summary>
            <returns>The value of the array at the specified index.</returns>
            <remarks>
            This redundant indexer is required by C# because the compiler imagines
            that the setter in <see cref="T:Loyc.Collections.IArraySink`1"/> conflicts with the getter
            in <see cref="T:Loyc.Collections.IListSource`1"/>.
            </remarks>
        </member>
        <member name="T:Loyc.Collections.IIndexed`2">
            <summary>Represents the essence of a dictionary, which returns a value given a key.</summary>
            <typeparam name="K">Input type.</typeparam>
            <typeparam name="V">Output type.</typeparam>
            <remarks>Consider implementing <see cref="T:Loyc.Collections.ITryGet`2"/> instead, or in addition 
            to this interface alone.</remarks>
        </member>
        <member name="P:Loyc.Collections.IIndexed`2.Item(`0)">
            <summary>Gets the value associated with the specified key.</summary>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">The key was not found.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The class implements <see cref="T:System.Collections.Generic.IReadOnlyList`1"/>
            and the key is an integer index that is outside the valid range.</exception>
            <exception cref="T:System.IndexOutOfRangeException">The object is an array or other list,
            and the key is an integer index that is outside the valid range.</exception>
        </member>
        <member name="T:Loyc.Collections.ITryGet`2">
            <summary>Enables access to TryGet extension methods for retrieving items from 
            a collection without risk of exceptions.</summary>
        </member>
        <member name="M:Loyc.Collections.ITryGet`2.TryGet(`0,System.Boolean@)">
            <summary>Gets the item for the specified key or index, and does not throw an
            exception on failure.</summary>
            <param name="key">A lookup key that might be associated with a value in this 
            object. If K is an integer, this value could be an index into a list.</param>
            <param name="fail">TryGet sets this to true on failure or false on success.</param>
            <returns>The element at the specified index, or default(V) if the index
            is not valid.</returns>
            <remarks>
            This method should never intentionally throw (e.g. don't throw if key == null)
            although it may use third-party methods that throw (e.g. Object.Equals()).
            <para/>
            Ideally the return type would be <see cref="T:Loyc.Maybe`1"/> but that design would
            not allow variance on the output type (out V). Instead, an extension method
            <see cref="M:Loyc.Collections.TryGetExt.TryGet``2(Loyc.Collections.ITryGet{``0,``1},``0)"/> is provided that returns
            <see cref="T:Loyc.Maybe`1"/>.
            </remarks>
        </member>
        <member name="T:Loyc.Collections.TryGetExt">
            <summary>Standard extension methods for <see cref="T:Loyc.Collections.ITryGet`2"/>.</summary>
        </member>
        <member name="M:Loyc.Collections.TryGetExt.TryGet``2(Loyc.Collections.ITryGet{``0,``1},``0)">
            <summary>Returns the value at the specified key or index, wrapped in 
            <see cref="T:Loyc.Maybe`1"/>.</summary>
            <param name="key">A lookup key that might be associated with a value in this 
            object. If K is an integer, this value could be an index into a list.</param>
            <returns>A value associated with the key, wrapped in <see cref="T:Loyc.Maybe`1"/>
            so that <see cref="P:Loyc.Maybe`1.HasValue"/> is false if lookup fails.</returns>
        </member>
        <member name="M:Loyc.Collections.TryGetExt.TryGet``2(Loyc.Collections.ITryGet{``0,``1},``0,``1)">
            <summary>Returns the value at the specified key or index, or the specified
            default value if the key was not found.</summary>
            <param name="key">A lookup key that might be associated with a value in this 
            object. If K is an integer, this value could be an index into a list.</param>
            <param name="defaultValue">A value to return if lookup fails.</param>
        </member>
        <member name="T:Loyc.Collections.IOptimize">
            <summary>Interface for an Optimize() method.</summary>
        </member>
        <member name="M:Loyc.Collections.IOptimize.Optimize">
            <summary>Optimizes the data structure to consume less memory or storage space.</summary>
            <remarks>
            Typically this method will take O(N) or O(N log N) time.
            <para/>
            For example, a simple <see cref="T:Loyc.Collections.IAutoSizeArray`1"/> implementation
            could implement this method by examining the final elements and removing 
            any that are equal to default(T).
            </remarks>
        </member>
        <member name="T:Loyc.Collections.IAutoSizeArray`1">
            <summary>An auto-sizing array is a list structure that allows you to modify
            the element at any index, including indices that don't yet exist; the
            collection automatically adds missing indices.</summary>
            <typeparam name="T">Data type of each element.</typeparam>
            <remarks>
            This interface begins counting elements at index zero. The <see
            cref="T:Loyc.Collections.INegAutoSizeArray`1"/> interface supports negative indexes.
            <para/>
            Although it is legal to set <c>this[i]</c> for any <c>i >= 0</c> (as long
            as there is enough memory available for required array), <c>this[i]</c>
            may still throw <see cref="T:System.ArgumentOutOfRangeException"/> when the 
            index is not yet valid. However, implementations can choose not to throw
            an exception and return <c>default(T)</c> instead.
            </remarks>
        </member>
        <member name="T:Loyc.Either`2">
            <summary>Holds a single value of one of two types (L or R).</summary>
            <remarks>For efficiency, this is a struct, but this makes it possible
            to default-construct it. In that case its value will be <c>default(R)</c>.</remarks>
        </member>
        <member name="M:Loyc.Either`2.NewLeft(`0)">
            <summary>Simply calls the constructor. This method exists to make
            it possible to construct an Either when both types are the same.</summary>
        </member>
        <member name="M:Loyc.Either`2.NewRight(`1)">
            <summary>Simply calls the constructor. This method exists to make
            it possible to construct an Either when both types are the same.</summary>
        </member>
        <member name="M:Loyc.Either`2.From``2(Loyc.Either{``0,``1})">
            <summary>Does an upcast, e.g. Either{string,ArgumentException} to Either{object,Exception}.
            C# does not allow defining conversion operators to take generic 
            parameters, so you'll have to put up with this hassle instead.</summary>
            <remarks>
            Sadly, automatically upcasting value types to reference types doesn't seem possible.
            </remarks>
        </member>
        <member name="M:Loyc.Either`2.Select``2(System.Func{`0,``0},System.Func{`1,``1})">
            <summary>Converts an Either to another with different types.</summary>
        </member>
        <member name="M:Loyc.Either`2.MapLeft``1(System.Func{`0,``0})">
            <summary>Transforms <c>Left</c> with the given selector, if <c>Left.HasValue</c>. Otherwise, returns Right unchanged.</summary>
        </member>
        <member name="M:Loyc.Either`2.MapRight``1(System.Func{`1,``0})">
            <summary>Transforms <c>Right</c> with the given selector, if <c>Right.HasValue</c>. Otherwise, returns Left unchanged.</summary>
        </member>
        <member name="M:Loyc.Either`2.IfLeft(System.Action{`0})">
            <summary>Runs actionL if <c>Left.HasValue</c>. Equivalent to <c>Left.Then(actionL)</c>, but also returns <c>this</c>.</summary>
        </member>
        <member name="M:Loyc.Either`2.IfRight(System.Action{`1})">
            <summary>Runs actionR if <c>Right.HasValue</c>. Equivalent to <c>Right.Then(actionL)</c>, but also returns <c>this</c>.</summary>
        </member>
        <member name="T:Loyc.Syntax.EmptySourceFile">
            <summary>
            A dummy implementation of <see cref="T:Loyc.Syntax.ISourceFile"/> that has only a 
            filename, no source text. Used as the source file of synthetic syntax 
            nodes.
            </summary>
        </member>
        <member name="T:Loyc.Syntax.IIndexToLine">
            <summary>Contains <see cref="M:Loyc.Syntax.IIndexToLine.IndexToLine(System.Int32)"/> method.</summary>
            <remarks>
            The FileName property gets the name of the file on which results returned by 
            <see cref="M:Loyc.Syntax.IIndexToLine.IndexToLine(System.Int32)"/> are based. It is not guaranteed that <i>all</i> 
            return values from <see cref="M:Loyc.Syntax.IIndexToLine.IndexToLine(System.Int32)"/> use this filename. 
            For example, the file may have mappings to other files; see 
            <see cref="!:SourceFileWithLineRemaps"/>.</remarks>
        </member>
        <member name="M:Loyc.Syntax.IIndexToLine.IndexToLine(System.Int32)">
            <summary>Returns the position in a source file of the specified index.</summary>
            <remarks>If index is negative, this should return a SourcePos where 
            Line and PosInLine are zero (signifying an unknown location). If index 
            is beyond the end of the file, this should retun the final position in 
            the file.</remarks>
        </member>
        <member name="T:Loyc.Syntax.IIndexPositionMapper">
            <summary>
            This interface is for classes that can convert indexes to SourcePos
            structures and back.
            </summary>
        </member>
        <member name="M:Loyc.Syntax.IIndexPositionMapper.LineToIndex(System.Int32)">
            <summary>Returns the index in a source file of the beginning of the 
            specified line, where the first line is number 1, not 0.</summary>
            <remarks>If lineNo is zero, this method should return -1 (signifying 
            an unknown location). If lineNo is larger than the largest line 
            number, this method should return the index of end-of-file.</remarks>
        </member>
        <member name="T:Loyc.Syntax.ILineAndColumn">
            <summary>A line/column pair representing a location in a text file. 
            Numbering starts at one for both Line and Column.</summary>
        </member>
        <member name="T:Loyc.Syntax.ISerializedLiteral">
            <summary>Represents a serialized text form of a literal value.</summary>
        </member>
        <member name="P:Loyc.Syntax.ISerializedLiteral.TextValue">
            <summary>Represents the serialized text of the value.</summary>
            <remarks>Typically this will be a parsed form of the string; for example in LES3, 
            if the TextValue is `C:\Users`, the raw text may be `C:\\Users` which was parsed 
            so that the double backslash became a single backslash.</remarks>
        </member>
        <member name="P:Loyc.Syntax.ISerializedLiteral.TypeMarker">
            <summary>Represents the type of the value.</summary>
            <remarks>The Type Marker indicates not just the type but also the syntax of the
            <see cref="P:Loyc.Syntax.ISerializedLiteral.TextValue"/>. If the syntax of a TextValue is not compatible with 
            the syntax used in LES, it should not use the same type marker as used in LES.
            <para/>
            The TypeMarker can be null if this is a <see cref="T:Loyc.Syntax.ILiteralValue"/> and the
            <see cref="P:Loyc.Syntax.ISerializedLiteral.TextValue"/> is empty.
            </remarks>
        </member>
        <member name="T:Loyc.Syntax.ILiteralValue">
            <summary>Bundles the optional original text of a value with an optional in-memory form of it.</summary>
            <remarks>
            <see cref="T:Loyc.Syntax.ILNode"/> objects that do not represent literals will have a Value property 
            that returns <see cref="F:Loyc.NoValue.Value"/>. Also, the TextValue and TypeMarker for a value 
            may not be known, in which case they will return an empty string and null, respectively. 
            It could also be that the <see cref="P:Loyc.Syntax.ISerializedLiteral.TextValue"/> is known but the 
            value it represents is not known, in which case the Value may be a copy of the TextValue.
            <para/>
            If this object represents a literal, Value should never be <see cref="F:Loyc.NoValue.Value"/>, 
            and it should not be null unless null is the actual value of the literal.
            <para/>
            In all, a literal may have the the following valid combinations of properties:
            <ul>
            <li>TextValue.IsNull, null TypeMarker, valid Value: this combination often occurs when
                nodes created programmatically and have never been in text form before, but it 
                may also occur if the parser isn't designed to preserve input text, or if the
                syntax is nonstandard and there is no benefit in preserving the text. Keep in
                mind that the TypeMarker dictates constraints on syntax, not just type, so if a 
                language uses an unusual literal syntax the most reasonable thing is often to
                parse the text and not include it in the Loyc tree.</li>
            <li>TextValue.IsNull, non-null TypeMarker, valid Value: this combination can be used
                to disambiguate when one type corresponds to multiple TypeMarkers. For example,
                the literal 123 has the generic numeric type marker "_". This may be stored as 
                a 32-bit integer in the Loyc tree, but suppose that an attempt is made to store
                the integer in an 8-bit integer variable. Should it succeed? It is conceivable
                that in a particular programming language, a generic number 123 (type marker "_") 
                can be stored in a byte variable, but that a literal with the explicit type 
                marker "_i32" should not be convertible to a byte because is marked as 32 bits.</li>
            <li>Non-null TextValue, non-null TypeMarker: In this case the Value will either be
                a parsed form of TextValue (so that <c>!Value.Equals(TextValue)</c> or a boxed
                form of TextValue so that <c>Value.Equals(TextValue)</c>. The latter case 
                indicates that the parser did not recognize the TypeMarker, or that parsing the 
                TextValue failed, that literal parsing is not enabled in the parser, or that
                the value is a string but the parser chose not to convert it to the .NET native
                string type.</li>
            </ul>
            Caution: TextValue is <see cref="T:Loyc.UString"/> and an "empty" UString is "equal" to a 
            "null" UString since the list of characters is the same. Do not compare UString 
            with null; instead, use <see cref="P:Loyc.UString.IsNull"/>.
            </remarks>
        </member>
        <member name="T:Loyc.Syntax.LNodeKind">
            <summary>The three kinds of nodes in a Loyc tree</summary>
        </member>
        <member name="T:Loyc.Syntax.ILNode">
            <summary>A read-only interface for objects that act as Loyc trees.</summary>
            <remarks>
            To simplify implementations of this interface, there is no separate 
            list of attributes and arguments; ILNode itself acts as a list of child
            nodes. The argument list is numbered from 0 to Max, so the number of 
            arguments is <c>Max + 1</c> (which is what the ArgCount() extension method 
            returns).
            <para/>
            A node with no children must report <c>Min = -1</c> and <c>Max = -2</c>,
            or some extension methods will malfunction.
            <para/>
            You can think of any node <c>N</c> as having a single contiguous list 
            of child nodes indexed from <c>N.Min</c> to <c>N.Max</c>. Items with
            non-negative indexes (e.g. <c>N[0], N[1]</c>) are arguments; <c>N[-1]</c>
            is an alias for <c>Target</c>; and indexes below -1 refer to attributes
            (e.g. <c>N[-2]</c> is the last attribute in the attribute list)
            <para/>
            ArgCount() and AttrCount() are implemented as extension methods; they
            return <c>Max + 1</c> and <c>-Min - 1</c> respectively (note: ArgCount()
            is different from <see cref="!:LNode.ArgCount"/> in case 
            <c>Kind != LNodeKind.Call</c>: ArgCount() returns -1 in that case while
            <see cref="!:LNode.ArgCount"/> reurns zero.
            <para/>
            The IsId(), IsLiteral() and IsCall() extension methods are useful 
            shorthand for testing the <see cref="P:Loyc.Syntax.ILNode.Kind"/> property.
            <para/>
            The Attrs() and Args() extension methods return slices of this node
            corresponding to the attributes and arguments.
            <para/>
            Tip: the LES node printer can print any ILNode as a string. See
            <see cref="!:Loyc.Syntax.Les.Les3LanguageService.Print(ILNode, StringBuilder, IMessageSink, ParsingMode, ILNodePrinterOptions)"/>
            </remarks>
        </member>
        <member name="P:Loyc.Syntax.ILNode.Kind">
            <inheritdoc cref="!:LNode.Kind"/>
        </member>
        <member name="P:Loyc.Syntax.ILNode.Name">
            <inheritdoc cref="!:LNode.Name"/>
        </member>
        <member name="P:Loyc.Syntax.ILNode.Target">
            <inheritdoc cref="!:LNode.Target"/>
        </member>
        <member name="P:Loyc.Syntax.ILNode.Range">
            <inheritdoc cref="!:LNode.Range"/>
        </member>
        <member name="P:Loyc.Syntax.ILNode.Style">
            <inheritdoc cref="!:LNode.Style"/>
        </member>
        <member name="M:Loyc.Syntax.ILNode.CallsMin(Loyc.Symbol,System.Int32)">
            <summary>Returns true if <c>Kind == LNodeKind.Call</c>, <c>Name == name</c>, 
            and <c>Max + 1 >= argCount</c>.</summary>
            <seealso cref="!:LNodeExt.Calls"/>
        </member>
        <member name="M:Loyc.Syntax.ILNode.Calls(Loyc.Symbol,System.Int32)">
            <summary>Returns true if <c>Name == name</c> and <c>Max + 1 == argCount</c>
            (which implies <c>Kind == LNodeKind.Call</c> if argCount != -1).</summary>
            <remarks>This could have been an extension method, but when verifying that
            you have a certain kind of node, it's common to check <i>both</i> the Name 
            and ArgCount(); checking both in one call avoids extra interface invocations.</remarks>
        </member>
        <member name="T:Loyc.Syntax.ILNodePrinterOptions">
            <summary>A set of relatively universal printing options that 
            <see cref="!:LNodePrinter"/>s should understand.</summary>
            <seealso cref="!:LNodePrinterOptions"/>
        </member>
        <member name="P:Loyc.Syntax.ILNodePrinterOptions.AllowChangeParentheses">
            <summary>Indicates that it is preferable to add (or remove) parenthesis 
            to produce good-looking output, rather than to express faithfully whether 
            or not parentheses were present in the Loyc tree being printed.</summary>
            <remarks>For example, the Loyc tree <c>x * `+`(a, b)</c> (LESv3 notation)
            will be printed <c>x * (a + b)</c>, which is a slightly different tree 
            (the parenthesis add the trivia attribute %inParens.)</remarks>
        </member>
        <member name="P:Loyc.Syntax.ILNodePrinterOptions.OmitComments">
            <summary>When this flag is set, comment trivia attributes are suppressed
            (e.g. <see cref="!:CodeSymbols.TriviaSLCommentAfter"/>).</summary>
        </member>
        <member name="P:Loyc.Syntax.ILNodePrinterOptions.OmitUnknownTrivia">
            <summary>Causes trivia that the printer does not recognize (other than 
            comments, spaces and raw text) to be dropped from the output rather than
            printed as attributes.</summary>
            <remarks>Note: Some printers may force all unknown trivia to be dropped.</remarks>
        </member>
        <member name="P:Loyc.Syntax.ILNodePrinterOptions.PrintTriviaExplicitly">
            <summary>If supported by the printer, this option causes comments and 
            spaces to be printed as attributes in order to ensure faithful round-trip 
            parsing.</summary>
            <remarks>Note: Some printers may ignore <see cref="P:Loyc.Syntax.ILNodePrinterOptions.OmitUnknownTrivia"/>,
            and <see cref="P:Loyc.Syntax.ILNodePrinterOptions.OmitComments"/> when this flag is true.</remarks>
        </member>
        <member name="P:Loyc.Syntax.ILNodePrinterOptions.CompatibilityMode">
            <summary>If there are multiple ways to print a given node, this option 
            indicates that the printer should prefer an older, more compatible 
            syntactic style over new ones, where applicable.</summary>
            <remarks>For example, it tells the EC# printer to use C# printing mode.
            This option does not prevent printing of new constructs if such are 
            present in the code, however.
            </remarks>
        </member>
        <member name="P:Loyc.Syntax.ILNodePrinterOptions.CompactMode">
            <summary>When this flag is set, the amount of whitespace in the output
            is reduced in a printer-defined way, in order to save bits.</summary>
            <remarks>This option should not suppress newlines, indents or trivia.
            To suppress newlines or indents, the user can use empty strings for 
            <see cref="P:Loyc.Syntax.ILNodePrinterOptions.IndentString"/> and <see cref="P:Loyc.Syntax.ILNodePrinterOptions.NewlineString"/>.</remarks>
        </member>
        <member name="P:Loyc.Syntax.ILNodePrinterOptions.IndentString">
            <summary>Specifies the string to use for each level of indentation of 
            nested constructs in the language, e.g. a tab or four spaces.</summary>
            <remarks>
            If this option is null, the printer should use its default indent string.
            <para/>
            Indentation-sensitive languages should treat an empty string as one space or tab.
            </remarks>
        </member>
        <member name="P:Loyc.Syntax.ILNodePrinterOptions.NewlineString">
            <summary>Specifies the string to use for line breaks (typically "\n").</summary>
            <remarks>
            If this option is null, the printer should use its default newline string, which
            is almost always "\n".
            <para/>
            Newline-sensitive languages should treat an empty string the same as null.
            <para/>
            This string may or may not be used for line breaks inside multiline strings, 
            depending on how strings are defined in the language being printed.
            </remarks>
        </member>
        <member name="T:Loyc.Syntax.ISourceFile">
            <summary>Represents a text file with a file name and its textual content,
            plus the data necessary to convert between line-column positions and 
            0-based integer indexes.</summary>
        </member>
        <member name="T:Loyc.Syntax.ISourceRange">
            <summary>Represents a (contiguous) region of text in a source file.</summary>
        </member>
        <member name="T:Loyc.Syntax.SourceRangeExt">
            <summary>Standard extension methods for <see cref="T:Loyc.Syntax.ISourceRange"/>.</summary>
        </member>
        <member name="T:Loyc.Syntax.NodeStyle">
            <summary>Suggests a printing style when serializing a Loyc tree to text.</summary>
            <remarks>See <see cref="!:LNode.Style"/>.
            <para/>
            TODO: review, rethink.
            <para/>
            A printer should not throw exceptions unless specifically requested. It 
            should ignore printing styles that it does not allow, rather than throwing.
            <para/>
            Styles may be used in different ways by different parsers, different
            printers and different people. Be careful how you rely on them; they are 
            intended to affect only the appearance of a node when it is printed, not 
            its semantics.
            <para/>
            Please note that language-specific printing styles can be denoted by 
            attaching special attributes recognized by the printer for that language.
            These attributes should have Names starting with the % character;
            printers are programmed to ignore trivia attributes that they do not
            understand.</remarks>
        </member>
        <member name="F:Loyc.Syntax.NodeStyle.Default">
            <summary>No style category is specified; the printer should choose a 
            style automatically.</summary>
        </member>
        <member name="F:Loyc.Syntax.NodeStyle.Operator">
            <summary>Indicates that a node was parsed as an operator (infix, prefix, 
            suffix, or other operator), or that it should be printed with operator 
            notation if possible.</summary>
        </member>
        <member name="F:Loyc.Syntax.NodeStyle.StatementBlock">
            <summary>The node's immediate children (and/or the node itself) should be 
            printed in statement notation, if possible in the context in which it is 
            located.</summary>
            <remarks>Used to mark braced blocks. In LES, marks a call in which ';'
            is used as the argument separator.</remarks>
        </member>
        <member name="F:Loyc.Syntax.NodeStyle.Special">
            <summary>A language-specific special notation should be used for this
            node. In LES3, the parser puts this style on keyword expressions (e.g. 
            <c>#if x {...}</c>).</summary>
        </member>
        <member name="F:Loyc.Syntax.NodeStyle.PrefixNotation">
            <summary>The node should be printed in prefix notation (even if it is 
            not the natural notation to use). An example in EC# notation is 
            <c>@`'+`(X, Y)</c> instead of <c>X + Y</c>.</summary>
        </member>
        <member name="F:Loyc.Syntax.NodeStyle.Expression">
            <summary>The node(s) should be printed as a normal expression, rather
            than using a special or statement notation.</summary>
            <remarks>In EC#, braced initializer blocks have this style. The EC# 
            node printer will refuse to print a node with this style as a statement.</remarks>
        </member>
        <member name="F:Loyc.Syntax.NodeStyle.Compact">
            <summary>The node's children should have a compact notation. In LES3, the 
            Julia-style list or call notation has this style: <c>[. a b c 2+2]</c>.
            When combined with NodeStyle.Alternate, this requests expression-tree 
            notation like [' ...], which can only be used if the Loyc tree meets
            certain constraints.</summary>
        </member>
        <member name="F:Loyc.Syntax.NodeStyle.OldStyle">
            <summary>Use an older or backward-compatible notation.</summary>
            <remarks>In EC#: prints lambda as delegate; forces old cast notation in EC#.</remarks>
        </member>
        <member name="F:Loyc.Syntax.NodeStyle.BaseStyleMask">
            <summary>If s is a NodeStyle, (s &amp; NodeStyle.BaseStyleMask) is the 
            base style (Default, Operator, Statement, Special, PrefixNotation, Expression or OldStyle).</summary>
        </member>
        <member name="F:Loyc.Syntax.NodeStyle.VerbatimId">
            <summary>Indicates that an identifier was marked in the standard way 
            used to indicate that it contained special characters or matched a 
            keyword (e.g. @int in C#)</summary>
            <remarks>Indicates the presence of the marking (e.g. @ sigil in C#) 
            regardless of whether the marking is necessary. Node printers must
            ensure their output is valid even when this style is not present.</remarks>
        </member>
        <member name="F:Loyc.Syntax.NodeStyle.BinaryLiteral">
            <summary>Used for a binary (base-2) literal like 0b11111.</summary>
        </member>
        <member name="F:Loyc.Syntax.NodeStyle.HexLiteral">
            <summary>Used for a hexadecimal (base-16) literal like 0x1F.</summary>
        </member>
        <member name="F:Loyc.Syntax.NodeStyle.OctalLiteral">
            <summary>Used for an octal (base-7) literal like 0o37.</summary>
            <remarks>Octal literals are not natively supported in LES.</remarks>
        </member>
        <member name="F:Loyc.Syntax.NodeStyle.VerbatimStringLiteral">
            <summary>Used for an EC# verbatim string literal like <c>@"foo"</c>.</summary>
        </member>
        <member name="F:Loyc.Syntax.NodeStyle.TQStringLiteral">
            <summary>Used for a triple-quoted string literal like <c>'''foo'''</c>.</summary>
        </member>
        <member name="F:Loyc.Syntax.NodeStyle.TDQStringLiteral">
            <summary>Used for a triple-double-quoted string literal like <c>"""foo"""</c>.</summary>
        </member>
        <member name="F:Loyc.Syntax.NodeStyle.Alternate">
            <summary>If this node has two styles in which it can be printed, this
            selects the second (the less common style, or less-well-supported style).
            In EC#, it denotes x(->int) as opposed to (int)x, and x (as Y) as opposed 
            to (x as Y). In C#, delegate(X) {Y;} is considered to be the alternate 
            style for X => Y; it forces parens and braces as a side-effect.</summary>
        </member>
        <member name="F:Loyc.Syntax.NodeStyle.InternalFlag">
            <summary>Reserved for use by specific compilers/languages.</summary>
        </member>
        <member name="F:Loyc.Syntax.NodeStyle.OneLiner">
            <summary>Indicates that the there is no comment or newline trivia associated
            with the children of this node, and therefore when printing this node,
            automatic newlines can be suppressed.</summary>
        </member>
        <member name="F:Loyc.Syntax.NodeStyle.Handled">
            <summary>Indicates that some part of a compiler, or a macro, has seen 
            the node and done something with it.</summary>
            <remarks>The motivation for this flag relates to compilers that allow 
            user-defined attributes for plug-ins or macros that add functionality. 
            For example, internationalization plug-in might notice a language marker:
            <code>
               MessageBox.Show([en] "Hello, World!");
            </code>
            If an attribute is not used by any plug-in, the compiler should print 
            a warning that the attribute is unused. This leads to the question, how
            can a compiler tell if an attribute was ever used? The Handled flag
            is one possible mechanism; when any part of the compiler or its plug-
            ins use an attribute, the Handled flag could be set to disable the
            compiler warning.
            <para/>
            Remember that the same node can theoretically appear in multiple
            places in a syntax tree, which typically happens when a statement or
            expression is duplicated by a macro, without being changed. When a 
            style is changed on such a node, the change is visible at all locations 
            where the same node is used. However, style flags are not synchronized 
            between copies of a node.
            </remarks>
        </member>
        <member name="T:Loyc.Syntax.SourcePosIsObsolete">
            <summary>This just helps end-users to discover the name change 
            SourcePos.PosInLine => ILineAndColumn.Column during upgrades</summary>
        </member>
        <member name="T:Loyc.Syntax.LineAndCol">
            <summary>Please use the new name of this class: LineAndColumn.
            Holds a line number (Line) and a position in the line (Column).
            This class isn't really needed in Loyc but is separated from SourcePos 
            in case anyone might want position without a filename.</summary>
            <remarks>Numbering starts at one for both Line and Column. 
            Line=0 signifies nowhere in particular, or an unknown location.</remarks>
        </member>
        <member name="T:Loyc.Syntax.SourcePos">
            <summary>Please use the new name of this class: LineColumnFile.
            Holds a filename (FileName), a line number (Line) and a position in 
            the line (Column), representing a position in a source code file.</summary>
            <remarks>
            Line and column numbering both start at one (1). Line=0 signifies nowhere 
            in particular. Instances are immutable.
            </remarks>
        </member>
        <member name="T:Loyc.Syntax.LineAndColumn">
            <summary>This is the new (and recommended) name for LineAndCol. It
            holds a line number (Line) and a position in the line (Column).
            Numbering starts at one for both Line and Column.</summary>
        </member>
        <member name="T:Loyc.Syntax.LineColumnFile">
            <summary>This is the new (and recommended) name for SourcePos. It's named 
            after what it contains: a line number, column number and file name.
            Numbering starts at one for both Line and Column.</summary>
        </member>
        <member name="T:Loyc.Syntax.ParsingMode">
            <summary>Standard parsing modes used with <see cref="!:IParsingService"/> and
            <see cref="T:Loyc.Syntax.ILNodePrinterOptions"/>.</summary>
        </member>
        <member name="F:Loyc.Syntax.ParsingMode.Expressions">
            <summary>Tells <see cref="!:IParsingService.Parse"/> to treat the input 
            as a single expression or expression list (which, in most languages, 
            is comma-separated).</summary>
        </member>
        <member name="F:Loyc.Syntax.ParsingMode.Statements">
            <summary>Tells <see cref="!:IParsingService.Parse"/> to treat the input
            as a list of statements. If the language makes a distinction between 
            executable and declaration contexts, this refers to the executable 
            context.</summary>
        </member>
        <member name="F:Loyc.Syntax.ParsingMode.Declarations">
            <summary>Tells <see cref="!:IParsingService.Parse"/> to treat the input
            as a list of statements. If the language makes a distinction between 
            executable and declaration contexts, this refers to the declaration
            context, in which types, methods, and properties are recognized.</summary>
        </member>
        <member name="F:Loyc.Syntax.ParsingMode.Types">
            <summary>Tells <see cref="!:IParsingService.Parse"/> to treat the input
            as a list of types (or a single type, if a list is not supported).</summary>
        </member>
        <member name="F:Loyc.Syntax.ParsingMode.FormalArguments">
            <summary>Tells <see cref="!:IParsingService.Parse"/> to treat the input
            as a formal argument list (parameter names with types).</summary>
        </member>
        <member name="F:Loyc.Syntax.ParsingMode.File">
            <summary>Tells <see cref="!:IParsingService.Parse"/> to treat the input
            as a complete source file (this should be the default, i.e. null will
            do the same thing).</summary>
        </member>
        <member name="T:Loyc.InvalidStateException">
            <summary>An exception thrown when an object detects that its own state is
            invalid, or in other words, that an invariant has been violated. 
            </summary><remarks>
            This exception often indicates that something went wrong earlier in the 
            execution of the program, before the method was called that threw this
            exception.
            </remarks>
        </member>
        <member name="T:Loyc.ConcurrentModificationException">
            <summary>An exception thrown when a data structure is accessed (read or 
            written) by one thread at the same time as it is modified on another 
            thread.</summary><remarks>
            Note: most data structures do not detect this situation, or do not detect it
            reliably. For example, the <see cref="!:Loyc.Collections.AList&lt;T&gt;"/> family of data structures 
            may or may not detect this situation. If it is detected then this exception
            is thrown, otherwise the data structure may take on an invalid state, leading
            to <see cref="T:Loyc.InvalidStateException"/> or other unexpected exceptions.
            </remarks>
        </member>
        <member name="T:Loyc.ReadOnlyException">
            <summary>An exception thrown when an attempt is made to modify a read-only object.</summary>
        </member>
        <member name="T:Loyc.CheckParam">
            <summary>Helper methods for checking argument values that throw exceptions 
            when an argument value is not acceptable.</summary>
        </member>
        <member name="T:Loyc.MemoizedTypeName">
            <summary>.NET Framework reflection doesn't offer complete type names for 
            generic types such as "List&lt;int>" (the <c>Type.Name</c> value of that class is 
            "List`1"). <see cref="M:Loyc.MemoizedTypeName.Get(System.Type)"/> fills in the gap, and also saves the 
            computed name for fast repeated lookups.</summary>
        </member>
        <member name="M:Loyc.MemoizedTypeName.Get(System.Type)">
            <summary>Computes a short language-agnostic name for a type, including 
            generic parameters, e.g. GenericName(typeof(int)) is "Int32"; 
            GenericName(typeof(Dictionary&lt;int, string>)) is 
            "Dictionary&lt;Int32, String>".</summary>
            <param name="type">Type whose name you want</param>
            <returns>Name with generic parameters, as explained in the summary.</returns>
            <remarks>The result is memoized for generic types, so that the name is
            computed only once.</remarks>
        </member>
        <member name="M:Loyc.MemoizedTypeName.ComputeGenericName(System.Type)">
            <summary>Computes a type's name without memoization.</summary>
        </member>
        <member name="M:Loyc.MemoizedTypeName.NameWithGenericParams(System.Type)">
            <summary>Extension method on <c>Type</c> that is an alias for the <see cref="M:Loyc.MemoizedTypeName.Get(System.Type)"/> method.</summary>
        </member>
        <member name="T:Loyc.MemoizedTypeName`1">
            <summary><c>MemoizedTypeName&lt;T>.Get()</c> is an alternative to
            <see cref="M:Loyc.MemoizedTypeName.Get(System.Type)"/>(typeof(T)).</summary>
            <remarks>This class is faster for getting the same name repeatedly, but 
            demands more memory and initialization overhead from the CLR.</remarks>
        </member>
        <member name="T:Loyc.Pair">
            <summary><c>Pair.Create(a, b)</c> is a helper method for making pairs.</summary>
            <remarks>To avoid creating an extra class, this class also contains 
            <c>Pair.Create(a, b, c)</c> which makes triplet structs.</remarks>
        </member>
        <member name="T:Loyc.Pair`2">
            <summary>A tuple of two values, <c>A</c> and <c>B</c>, in a struct.</summary>
            <remarks>
            The BCL has a <see cref="T:System.Collections.Generic.KeyValuePair`2"/> structure that has two problems:
            not all pairs are key-value pairs, and its name is overly long and clumsy.
            There is also a <see cref="T:System.Tuple`2"/> type, whose problem is that it 
            requires a heap allocation.
            <para/>
            For compatibility with <see cref="T:System.Collections.Generic.KeyValuePair`2"/>, this 
            structure has <c>Key</c> and <c>Value</c> properties. For compatibility
            with <see cref="T:System.Tuple`2"/>, it has <c>Item1</c> and <c>Item2</c> 
            properties. Respectively, these properties refer to the A and B fields.
            <para/>
            This is a mutable structure. Some people fear mutable structures, but I have 
            heard all the arguments, and find them unpersuasive. The most common pitfall, 
            changing a copy and expecting a different copy to change, is nothing more than
            ignorance about how structs work. The second most common pitfall involves 
            mutator methods inside a struct, but this struct doesn't have any of those
            (and the problem would largely be fixed by a compiler-recognized attribute 
            like <c>[Mutates]</c> that would detect potential problems).
            </remarks>
        </member>
        <member name="T:Loyc.UString">
            <summary>UString is a slice of a string. It is a wrapper around string that 
            provides a <see cref="T:Loyc.Collections.IBRange`1"/> of 21-bit UCS-4 characters. "U" stands for 
            "Unicode", as in UCS-4, as opposed to a normal string that is UTF-16.</summary>
            <remarks>
            UString is a slice type: it represents either an entire string, or a region
            of code units in a string. .NET strings are converted implicitly to UString.
            UString is similar to .NET Core's Memory{char}, but predates it by a few 
            years.
            <para/>
            It has been suggested that Java and .NET's reliance on 16-bit "unicode" 
            characters was a mistake, because it turned out that 16 bits was not enough 
            to represent all the world's characters.
            <para/>
            Instead it has been suggested that we should use <a href="http://www.utf8everywhere.org/">
            UTF-8 everywhere</a>. To scan UTF-8 data instead of UTF-16 while still 
            supporting non-English characters (or "rtr", as I like to say),
            it is useful to have a bidirectional iterator that scans characters one
            codepoint at a time. UString provides that functionality for .NET, and
            the nice thing about UString is that it's largely portable to UTF-8 
            environments. That is, if you use UString, as long as you do not assume 
            that you can access non-ASCII characters via the indexer, your code 
            will be portable to a UTF-8 environment that uses an equivalent 
            implementation of UString for UTF-8. Eventually I want Loyc to target 
            native environments, where UTF-8 is common, and UString can provide a 
            common data type for both UTF-8 and UTF-16 environments.
            <para/>
            UString is a bidirectional range of Unicode UCS-4 integers (known as 
            "uchar" in the source code.)
            <para/>
            UString has a <see cref="M:Loyc.UString.DecodeAt(System.Int32)"/> method that tries to decode
            a UTF character to UCS at a particular index.
            <para/>
            Unfortunately, it's not possible for UString to compare equal to its 
            equivalent string, for two reasons: (1) System.String.Equals cannot be
            changed, and (2) UString.GetHashCode cannot return the same value as
            String.GetHashCode without actually generating a String object, which
            would be inefficient (String.GetHashCode cannot be emulated because it
            changes between versions of the .NET framework and even between 32- and 
            64-bit builds.)
            <para/>
            TODO: add Normalize, FindLast, ReplaceAll, etc.
            </remarks>
        </member>
        <member name="M:Loyc.UString.#ctor(System.String,System.Int32,System.Int32)">
            <summary>Initializes a UString slice.</summary>
            <exception cref="T:System.ArgumentException">The start index was below zero.</exception>
            <remarks>The (start, count) range is allowed to be invalid, as long
            as 'start' is zero or above. 
            <ul>
            <li>If 'count' is below zero, or if 'start' is above the original Length, 
            the Count of the new slice is set to zero.</li>
            <li>if (start + count) is above the original Length, the Count of the new
            slice is reduced to <c>list.Length - start</c>.</li>
            </ul>
            </remarks>
        </member>
        <member name="P:Loyc.UString.InternalString">
            <summary>Returns the original string.</summary>
            <remarks>Ideally, the string would be private and there would be no way 
            to access its contents beyond the boundaries of the slice. However, the
            reality in .NET today is that many methods accept "slices" in the 
            form of a triple (string, start index, count). In order to call such an
            old-style API using a slice, one must be able to extract the internal
            string and start index values.</remarks>
        </member>
        <member name="P:Loyc.UString.Length">
            <summary>Gets the length of the string in code units (which may be 
            greater than the number of actual characters or code points).</summary>
        </member>
        <member name="P:Loyc.UString.IsEmpty">
            <summary>Returns true if and only if Count == 0.</summary>
        </member>
        <member name="P:Loyc.UString.IsNull">
            <summary>Returns true if the internal string is a null reference.
            Caution: an "empty" UString is "equal" to a "null" UString because the 
            list of characters is the same. If you want to know if the internal string 
            reference is null, you must use this property instead of comparing with
            null.</summary>
        </member>
        <member name="M:Loyc.UString.TryDecodeAt(System.Int32)">
            <summary>Returns the UCS code point that starts at the specified index.</summary>
            <remarks>
            Works the same way as <see cref="M:Loyc.UString.DecodeAt(System.Int32)"/> except that if the index
            is invalid, this method returns -1 rather than throwing.
            </remarks>
        </member>
        <member name="M:Loyc.UString.DecodeAt(System.Int32)">
            <summary>Returns the UCS code point that starts at the specified index.</summary>
            <param name="index">Code unit index at which to decode.</param>
            <returns>The code point starting at this index.</returns>
            <exception cref="T:System.IndexOutOfRangeException">invalid <c>index</c>.</exception>
        </member>
        <member name="P:Loyc.UString.Item(System.Int32)">
            <summary>Returns the code unit (16-bit value) at the specified index.</summary>
            <exception cref="T:System.IndexOutOfRangeException">Oops.</exception>
        </member>
        <member name="P:Loyc.UString.Item(System.Int32,System.Char)">
            <summary>Returns the code unit (16-bit value) at the specified index,
            or a default value if the specified index was out of range.</summary>
        </member>
        <member name="P:Loyc.UString.Item(System.Int32,System.Int32)">
            <summary>Returns the code point (21-bit value) at the specified index,
            or a default value if the specified index was out of range.</summary>
        </member>
        <member name="M:Loyc.UString.Substring(System.Int32,System.Int32)">
            <summary>Synonym for Slice()</summary>
        </member>
        <member name="M:Loyc.UString.Substring(System.Int32)">
            <summary>Returns the sequence of code units from this UString starting
            at the index <c>start</c>, e.g. Substring(1) returns all code units 
            except the first.</summary>
        </member>
        <member name="M:Loyc.UString.Left(System.Int32)">
            <summary>Returns the leftmost <c>length</c> code units of the string, 
            or fewer if the string length is less than <c>length</c>.</summary>
        </member>
        <member name="M:Loyc.UString.Right(System.Int32)">
            <summary>Returns the rightmost <c>length</c> code units of the string,
            or fewer if the string length is less than <c>length</c>.</summary>
        </member>
        <member name="M:Loyc.UString.Find(System.Int32,System.Boolean)">
            <summary>Finds the specified UCS-4 character.</summary>
            <returns>returns a range from the first occurrence of 'what' to the 
            original end of this UString. If the character is not found, an empty 
            string (slicing the end of this range) is returned.</returns>
        </member>
        <member name="M:Loyc.UString.Find(Loyc.UString,System.Boolean)">
            <summary>Finds the specified string within this string.</summary>
            <returns>Returns a range from the first occurrence of 'what' to the 
            original end of this UString. If 'what' is not found, an empty string
            (slicing the end of this range) is returned.</returns>
        </member>
        <member name="M:Loyc.UString.ShedExcessMemory(System.Int32)">
            <summary>This method makes a copy of the string if this is a 
            sufficiently small slice of a larger string.</summary>
            <returns>returns ToString() if <c>InternalString.Length - Length > maxExtra</c>, otherwise this.</returns>
        </member>
        <member name="M:Loyc.UString.ToUpper">
            <summary>Converts the string to uppercase using the 'invariant' culture.</summary>
        </member>
        <member name="M:Loyc.UString.StartsWith(Loyc.UString,System.Boolean)">
            <summary>Determines whether this string starts with the specified other 
            string.</summary>
            <returns>true if this string starts with the contents of 'what'</returns>
        </member>
        <member name="M:Loyc.UString.Replace(Loyc.UString,Loyc.UString,System.Boolean,System.Int32)">
            <summary>Returns a new string in which all occurrences (or a specified 
            number of occurrences) of a specified string in the current instance 
            are replaced with another specified string.</summary>
            <param name="what"></param>
            <param name="replacement"></param>
            <param name="ignoreCase"></param>
            <param name="maxReplacements"></param>
            <returns>Returns a new string with replacements made, or the same 
            string if no replacements occurred.</returns>
        </member>
        <member name="T:Loyc.IHasLocation">
            <summary>This interface allows an object to declare its "location".</summary>
            <remarks>
            Objects designed to be used as a context parameter in <see cref="T:Loyc.IMessageSink`1"/>
            can implement this interface so that the string form of the message shows
            the location of a piece of data instead of the data itself. For example, 
            <see cref="!:Loyc.Syntax.LNode"/> implements this interface so that when a 
            compiler error refers to a source code construct, the context of the
            <see cref="!:LogMessage"/> can refer to the code itself while the printed form 
            of the the error message shows the location of the code instead.
            <para/>
            Given a context object that may or may not implement this interface, it's
            handy to use <see cref="!:MessageSink.ContextToString"/> to convert the 
            "context" of a message into a string, or <see cref="!:MessageSink.LocationOf(object)"/> 
            to unwrap objects that implement IHasLocation.
            </remarks>
        </member>
        <member name="T:Loyc.Localize">
            <summary>
            Localize is a global hook into which a string-mapping localizer can be
            installed. It makes your program localization-ready with no effort.
            See article: http://core.loyc.net/essentials/localize.html
            </summary><remarks>
            The idea of the Localize facility is to convince programmers to support
            localization by making it dead-easy to do. By default it is not connected to
            any translator (it just passes strings through), so people who are only
            writing a program for a one-language market can easily make their code
            "multiligual-ready" without doing any extra work. All you do is call the
            <c>.Localized()</c> extension method, which is actually shorter than 
            <c>string.Format()</c>.
            <p/>
            All errors thrown from Loyc libraries are in English but pass through this 
            localizer.
            <p/>
            The translation system itself is separate from this class, and connected 
            to `Localized()` by a delegate, so that multiple translation systems are 
            possible. This class should be suitable for use in any .NET program, and 
            some programs using this utility will want to plug-in a different localizer.
            <p/>
            Use it like this:
            <code>
            string result = "Hello, {0}".Localized(userName);
            </code>
            Or, for increased clarity, use named placeholders:
            <code>
            string result = "Hello, {person's name}".Localized("person's name", userName);
            </code>
            Whatever localizer is installed will look up the text in its database and
            return a translation. If no translation to the end user's language is
            available, an appropriate default translation should be returned: either the
            original text, or a translation to some default language, e.g. English.
            <para/>
            The localizer will need an external table of translations, conceptually like 
            this:
            <pre>
            | Key name      | Language | Translated text |
            | "Hello, {0}"  | "es"     | "Hola, {0}"     |
            | "Hello, {0}"  | "fr"     | "Bonjour, {0}"  |
            | "Load"        | "es"     | "Cargar"        |
            | "Load"        | "fr"     | "Charge"        |
            | "Save"        | "es"     | "Guardar"       |
            | "Save"        | "fr"     | "Enregistrer"   |
            </pre>
            Many developers use a resx file to store translations. This class supports 
            that approach, as explained below.
            <para/>
            For longer messages, it is preferable to use a short name to represent the
            message so that, when the English language text is edited, the translation
            tables do not have to be updated. To do this, use the 
            <see cref="M:Loyc.Localize.Symbol(System.String,System.String,System.Object[])"/> method:
            <pre>
            string result = Localize.Symbol("ConfirmQuitWithoutSaving", 
            	"Are you sure you want to quit without saving '{filename}'?", "filename", fileName);
            
            // Enhanced C# syntax with symbol literal
            string result = Localize.Symbol(@@ConfirmQuitWithoutSaving, 
            	"Are you sure you want to quit without saving '{filename}'?", "filename", fileName);
            </pre>
            This is most useful for long strings or paragraphs of text, but I expect
            that some projects, as a policy, will use symbols for all localizable text.
            (When using Localize.Symbol, the actual message is allowed to be null. In 
            that case, the symbol (first argument) is returned as a last resort if no 
            translation is found.
            <p/>
            If the variable argument list is not empty, <see cref="P:Loyc.Localize.Formatter"/> 
            is called to build the completed string from the format string. It is 
            possible to perform formatting separately, for example:
            <code>
            Console.WriteLine("{0} is {0:X} in hexadecimal".Localized(), N);
            </code>
            Here, WriteLine itself performs the formatting instead. 
            <p/>
            As demonstrated above, Localize's default formatter, <see cref="!:StringExt.FormatCore"/>, 
            has an extra feature that the standard formatter does not: named arguments. 
            Here is an example:
            <code>
            ...
            string verb = (IsFileLoaded ? "parse" : "load").Localized();
            MessageBox.Show(
                "Not enough memory to {load/parse} '{filename}'.".Localized(
                  "load/parse", verb, "filename", FileName));
            </code>
            As you can see, named arguments are mentioned in the format string by
            specifying an argument name such as <c>{filename}</c> instead of a number 
            like <c>{0}</c>. The variable argument list contains the same name followed 
            by its value, e.g. "filename", FileName. This feature gives you, the 
            developer, the opportunity to tell the person writing translations what 
            the purpose of a particular argument is.
            <p/>
            The translator must not change any of the arguments: the word "{filename}"
            is not to be translated.
            <p/>
            At run-time, the format string with named arguments is converted to a
            "normal" format string with numbered arguments. The above example would
            become "Could not {1} the file: {3}" and then be passed to string.Format.
            
            <h3>Design rationale</h3>
            
            Many developers don't want to spend time writing internationalization or
            localization code, and are tempted to write code that is only for one
            language. It's no wonder, because it's a relative pain in the neck.
            Microsoft suggests that code carry around a "ResourceManager" object and
            directly request strings from it:
            <code>
            private ResourceManager rm;
            rm = new ResourceManager("AssemblyName.Resources", this.GetType().Assembly);
            Console.Writeline(rm.GetString("StringIdentifier"));
            </code>
            This approach has drawbacks:
            
            * It may be cumbersome to pass around a ResourceManager instance between all
              classes that might contain localizable strings; a global facility is
              much more convenient.
            * The programmer has to put all translations in the resource file;
              consequently, writing the code is bothersome because the programmer has
              to switch to the resource file and add the string to it. Someone reading
              the code, in turn, can't tell what the string says and has to load up
              the resource file to find out.
            * It is not easy to change the localization manager; for instance, what if
              someone wants to store translations in an .ini, .xml or .les file rather 
              than inside the assembly? What if the user wants to centralize all
              translations for a set of assemblies, rather than having separate
              resources in each assembly? 
            <p/>
            Microsoft does address the first of these drawbacks by providing a code 
            generator built into Visual Studio that gives you a global property for
            each string; see
            http://stackoverflow.com/questions/1142802/how-to-use-localization-in-c-sharp
            <p/>
            Even so, you may find that this class provides a more convenient approach 
            because your native-language strings are written right in your code, and 
            because you are guaranteed to get a string at runtime (not null) if the 
            desired language is not available.
            <p/>
            This class supports ResourceManager via the <see cref="M:Loyc.Localize.UseResourceManager(System.Resources.ResourceManager,System.Globalization.CultureInfo,System.Func{System.String,System.String})"/> 
            helper method. For example, after calling 
            <c>Localize.UseResourceManager(resourceManager)</c>, if you write 
            <code>
            "Save As...".Localized()
            </code>
            Then <c>resourceManager.GetString("Save As...")</c> is called to get the 
            translated string, or the original string if no translation was found. 
            You can even add a "name calculator" to encode your resx file's naming 
            convention, e.g. by removing spaces and punctuation (for details, see 
            <see cref="M:Loyc.Localize.UseResourceManager(System.Resources.ResourceManager,System.Globalization.CultureInfo,System.Func{System.String,System.String})"/>.)
            <p/>
            It is conventional in .NET programs to have one "main" resx file, e.g.
            Resources.resx, that contains default strings, along other files with 
            non-English translations (e.g. Resources.es.resx for Spanish). When using
            Localized() you would typically use a slightly different approach: you
            still have a Resources.resx file, but you leave the string table empty. 
            This causes Visual Studio to generate a Resources class with a 
            ResourceManager property so that you need can easily get the ResourceManager 
            object.
            <ol>
            <li>When your program starts, call <c>Localize.UseResourceManager(Resources.ResourceManager)</c>.</li>
            <li>Use the <c>Localized()</c> extension method to get translations of short strings.</li>
            <li>For long strings, use <c>Localize.Symbol("ShortAlias", "Long string", params...)</c>.
            The first argument is the string passed to ResourceManager.GetString()</li>
            </ol>
            In the open source world, most developers don't have a team of translators
            ready make translations for them. The idea of Loyc, for example, is that
            many different individuals--not one big team--of programmers will create
            and maintain features. By centralizing this translation facility, it should
            be straightforward for a single multilingual individual to translate the
            text of many modules made by many different people.
            <p/>
            To facilitate this, I propose that in addition to a translator, a program
            should be made to figure out all the strings/symbols for which translations 
            are needed. To do this it would scan source code (at compile time) for 
            calls to methods in this class and generate a list of strings and symbols 
            needing translation. It would also have to detect certain calls that
            perform translation implicity, such as IMessageSink.Write(). See
            <see cref="T:Loyc.LocalizableAttribute"/>.
            <p/>
            TODO: expand I18N features based on Mozilla's L20N.
            </remarks>
        </member>
        <member name="P:Loyc.Localize.GlobalDefaultLocalizer">
            <summary>Gets or sets the localizer used when one has not been assigned 
            to the current thread with <see cref="M:Loyc.Localize.SetLocalizer(Loyc.LocalizerDelegate)"/>.</summary>
        </member>
        <member name="P:Loyc.Localize.GlobalDefaultFormatter">
            <summary>Gets or sets the formatter used when one has not been assigned 
            to the current thread with <see cref="M:Loyc.Localize.SetFormatter(Loyc.FormatterDelegate)"/>.</summary>
        </member>
        <member name="P:Loyc.Localize.Localizer">
            <summary>Localizer method, which is a do-nothing pass-through by default</summary>
        </member>
        <member name="P:Loyc.Localize.Formatter">
            <summary>String formatter method, which is `string.Format` by default</summary>
        </member>
        <member name="M:Loyc.Localize.SetLocalizer(Loyc.LocalizerDelegate)">
            <summary>Sets the localizer method.</summary>
            <remarks><see cref="P:Loyc.Localize.Localizer"/> is a thread-local value, but since
            .NET does not support inheritance of thread-local values, this method
            also sets the global default used by threads on which this method was 
            never called.
            <para/>
            This property follows the Ambient Service Pattern:
            http://core.loyc.net/essentials/ambient-service-pattern.html
            </remarks>
        </member>
        <member name="M:Loyc.Localize.SetFormatter(Loyc.FormatterDelegate)">
            <summary>Sets the formatter method.</summary>
            <remarks><see cref="P:Loyc.Localize.Formatter"/> is a thread-local value, but since
            .NET does not support inheritance of thread-local values, this method
            also sets the global default used by threads on which this method was 
            never called.
            </remarks>
        </member>
        <member name="M:Loyc.Localize.UseResourceManager(System.Resources.ResourceManager,System.Globalization.CultureInfo,System.Func{System.String,System.String})">
            <summary>Uses a standard <see cref="T:System.Resources.ResourceManager"/> object to obtain translations.</summary>
            <param name="manager">A ResourceManager that provides access to resources (resx embedded in an assembly)</param>
            <param name="culture">A value of <see cref="T:System.Globalization.CultureInfo"/> that
            represents the language to look up in the ResourceManager. If this is
            null, the ResourceManager will use CultureInfo.CurrentUICulture.</param>
            <param name="resxNameCalculator">An optional function that will be 
            called when a translation is requested without providing a resource 
            key symbol. For example, if someone writes <c>"Save as...".Localized()</c>
            using the <see cref="M:Loyc.Localize.Localized(System.String)"/> extension method, this 
            function is called on the string "Save as...". This function could
            be used to compute a resource name such as "strSaveAs" automatically,
            according to whatever naming convention is used in your resource file.
            </param>
            <returns></returns>
            <remarks>If a translation was not found in the specified ResourceManager 
            and this parameter is true, the previously-installed <see cref="P:Loyc.Localize.Localizer"/> 
            is called instead.</remarks>
        </member>
        <member name="M:Loyc.Localize.Passthrough(Loyc.Symbol,System.String)">
            <summary>
            This is the dummy translator, which is the default value of Localizer. 
            It passes strings through untranslated. A msgId symbol cannot be handled 
            so it is simply converted to a string.
            </summary>
        </member>
        <member name="M:Loyc.Localize.Localized(Loyc.Symbol,System.String,System.Object[])">
            <summary>
            This is the heart of the Localize class, which localizes and formats a string.
            </summary>
            <param name="resourceId">Resource ID used to look up a translated format
            string using the current user-defined <see cref="P:Loyc.Localize.Localizer"/>. If this 
            parameter is null, a message must be provided; otherwise, the message is only 
            used if no translation is associated with the specified Symbol.</param>
            <param name="message">The message to be translated, which may include 
            argument placeholders (e.g. "{0}"). The default formatter also accepts 
            named parameters like "{firstName}"; see <see cref="!:StringExt.FormatCore"/> 
            for details.</param>
            <param name="args">Arguments given to <see cref="P:Loyc.Localize.Formatter"/> to fill in 
            placeholders after the Localizer is called. If args is null or empty then 
            Formatter is not called.</param>
            <returns>The translated and formatted string.</returns>
        </member>
        <member name="M:Loyc.Localize.WithSymbol(System.String,System.String,System.Object[])">
            <inheritdoc cref="M:Loyc.Localize.Symbol(Loyc.Symbol,System.String,System.Object[])"/>
        </member>
        <member name="M:Loyc.Localize.Localized(System.String,System.Object[])">
            <summary>Finds and formats a localization of the given message. If none is 
            found, the original string is formatted.</summary>
            <param name="message">The message to translate, which may include argument 
            placeholders (e.g. "{0}"). The default formatter also accepts named 
            parameters like "{firstName}"; see <see cref="!:StringExt.FormatCore"/> for 
            details.</param>
            <param name="args">Arguments given to <see cref="P:Loyc.Localize.Formatter"/> to fill in 
            placeholders after the Localizer is called. If args is null or empty then 
            Formatter is not called.</param>
            <returns>The translated and formatted string.</returns>
        </member>
        <member name="T:Loyc.LocalizableAttribute">
            <summary>
            I plan to use this attribute someday to gather all the localizable strings 
            in an application. This attribute should be applied to a string function 
            parameter if the method calls Localized() using that parameter as the 
            format string, or passes it to another localizing method.
            </summary>
        </member>
        <member name="M:Loyc.Maybe.Value``1(``0)">
            <summary>Returns <c>new Maybe&lt;T>(value)</c>. (exists for type inference)</summary>
        </member>
        <member name="M:Loyc.Maybe.AsNullable``1(Loyc.Maybe{``0})">
            <summary>Converts <see cref="T:Loyc.Maybe`1"/> to a <see cref="T:System.Nullable`1"/> having the same HasValue property.</summary>
        </member>
        <member name="M:Loyc.Maybe.AsMaybe``1(System.Nullable{``0})">
            <summary>Creates a <see cref="T:Loyc.Maybe`1"/>, using <see cref="P:Loyc.Maybe`1.NoValue"/> if and only if the input is null.</summary>
        </member>
        <member name="M:Loyc.Maybe.AsMaybe``1(``0)">
            <summary>Creates a <see cref="T:Loyc.Maybe`1"/>, using <see cref="P:Loyc.Maybe`1.NoValue"/> if and only if the input is null.</summary>
        </member>
        <member name="M:Loyc.Maybe.Or``2(``0,``1)">
            <summary>Converts <see cref="T:Loyc.IMaybe`1"/> to T, returning a default value if <see cref="!:HasValue"/> is false.</summary>
            <remarks>This is like the <c>??</c> operator of <c>T?</c>.</remarks>
        </member>
        <member name="M:Loyc.Maybe.Or``2(``0,System.Func{``1})">
            <summary>Converts <see cref="T:Loyc.IMaybe`1"/> to T, calling a factory function if <see cref="!:HasValue"/> is false.</summary>
            <remarks>This is like the <c>??</c> operator of <c>T?</c>.</remarks>
        </member>
        <member name="M:Loyc.Maybe.Then``1(Loyc.IMaybe{``0},System.Action{``0})">
            <summary>Runs a function if and only if <see cref="P:Loyc.IMaybe`1.HasValue"/>.</summary>
        </member>
        <member name="M:Loyc.Maybe.Then``2(Loyc.IMaybe{``0},System.Func{``0,``1},System.Func{``1})">
            <summary>Runs one of two functions depending on whether <see cref="P:Loyc.IMaybe`1.HasValue"/>.</summary>
        </member>
        <member name="M:Loyc.Maybe.Then``2(Loyc.IMaybe{``0},System.Func{``0,``1},``1)">
            <summary>Runs a function if and only if <see cref="P:Loyc.IMaybe`1.HasValue"/>, returning a default value otherwise.</summary>
        </member>
        <member name="T:Loyc.Maybe`1">
            <summary>Same as <see cref="T:System.Nullable`1"/> except that it behaves like a
            normal type, i.e. (1) T is allowed to be a reference type and (2) you can
            nest them, as in <c>Maybe{Maybe{int}}</c>.</summary>
            <remarks>The name of this type comes from some functional programming 
            languages which define a type such as <c>data Maybe t = Nothing | Just t</c>.
            <para/>
            This type exists primarily for generic code, since C# does not allow you
            to write a generic function that returns "T?" if T could be a class.
            Places where this type is used include the DictionaryExt.TryGetValue(key) 
            extension method, and the ILexer&lt;T>.NextToken() method. Both of these
            may not be able to return a value, but they cannot return T? because T 
            could be a class (or even a Nullable-of-something).
            <para/>
            There is an implicit conversion from T that returns <c>new Maybe{T}(value)</c>,
            and from <see cref="F:Loyc.NoValue.Value"/> that returns <see cref="P:Loyc.Maybe`1.NoValue"/>.
            Since C# doesn't allow us to define conversions to/from <c>T?</c>, these
            conversions can be accomplished with the extension methods <see cref="M:Loyc.Maybe.AsNullable``1(Loyc.Maybe{``0})"/>
            and <see cref="M:Loyc.Maybe.AsMaybe``1(System.Nullable{``0})"/>.
            <para/>
            The <see cref="M:Loyc.Maybe`1.Or(`0)"/> method replicates the C# <c>??</c> operator.
            </remarks>
        </member>
        <member name="M:Loyc.Maybe`1.Or(`0)">
            <summary>Converts <see cref="T:Loyc.Maybe`1"/> to T, returning a default value if <see cref="P:Loyc.Maybe`1.HasValue"/> is false.</summary>
            <remarks>This is equivalent to the <c>??</c> operator of <c>T?</c>.</remarks>
        </member>
        <member name="T:Loyc.WriteMessageFn">
            <summary>This is the method signature of <c>IMessageSink.Write()</c>. You 
            can convert from one of these delegates to <see cref="T:Loyc.IMessageSink"/> by 
            calling <see cref="!:MessageSink.FromDelegate"/>.</summary>
            <param name="type">Severity or importance of the message; widely-used
            types include Error, Warning, Note, Debug, and Verbose. The special 
            type Detail is intended to provide more information about a previous 
            message.</param>
            <param name="context">An object that represents the location that the
            message applies to, a string that indicates what the program was doing 
            when the message was generated, or any other relevant context information.
            See also <see cref="!:MessageSink.ContextToString"/>().</param>
            <param name="format">A message to display. If there are additional 
            arguments, placeholders such as {0} and {1} refer to these arguments.</param>
            <param name="args">Optional arguments to fill in placeholders in the format 
            string.</param>
        </member>
        <member name="T:Loyc.NoValue">
            <summary><c>NoValue.Value</c> is meant to be used as the value of a 
            property that has "no value", meaning no value is assigned or that the 
            property is meaningless at the current time or in the current context.
            </summary><remarks>
            Most often <c>null</c> is used for this purpose; <c>NoValue.Value</c> 
            is used when <c>null</c> is (or might be) a valid, meaningful 
            value and you want to distinguish between "no value" and "null".
            For example, this can be returned by the Value property of <see cref="T:Loyc.Syntax.ILNode"/>,
            in which <c>NoValue</c> means "this is not a literal, so it can't have
            a value, not even null".
            <para/>
            Also, this value converts implicitly to <see cref="P:Loyc.Maybe`1.NoValue"/>.
            </remarks>
        </member>
        <member name="T:Loyc.Threading.SavedThreadLocal`1">
            <summary>
            Designed to be used in a "using" statement to temporarily alter a 
            <see cref="T:System.Threading.ThreadLocal`1"/>.
            </summary>
        </member>
        <member name="T:Loyc.Threading.ScratchBuffer`1">
             <summary>Holds a single Value that is associated with the thread that
             assigned it.</summary>
             <remarks>
             ScratchBuffer is typically used as a static variable to hold a temporary
             object used for operations that are done frequently and require a 
             temporary memory space--but only during the operation, not afterward.
             <para/>
             For example, CPTrie may require a temporary byte array during searches.
             Re-creating the byte array for every search might cause a too much time
             to be spent garbage-collecting. On the other hand, if CPTrie keeps a 
             reference to the temporary buffer in itself, what if a program contains 
             many instances of CPTrie? Each one would have its own separate temporary
             buffer, wasting memory. The buffer can't be a straightforward global
             variable, either, in case two threads need a scratch buffer at once.
             ScratchBuffer, then, exists to prevent two threads from using the same 
             buffer.
             <para/>
             ScratchBuffer is designed with the assumption that creating a scratch
             buffer is fast, but re-using an existing buffer is faster. Since 
             creating a scratch buffer is cheap already, this class is worthless 
             unless it is even cheaper. Therefore, it does not hold a buffer for 
             each thread, since managing multiple buffers would be too expensive; 
             and volatile variable access is used instead of locking.
             <para/>
             ScratchBuffer originally returned null if the scratch buffer had not 
             been initialized or was associated with a different thread, requiring
             the caller to create a new buffer manually. Now there is a new constructor 
             that takes a factory function, which is called automatically by the Value
             property if the scratch buffer is null or belongs to another thread. If
             you use this constructor, then you do longer have to worry about Value 
             returning null.
             <example>
             static ScratchBuffer&lt;byte[]&gt; _buf = 
                new ScratchBuffer&lt;byte[]&gt;(() => new byte[40]);
            
             // A method called a million times that needs a scratch buffer each time
             void FrequentOperation()
             {
            		byte[] buf = _buf.Value;
                 
                 // do something here involving the buffer ...
             }
             </example>
             Arguably it is better to use a [ThreadStatic] variable is instead of 
             ScratchBuffer, but FWIW [ThreadStatic] is not available on the .NET
             Compact Framework.
             </remarks>
        </member>
        <member name="P:Loyc.Threading.ScratchBuffer`1.Value">
            <summary>Please see the documentation of <see cref="T:Loyc.Threading.ScratchBuffer`1"/> itself.</summary>
        </member>
        <member name="T:Loyc.Math.IConvertTo`1">
            <summary>
            Provides methods for converting common numeric types to another numeric type "T".
            </summary>
            <typeparam name="T">A numeric type</typeparam>
            <remarks>Methods for converting type T to standard numeric types would be 
            redundant, because standard numeric types already implement IConvertible for 
            this purpose. To use IConvertible in generic code, add IConvertible as a 
            type constraint on the numeric type.</remarks>
        </member>
        <member name="T:Loyc.Math.IOrdered`1">
            <summary>Provides comparison function for type T along with absolute value 
            (Abs), and the minimum or maximum of two values (Min, Max).</summary>
        </member>
        <member name="T:Loyc.Math.IOrderedExt">
            <summary>Extension methods for <see cref="T:Loyc.Math.IOrdered`1"/>.</summary>
        </member>
        <member name="T:Loyc.Math.IZeroProvider`1">
            <summary>Provides the value of "zero" for type T.</summary>
        </member>
        <member name="P:Loyc.Math.IZeroProvider`1.Zero">
            <summary>Returns the "zero" or additive identity of this type.</summary>
        </member>
        <member name="T:Loyc.Math.IOneProvider`1">
            <summary>Provides the value of "one" for type T.</summary>
        </member>
        <member name="P:Loyc.Math.IOneProvider`1.One">
            <summary>Returns the "one" or identity value of this type.</summary>
        </member>
        <member name="T:Loyc.Math.INumTraits`1">
            <summary>This interface provides information about a numeric type T.</summary>
            <typeparam name="T">A numeric type</typeparam>
        </member>
        <member name="P:Loyc.Math.INumTraits`1.MinValue">
            <summary>Minimum value of this type above negative infinity.</summary>
        </member>
        <member name="P:Loyc.Math.INumTraits`1.MaxValue">
            <summary>Maximum value of this type below infinity.</summary>
        </member>
        <member name="P:Loyc.Math.INumTraits`1.Epsilon">
            <summary>Smallest representable positive value of T (1 for integer types).</summary>
        </member>
        <member name="P:Loyc.Math.INumTraits`1.PositiveInfinity">
            <summary>Returns positive infinity, or MaxValue for types that cannot represent infinity.</summary>
        </member>
        <member name="P:Loyc.Math.INumTraits`1.NegativeInfinity">
            <summary>Returns negative infinity, or throws NotSupportedException if T is unsigned.</summary>
            <exception cref="T:System.NotSupportedException">T is unsigned.</exception>
        </member>
        <member name="P:Loyc.Math.INumTraits`1.NaN">
            <summary>Not-a-number or null representation for this type.</summary>
            <exception cref="T:System.NotSupportedException">There is no null or NaN value for type T.</exception>
        </member>
        <member name="M:Loyc.Math.INumTraits`1.IsInfinity(`0)">
            <summary>Returns true if the given value is infinite.</summary>
            <remarks>Types that do not have an infinity value always return false 
            from this method.</remarks>
        </member>
        <member name="M:Loyc.Math.INumTraits`1.IsNaN(`0)">
            <summary>Returns true if the given value is not a number (can only be true for floats).</summary>
        </member>
        <member name="M:Loyc.Math.INumTraits`1.Floor(`0)">
            <summary>Gets the closest integer equal to or lower than the specified number.</summary>
            <remarks>For integer types, this has no effect.</remarks>
        </member>
        <member name="M:Loyc.Math.INumTraits`1.Ceiling(`0)">
            <summary>Gets the closest integer equal to or higher than the specified number.</summary>
            <remarks>For integer types, this has no effect.</remarks>
        </member>
        <member name="P:Loyc.Math.INumTraits`1.IsSigned">
            <summary>Returns true if T can represent negative values.</summary>
        </member>
        <member name="P:Loyc.Math.INumTraits`1.IsFloatingPoint">
            <summary>Returns true if T is floating-point, meaning that it can 
            represent very large and very small numbers, despite possibly limited 
            precision. Returns false for fixed-point and integer-rational types.</summary>
        </member>
        <member name="P:Loyc.Math.INumTraits`1.IsInteger">
            <summary>Returns true if the type represents only whole numbers.</summary>
        </member>
        <member name="P:Loyc.Math.INumTraits`1.IsOrdered">
            <summary>Returns true for "normal" numbers, false for ones that aren't 
            necessarily comparable (notably complex numbers).</summary>
        </member>
        <member name="P:Loyc.Math.INumTraits`1.SignificantBits">
            <summary>Returns the normal maximum number of significant (mantissa) 
            bits for this type (not counting the sign bit), or int.MaxValue for 
            unlimited-size types.</summary>
        </member>
        <member name="P:Loyc.Math.INumTraits`1.MaxIntPowerOf2">
            <summary>Returns the maximum power-of-two-minus-one that can be 
            represented by this type, e.g. for Int32 it's 31, and for UInt32 it's 
            32.</summary>
        </member>
        <member name="P:Loyc.Math.INumTraits`1.MaxInt">
            <summary>Returns the maximum integer that this type can represent.</summary>
            <remarks>If the maximum integer exceeds ulong.MaxValue, this returns 
            ulong.MaxValue.</remarks>
        </member>
        <member name="P:Loyc.Math.INumTraits`1.MinInt">
            <summary>Returns the minimum integer that this type can represent.</summary>
            <remarks>If the minimum is less than long.MinValue, this returns 
            long.MinValue.</remarks>
        </member>
        <member name="T:Loyc.Math.IIncrementer`1">
            <summary>Provides increment, decrement, and next/previous-representable-
            value operations.</summary>
            <typeparam name="T">A numeric type.</typeparam>
            <remarks>Implementations may or may not detect overflow.</remarks>
        </member>
        <member name="M:Loyc.Math.IIncrementer`1.AddOne(`0)">
            <summary>Returns a + 1.</summary>
        </member>
        <member name="M:Loyc.Math.IIncrementer`1.SubOne(`0)">
            <summary>Returns a - 1.</summary>
        </member>
        <member name="M:Loyc.Math.IIncrementer`1.NextHigher(`0)">
            <summary>Returns the next representable number higher than a.</summary>
        </member>
        <member name="M:Loyc.Math.IIncrementer`1.NextLower(`0)">
            <summary>Returns the next representable number lower than a.</summary>
        </member>
        <member name="T:Loyc.Math.IBitwise`1">
            <summary>Provides the standard set of bitwise operators.</summary>
            <typeparam name="T">An integer or bit array type.</typeparam>
        </member>
        <member name="T:Loyc.Math.IBinaryMath`1">
            <summary>Provides additional bit-oriented integer operations.</summary>
            <typeparam name="T">An integer or integer-based types.</typeparam>
        </member>
        <member name="M:Loyc.Math.IBinaryMath`1.Shl(`0,System.Int32)">
            <summary>Shifts 'a' left by the specified number of bits.</summary>
            <remarks>A shift amount A negative shift amount produces undefined results</remarks>
        </member>
        <member name="M:Loyc.Math.IBinaryMath`1.Shr(`0,System.Int32)">
            <summary>Shifts 'a' right by the specified number of bits.</summary>
        </member>
        <member name="M:Loyc.Math.IBinaryMath`1.CountOnes(`0)">
            <summary>Returns the number of '1' bits in 'a'.</summary>
        </member>
        <member name="M:Loyc.Math.IBinaryMath`1.Log2Floor(`0)">
            <summary>
            Returns the floor of the base-2 logarithm of x. e.g. 1024 -> 10, 1000 -> 9
            </summary><remarks>
            The return value is int.MinValue for an input of zero (for which the 
            logarithm is technically undefined.)
            </remarks>
        </member>
        <member name="T:Loyc.Math.IAdditionGroup`1">
            <summary>
            This defines a Group with the operation +, the neutral element Zero,
            and an operation - that is defined in terms of the inverse. A Negate 
            operation is not provided so that this interface makes more sense for 
            use with unsigned types.
            
            Axioms that have to be satisified by the operations:
            Commutativity of addition: Add(a,b)=Add(b,a) for all a,b in T
            Associativity of addition: Add(Add(a,b),c)=Add(a,Add(b,c))
            Inverse of addition: Add(a,Negate(a))==Zero
            Subtraction: Subtract(a,b)==Add(a,Negate(b))
            Neutral element: Add(Zero,a)==a for all a in T
            </summary>
        </member>
        <member name="T:Loyc.Math.ITrigonometry`1">
            <summary>Provides trigonometry operations.</summary>
        </member>
        <member name="T:Loyc.Math.IHasRoot`1">
            <summary>Provides the Sqrt operation and its inverse, Square.</summary>
        </member>
        <member name="T:Loyc.Math.IExp`1">
            <summary>Provides power, logarithm, raise-e-to-exponent (Exp) and logarithm-of-e (Log) operations.</summary>
        </member>
        <member name="T:Loyc.Math.IMultiply`1">
            <summary>Provides the multiplication operation and the multiplicative identity, one.</summary>
        </member>
        <member name="T:Loyc.Math.IMultiplicationGroup`1">
            <summary>
            This defines a Group with the operation *, the neutral element One,
            the inverse Inverse and an operation / that is defined in terms of the inverse.
            </summary>
            <remarks>
            Axioms that have to be satisified by the operations:
            Commutativity of multiplication: Multiply(a,b)=Multiply(b,a) for all a,b in T
            Associativity of multiplication: Multiply(Multiply(a,b),c)=Multiply(a,Multiply(b,c))
            Inverse of multiplication: Multiply(a,Inverse(a))==One for all a in T
            Divison: Divide(a,b)==Multiply(a,Inverse(b)) for all a in T
            Neutral element: Multiply(One,a)==a for all a in T
            <br/><br/>
            Shl and Shr (shift left/right) operations are commonly thought of as binary 
            operations, but some algorithms need to multiply numbers by powers of two 
            and want to do so efficiently, while still supporting floating-point types. 
            Therefore it makes sense to offer Shl ("multiply by a power of two")
            and ShiftRight ("divide by a power of two") operators as part of the 
            multiple/divide interface, not just <see cref="T:Loyc.Math.IBinaryMath`1"/>. Even 
            floating-point types can support these two operations efficiently by 
            directly modifying the exponent part of the floating-point representation.
            </remarks>
        </member>
        <member name="T:Loyc.Math.IRing`1">
            <summary>
            This defines a Ring with the operations +,*        
            
            Axioms that have to be satisified by the operations:
            The group axioms for +
            Associativity of *: a * (b*c) = (a*b) * c
            Neutral element of *: Multiply(One,a)==a for all a in T
            Distributivity: 
                a * (b+c) = (a*b) + (a*c) 
                (a+b) * c = (a*c) + (b*c) 
            </summary>
        </member>
        <member name="T:Loyc.Math.IField`1">
            <summary>This defines a Field with the operations +,-,*,/</summary>
            <remarks>
            Axioms that have to be satisified by the operations:
            The group axioms for +
            The group axioms for *
            Associativity: a * (b*c) = (a*b) * c
            Distributivity: 
                a * (b+c) = (a*b) + (a*c) 
                (a+b) * c = (a*c) + (b*c) 
            </remarks>
        </member>
        <member name="T:Loyc.Math.IMath`1">
            <summary>
            Provides operations available on all system numeric types (int, uint, double,
            etc.); see also <see cref="T:Loyc.Math.ISignedMath`1"/>, <see cref="T:Loyc.Math.IUIntMath`1"/>, 
            <see cref="T:Loyc.Math.IIntMath`1"/> and <see cref="T:Loyc.Math.IFloatMath`1"/>.
            </summary>
            <typeparam name="T">An integer, fixed-point, rational or floating-point numeric type</typeparam>
            <remarks>
            List of operations and properties: From, CompareTo, Equals, IsLess, 
            IsLessOrEqual, Abs, Min, Max, MinValue, MaxValue, Epsilon, PositiveInfinity,
            NegativeInfinity, IsSigned, Increment, Decrement, NextHigher, NextLower, 
            Add, Subtract, Zero, One, Multiply, Divide, Shl (Shift left), Shr (shift right), 
            Sqrt, Square.
            <para/>
            Also available as extension methods: IsGreater, IsGreaterOrEqual
            <para/>
            It is commonly thought that integer types do not support square root. 
            Obviously, the accuracy of Sqrt on integers is limited, but Sqrt(uint) and 
            Sqrt(ulong) are still provided in Loyc.Essentials.
            </remarks>
        </member>
        <member name="T:Loyc.Math.ISignedMath`1">
            <summary>
            Provides operations available on all signed numeric types (int, double,
            etc.); see also <see cref="T:Loyc.Math.IUIntMath`1"/>, <see cref="T:Loyc.Math.IIntMath`1"/> and 
            <see cref="T:Loyc.Math.IFloatMath`1"/>.</summary>
        </member>
        <member name="T:Loyc.Math.IUIntMath`1">
            <summary>
            Provides operations available on all unsigned integer types (byte, uint,
            etc.); see also <see cref="T:Loyc.Math.IMath`1"/>, <see cref="T:Loyc.Math.IIntMath`1"/>, and
            <see cref="T:Loyc.Math.IFloatMath`1"/>.</summary>
        </member>
        <member name="T:Loyc.Math.IIntMath`1">
            <summary>
            Provides operations available on all unsigned integer types (byte, uint,
            etc.); see also <see cref="T:Loyc.Math.IMath`1"/>, <see cref="T:Loyc.Math.IIntMath`1"/>, and
            <see cref="T:Loyc.Math.IFloatMath`1"/>.</summary>
        </member>
        <member name="T:Loyc.Math.IRationalMath`1">
            <summary>
            Use this interface for floating-point, fixed-point, and rational types.
            Rational types support reciprocal and negation.
            </summary>
        </member>
        <member name="T:Loyc.Math.IFloatMath`1">
            <summary>Provides operations available on floating-point types 
            (float and double), including trigonometry and exponentiation.
            </summary>
            <typeparam name="T">A floating-point type</typeparam>
            <remarks>Algorithms that support both floating and fixed-point should 
            require <see cref="T:Loyc.Math.IRationalMath`1"/> instead.</remarks>
        </member>
        <member name="T:Loyc.Math.IComplexMath`1">
            <summary>
            Use this interface for types such as complex numbers that satisfy 
            the field axioms but do not have a natural order.
            complex numbers of course do support IHasRoot.
            </summary>
        </member>
        <member name="T:Loyc.Geometry.IPointReader`1">
            <summary>Interface for reading the coordinates of a 2D point.</summary>
            <typeparam name="T">Coordinate type.</typeparam>
        </member>
        <member name="T:Loyc.Geometry.IPointBase`1">
            <summary>This interface exists to work around a limitation of C#; use 
            <see cref="T:Loyc.Geometry.IPoint`1"/> instead.</summary>
            <remarks>
            C# cannot combine a getter property and a setter property from two 
            interfaces, so this interface cannot inherit its getters from <see 
            cref="T:Loyc.Geometry.IPointReader`1"/>. The workaround is to define another getter in 
            the read-write interface for each getter in the read-only interface. As far 
            as the CLR is concerned, the two getters are unrelated, but you won't 
            notice that unless you need to explicitly implement this interface.
            </remarks>
        </member>
        <member name="P:Loyc.Geometry.IPointBase`1.X">
            <summary>Horizontal coordinate of a point or vector.</summary>
            <remarks>In geographic points, X represents the longitude.</remarks>
        </member>
        <member name="P:Loyc.Geometry.IPointBase`1.Y">
            <summary>Vertical coordinate of a point or vector.</summary>
            <remarks>
            In 3D spaces, Y is sometimes used as a depth coordinate instead.
            In geographic points, Y represents the latitude.
            </remarks>
        </member>
        <member name="T:Loyc.Geometry.IPoint`1">
            <summary>A mutable 2D point with X and Y coordinates.</summary>
            <remarks>
            WARNING: When casting a point (or vector) structure to this interface, 
            it is boxed, making a copy. Changes made through a reference to IPoint do 
            not affect the original point!
            <para/>
            It is important to distinguish between generic code that operates on points
            (e.g. Foo&lt;Point,T>(Point x) where Point:IPoint&lt;T>) and code that uses 
            the IPoint interface directly (e.g. Foo(IPoint&lt;int>) or even 
            Foo&lt;T>(IPoint&lt;T> x)). The latter uses slow, late-bound interface 
            calls and the boxing-copy issue mentioned before must be kept in mind.
            Generic code that uses IPoint as a <i>constraint</i>, not as a <i>parameter 
            type,</i> is faster and does not have the same problem because it does not 
            actually box the point, nor does it use late-bound invocation.
            <para/>
            Normally this interface is not used directly, and the only operation
            provided is New(). It is provided in case you want it, but generally
            it's better to use <see cref="!:Point&lt;T&gt;"/>.
            <para/>
            In order for this interface to work more easily in generic code, there is 
            no corresponding IVector type for vectors because generic code must declare 
            every type it needs as a separate type parameter, which makes the code very 
            cumbersome to write already, even without a point/vector distinction.
            <para/>
            The New() method is not normally used in generic code because it returns 
            IPoint&lt;T>, not the original point type. It is provided mainly in case 
            somebody wants to use the raw interface to manipulate points.
            <para/>
            Due to a limitation of C#, the X and Y coordinates are separated into a 
            separate interface (<see cref="T:Loyc.Geometry.IPointBase`1"/>) from the New() method in
            <see cref="T:Loyc.Geometry.INewPoint`2"/>. Without this separation, it's impossible 
            to write fast generic code that can operate on both IPoint itself and on 
            concrete types such as <see cref="!:Point&lt;T&gt;"/>. The reason for this is very 
            subtle. To understand it, consider the following generic method that adds 
            two points together:
            <para/>
            <code>
            public static Point Add&lt;Point,T,M>(this M m, Point a, Point b)
            	where Point : IPoint&lt;T>
            	where M : IAdditionGroup&lt;T>
            {
            	return a.New(m.Add(a.X, b.X), m.Add(a.Y, b.Y));
            }
            </code>
            As written, this code does not compile. The reason is that a.New() does not 
            return a Point; instead, it returns <see cref="T:Loyc.Geometry.IPoint`1"/>, which is a more 
            general (interface) type than Point (which is probably a struct). Therefore, 
            in order for the code above to work, a cast from IPoint to Point would be 
            necessary. However, the boxing performed by new() and the unboxing performed 
            by the cast will slow down the method. My goal, however, is to allow generic
            code to run fast; otherwise it's hard to justify the extra effort required 
            to make the code generic. After all, the code to add non-generic points is
            trivial in comparison:
            <code>
            public static PointD Add(PointD a, PointD b) { return a + b; }
            </code>
            You might think to yourself, "okay, why don't we just add a new() 
            constraint on Point?" In that case the Add() method can be written as 
            follows:
            <code>
            public static Point Add&lt;Point,T,M>(this M m, Point a, Point b)
            	where Point : IPoint&lt;T>, new()
            	where M : IAdditionGroup&lt;T>
            {
            	Point p = new Point();
            	p.X = m.Add(a.X, b.X);
            	p.Y = m.Add(a.Y, b.Y);
            	return p;
            }
            </code>
            This works if the input is a concrete point type, but this version of the 
            method cannot be used if Point happens to be <see cref="T:Loyc.Geometry.IPoint`1"/> itself;
            you cannot do "new IPoint" because it is an interface. To solve this I 
            considered splitting out New() into a separate interface and using it as a 
            constraint of the generic method:
            <code>
            public static Point Add&lt;Point,T,M>(this M m, Point a, Point b)
            	where Point : IPoint&lt;T>, INewPoint&lt;Point, T>
            	where M : IAdditionGroup&lt;T>
            {
            	return a.New(m.Add(a.X, b.X), m.Add(a.Y, b.Y));
            }
            </code>
            This code compiles under one condition: IPoint must <i>not</i> be derived 
            from INewPoint&lt;IPoint&lt;T>,T>. Because if it is, then the call to New()
            is ambiguous: does a.New() refer to INewPoint&lt;IPoint&lt;T>,T>.New() or 
            to INewPoint&lt;Point,T>.New()? Remember, IPoint is not the same as Point 
            from the compiler's perspective--IPoint is an interface, but Point is 
            typically a struct (it could be the same as IPoint, but in general, it is 
            not). The compiler doesn't know which version of New() to call, so it 
            refuses to compile the code. It will compile if we change the method body 
            to 
            <code>
            	return ((INewPoint&lt;Point,T>)a).New(m.Add(a.X, b.X), m.Add(a.Y, b.Y));
            </code>
            The cast resolves the ambiguity, but as a side-effect, 'a' is boxed and 
            the call to New() becomes a virtual call that cannot be inlined. So the 
            same performance penalty is back!
            <para/>
            But as I was saying, the original code does compile if IPoint is <i>not</i>
            derived from INewPoint. Unfortunately, if IPoint is not derived from 
            INewPoint then it is impossible to pass a reference to IPoint to this 
            method (because it no longer meets the constraints). Remember, that is 
            the limitation I am trying to avoid!
            <para/>
            One more "solution" is not to create any new points:
            <code>
            public static Point Add&lt;Point,T,M>(this M m, Point a, Point b)
            	where Point : IPoint&lt;T>
            	where M : IAdditionGroup&lt;T>
            {
            	a.X = m.Add(a.X, b.X);
            	a.Y = m.Add(a.Y, b.Y);
            	return a;
            }
            </code>
            Alas, this version of the code modifies the point 'a' if Point is IPoint, 
            but it does not modify 'a' if Point is a struct, because structs are passed 
            by value. This inconsistency is not acceptable, and besides, there are
            (of course) situations where creating new points is required.
            <para/>
            The problem is that if there is only one New() method defined (in the 
            point structures such as PointI and PointD) then it's impossible to pass
            references to IPoint to Add(); however, if there are two New() methods (one 
            in the point struct and one in IPoint), it is impossible to tell the C# 
            compiler which method we want to call without slowing down the code as a 
            side-effect. My solution to this very peculiar problem is to split IPoint
            into two independent interfaces, IPointBase and INewPoint. This separation
            allows us to tell the C# compiler that Point implements only one of the 
            New() methods, not both:
            <code>
            public static Point Add&lt;Point,T,M>(this M m, Point a, Point b)
                where Point : IPointBase&lt;T>, INewPoint&lt;Point, T>
                where M : IAdditionGroup&lt;T>
            {
                return a.New(m.Add(a.X, b.X), m.Add(a.Y, b.Y));
            }
            </code>
            IPointBase, unlike IPoint, does not have a New() method, so only the 
            New() method in INewPoint&lt;Point, T> is available to be called, and the 
            C# compiler stops complaining. Also, since IPoint&lt;T> implements both 
            IPointBase&lt;T> and INewPoint&lt;IPoint&lt;T>, T>, it meets the generic
            constraints of this method and can be passed to it.
            <para/>
            Note that you don't have to write methods like Add() yourself (they are 
            provided as extension methods on IPoint.) Still, if you've read this far,
            you're probably now afraid of the effort required to write generic code! 
            Your fear may be justified. But there is another, easier way that you can 
            write generic code, based on <see cref="!:Point&lt;T&gt;"/> instead of IPoint:
            <code>
            public static Point&lt;T> Add&lt;T>(Point&lt;T> a, Point&lt;T> b)
            {
            	return a+b;
            }
            </code>
            A lot easier without all those constraints, yes? The main disadvantage of 
            this version is that it doesn't have great performance, because the 
            additions are done through interface calls. A second disadvantage is that 
            you can't pass an IPoint to it. That's okay because as stated before, 
            normally the IPoint interface is not used directly!
            <para/>
            Code that uses Point&lt;T,M> can run faster:
            <code>
            public static Point&lt;T,M> Add&lt;T,M>(Point&lt;T,M> a, Point&lt;T,M> b)
            {
            	return a+b;
            }
            </code>
            So, in summary, supporting fast generic code that can also operate on IPoint
            requires this odd arrangement of interfaces, and if you want to write such
            generic code then you will need three type parameters (Point, T and M) with
            the following constraints:
            <code>
                where Point : IPointBase&lt;T>, INewPoint&lt;Point, T>
                where M : IMath&lt;T> // or another math interface
            </code>
            It may help to place your methods in a generic class (of Point, T and M) so 
            that you only have to write the constraints once.
            </remarks>
        </member>
        <member name="T:Loyc.Geometry.INewPoint`2">
            <summary>This interface exists to work around a limitation of C#; see
            <see cref="T:Loyc.Geometry.IPoint`1"/>.</summary>
        </member>
        <member name="T:Loyc.Geometry.IPoint3Reader`1">
            <summary>Interface for reading the coordinates of a 3D point.</summary>
            <typeparam name="T">Coordinate type.</typeparam>
        </member>
        <member name="T:Loyc.Geometry.IPoint3Base`1">
            <summary>This interface exists to work around a limitation of C#; use 
            <see cref="T:Loyc.Geometry.IPoint`1"/> instead.</summary>
            <remarks>
            C# cannot combine a getter property and a setter property from two 
            interfaces, so this interface cannot inherit its getters from <see 
            cref="T:Loyc.Geometry.IPoint3Reader`1"/>. The workaround is to define another getter in 
            the read-write interface for each getter in the read-only interface. As far 
            as the CLR is concerned, the two getters are unrelated, but you won't 
            notice that unless you need to explicitly implement this interface.
            </remarks>
        </member>
        <member name="P:Loyc.Geometry.IPoint3Base`1.Z">
            <summary>Z coordinate of a point or vector.</summary>
            <remarks>
            Z typically represents either the vertical or depth component of a 
            point or vector.
            </remarks>
        </member>
        <member name="T:Loyc.Geometry.IPoint3`1">
            <summary>A mutable 3D point with X, Y, and Z coordinates.</summary>
            <remarks>
            WARNING: When casting a point (or vector) structure to this interface, 
            it is boxed, making a copy. Changes made through a reference to IPoint3 do 
            not affect the original point!
            <para/>
            The coordinates of an IPoint3 are separated into a base interface, 
            <see cref="T:Loyc.Geometry.IPoint3Base`1"/>, for the same reason that <see cref="T:Loyc.Geometry.IPoint`1"/>'s
            coordinates are separated into <see cref="T:Loyc.Geometry.IPointBase`1"/>, as explained in 
            the documentation of <see cref="T:Loyc.Geometry.IPoint`1"/>. 
            </remarks>
        </member>
        <member name="T:Loyc.Geometry.INewPoint3`2">
            <summary>This interface exists to work around a limitation of C#; see
            <see cref="T:Loyc.Geometry.IPoint`1"/> and <see cref="T:Loyc.Geometry.IPoint3`1"/>.</summary>
        </member>
        <member name="T:Loyc.Geometry.ISizeReader`1">
            <summary>Interface for reading the size of a 2D object.</summary>
            <typeparam name="T">Coordinate type.</typeparam>
        </member>
        <member name="P:Loyc.Geometry.ISizeReader`1.Width">
            <summary>Gets the width of a rectangle (the difference between X coordinates).</summary>
        </member>
        <member name="P:Loyc.Geometry.ISizeReader`1.Height">
            <summary>Gets the height of a rectangle (the difference between Y coordinates).</summary>
        </member>
        <member name="T:Loyc.Geometry.IRectangleReader`1">
            <summary>Represents a read-only 2D rectangle.</summary>
            <remarks>
            The relationship between X1, X2 and Width, and the relationship between 
            Y1, Y2 and Height, depends on whether the object represents a normal 
            (traditional Windows) rectangle, a bounding rectangle, or a pair of 
            points. A traditional rectangle defines its Height as Y2 - Y1, and its
            Width as X2 - X1. A bounding rectangle is defined slightly differently:
            the Width is X2 - X1 + e, and the Height is Y2 - Y1 + e, where e is an
            infitessimal value of type T (e=1 if T is an integer type).
            <para/>
            Also, a traditional rectangle is stored as a starting point (X1, Y1)
            and a size (Width, Height), while a bounding rectangle stores X2 and Y2 
            instead, not the Width and Height.
            <para/>
            Finally, this interface could simply represent a pair of points. In 
            that case, Width and Height return the absolute value of X2-X1 and 
            Y2-Y1 respectively.
            <para/>
            A rectangle may or may not require X2 >= X1 and Y2 >= Y1. If X1>X2 or
            Y1>Y2, the rectangle is said to be "not normalized" and the 
            <see cref="!:RectangleExt.IsNormal&lt;Rect, T&gt;(Rect)"/> extension method 
            returns false.
            </remarks>
        </member>
        <member name="T:Loyc.Geometry.IRectangleBase`1">
            <summary>Represents a mutable 2D rectangle.</summary>
            <typeparam name="T">Type of each coordinate.</typeparam>
            <remarks>
            This interface can represent one of three types of rectangles: either 
            "normal" rectangles with fundamental variables X, Y, Width, Height, 
            bounding rectangles with two coordinate ranges (X1-X2) and (Y1-Y2), or
            or pairs of points (X1, Y1) and (X2, Y2).
            <para/>
            Because of this fact, it is not clear when you modify X1 whether this
            should affect X2 or Width. Similarly, when you modify X2, Y1 or Y2, it
            is not clear whether the size property or the opposite boundary should 
            change. To resolve this question, this interface does not allow you to
            modify the coordinates individually; instead you must change them in 
            pairs: you either set X and Width together, or X1 and X2 together; and
            similarly Y and Height together, or Y1 and Y2 together.
            <para/>
            You can also call the extension methods SetRect() or SetRange() to set
            all four coordinates at once.
            </remarks>
            <seealso cref="T:Loyc.Geometry.IRectangle`1"/>
            <seealso cref="!:BoundingBox&lt;T&gt;"/>
        </member>
        <member name="T:Loyc.Geometry.INewRectangle`2">
            <summary>This interface exists to work around a limitation of C#; see
            <see cref="T:Loyc.Geometry.IRectangle`1"/>.</summary>
        </member>
        <member name="T:Loyc.Geometry.IRectangle`1">
            <summary>Represents a mutable 2D rectangle.</summary>
            <remarks>
            This interface is separated into two bases, 
            <see cref="T:Loyc.Geometry.IRectangleBase`1"/> and <see cref="T:Loyc.Geometry.INewRectangle`2"/>, 
            for the same reason that <see cref="T:Loyc.Geometry.IPoint`1"/>'s coordinates are 
            divided into <see cref="T:Loyc.Geometry.IPointBase`1"/> and <see cref="T:Loyc.Geometry.INewPoint`2"/>,
            as explained in the documentation of <see cref="T:Loyc.Geometry.IPoint`1"/>. 
            </remarks>
        </member>
        <member name="T:Loyc.Geometry.ISize3Reader`1">
            <summary>Interface for reading the size of a 3D object.</summary>
            <typeparam name="T">Coordinate type.</typeparam>
        </member>
        <member name="P:Loyc.Geometry.ISize3Reader`1.Depth">
            <summary>Gets the depth of a rectangle (the difference between Z coordinates).</summary>
        </member>
        <member name="T:Loyc.Geometry.IRectangle3Reader`1">
            <summary>Represents a read-only 3D rectangular prism.</summary>
            <remarks>
            The relationship between Z1, Z2 and Depth, as well as between the 
            other coodinates and Width/Height, depends on whether the object represents 
            a starting point plus a size, or a bounding rectangle or a pair of 
            points. Either the object stores a starting point (X1, Y1, Z1) and
            a size (Width, Height, Depth), or it stores a starting point and an
            ending point (X2, Y2, Z2).
            <para/>
            Conventionally, when using the size representation, the Width is 
            defined as X2 - X1, the Height as Y2 - Y1, and the Depth as Z2 - Z1.
            A bounding rectangle is defined slightly differently: the Width is 
            X2 - X1 + e, the Height is Y2 - Y1 + e, and the Depth is Z2 - Z1 + e,
            where e is an infitessimal value of type T (e=1 if T is an integer 
            type).
            <para/>
            Finally, this interface could simply represent a pair of points. In 
            that case, Width and Height return the absolute value of X2-X1 and 
            Y2-Y1 respectively.
            <para/>
            The object may or may not require X2 >= X1 and Y2 >= Y1 and Z2 >= Z1.
            If X1>X2 or Y1>Y2 or Z1>Z2, the rectangle is said to be "not 
            normalized" and the <see cref="!:Rectangle3Ext.IsNormal&lt;Rect,T&gt;(Rect)"/> extension 
            method returns false.
            </remarks>
        </member>
        <member name="T:Loyc.Geometry.IRectangle3Base`1">
            <summary>Represents a mutable 3D rectangular prism.</summary>
            <typeparam name="T">Type of each coordinate.</typeparam>
            <remarks>
            This interface can represent one of three types of rectangles: either 
            "normal" rectangles with fundamental variables X, Y, Z, Width, Height, 
            Depth, bounding rectangles with two coordinate ranges (X1-X2), (Y1-Y2),
            and (Z1-Z2), or pairs of points (X1, Y1, Z1) and (X2, Y2, Z2).
            <para/>
            Because of this fact, it is not clear when if modify X1 whether this
            should affect X2 or Width. Similarly for Y1, Z1, X2, Y2 and Z2:
            should the size property or the opposite boundary change?. To resolve 
            this question, this interface does not allow you to modify the 
            coordinates individually; instead you must change them in pairs: you 
            either set X and Width together, or X1 and X2 together; and similarly
            for Y1/Y2/Height and Z1/Z2/Depth.
            <para/>
            You can also call the extension methods SetRect() or SetRange() to set
            all six coordinates at once.
            </remarks>
            <seealso cref="T:Loyc.Geometry.IRectangle3`1"/>
        </member>
        <member name="T:Loyc.Geometry.INewRectangle3`2">
            <summary>This interface exists to work around a limitation of C#; see
            <see cref="T:Loyc.Geometry.IRectangle3`1"/>.</summary>
        </member>
        <member name="T:Loyc.Geometry.IRectangle3`1">
            <summary>Represents a mutable 3D rectangle.</summary>
            <remarks>
            This interface is separated into two bases, 
            <see cref="T:Loyc.Geometry.IRectangle3Base`1"/> and <see cref="T:Loyc.Geometry.INewRectangle3`2"/>, 
            for the same reason that <see cref="T:Loyc.Geometry.IPoint`1"/>'s coordinates are 
            divided into <see cref="T:Loyc.Geometry.IPointBase`1"/> and <see cref="T:Loyc.Geometry.INewPoint`2"/>,
            as explained in the documentation of <see cref="T:Loyc.Geometry.IPoint`1"/>. 
            </remarks>
        </member>
        <member name="T:Loyc.IMessageSink`1">
            <summary>A general-purpose interface for a class that accepts formatted 
            messages with context information.</summary>
            <remarks>
            Helpful article: http://core.loyc.net/essentials/messagesink.html 
            <para/>
            IMessageSink is used for dependency injection of a target for formatted 
            messages; it could be used for log messages, compiler error messages, or
            to report the progress of a process, for instance. Frequently-used 
            message sinks include <see cref="!:ConsoleMessageSink.Value"/>, 
            <see cref="!:TraceMessageSink.Value"/>, and <see cref="!:MessageHolder"/>.
            <para/>
            It is typical to use <see cref="T:Loyc.IMessageSink"/> without type parameters.
            <para/>
            Since .NET does not allow static members in an interface, the static
            members can be found in <see cref="!:MessageSink"/>.
            <para/>
            Each message has a <see cref="T:Loyc.Severity"/>. For message sinks that are used 
            as loggers, this should be one of the following logging levels, listed
            in order of importance: Fatal, Error, Warning, Note, Debug, Verbose.
            <para/>
            For message sinks that are used for compiler messages, the standard
            levels are: Fatal, Error, Warning, Note, Detail. "Detail" provides more 
            information about a previously-printed message, while "Note" is intended 
            for independent messages that are less severe than warnings (e.g. lints).
            Some compilers may distiguish "soft" errors (which do not prevent the
            program from starting) from "critical" errors (which do). In that case, 
            Error may represent such a "soft" error and Critical may represent a
            "hard" error. Fatal, in contrast, represents an error that causes the
            compiler to halt immediately.
            <para/>
            If the message sink may produce messages that users will see, the message 
            sink itself should perform localization using <see 
            cref="M:Loyc.Localize.Localized(System.String,System.Object[])"/>.
            <para/>
            Only a single Write() method is truly needed (<see cref="M:Loyc.IMessageSink`1.Write(Loyc.Severity,`0,System.String,System.Object[])"/>),
            but for efficiency reasons the interface contains two other writers. It 
            is expected to be fairly common that a message sink will drop some or
            all messages without printing them, e.g. if a message sink is used for 
            logging, verbose messages might be "off" by default. It would be 
            wasteful to actually localize and format a message if the message will
            not actually be printed, and it would also be wasteful to create an array 
            of objects to hold the arguments if they are just going to be discarded.
            With that in mind, since most formatting requests only need a couple of 
            arguments, there is an overload of Write() that accepts up to two
            arguments without the need to package them into an array, and there is
            an overload that takes no formatting arguments (this indicates that 
            parameter substitution is not required and should not be attempted.)
            <para/>
            In addition, the caller can call <see cref="M:Loyc.IMessageSink`1.IsEnabled(Loyc.Severity)"/> to avoid 
            doing any work required to prepare a message for printing when a certain
            category of output is disabled.
            </remarks>
            <typeparam name="TContext">The type of the second parameer to <c>Write</c>, 
            which indicates where the error occurs. If the message relates to a text
            file or source code, the location is typically indicated with an object of
            type <see cref="T:Loyc.Syntax.ISourceRange"/> or <see cref="T:Loyc.Syntax.ILNode"/>.</typeparam>
            <seealso cref="!:MessageSink"/>
            <seealso cref="!:ConsoleMessageSink"/>
            <seealso cref="!:TraceMessageSink"/>
            <seealso cref="!:NullMessageSink"/>
            <seealso cref="!:MessageFilter"/>
            <seealso cref="!:MessageHolder"/>
            <seealso cref="!:MessageMulticaster"/>
            <seealso cref="T:Loyc.IHasLocation"/>
        </member>
        <member name="M:Loyc.IMessageSink`1.Write(Loyc.Severity,`0,System.String)">
            <summary>Writes a message to the target that this object represents.</summary>
            <param name="level">Severity or importance of the message; widely-used
            types include Error, Warning, Note, Debug, and Verbose. The special 
            type Detail is intended to provide more information about a previous 
            message.</param>
            <param name="context">An object that the message is related to, or that 
            represents the location that the message applies to. The message sink
            may try to convert this object to a string and include it in its output.
            See also <see cref="!:MessageSink.ContextToString"/>().</param>
            <param name="format">A message to display. If there are additional 
            arguments, placeholders such as {0} and {1} refer to these arguments.</param>
        </member>
        <member name="M:Loyc.IMessageSink`1.IsEnabled(Loyc.Severity)">
            <summary>Returns true if messages of the specified type will actually be 
            printed, or false if Write(type, ...) has no effect.</summary>
        </member>
        <member name="T:Loyc.IMessageSink">
            <summary>Alias for IMessageSink&lt;object>.</summary>
            <seealso cref="T:Loyc.IMessageSink`1"/>
        </member>
        <member name="T:Loyc.Severity">
            <summary>A linear scale to categorize the importance and seriousness of 
            messages sent to <see cref="T:Loyc.IMessageSink"/>.</summary>
            <remarks>
            The numbers are Fatal=110, Critical=90, Error=70, Warning=60, Note=50, 
            Debug=30, Verbose=10 and Detail=0. The severity numbers are based on 
            those defined in log4net, divided by 1000, e.g. Warning=60000 in log4net
            but 60 in this enum.
            <para/>
            Some of the enumeration values begin with an underscore. These are
            values defined by Log4net that are deprecated in LoycCore.
            <para/>
            The "Detail" severity levels are meant to contain extra information 
            associated with the most recent non-Detail message, e.g. stack traces 
            or extra diagnostic information for Errors.
            </remarks>
        </member>
        <member name="T:Loyc.ICloneable`1">
            <summary>Interface for types that can duplicate themselves.</summary>
            <typeparam name="T">Normally T is the type that implements this interface.</typeparam>
        </member>
        <member name="T:Loyc.ITags`1">
            <summary>Interface for an object that can have "tags" attached, which are 
            arbitrary objects reached through a key <see cref="T:Loyc.Symbol"/>.</summary>
        </member>
        <member name="P:Loyc.ITags`1.Tags">
            <summary>Returns a dictionary that can be used to store additional state
            beyond the standard content of the object.
            </summary><remarks>
            Is is possible that Tags==this to reduce overhead.
            </remarks>
        </member>
        <member name="T:Loyc.IReferenceEquatable">
            <summary>This is a tag which indicates that objects of this type are 
            unique; specifically, any two different objects that implement this 
            interface are always unequal, and one object is equal only to itself.</summary>
            <remarks>
            This interface is recognized by <see cref="!:Loyc.Collections.MSet&lt;T&gt;"/>, <see cref="!:Loyc.Collections.Set&lt;T&gt;"/>
            and <see cref="!:Loyc.Collections.InternalSet&lt;T&gt;"/>. It causes normal comparison (via
            <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to be skipped in favor of reference 
            comparison. <see cref="T:Loyc.Symbol"/> implements this interface.
            </remarks>
        </member>
        <member name="T:Loyc.IHasValue`1">
            <summary>Interface for things that have a Value property.</summary>
        </member>
        <member name="T:Loyc.IHasMutableValue`1">
            <summary>Interface for things that have a mutable Value property.</summary>
        </member>
        <member name="T:Loyc.IEither`2">
            <summary>Represents a type that holds a single value of one of two types (L or R).</summary>
        </member>
        <member name="T:Loyc.Symbol">
            <summary>Represents a symbol, which is a singleton string that supports fast 
            comparisons and extensible enums.</summary>
            <remarks>
            Call GSymbol.Get() to create a Symbol from a string, or GSymbol.GetIfExists()
            to find a Symbol that has already been created.
            <para/>
            Symbols can be used like a global, extensible enumeration. Comparing symbols
            is as fast as comparing two integers; this is because '==' is not
            overloaded--equality is defined as reference equality, as there is only one
            instance of a given Symbol.
            <para/>
            Symbols can also be produced in namespaces called "pools". Two Symbols with
            the same name, but in different pools, are considered to be different
            symbols. Using a derived class D of Symbol and a SymbolPool&lt;D&gt;,
            you can make Symbols that are as type-safe as enums.
            <para/>
            A Symbol's ToString() function formerly returned the symbol name prefixed 
            with a colon (:), following the convention of the Ruby language, from which 
            I got the idea of Symbols in the first place. However, since Symbols are 
            commonly used for extensible enums, I decided it was better that ToString()
            return just the Name alone, which makes Symbol more suitable as a drop-in 
            replacement for enums.
            <para/>
            Symbols are also useful in compilers and Loyc trees, where there may be a 
            performance advantage in comparing identifiers by reference rather than
            character-by-character.
            </remarks>
        </member>
        <member name="P:Loyc.Symbol.Name">
            <summary>Gets the name of the Symbol.</summary>
        </member>
        <member name="P:Loyc.Symbol.Pool">
            <summary>Gets the <see cref="T:Loyc.SymbolPool"/> in which this Symbol was created.</summary>
        </member>
        <member name="P:Loyc.Symbol.IsGlobal">
            <summary>Returns true if this symbol is in the global pool (<see cref="F:Loyc.GSymbol.Pool"/>).</summary>
        </member>
        <member name="P:Loyc.Symbol.Id">
            <summary>Returns a numeric ID for the Symbol.</summary>
            <remarks>Normally the Id is auto-assigned and the Id corresponding to 
            a particular Name may vary between different runs of the same program. 
            However, <see cref="!:SymbolPool.Get(string, int)"/> can be used to 
            assign a specific Id to a Name when setting up a new pool.</remarks>
        </member>
        <member name="M:Loyc.Symbol.#ctor(System.Int32,System.String,Loyc.SymbolPool)">
            <summary>For internal use only. Call GSymbol.Get() instead!</summary>
        </member>
        <member name="M:Loyc.Symbol.#ctor(Loyc.Symbol)">
            <summary>For use by a derived class to produce a statically-typed 
            enumeration in a private pool. See the example under SymbolPool 
            (of SymbolEnum)</summary>
            <param name="prototype">A strictly temporary Symbol that is used
            to initialize this object. The derived class should discard the
            prototype after calling this constructor.</param>
        </member>
        <member name="M:Loyc.Symbol.For(System.String)">
            <summary>Alias for <see cref="!:GSymbol.Get(string)"/>. This function was 
            introduced to match the equivalent ES6 API <c>Symbol.for("string")</c></summary>
        </member>
        <member name="T:Loyc.GSymbol">
            <summary>This class produces global symbols.</summary>
            <remarks>
            Call GSymbol.Get() to create a Symbol from a string, or GSymbol.GetIfExists()
            to find a Symbol that has already been created.
            <para/>
            Symbols in the global pool are weak-referenced to allow garbage collection.
            </remarks>
        </member>
        <member name="T:Loyc.SymbolPool">
            <summary>A collection of <see cref="T:Loyc.Symbol"/>s.</summary>
            <remarks>
            There is one global symbol pool (<c>GSymbol.Pool</c>) and you can create an 
            unlimited number of private pools, each with an independent namespace.
            <para/>
            Methods of this class are synchronized, so a SymbolPool can be used from
            multiple threads.
            <para/>
            By default, SymbolPool uses weak references to refer to Symbols, so they 
            can be garbage-collected when no longer in use. When creating a private 
            pool you can tell the SymbolPool constructor to use strong references 
            instead, which ensures that none of the symbols disappear, but risks a 
            memory leak if the pool itself is never garbage-collected. Strong 
            references also require less memory and may be slightly faster.
            <para/>
            By default, all Symbol are given non-negative IDs. GSymbol.Empty (whose 
            Name is "") has an Id of 0, but in a private pool, "" is not treated 
            differently than any other symbol so a new ID will be allocated for it.
            </remarks>
        </member>
        <member name="M:Loyc.SymbolPool.new(System.Int32,System.Boolean,System.Int32)">
            <summary>Initializes a new Symbol pool.</summary>
            <param name="firstID">The first Symbol created in the pool will have 
            the specified ID number, and IDs will proceed downward from there.</param>
            <param name="useStrongRefs">True to use strong references to the 
            Symbols in the pool, false to use WeakReferences that allow garbage-
            collection of individual Symbols.</param>
            <param name="poolId">Numeric ID of the pool (affects the HashCode of 
            Symbols from the pool)</param>
        </member>
        <member name="M:Loyc.SymbolPool.Get(Loyc.UString)">
            <summary>Gets a symbol from this pool, or creates it if it does not 
            exist in this pool already.</summary>
            <param name="name">Name to find or create.</param>
            <returns>A symbol with the requested name, or null if the name was null.</returns>
            <remarks>
            If Get("foo") is called in two different pools, two Symbols will be 
            created, each with the Name "foo" but not necessarily with the same 
            IDs. Note that two private pools re-use the same IDs, but this 
            generally doesn't matter, as Symbols are compared by reference, not by 
            ID.
            </remarks>
        </member>
        <member name="P:Loyc.SymbolPool.Item(Loyc.UString)">
            <inheritdoc cref="!:Get(string)"/>
        </member>
        <member name="M:Loyc.SymbolPool.Get(Loyc.UString,System.Int32)">
            <summary>Creates a Symbol in this pool with a specific ID, or verifies 
            that the requested Name-Id pair is present in the pool.</summary>
            <param name="name">Name to find or create.</param>
            <param name="id">Id that must be associated with that name.</param>
            <exception cref="T:System.ArgumentNullException">name was null.</exception>
            <exception cref="T:System.ArgumentException">The specified Name or Id is already 
            in use, but the Name and Id do not match. For example, Get("a", 1) throws 
            this exception if a Symbol with Id==1 is not named "a", or a Symbol with
            Name=="a" does not have Id==1.</exception>
            <returns>A symbol with the requested Name and Id.</returns>
        </member>
        <member name="M:Loyc.SymbolPool.Get(Loyc.UString,Loyc.Symbol@)">
            <summary>Workaround for lack of covariant return types in C#</summary>
        </member>
        <member name="M:Loyc.SymbolPool.Get(Loyc.UString,System.Int32,Loyc.Symbol@)">
            <summary>Workaround for lack of covariant return types in C#</summary>
        </member>
        <member name="M:Loyc.SymbolPool.NewSymbol(System.Int32,System.String)">
            <summary>Factory method to create a new Symbol.</summary>
        </member>
        <member name="M:Loyc.SymbolPool.GetIfExists(Loyc.UString)">
            <summary>Gets a symbol from this pool, if the name exists already.</summary>
            <param name="name">Symbol Name to find</param>
            <returns>Returns the existing Symbol if found; returns null if the name 
            was not found, or if the name itself was null.</returns>
        </member>
        <member name="M:Loyc.SymbolPool.GetGlobalOrCreateHere(System.String)">
            <summary>Gets a symbol from the global pool, if it exists there already;
            otherwise, creates a Symbol in this pool.</summary>
            <param name="name">Name of a symbol to get or create</param>
            <returns>A symbol with the requested name</returns>
        </member>
        <member name="M:Loyc.SymbolPool.GetById(System.Int32)">
            <summary>Gets a symbol by its ID, or null if there is no such symbol.</summary>
            <param name="id">ID of a symbol. If this is a private pool and the 
            ID does not exist in the pool, the global pool is searched instead.
            </param>
            <remarks>
            GetById() uses a dictionary of ID numbers to Symbols for fast lookup.
            To save time and memory, this dictionary is not created until either 
            GetById() or Get(string name, int id) is called.
            </remarks>
            <returns>The requested Symbol, or null if not found.</returns>
        </member>
        <member name="P:Loyc.SymbolPool.TotalCount">
            <summary>Returns the number of Symbols created in this pool.</summary>
        </member>
        <member name="T:Loyc.SymbolPool`1">
             <summary>This type of SymbolPool helps create more strongly typed Symbols
             that simulate enums, but provide extensibility. Specifically, it 
             creates SymbolE objects, where SymbolE is some derived class of Symbol.
             </summary>
             <typeparam name="SymbolE">
             A derived class of Symbol that owns the pool. See the example below.
             </typeparam>
             <example>
             public class ShapeType : Symbol
             {
                 private ShapeType(Symbol prototype) : base(prototype) { }
                 public static new readonly SymbolPool&lt;ShapeType> Pool 
                                      = new SymbolPool&lt;ShapeType>(p => new ShapeType(p));
            
                 public static readonly ShapeType Circle  = Pool.Get("Circle");
                 public static readonly ShapeType Rect    = Pool.Get("Rect");
                 public static readonly ShapeType Line    = Pool.Get("Line");
                 public static readonly ShapeType Polygon = Pool.Get("Polygon");
             }
             </example>
        </member>
    </members>
</doc>
