<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Loyc.Collections</name>
    </assembly>
    <members>
        <member name="T:Loyc.Collections.AList`1">
            <summary>
            An all-purpose list structure with the following additional features beyond 
            what's offered by <see cref="T:System.Collections.Generic.List`1"/>: fast insertion and deletion 
            (O(log N)), batch insertion and deletion, observability, fast cloning, 
            freezability, and fast splitting and joining of large collections.
            </summary>
            <typeparam name="T">Type of each element in the list</typeparam>
            <remarks>
            The name "A-List" is short for All-purpose List. It is so named because
            it has a very large amount of functionality and extension points for 
            further extending this functionality. Essentially, this data structure
            is jack-of-all-trades, master of none.
            <para/>
            Structurally, ALists (like BLists) are very similar to B+trees. They use
            memory almost as efficiently as arrays, and offer O(log N) insertion and
            deletion in exchange for a O(log N) indexer, which is distinctly slower 
            than the indexer of <see cref="T:System.Collections.Generic.List`1"/>. They use slightly more memory 
            than <see cref="T:System.Collections.Generic.List`1"/> for all list sizes.
            <para/>
            That said, you should use an AList whenever you know that the list might be 
            large and need insertions or deletions somewhere in the middle. If you 
            expect to do insertions and deletions at random locations, but only 
            occasionally, <see cref="T:Loyc.Collections.DList`1"/> is sometimes a better choice because 
            it has a faster indexer. Both classes provide fast enumeration (O(1) per 
            element), but <see cref="T:Loyc.Collections.DList`1"/> enumerators initialize faster.
            <para/>
            Although AList isn't the fastest or smallest data structure for any 
            single task, it is very useful when you need several different 
            capabilities, and there are certain tasks for which it excels; for 
            example, have you ever wanted to remove all items that meet certain 
            criteria from a list? You cannot accomplish this with a foreach loop 
            such as this:
            <para/>
            foreach (T item in list)
               if (MeetsCriteria(item))
                  list.Remove(item);
                  // Exception occurs! foreach loop cannot continue after Remove()!
            <para/>
            When you are using a <see cref="T:System.Collections.Generic.List`1"/>, you might try to solve this 
            problem with a reverse for-loop such as this:
            <para/>
            for (int i = list.Count - 1; i &gt;= 0; i--)
               if (MeetsCriteria(list[i]))
                  list.RemoveAt(i);
            <para/>
            This works, but it runs in O(N^2) time, so it's very slow if the list is 
            large. The easiest way to solve this problem that is also efficient is to 
            duplicate all the items that you want to keep in a new list:
            <para/>
            var list2 = new List&lt;T&gt;();
            foreach (T item in list)
               if (!MeetsCriteria(item))
                  list2.Add(item);
            list = list2;
            <para/>
            But what if you didn't think of that solution and already wrote the O(N^2)
            version? There's a lot of code out there already that relies on slow 
            <see cref="T:System.Collections.Generic.List`1"/> operations. An easy way to solve performance caused
            by poor use of <see cref="T:System.Collections.Generic.List`1"/> is simply to add "A" in front. AList
            is pretty much a drop-in replacement for List, so you can convert O(N^2) 
            into faster O(N log N) code simply by using an AList instead of a List.
            <para/>
            I like to think of AList as the ultimate novice data structure. Novices
            like indexed lists, although for many tasks they are not the most efficient
            choice. AList isn't optimized for any particular task, but it isn't 
            downright slow for any task except <see cref="!:IndexOf"/>, so it's very 
            friendly to novices that don't know about all the different types of data
            structures and how to choose one. Don't worry about it! Just pick AList.
            It's also a good choice when you're just too busy to think about 
            performance, such as in a scripting environment.
            <para/>
            Plus, you can subscribe to the <see cref="!:ListChanging"/> event to
            find out when the list changes. AList's observability is more lightweight 
            than that of <see cref="!:ObservableCollection&lt;T&gt;"/>.
            <para/>
            Although single insertions, deletions, and random access require O(log N)
            time, you can get better performance using any overload of 
            <see cref="M:Loyc.Collections.AList`1.InsertRange(System.Int32,Loyc.Collections.AList{`0})"/>, <see cref="!:RemoveRange"/>, <see cref="!:GetIterator"/> or <see cref="!:Resize"/>. These methods require only
            O(log N + M) time, where M is the number of elements you are inserting,
            removing or enumerating.
            <para/>
            AList is an excellent choice if you need to make occasional snapshots of
            the tree. Cloning is fast and memory-efficient, because none of the tree
            is copied at first. The root node is simply marked as frozen, and nodes 
            are duplicated on-demand as changes are made. Thus, AList can be used as a 
            so-called "persistent" data structure, but it is fairly expensive to clone 
            the tree after every modification. When modifying a tree that was just 
            cloned (remember, AList is really a tree), the leaf node being changed and 
            all of its ancestors must be duplicated. Therefore, it's better if you can 
            arrange to have a high ratio of changes to clones.
            <para/>
            AList is also freezable, which is useful if you need to construct a list 
            in a read-only or freezable data structure. You could also freeze the list
            in order to return a read-only copy of it, which, compared to cloning, has 
            the advantage that no memory allocation is required at the time you return 
            the list. If you need to edit the list later, you can clone the list (the 
            clone can be modified).
            <para/>
            As explained in the documentation of <see cref="T:Loyc.Collections.AListBase`1"/>, this class
            is NOT multithread-safe. Multiple concurrent readers are allowed, as long 
            as the collection is not modified, so frozen instances ARE multithread-safe.
            </remarks>
            <seealso cref="T:Loyc.Collections.BList`1"/>
            <seealso cref="!:BTree&lt;T&gt;"/>
            <seealso cref="T:Loyc.Collections.DList`1"/>
        </member>
        <member name="T:Loyc.Collections.AListBase`1">
            <summary>
            Common base class of <see cref="T:Loyc.Collections.AList`1"/> and <see cref="T:Loyc.Collections.SparseAList`1"/>.
            Most of the functionality of the two types is identical, so this class is 
            used to share code between them.
            </summary>
            <remarks>
            This class exists for code sharing only. Clients should ignore it.
            <para/>
            The difference between <see cref="T:Loyc.Collections.AListBase`2"/> and <see cref="T:Loyc.Collections.AListBase`1"/>
            is that the first one is the base class of all data structures in the A-List 
            family (including <see cref="T:Loyc.Collections.BList`1"/>, <see cref="T:Loyc.Collections.BDictionary`2"/>, 
            etc.) while the second one is only the base class of non-organized ALists 
            (<see cref="T:Loyc.Collections.AList`1"/> and <see cref="T:Loyc.Collections.SparseAList`1"/>).
            </remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Loyc.Collections.AListBase`2" -->
        <member name="M:Loyc.Collections.AListBase`2.#ctor(Loyc.Collections.AListBase{`0,`1},System.Boolean)">
            <summary>Cloning constructor. Does not duplicate the observer 
            (<see cref="!:AListNodeObserver&lt;T&gt;"/>), if any, because it may not be 
            cloneable.</summary>
            <param name="items">Original list</param>
            <param name="keepListChangingHandlers">Whether to duplicate the 
            delegate for ListChanging; if false, this new object will not include 
            any handlers for the ListChanging event.</param>
            <remarks>This constructor leaves the new clone unfrozen.</remarks>
        </member>
        <member name="M:Loyc.Collections.AListBase`2.#ctor(Loyc.Collections.AListBase{`0,`1},Loyc.Collections.Impl.AListNode{`0,`1})">
            <summary>
            This is the constructor that CopySection(), which can be defined by 
            derived classes, should call to create a sublist of a list. Used in 
            conjunction with CopySectionHelper().
            </summary>
        </member>
        <member name="M:Loyc.Collections.AListBase`2.GetKey(`1)">
            <summary>Retrieves the key K from an item T. This method is only needed by "B" lists.</summary>
        </member>
        <member name="M:Loyc.Collections.AListBase`2.DoSingleOperation(Loyc.Collections.Impl.AListSingleOperation{`0,`1}@)">
            <summary>Performs an operation on a single item in an organized tree.</summary>
            <param name="op">Describes the operation to perform. The following 
            members must be initialized: Mode, CompareKeys, CompareToKey, Item, and
            Key. Also, set <see cref="F:Loyc.Collections.Impl.AListSingleOperation`2.RequireExactMatch"/> 
            if desired.</param>
            <returns>Returns the number of items that were added or removed, which
            is always 1, 0, or -1.</returns>
            <remarks>
            This method can be used to add, remove, or replace an item in an
            organized tree such as a B+ tree. It also finds the index of the item
            that was found, added, removed, or replaced, so it can be used to
            implement IndexOf(K) for a key K. Please note that in a dictionary, 
            this method cannot find an exact item (key-value pair) reliably when 
            duplicate keys exist.*
            <para/>
            This method could be used to find items also, but it assumes the 
            operation might modify the tree and therefore enables concurrent
            access detection and will create the root node if it doesn't exist.
            Therefore, you should call <see cref="M:Loyc.Collections.AListBase`2.OrganizedRetrieve(Loyc.Collections.Impl.AListSingleOperation{`0,`1}@)"/> if you 
            only want to retrieve an item from the tree.
            <para/>
            See the documentation of <see cref="T:Loyc.Collections.Impl.AListSingleOperation`2"/> and
            <see cref="T:Loyc.Collections.AListOperation"/> for more information.
            <para/>
            * Actually it is possible in a B+ tree, but requires a specially-
              designed derived class. Specifically, it is necessary to store 
              key-value pairs in inner nodes instead of just keys (so K := T),
              and to implement two different sorting functions. One sort function
              only compares keys, but this function can only be used for find
              and remove operations. The other function compares entire key-value 
              pairs in order to find an exact match (note that this requires 
              ordered values); this second function must be used for all add 
              operations, otherwise the tree may not stay sorted. In this kind
              of tree, replacements are generally unsafe (unless the new key and 
              value both compare equal to the old key and value).
            </remarks>
        </member>
        <member name="M:Loyc.Collections.AListBase`2.OrganizedRetrieve(Loyc.Collections.Impl.AListSingleOperation{`0,`1}@)">
            <summary>Performs a retrieve operation for a specific item.</summary>
            <param name="op">Describes the item to retrieve and receives information
            about the item retrieved. The following members must be initialized: 
            CompareKeys, CompareToKey, and Key. Also, if desired, set 
            <see cref="F:Loyc.Collections.Impl.AListSingleOperation`2.RequireExactMatch"/>.
            <para/>
            When this method returns, op.Found indicates whether the requested key
            was found, op.Item will contain the item with that key (if found), and 
            op.BaseIndex will contain the index of the item (see 
            <see cref="F:Loyc.Collections.Impl.AListSingleOperation`2.BaseIndex"/>).
            </param>
        </member>
        <member name="M:Loyc.Collections.AListBase`2.RemoveAll(System.Predicate{`1})">
            <summary>Removes all the elements that match the conditions defined by the specified predicate.</summary>
            <param name="match">A lambda that defines the conditions on the elements to remove.</param>
            <returns>The number of elements removed from the list.</returns>
        </member>
        <member name="M:Loyc.Collections.AListBase`2.ClearInternal(System.Boolean)">
            <summary>Clears the tree.</summary>
            <param name="forceClear">If true, the list is cleared even if 
            _listChanging throws an exception. If false, _listChanging can cancel 
            the operation by throwing an exception.</param>
            <remarks>If the list is frozen, it is not cleared even if forceClear=true.</remarks>
        </member>
        <member name="M:Loyc.Collections.AListBase`2.IndexesOf(`1)">
            <summary>
            Returns a sequence of integers that represent the locations where a given item appears in the list.
            </summary>
        </member>
        <member name="M:Loyc.Collections.AListBase`2.LinearScanFor(`1,System.Int32,System.Collections.Generic.EqualityComparer{`1})">
            <summary>Scans the list starting at startIndex and going upward, and 
            returns the index of an item that matches the first argument.</summary>
            <param name="item">Item to find</param>
            <param name="startIndex">Index of first element against which to compare the item.</param>
            <param name="comparer">Comparison object (e.g. <see cref="P:System.Collections.Generic.EqualityComparer`1.Default"/>.)</param>
            <returns>Index of the matching item, or -1 if no matching item was found.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">when startIndex &gt; Count</exception>
        </member>
        <member name="M:Loyc.Collections.AListBase`2.Freeze">
            <summary>Prevents further changes to the list.</summary>
            <remarks>
            After calling this method, any attempt to modify the list will cause
            a <see cref="T:Loyc.ReadOnlyException"/> to be thrown.
            <para/>
            Note: although they will no longer be called, any ListChanging handlers
            will not be forgotten, because it is possible to clone an unfrozen
            version of the list while keeping those handlers.
            <para/>
            This feature can be disabled in a derived class by overriding this
            method to throw <see cref="T:System.NotSupportedException"/>.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.AListBase`2.CopySectionHelper(System.Int32,System.Int32)">
            <summary>Together with the <see cref="!:AListBase(AListBase&lt;T&gt;,AListNode&lt;T&gt;)"/>
            constructor, this method helps implement the CopySection() method in derived 
            classes, by cloning a section of the tree.</summary>
        </member>
        <member name="M:Loyc.Collections.AListBase`2.SwapHelper(Loyc.Collections.AListBase{`0,`1},System.Boolean)">
            <summary>Swaps two ALists.</summary>
            <remarks>
            Usually, swapping is a useless feature, since usually you can just 
            swap the references to two lists instead of the contents of two lists.
            This method is provided anyway because <see cref="M:Loyc.Collections.AList`1.Append(Loyc.Collections.AList{`0})"/> 
            and <see cref="M:Loyc.Collections.AList`1.Prepend(Loyc.Collections.AList{`0})"/> need to be able to swap in-place in 
            some cases.
            <para/>
            The derived class must manually swap any additional data members that 
            it defines.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.AListBase`2.AddObserver(Loyc.Collections.Impl.IAListTreeObserver{`0,`1})">
            <summary>Attaches a tree observer to this object.</summary>
            <returns>True if the observer was added, false if it was already attached.</returns>
            <remarks>
            The tree observer mechanism is much more advanced, and less efficient, 
            than the <see cref="E:Loyc.Collections.AListBase`2.ListChanging"/> event. You should use that event
            instead if you can accomplish what you need with it.
            <para/>
            Observers cannot be added when the list is frozen, although they can
            be removed.
            <para/>
            This feature can be disabled in a derived class by overriding this
            method to throw <see cref="T:System.NotSupportedException"/>.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.AListBase`2.RemoveObserver(Loyc.Collections.Impl.IAListTreeObserver{`0,`1})">
            <summary>Removes a previously attached tree observer from this list.</summary>
            <returns>True if the observer was removed, false if it was not attached.</returns>
        </member>
        <member name="P:Loyc.Collections.AListBase`2.ImmutableCount">
            <summary>Diagnostic method. Returns the number of elements of the list
            that are located in immutable nodes, which will be copied if modified.
            Used by the test suite.</summary>
            <remarks>Variable time required. Scans all nodes if none are immutable; 
            stops at the root if the root is immutable.</remarks>
        </member>
        <member name="P:Loyc.Collections.AListBase`2.ObserverCount">
            <summary>Returns the number of tree observers attached to this list.</summary>
        </member>
        <member name="M:Loyc.Collections.AListBase`2.Enumerator.#ctor(Loyc.Collections.AListBase{`0,`1},System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Initializes an AList enumerator.
            </summary>
            <param name="self">AList to be enumerated.</param>
            <param name="start">Value of CurrentIndex after initialization; 
            should be firstIndex-1 if you want to enumerate forward, or 
            lastIndex if you want to enumerate backward.</param>
            <param name="firstIndex">Minimum index to enumerate. When enumerating
            backward, enumeration will stop after this index.</param>
            <param name="lastIndex">Maximum index to enumerate plus one. When 
            enumerating forward, enumeration will stop at this index (without 
            yielding the value there, if any).</param>
            <remarks>
            The Current property is never initialized by the constructor. You
            must call MoveNext() or MovePrevious() to initialize it.
            </remarks>
        </member>
        <member name="P:Loyc.Collections.AListBase`2.Enumerator.CurrentIndex">
            <summary>
            Index of the last item that was enumerated. If has been enumerated 
            yet, this will typically be one beyond the range of indexes with 
            which this enumerator was initialized, e.g. -1 when enumerating 
            the entire list from the beginning.
            </summary>
        </member>
        <member name="T:Loyc.Collections.Impl.IAListTreeObserver`2">
            <summary>
            An interface that is called to notify observers when items or nodes in the 
            tree of a class derived from <see cref="T:Loyc.Collections.AListBase`2"/> (e.g. AList or 
            BList) are added or removed.
            </summary>
            <typeparam name="K"></typeparam>
            <typeparam name="T"></typeparam>
            <remarks>
            This interface is useful for keeping track of information about a collection 
            that is impossible to track efficiently by any other means. It can be used 
            to:
            <ul>
            <li>- Maintain an inverse dictionary of items in an AList, so you can get 
            the (integer) index of an item in O(log N) time. This was the original 
            purpose for which the observer idea was developed.</li>
            <li>- Keep certain statistics about an unsorted list up-to-date efficiently,
            such as the maximum, minimum or average.</li>
            <li>- Connect AList/BList to Update Controls.</li>
            </ul>
            An observer object should be attached to only one list, because change 
            notifications do not indicate which list is being changed.
            <para/>
            When an A-list is cloned, observers do are not included in the clone.
            <para/>
            IMPORTANT: unless otherwise noted, implementations of this interface 
            must not throw exceptions because these methods are called during 
            operations in progress. If you throw an exception, the tree can be 
            left in an invalid state. Attach() can safety throw, but the exception 
            will propagate out of the <see cref="!:AListBase.AddObserver"/> method.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.Impl.IAListTreeObserver`2.Attach(Loyc.Collections.AListBase{`0,`1},System.Action{System.Boolean})">
            <summary>Called when the observer is being attached to an AList.</summary>
            <param name="list">The list that the observer is being attached to.</param>
            <param name="populate">The observer can invoke this delegate to cause 
            notifications to be sent about all the nodes in the tree through a
            depth-first search that calls <see cref="M:Loyc.Collections.Impl.IAListTreeObserver`2.AddAll(Loyc.Collections.Impl.AListNode{`0,`1})"/> for each node in
            the tree. When calling this delegate, use a parameter of True if you 
            want AddAll to be called for children before parents (roughly, leaves 
            first). Use False if you want AddAll to be called for inner nodes 
            before their children. populate() also calls <see cref="M:Loyc.Collections.Impl.IAListTreeObserver`2.RootChanged(Loyc.Collections.Impl.AListNode{`0,`1},System.Boolean)"/>()
            before scanning the tree.
            </param>
            <remarks>
            If Attach() throws an exception, <see cref="T:Loyc.Collections.AListBase`2"/> will
            cancel the AddObserver() operation and it will not catch the exception.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.Impl.IAListTreeObserver`2.Detach">
            <summary>Called when the observer is being detached from an AList.</summary>
        </member>
        <member name="M:Loyc.Collections.Impl.IAListTreeObserver`2.RootChanged(Loyc.Collections.Impl.AListNode{`0,`1},System.Boolean)">
            <summary>Called when the root of the tree changes, or when the
            list is cleared.</summary>
            <param name="clear">true if the root is changing due to a Clear() 
            operation. If this parameter is true, the observer should clear its
            own state. If this parameter is false but newRoot is null, it means
            that the list was cleared by removing all the items (rather than 
            by calling Clear() on the list). In that case, if the observer still 
            believes that any items exist in leaf nodes, it means that there is 
            a bookkeeping error somewhere.</param>
            <param name="newRoot">The new root (null if the tree is cleared).</param>
        </member>
        <member name="M:Loyc.Collections.Impl.IAListTreeObserver`2.ItemAdded(`1,Loyc.Collections.Impl.AListLeaf{`0,`1})">
            <summary>Called when an item is added to a leaf node.</summary>
            <param name="isMoving">true if the item is being transferred from another node.</param>
        </member>
        <member name="M:Loyc.Collections.Impl.IAListTreeObserver`2.ItemRemoved(`1,Loyc.Collections.Impl.AListLeaf{`0,`1})">
            <summary>Called when an item is removed from a leaf node.</summary>
            <param name="isMoving">true if the item is being transferred to another node.</param>
        </member>
        <member name="M:Loyc.Collections.Impl.IAListTreeObserver`2.NodeAdded(Loyc.Collections.Impl.AListNode{`0,`1},Loyc.Collections.Impl.AListInnerBase{`0,`1})">
            <summary>Called when a child node is added to an inner node.</summary>
            <param name="isMoving">true if the node is being transferred from another inner node.</param>
        </member>
        <member name="M:Loyc.Collections.Impl.IAListTreeObserver`2.NodeRemoved(Loyc.Collections.Impl.AListNode{`0,`1},Loyc.Collections.Impl.AListInnerBase{`0,`1})">
            <summary>Called when a child node is removed from an inner node.</summary>
            <param name="isMoving">true if the node is being transferred to another inner node.</param>
        </member>
        <member name="M:Loyc.Collections.Impl.IAListTreeObserver`2.RemoveAll(Loyc.Collections.Impl.AListNode{`0,`1})">
            <summary>Called when all children are being removed from a node (leaf 
            or inner). Notifications are not sent for individual children.</summary>
        </member>
        <member name="M:Loyc.Collections.Impl.IAListTreeObserver`2.AddAll(Loyc.Collections.Impl.AListNode{`0,`1})">
            <summary>Called when all children are being added to a node (leaf 
            or inner). Notifications are not sent for individual children.</summary>
        </member>
        <member name="M:Loyc.Collections.Impl.IAListTreeObserver`2.CheckPoint">
            <summary>Called when a tree modification operation is completed.</summary>
            <remarks>This is called after each modification operation (Add,
            Insert, Remove, Replace, etc.); the list will normally be in a
            read-only state ("frozen for concurrency") when this method is 
            called, so do not initiate changes from here.
            <para/>
            This method can safely throw an exception, and the list class will
            not swallow it. Note: if there are multiple observers, throwing an
            exception from one observers will prevent this notification from
            reaching other observers that have not been notified yet.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.AListBase`2.ObserverMgr.IllegalException(System.Exception)">
            <summary>Called when an observer throws something and the exception is
            being swallowed (because IAListTreeObserver is not allowed to throw).</summary>
            <param name="e">An exception that was caught.</param>
        </member>
        <member name="M:Loyc.Collections.AListBase`1.DetectSizeOverflow(System.Int32)">
            <summary>Throws <see cref="T:System.OverflowException"/> if inserting the 
            specified number of items would cause Count to overflow.</summary>
        </member>
        <member name="M:Loyc.Collections.AListBase`1.IndexOf(`0)">
            <summary>Finds an index of an item in the list.</summary>
            <param name="item">An item for which to search.</param>
            <returns>An index of the item.</returns>
            <remarks>
            The default implementation simply calls <see cref="!:LinearScanFor"/>.
            This method is called by <see cref="M:Loyc.Collections.AListBase`1.Remove(`0)"/> and <see cref="M:Loyc.Collections.AListBase`1.Contains(`0)"/>.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.AListBase`1.Contains(`0)">
            <summary>Returns true if-and-only-if the specified item exists in the list.</summary>
        </member>
        <member name="M:Loyc.Collections.AListBase`1.Remove(`0)">
            <summary>Finds a specific item and removes it. If duplicates of the item exist, 
            only the first occurrence is removed.</summary>
            <returns>True if an item was removed, false if not.</returns>
        </member>
        <member name="F:Loyc.Collections.AList`1.SortCopyThreshold">
            When sorting data that is smaller than this threshold, yet spans 
            multiple leaf nodes, the data is copied to an array, sorted, then
            copied back to the AList. This minimizes use of the indexer and
            minimizes the number of copies of Enumerator that are made.
        </member>
        <member name="M:Loyc.Collections.AList`1.Swap(Loyc.Collections.AList{`0})">
            <summary>Swaps the contents of two <see cref="T:Loyc.Collections.AList`1"/>s in O(1) time.</summary>
            <remarks>Any observers are also swapped.</remarks>
        </member>
        <member name="M:Loyc.Collections.AList`1.Append(Loyc.Collections.AList{`0})">
            <inheritdoc cref="M:Loyc.Collections.AList`1.Append(Loyc.Collections.AList{`0},System.Boolean)"/>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Loyc.Collections.AList`1.Append(Loyc.Collections.AList{`0},System.Boolean)" -->
        <member name="M:Loyc.Collections.AList`1.Prepend(Loyc.Collections.AList{`0})">
            <summary>Prepends an AList to this list in sublinear time.</summary>
            <param name="other">A list of items to be added to the front of this list (at index 0).</param>
            <inheritdoc cref="M:Loyc.Collections.AList`1.Append(Loyc.Collections.AList{`0},System.Boolean)"/>
        </member>
        <member name="M:Loyc.Collections.AList`1.Prepend(Loyc.Collections.AList{`0},System.Boolean)">
            <summary>Prepends an AList to this list in sublinear time.</summary>
            <param name="other">A list of items to be added to the front of this list (at index 0).</param>
            <inheritdoc cref="M:Loyc.Collections.AList`1.Append(Loyc.Collections.AList{`0},System.Boolean)"/>
        </member>
        <member name="M:Loyc.Collections.AList`1.Sort">
            <summary>Uses a specialized "tree quicksort" algorithm to sort this 
            list using <see cref="P:System.Collections.Generic.Comparer`1.Default"/>.</summary>
        </member>
        <member name="M:Loyc.Collections.AList`1.Sort(System.Collections.Generic.Comparer{`0})">
            <summary>Uses a specialized "tree quicksort" algorithm to sort this 
            list using the specified <see cref="T:System.Collections.Generic.Comparer`1"/>.</summary>
        </member>
        <member name="M:Loyc.Collections.AList`1.Sort(System.Comparison{`0})">
            <summary>Uses a specialized "tree quicksort" algorithm to sort this 
            list using the specified <see cref="T:System.Comparison`1"/>.</summary>
        </member>
        <member name="M:Loyc.Collections.AList`1.Sort(System.Int32,System.Int32,System.Comparison{`0})">
            <inheritdoc cref="M:Loyc.Collections.AList`1.Sort(System.Comparison{`0})"/>
            <param name="start">Index of first item in a range of items to sort.</param>
            <param name="subcount">Size of the range of items to sort.</param>
            <remarks></remarks>
        </member>
        <member name="T:Loyc.Collections.AListReverseView`2">
            <summary>A reverse view of an AList.</summary>
        </member>
        <member name="T:Loyc.Collections.Impl.AListIndexer`2">
            <summary>Observes changes and builds a table of items in the tree.</summary>
            <remarks>
            The <see cref="T:Loyc.Collections.IndexedAList`1"/> class uses one of these objects to speed
            up methods that search for items in an <see cref="T:Loyc.Collections.AList`1"/> (IndexOf,
            Contains, and Remove). The amount of speedup is limited by the size of
            the nodes in the list being indexed; see <see cref="M:Loyc.Collections.Impl.AListIndexer`2.IndexOfAny(`1)"/>.
            <para/>
            It is wasteful to use an AListIndexer if the list is small. AListIndexer
            is designed to accelerate searches in very large lists, and it offers no
            performance benefit to small lists; to the contrary, it just wastes time
            and memory in small lists.
            <para/>
            It is recommended to use IndexedAList instead of instantiating this class 
            directly.
            <para/>
            In general, AListIndexer requires more memory than the list that is being
            indexed. Specifically, if pointers use P bytes, then AListIndexer itself
            consumes moderately MORE than X+P*N bytes of memory, where X is the size 
            of the list being indexed, and N is the number of items in the list. Thus,
            for example, an indexed list of <see cref="!:AList&lt;object&gt;"/> requires 
            approximately three times as much memory as an AList that is not indexed.
            <para/>
            Moreover, changing an indexed list takes at least twice as much time, since 
            the indexer must be notified of each change and updates to the index take
            O(log N) time per update. Batch operations involving X items that take 
            O(log N) time without an indexer (e.g. RemoveRange(i, X)) will take 
            O(X log N) time instead, because the indexer must be notified about each 
            item changed.
            <para/>
            Still, these costs are worthwhile in applications that frequently search
            for items in the list.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.Impl.AListIndexer`2.IndexOfAny(`1)">
            <summary>Returns an index at which the specified item can be found.</summary>
            <param name="item">Item to find.</param>
            <returns>The index of the item in the list being indexed by this 
            object, or -1 if the item does not exist in the list.</returns>
            <remarks>
            The search takes O(M log^2 N) time, where N is the size of the list 
            and M is the maximum size of nodes in the list. Due to the "M" factor,
            A-lists with large nodes are searched more slowly than A-lists with 
            small nodes; however, the "log N" part is a base-M logarithm, so you
            don't actually gain performance by using very small nodes. This is
            because very small nodes require deeply nested trees, and deep trees 
            are slow. The <see cref="T:Loyc.Collections.AListBase`2"/> documentation discusses 
            the effect of node size further.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.Impl.AListIndexer`2.ReconstructIndex(`1,Loyc.Collections.Impl.AListLeaf{`0,`1})">
            <summary>Given an item and a leaf that is known to contain a copy of 
            the item, this method returns the index of the item in the tree as 
            a whole. Requires O(M )</summary>
        </member>
        <member name="M:Loyc.Collections.Impl.AListIndexer`2.VerifyCorrectness">
            <summary>Scans the index to verify that it matches the tree that is 
            being indexed. The scan takes O(N log N + N M) time for a list of 
            length N with maximum node size M.</summary>
            <exception cref="T:Loyc.InvalidStateException">
            The index is out of sync with the tree. 
            <para/>
            This could indicate a bug somewhere in the A-list code, but it could
            also be caused by other rogue code, such as items that change their
            sort order or hashcode after being added to the collection, an observer
            that has thrown exceptions when it's not allowed to, or buggy 
            multithreading (modifying a list from two threads at once).
            </exception>
            <remarks>
            Tree observability is a difficult feature to implement correctly, so 
            this method is called a lot in unit tests to help work out the bugs.
            </remarks>
        </member>
        <member name="T:Loyc.Collections.Impl.AListNode`2">
            <summary>
            Base class for tree nodes in a list class derived from 
            <see cref="T:Loyc.Collections.AListBase`1"/>. These nodes basically form an in-memory B+tree, 
            not necessarily sorted, but structured like a B+tree. That means there are 
            two node types: leaf and inner nodes.
            </summary>
            <remarks>
            Indexes that are passed to methods such as Index, this[] and RemoveAt are
            not range-checked except by assertion. The caller (AList or BList) is 
            expected to ensure indexes are valid.
            <para/>
            At the root node level, indexes have the same meaning as they do in 
            AListBase itself. However, below the root node, each node has a "base 
            index" that is subtracted from any index passed to the node. For example, 
            if the root node has two leaf children, and the left one has 20 items, then 
            the right child's base index is 20. When accessing item 23, the subindex 3 
            is passed to the right child. Note that the right child is not aware of its 
            own base index (the parent node manages the base index); as far as each 
            node is concerned, it manages a collection of items numbered 0 to 
            TotalCount-1.
            <para/>
            Indexes are expressed with a uint so that nodes are capable of holding up 
            to uint.MaxValue-1 elements. AList itself doesn't support sizes over 
            int.MaxValue, since it assumes indexes are signed (some protected methods
            in AList take unsigned indexes, however). It should be possible to support 
            oversize lists in 64-bit machines by writing a derived class based on 
            "uint" or "long" indexes; 32-bit processes, however, don't have enough 
            address space to even hold int.MaxValue bytes.
            <para/>
            Before calling any method that modifies a node, it is necessary to call
            AutoClone() to check if the node is frozen and clone it if necessary.
            TakeFromRight and TakeFromLeft can be called when one or both nodes are 
            frozen, but will have no effect.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.Impl.AListNode`2.Insert(System.UInt32,`1,Loyc.Collections.Impl.AListNode{`0,`1}@,Loyc.Collections.Impl.IAListTreeObserver{`0,`1})">
            <summary>Inserts an item at the specified index. This method can only
            be called for ALists, since other tree types don't allow insertion at
            a specific index.</summary>
            <returns>Returns null if the insert completed normally. If the node 
            split in half, the return value is the left side, and splitRight is
            set to the right side.</returns>
            <exception cref="T:System.NotSupportedException">This node does not allow insertion at an arbitrary location (e.g. BList node).</exception>
        </member>
        <member name="M:Loyc.Collections.Impl.AListNode`2.InsertRange(System.UInt32,Loyc.Collections.IListSource{`1},System.Int32@,Loyc.Collections.Impl.AListNode{`0,`1}@,Loyc.Collections.Impl.IAListTreeObserver{`0,`1})">
            <summary>Inserts a list of items at the specified index. This method
            may not insert all items at once, so there is a sourceIndex parameter 
            which points to the next item to be inserted. When sourceIndex reaches
            source.Count, the insertion is complete.</summary>
            <param name="index">The index at which to insert the contents of 
            source. Important: if sourceIndex &gt; 0, insertion of the remaining 
            items starts at [index + sourceIndex].</param>
            <returns>Returns non-null if the node is split, as explained 
            in the documentation of <see cref="M:Loyc.Collections.Impl.AListNode`2.Insert(System.UInt32,`1,Loyc.Collections.Impl.AListNode{`0,`1}@,Loyc.Collections.Impl.IAListTreeObserver{`0,`1})"/>.</returns>
            <remarks>This method can only be called for ALists, since other tree 
            types don't allow insertion at a specific index.</remarks>
            <exception cref="T:System.NotSupportedException">This node does not allow insertion at an arbitrary location (e.g. BList node).</exception>
        </member>
        <member name="M:Loyc.Collections.Impl.AListNode`2.DoSingleOperation(Loyc.Collections.Impl.AListSingleOperation{`0,`1}@,Loyc.Collections.Impl.AListNode{`0,`1}@,Loyc.Collections.Impl.AListNode{`0,`1}@)">
            <summary>Performs a retrieve, add, remove or replace operation on a
            single item in an organized A-list (such as a BList or BDictionary).</summary>
            <param name="op">An object that describes the operation to be performed
            and the parameters of the tree (comparers and observers).</param>
            <param name="splitLeft">null if the operation completed normally. If an
            item was added and the node split, splitLeft and splitRight are new 
            nodes that each contain roughly half of the items from this node.
            <para/>
            If an item was removed and the node became undersized, splitLeft is set
            to this (the node itself) and splitRight is set to null. Likewise, if
            the aggregate value of the node changed (in a B+tree, this means that
            the highest key changed) then splitLeft is set to the node itself and
            splitRight is set to null.
            </param>
            <returns>Returns 1 if a new item was added, -1 if an item was removed,
            or 0 if the number of items in the tree did not change.</returns>
            <exception cref="T:System.NotSupportedException">This node does not belong to an 
            organized tree (e.g. normal AList).</exception>
            <exception cref="T:Loyc.Collections.KeyAlreadyExistsException">The key op.NewKey already 
            existed in the tree and op.Mode was 
            <see cref="T:Loyc.Collections.AListOperation"/>.AddOrThrow.</exception>
            <remarks>
            If op.Mode is <see cref="T:Loyc.Collections.AListOperation"/>.ReplaceIfPresent, this method
            informs the caller when replacement occurs in this mode by changing 
            op.Mode to AddDuplicateMode.ReplaceExisting.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.Impl.AListNode`2.DoSparseOperation(Loyc.Collections.Impl.AListSparseOperation{`1}@,System.Int32,Loyc.Collections.Impl.AListNode{`0,`1}@,Loyc.Collections.Impl.AListNode{`0,`1}@)">
            <summary>Performs an insert or replace operation in a <see cref="T:Loyc.Collections.SparseAList`1"/>.</summary>
            <param name="op">Describes the operation to be performed</param>
            <param name="index">Relative index in child node where the sparse
            operation began; <c>index + op.SourceIndex</c> is where the next 
            insertion or replacement must occur. For example if the child 
            node represents items 100-200, and op.SourceIndex is 7, and 
            the absolute index of the start of the operation (op.AbsoluteIndex)
            is 98, then <c>index</c> will be -2 (98-100) and the next insertion
            or replacement will occur at index 5 in the child. <c>index</c> may 
            be negative but <c>index + op.SourceIndex &gt;= 0</c>.</param>
            <param name="splitLeft">If the node needs to split, splitLeft and 
            splitRight are set to the new pieces. If the node is undersized, 
            splitLeft is set to <c>this</c> (the called node) and splitRight 
            is set to null.</param>
            <returns>Size change (always 0 for a replacement operation)</returns>
            <remarks>In a language with templates, I would change a couple
            of elements of <see cref="T:Loyc.Collections.Impl.AListSparseOperation`1"/> into 
            template parameters.</remarks>
        </member>
        <member name="M:Loyc.Collections.Impl.AListNode`2.GetLastItem">
            <summary>Gets the last item in the last leaf node (needed by B+ trees, 
            but is also called by <see cref="P:Loyc.Collections.AListBase`2.Last"/>).</summary>
        </member>
        <member name="M:Loyc.Collections.Impl.AListNode`2.SetAt(System.UInt32,`1,Loyc.Collections.Impl.IAListTreeObserver{`0,`1})">
            <summary>Sets an item at the specified sub-index.</summary>
            <remarks>Currently, this method can be called for all tree types, even 
            though improper use could break the tree invariant (e.g. sorted order of BList).
            </remarks>
        </member>
        <member name="M:Loyc.Collections.Impl.AListNode`2.RemoveAt(System.UInt32,System.UInt32,Loyc.Collections.Impl.IAListTreeObserver{`0,`1})">
            <summary>Removes an item at the specified index.</summary>
            <returns>Returns true if the node is undersized after the removal, or 
            if this is an organized tree and the removal caused the aggregate key 
            (highest key in a B+tree) to change.</returns>
            <remarks>
            When the node is undersized, but is not the root node, the parent will 
            shift an item from a sibling, or discard the node and redistribute its 
            children among existing nodes. If it is the root node, it is only 
            discarded if it is an inner node with a single child (the child becomes 
            the new root node), or it is a leaf node with no children.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.Impl.AListNode`2.TakeFromRight(Loyc.Collections.Impl.AListNode{`0,`1},Loyc.Collections.Impl.IAListTreeObserver{`0,`1})">
            <summary>Takes an element from a right sibling.</summary>
            <returns>Returns the number of elements moved on success (1 if a leaf 
            node, TotalCount of the child moved otherwise), or 0 if either (1) 
            IsFullLeaf is true, or (2) one or both nodes is frozen.</returns>
        </member>
        <member name="M:Loyc.Collections.Impl.AListNode`2.TakeFromLeft(Loyc.Collections.Impl.AListNode{`0,`1},Loyc.Collections.Impl.IAListTreeObserver{`0,`1})">
            <summary>Takes an element from a left sibling.</summary>
            <returns>Returns the number of elements moved on success (1 if a leaf 
            node, TotalCount of the child moved otherwise), or 0 if either (1) 
            IsFullLeaf is true, or (2) one or both nodes is frozen.</returns>
        </member>
        <member name="M:Loyc.Collections.Impl.AListNode`2.DetachedClone">
            <summary>Creates an unfrozen shallow duplicate copy of this node. The 
            child nodes (if this is an inner node) are frozen so that they will
            require duplication if they are to be modified. The name 
            "DetachedClone" is intended to emphasize that the AListNodeObserver 
            (if any) is not notified, and the clone is effectively independent of 
            the list that it came from.</summary>
        </member>
        <member name="M:Loyc.Collections.Impl.AListNode`2.AutoClone(Loyc.Collections.Impl.AListNode{`0,`1}@,Loyc.Collections.Impl.AListInnerBase{`0,`1},Loyc.Collections.Impl.IAListTreeObserver{`0,`1})">
            <summary>Checks whether 'node' is frozen and if so, replaces it with an unfrozen copy.</summary>
            <param name="node">A node that the caller needs to be unfrozen</param>
            <param name="parent">Parent node (used by tob)</param>
            <param name="tob">Tree observer (null if none)</param>
            <returns>True if the node was unfrozen</returns>
        </member>
        <member name="M:Loyc.Collections.Impl.AListNode`2.Verify(System.Boolean)">
            <summary>Same as Assert(), except that the condition expression can 
            have side-effects because it is evaluated even in Release builds.</summary>
        </member>
        <member name="M:Loyc.Collections.Impl.AListNode`2.CopySection(System.UInt32,System.UInt32,Loyc.Collections.AListBase{`0,`1})">
            <summary>Extracts and returns, as fast as possible, a subrange of the 
            list that this node represents.</summary>
            <param name="index">Index to start copying</param>
            <param name="count">Number of Ts to copy (must be greater than zero).</param>
            <param name="list">List that is making the request. This parameter
            may be needed by organized trees that need to call list.GetKey().</param>
            <remarks>This method may return a size-one inner node that the caller
            must replace with its child. It will fast-clone any nodes that can be
            copied in their entirety, including this node itself.</remarks>
        </member>
        <member name="F:Loyc.Collections.Impl.AListNode`2._maxNodeSize">
            <summary>Maximum number of slots in this node</summary>
        </member>
        <member name="F:Loyc.Collections.Impl.AListNode`2._isFrozen">
            <summary>Whether the node is knowingly cloned an therefore frozen.</summary>
        </member>
        <member name="F:Loyc.Collections.Impl.AListNode`2._childCount">
            <summary>Number of children, if this is an inner node.</summary>
            <remarks>
            Since <see cref="T:Loyc.Collections.Impl.AListLeaf`1"/> uses DListInternal, a separate item
            count is not needed and this counter is always zero. This field 
            logically belongs in <see cref="!:AListInnerBase&lt;T&gt;"/> but is defined here
            to ensure that inner nodes are not 4 bytes larger than necessary. This
            field is "free" if it is declared in the base class, since class sizes
            are rounded up to the nearest multiple of 4 bytes (8 bytes in 64-bit).
            The fact that this field is a byte, however, does limit inner node 
            sizes to 255.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.Impl.AListNode`2.GetObserver(Loyc.Collections.AListBase{`0,`1})">
            <summary>Allows derived classes of AListNode to access AListBase._observer.</summary>
        </member>
        <member name="M:Loyc.Collections.Impl.AListNode`2.HasListChanging(Loyc.Collections.AListBase{`0,`1})">
            <summary>Allows derived classes of AListNode to fire the AListBase.ListChanging event.</summary>
        </member>
        <member name="M:Loyc.Collections.Impl.AListNode`2.CallListChanging(Loyc.Collections.AListBase{`0,`1},Loyc.Collections.ListChangeInfo{`1})">
            <summary>Allows derived classes of AListNode to fire the AListBase.ListChanging event properly.</summary>
        </member>
        <member name="M:Loyc.Collections.Impl.AListNode`2.ImmutableCount">
            <summary>Diagnostic method. See <see cref="P:Loyc.Collections.AListBase`2.ImmutableCount"/>.</summary>
        </member>
        <member name="P:Loyc.Collections.Impl.AListNode`2.TotalCount">
            <summary>Gets the total number of (T) items in this node and all children</summary>
        </member>
        <member name="P:Loyc.Collections.Impl.AListNode`2.LocalCount">
            <summary>Gets the number of items (slots) used this node only.</summary>
        </member>
        <member name="P:Loyc.Collections.Impl.AListNode`2.IsFullLeaf">
            <summary>Returns true if the node is full and is a leaf node.</summary>
        </member>
        <member name="P:Loyc.Collections.Impl.AListNode`2.IsUndersized">
            <summary>Returns true if the node is undersized, meaning it would 
            prefer to have more immediate children.</summary>
        </member>
        <member name="P:Loyc.Collections.Impl.AListNode`2.Item(System.UInt32)">
            <summary>Gets an item at the specified sub-index.</summary>
        </member>
        <member name="P:Loyc.Collections.Impl.AListNode`2.IsFrozen">
            <summary>Returns true if the node is explicitly marked read-only. 
            Conceptually, the node can still be changed, but when any change needs 
            to be made, a clone of the node is created and modified instead.</summary>
            <remarks>When an inner node is frozen, all its children are implicitly 
            frozen, but not actually marked as frozen until the parent is cloned.
            This allows instantaneous cloning, since only the root node is marked 
            frozen in the beginning.</remarks>
        </member>
        <member name="F:Loyc.Collections.Impl.AListInnerBase`2._children">
            <summary>List of child nodes. Empty children are null.</summary>
            <remarks>
            *** TODO ***: don't increase _children size by 4. Increase it exponentially
            </remarks>
        </member>
        <member name="M:Loyc.Collections.Impl.AListInnerBase`2.BinarySearchI(System.UInt32)">
            <summary>Performs a binary search for an index.</summary>
            <remarks>Optimized. Fastest for power-of-two node sizes.</remarks>
        </member>
        <member name="M:Loyc.Collections.Impl.AListInnerBase`2.HandleChildSplit(System.Int32,Loyc.Collections.Impl.AListNode{`0,`1},Loyc.Collections.Impl.AListNode{`0,`1}@,Loyc.Collections.Impl.IAListTreeObserver{`0,`1})">
            <summary>Inserts a slot after _children[i], increasing _childCount and 
            replacing [i] and [i+1] with splitLeft and splitRight. Notifies 'tob' 
            of the replacement, and checks whether this node itself needs to split.</summary>
            <returns>Value of splitLeft to be returned to parent (non-null if splitting)</returns>
        </member>
        <member name="M:Loyc.Collections.Impl.AListInnerBase`2.SplitAt(System.Int32,Loyc.Collections.Impl.AListNode{`0,`1}@)">
            <summary>Splits this node into two halves</summary>
            <param name="divAt">Index into _children where the right half starts</param>
            <param name="right">An AListInner node containing the right children</param>
            <returns>An AListInner node containing the left children</returns>
        </member>
        <member name="M:Loyc.Collections.Impl.AListInnerBase`2.LLInsert(System.Int32,Loyc.Collections.Impl.AListNode{`0,`1},System.UInt32)">
            <summary>Inserts a child node into _children at index i (resizing 
            _children if necessary), increments _childCount, and adds 
            indexAdjustment to _children[j].Index for all j>i (indexAdjustment can
            be 0 if i==_childCount).</summary>
            <remarks>Derived classes can override to add their own bookkeeping.</remarks>
        </member>
        <member name="M:Loyc.Collections.Impl.AListInnerBase`2.HandleUndersized(System.Int32,Loyc.Collections.Impl.IAListTreeObserver{`0,`1})">
            <summary>
            This is called by RemoveAt(), DoSingleOperation() for B+ trees, or by
            the constructor called by CopySection(), when child [i] drops below its 
            normal size range. We'll either distribute the child's items to its 
            siblings, or transfer ONE item from a sibling to increase the node's 
            size.
            </summary>
            <param name="i">Index of undersized child</param>
            <param name="tob">Observer to notify about node movements</param>
            <returns>True iff this node has become undersized.</returns>
        </member>
        <member name="M:Loyc.Collections.Impl.AListInnerBase`2.LLDelete(System.Int32,System.Boolean)">
            <summary>Deletes the child _children[i], shifting all entries afterward 
            to the left, and decrements _childCount. If adjustIndexesAfterI is true,
            the values of _children[j].Index where j>i are decreased appropriately.</summary>
            <returns>True if the aggregate value of this node may have changed (organized lists only)</returns>
            <remarks>Derived classes can override to add their own bookkeeping.</remarks>
        </member>
        <member name="M:Loyc.Collections.Impl.AListInner`1.Combine(Loyc.Collections.Impl.AListInnerBase{System.Int32,`0},System.Int32,Loyc.Collections.Impl.AListNode{System.Int32,`0}@,Loyc.Collections.Impl.IAListTreeObserver{System.Int32,`0},System.Boolean,System.Boolean)">
            <summary>Appends or prepends some other list to this list. The other 
            list must be the same height or less tall.</summary>
            <param name="other">A list to append/prepend</param>
            <param name="heightDifference">Height difference between the trees (0 or >0)</param>
            <param name="splitRight">Right half in case node is split</param>
            <param name="tob">Observer to be notified of changes</param>
            <param name="move">Move semantics (avoids freezing the nodes of the other tree)</param>
            <param name="append">Operation to perform (true => append)</param>
            <returns>Normally null, or left half in case node is split</returns>
        </member>
        <member name="T:Loyc.Collections.Impl.AListLeaf`1">
            <summary>
            Leaf node of <see cref="T:Loyc.Collections.AList`1"/>.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Loyc.Collections.Impl.AListSingleOperation`2">
            <summary>This structure is passed from the collection class (AList, BList 
            or BDictionary) to the tree (AListNode classes), and it holds information 
            needed to run a command like "add or replace item", "add if not present" 
            or "remove item".</summary>
            <typeparam name="K">Key type (stored in inner nodes)</typeparam>
            <typeparam name="T">Item type (stored in leaf nodes)</typeparam>
            <remarks>A-List operations as diverse as "add", "remove" and "retrieve"
            are actually very similar and are implemented by the same method, 
            <see cref="M:Loyc.Collections.Impl.AListNode`2.DoSingleOperation(Loyc.Collections.Impl.AListSingleOperation{`0,`1}@,Loyc.Collections.Impl.AListNode{`0,`1}@,Loyc.Collections.Impl.AListNode{`0,`1}@)"/>.</remarks>
        </member>
        <member name="F:Loyc.Collections.Impl.AListSingleOperation`2.Mode">
            <summary>Specifies which operation is to be performed.</summary>
        </member>
        <member name="F:Loyc.Collections.Impl.AListSingleOperation`2.BaseIndex">
            <summary>While traversing the tree, this starts at zero and is 
            incremented by the base index of each new node before it is traversed.
            In the leaf node it is incremented by the local index of the affected
            item, so that its final value is the actual index of the item that
            was added, removed, replaced or retrieved.</summary>
            <remarks>
            This value is needed to call ListChanging in the leaf, and
            it is also used to support IndexOf(K) if K is a key.
            <para/>
            If the Mode is Retrieve and the tree is a B+ tree and the Key was not 
            found, op.BaseIndex will tell you the index of the item with the 
            nearest higher key, or it will be equal to Count if the requested key 
            is higher than all keys in the tree.
            </remarks>
        </member>
        <member name="F:Loyc.Collections.Impl.AListSingleOperation`2.CompareKeys">
            <summary>A function that compares two keys.</summary>
            <remarks>NOTE: by convention, the search key (<see cref="F:Loyc.Collections.Impl.AListSingleOperation`2.Key"/>) is 
            always passed as the second parameter. The caller can use a special
            search function based on this assumption (e.g. 
            <see cref="M:Loyc.Collections.BList`1.FindUpperBound(`0)"/>.</remarks>
        </member>
        <member name="F:Loyc.Collections.Impl.AListSingleOperation`2.CompareToKey">
            <summary>A function that compares an item to a key.</summary>
            <remarks>This is used to select an insertion location or (when 
            replacing an existing item) to find an item to be replaced. The
            second parameter will be the search key (<see cref="F:Loyc.Collections.Impl.AListSingleOperation`2.Key"/>).</remarks>
        </member>
        <member name="F:Loyc.Collections.Impl.AListSingleOperation`2.List">
            <summary>An A-list object that contains the tree being searched.</summary>
        </member>
        <member name="F:Loyc.Collections.Impl.AListSingleOperation`2.Item">
            <summary>For an add or remove operation, this field specifies an item 
            to be added or removed, and on exit it is set to the value of the item
            that was removed or replaced (if any). For a retrieval operation, its
            initial value is default(T) and it is set to the retrieved value on
            exit.</summary>
        </member>
        <member name="F:Loyc.Collections.Impl.AListSingleOperation`2.Key">
            <summary>Key of the item to be added, removed or retrieved.</summary>
        </member>
        <member name="F:Loyc.Collections.Impl.AListSingleOperation`2.AggregateKey">
            <summary>On exit, if <see cref="F:Loyc.Collections.Impl.AListSingleOperation`2.AggregateChanged"/> is true, this is
            set to the aggregate key of the node. In a B+ tree, this is the value 
            of the highest key in the node and all child nodes.</summary>
        </member>
        <member name="F:Loyc.Collections.Impl.AListSingleOperation`2.RequireExactMatch">
            <summary>Specifies that the operation will not be performed unless 
            the candidate item c is not equal to Item (object.Equals(Item, c)).</summary>
            <remarks>
            WARNING: If the collection is a dictionary with duplicate keys, 
            <see cref="M:Loyc.Collections.Impl.AListNode`2.DoSingleOperation(Loyc.Collections.Impl.AListSingleOperation{`0,`1}@,Loyc.Collections.Impl.AListNode{`0,`1}@,Loyc.Collections.Impl.AListNode{`0,`1}@)"/>() will NOT NECESSARILY 
            find an exact match when one exists! DoSingleOperation only finds one
            item with a matching key. It does not necessarily find the exact item
            you were looking for!
            <para/>
            In order to find an exact match when the dictionary has duplicate keys,
            one must check all candidate items one-by-one. DoSingleOperation cannot 
            do this because it is only designed to look for a single item.
            </remarks>
        </member>
        <member name="F:Loyc.Collections.Impl.AListSingleOperation`2.Found">
            <summary>DoSingleOperation() sets this field to true if the Key was 
            found in the collection.</summary>
        </member>
        <member name="F:Loyc.Collections.Impl.AListSingleOperation`2.LowerBound">
            <summary>Specifies that when multiple items have the same key, the one
            with the lowest index should be found or replaced. If this is false (the
            default) then any of the items can be chosen, which may be slightly 
            faster.</summary>
        </member>
        <member name="F:Loyc.Collections.Impl.AListSingleOperation`2.AggregateChanged">
            <summary>DoSingleOperation() sets this field to 1 if the aggregate
            key value (in a B+ tree, the value of the highest key) changed.</summary>
            <remarks>
            This must be cleared before the list calls DoSingleOperation(). The
            data type is byte instead of bool so that <see cref="T:Loyc.Collections.Impl.BListLeaf`2"/> 
            can internally use the extra bits to notify itself when a node split is 
            in progress.
            <para/>
            If a node splits, the parent node is responsible to send 
            <see cref="M:Loyc.Collections.Impl.IAListTreeObserver`2.RemoveAll(Loyc.Collections.Impl.AListNode{`0,`1})"/>() and AddAll() to 
            transfer the items to the new nodes. In that case, the child must not
            send an ItemAdded() notification because the AddAll() command will
            implicitly send that notification, and we mustn't double-notify.
            </remarks>
        </member>
        <member name="T:Loyc.Collections.Impl.AListSparseOperation`1">
            <summary>This structure is passed from the collection class (SparseAList)
            to the tree (AListNode classes), and it holds information needed to run 
            a command like "change item at index X" or "clear empty space".</summary>
            <typeparam name="T">Item type (stored in leaf nodes)</typeparam>
        </member>
        <member name="F:Loyc.Collections.Impl.AListSparseOperation`1.IsInsert">
            <summary>Which operation: Insert (true) or Set (false)</summary>
        </member>
        <member name="F:Loyc.Collections.Impl.AListSparseOperation`1.WriteEmpty">
            <summary>Whether to write empty space (true) or values (false)</summary>
        </member>
        <member name="T:Loyc.Collections.AListOperation">
            <summary>Indicates the way an add operation (such as <see cref="M:Loyc.Collections.BList`1.Do(Loyc.Collections.AListOperation,`0@)"/>
            should behave when an item being added to a set or list is a duplicate of 
            an item that is already present, or when the key of a key-value pair being 
            added to a dictionary is a duplicate of a key that is already present in 
            the dictionary.</summary>
            <remarks>All the "add" operations are deliberately listed last, so that
            <see cref="!:AListNode&lt;K,T&gt;.DoSingleOperation"/> can use a greater-than 
            operator to figure out whether an item may be added or not.</remarks>
        </member>
        <member name="F:Loyc.Collections.AListOperation.Retrieve">
            <summary>Default operation. The item with the specified key will be 
            retrieved. The tree will not be modified.</summary>
        </member>
        <member name="F:Loyc.Collections.AListOperation.ReplaceIfPresent">
            <summary>Replace an existing item/key if present, or do nothing if 
            there is no matching item/key.</summary>
        </member>
        <member name="F:Loyc.Collections.AListOperation.Remove">
            <summary>Remove the item with the specified key if present.</summary>
        </member>
        <member name="F:Loyc.Collections.AListOperation.Add">
            <summary>A new item will be added unconditionally, without affecting 
            existing elements, in no particular order with respect to existing
            items that have the same key.</summary>
        </member>
        <member name="F:Loyc.Collections.AListOperation.AddOrReplace">
            <summary>A new item will replace an item that has the same key. If the 
            collection already contains multiple instances of the item/key, the 
            instance to be replaced is undefined.</summary>
        </member>
        <member name="F:Loyc.Collections.AListOperation.AddIfNotPresent">
            <summary>A new item will be added if its key doesn't match an existing
            element. If the item already exists, it is not replaced.</summary>
        </member>
        <member name="F:Loyc.Collections.AListOperation.AddOrThrow">
            <summary>The item will be added if its key is not already present, but
            <see cref="T:Loyc.Collections.KeyAlreadyExistsException"/> or <see cref="T:System.InvalidOperationException"/> 
            will be thrown if the new item is equal to an existing element. If this 
            exception occurs during an AddRange() operation, some of the items may 
            have already been added successfully, and the changes will not be 
            rolled back unless otherwise specified in the documentation of the 
            method that performs the add operation.</summary>
        </member>
        <member name="T:Loyc.Collections.BDictionary`2">
            <summary>
            An sorted dictionary that is efficient for all operations and offers 
            indexed access to its list of key-value pairs.
            </summary>
            <remarks>
            This class offers the following additional features beyond what's offered 
            by <see cref="!:SortedDictionary&lt;T&gt;"/>: indexed access, a find-nearest-key
            operation called <see cref="M:Loyc.Collections.BDictionary`2.FindLowerBound(`0)"/> (similar to lower_bound in 
            C++), observability, fast cloning, freezability, fast cloning of an 
            arbitrary range of items in a large collection, enumeration of part
            of the list (not just the entire list), and reverse enumeration, and a 
            few compound operations.
            <para/>
            Duplicate keys are not allowed in a BDictionary. If you would like to be
            able to associate multiple values with a single key, use 
            <see cref="T:Loyc.Collections.BMultiMap`2"/> instead. 
            <para/>
            If you need to store only keys, not values, use <see cref="T:Loyc.Collections.BList`1"/> 
            instead (but note that BList does allow duplicate keys).
            </remarks>
        </member>
        <member name="M:Loyc.Collections.BDictionary`2.#ctor">
            <summary>Initializes an empty BList.</summary>
            <remarks>By default, elements of the list will be compared using
            <see cref="P:System.Collections.Generic.Comparer`1.Default"/>.Compare.</remarks>
        </member>
        <member name="M:Loyc.Collections.BDictionary`2.#ctor(System.Int32)">
            <inheritdoc cref="!:BDictionary(Func&lt;T,T,int&gt;, int, int)"/>
        </member>
        <member name="M:Loyc.Collections.BDictionary`2.#ctor(System.Int32,System.Int32)">
            <inheritdoc cref="!:BDictionary(Func&lt;T,T,int&gt;, int, int)"/>
        </member>
        <member name="M:Loyc.Collections.BDictionary`2.#ctor(System.Func{`0,`0,System.Int32})">
            <inheritdoc cref="!:BDictionary(Func&lt;T,T,int&gt;, int, int)"/>
        </member>
        <member name="M:Loyc.Collections.BDictionary`2.#ctor(System.Func{`0,`0,System.Int32},System.Int32)">
            <inheritdoc cref="!:BDictionary(Func&lt;T,T,int&gt;, int, int)"/>
        </member>
        <member name="M:Loyc.Collections.BDictionary`2.#ctor(System.Func{`0,`0,System.Int32},System.Int32,System.Int32)">
            <summary>Initializes an empty BDictionary.</summary>
            <param name="compareKeys">A method that compares two items and returns 
            a negative number (typically -1) if the first item is smaller than the 
            second item, 0 if it is equal, and a positive number (typically 1) if 
            it is greater.</param>
            <param name="maxLeafSize">Maximum number of elements to place in a leaf node of the B+ tree.</param>
            <param name="maxInnerSize">Maximum number of elements to place in an inner node of the B+ tree.</param>
            <remarks>
            If present, the compareKeys parameter must be a "Func" delegate instead 
            of the more conventional <see cref="T:System.Comparison`1"/> delegate for an 
            obscure design decision for the benefit of <see cref="T:Loyc.Collections.BList`1"/>.
            You should not notice any difference between the two, but the stupid 
            .NET type system  insists that the two types are not compatible. So, if 
            (for some reason) you already happen to have a <see cref="T:System.Comparison`1"/> 
            delegate, you must explicitly convert it to a Func delegate with code 
            such as "new Func&lt;K,K,int&gt;(comparisonDelegate)".
            <para/>
            If you leave out the compareKeys parameter, <see cref="P:System.Collections.Generic.Comparer`1.Default"/>.Compare
            will be used by default.
            <para/>
            See the documentation of <see cref="T:Loyc.Collections.AListBase`2"/> for a discussion
            about node sizes.
            <para/>
            An empty BDictionary is created with no root node, so it consumes much less 
            memory than a BDictionary with a single element.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.BDictionary`2.#ctor(Loyc.Collections.BDictionary{`0,`1},System.Boolean)">
            <inheritdoc cref="M:Loyc.Collections.BDictionary`2.Clone(System.Boolean)"/>
            <param name="items">A list of items to be cloned.</param>
        </member>
        <member name="M:Loyc.Collections.BDictionary`2.FindLowerBound(`0)">
            <summary>Finds the lowest index of an item with a key that is equal to 
            or greater than the specified key.</summary>
            <param name="key">The key to find. If passed by reference, when this 
            method returns, key is set to the key of the item that was found, or to 
            the next greater item if the item was not found. If the item passed in 
            is higher than all items in the list, it will be left unchanged when 
            this method returns.</param>
            <param name="found">Set to true if the item was found, false if not.</param>
            <returns>The index of the item that was found, or of the next
            greater item, or Count if the given item is greater than all items 
            in the list.</returns>
        </member>
        <member name="M:Loyc.Collections.BDictionary`2.FindLowerBound(`0,System.Boolean@)">
            <inheritdoc cref="!:FindLowerBound(T)"/>
        </member>
        <member name="M:Loyc.Collections.BDictionary`2.FindLowerBound(`0@)">
            <inheritdoc cref="!:FindLowerBound(T)"/>
        </member>
        <member name="M:Loyc.Collections.BDictionary`2.FindLowerBound(`0@,System.Boolean@)">
            <inheritdoc cref="!:FindLowerBound(T)"/>
        </member>
        <member name="M:Loyc.Collections.BDictionary`2.FindUpperBound(`0)">
            <summary>Finds the index of the first item in the list that is greater 
            than the specified item.</summary>
            <param name="item">The item to find. If passed by reference, when this 
            method returns, item is set to the next greater item than the item you 
            searched for, or left unchanged if there is no greater item.</param>
            <param name="index">The index of the next greater item that was found,
            or Count if the given item is greater than all items in the list.</param>
            <returns></returns>
        </member>
        <member name="M:Loyc.Collections.BDictionary`2.Clone">
            <inheritdoc cref="M:Loyc.Collections.BDictionary`2.Clone(System.Boolean)"/>
        </member>
        <member name="M:Loyc.Collections.BDictionary`2.Clone(System.Boolean)">
            <summary>Clones a BDictionary.</summary>
            <param name="keepListChangingHandlers">If true, ListChanging handlers
            will be copied from the existing list of items to the new collection.
            Note: if it exists, the NodeObserver is never copied. 
            <see cref="!:NodeObserver"/> will be null in the new list.</param>
            <remarks>
            Cloning is performed in O(1) time by marking the tree root as frozen 
            and sharing it between the two lists. However, the new dictionary 
            itself will not be frozen, even if the original dictionary was marked 
            as frozen. Instead, nodes will be copied on demand when you modify the 
            new dictionary.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.BDictionary`2.AddIfNotPresent(`0,`1)">
            <summary>Adds the specified pair only if the key is not already present in the dictionary.</summary>
            <param name="key">Key to search for or add. If this parameter is passed by reference and a matching pair exists already, this method sets it to the existing key instance.</param>
            <param name="value">Value to search for or add. If this parameter is passed by reference and a matching pair exists already, this method sets it to the existing value.</param>
            <returns>True if the new pair was added, false if not.</returns>
            <remarks>
            This method has no effect if the key is already present.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.BDictionary`2.AddIfNotPresent(`0,`1@)">
            <inheritdoc cref="M:Loyc.Collections.BDictionary`2.AddIfNotPresent(`0,`1)"/>
        </member>
        <member name="M:Loyc.Collections.BDictionary`2.AddIfNotPresent(`0@,`1@)">
            <inheritdoc cref="M:Loyc.Collections.BDictionary`2.AddIfNotPresent(`0,`1)"/>
        </member>
        <member name="M:Loyc.Collections.BDictionary`2.SetAndGetOldValue(`0,`1@)">
            <summary>Associates the specified value with the specified key, while getting the old value if one exists.</summary>
            <param name="key">Key to search for or add. If this parameter is passed by reference and a matching pair existed already, this method sets it to the old key instance.</param>
            <param name="value">Value to search for or add. If this parameter is passed by reference and a matching pair existed already, this method sets it to the old value.</param>
            <returns>True if the new pair was added, false if it was replaced.</returns>
        </member>
        <member name="M:Loyc.Collections.BDictionary`2.SetAndGetOldValue(`0@,`1@)">
            <inheritdoc cref="!:SetAndGetOldValue(K,V)"/>
        </member>
        <member name="M:Loyc.Collections.BDictionary`2.ReplaceIfPresent(`0,`1)">
            <summary>Replaces the value associated with a specified key, if it already exists in the dictionary.</summary>
            <param name="key">Key to replace. If this parameter is passed by reference and a matching pair existed, this method sets it to the old key instance.</param>
            <param name="value">New value to associate with the key. If this parameter is passed by reference and a matching pair existed, this method sets it to the old value.</param>
            <returns>True if the key was found and the pair was replaced, false if it was not found.</returns>
            <remarks>
            This method has no effect if the key was not already present.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.BDictionary`2.ReplaceIfPresent(`0,`1@)">
            <inheritdoc cref="M:Loyc.Collections.BDictionary`2.ReplaceIfPresent(`0,`1)"/>
        </member>
        <member name="M:Loyc.Collections.BDictionary`2.ReplaceIfPresent(`0@,`1@)">
            <inheritdoc cref="M:Loyc.Collections.BDictionary`2.ReplaceIfPresent(`0,`1)"/>
        </member>
        <member name="T:Loyc.Collections.BList`1">
            <summary>
            An sorted in-memory list that is efficient for all operations and offers 
            indexed access to its list.
            </summary>
            <remarks>
            When you need a sorted list of items, there's nothing quite like a BList. BList offers
            numerous features that none of the standard .NET collections can offer:
            <ul>
            <li>O(log N) efficiency for all standard list operations (Add, Remove, 
            IndexOf, this[]) plus and O(1) fast cloning and O(1)-per-element enumeration.</li>
            <li>Changes can be observed through the <see cref="!:ListChanging"/> event.
            The performance penalty for this feature is lower than for the standard
            <see cref="!:ObservableCollection&lt;T&gt;"/> class.</li>
            <li>Changes to the tree structure can be observed too (see <see cref="!:MakeObserver"/>).</li>
            <li>The list can be frozen with <see cref="!:Freeze"/>, making it read-only.</li>
            <li><see cref="M:Loyc.Collections.BList`1.FindLowerBound(`0)"/> and <see cref="M:Loyc.Collections.BList`1.FindUpperBound(`0)"/> operations
            that find the nearest item equal to or greater than a specified item.</li>
            <li>A reversed view of the list is available through the <see cref="!:Reversed"/> 
            property, and the list can be enumerated backwards, also in O(1) time 
            per element.</li>.
            <li>A BList normally uses less memory than a <see cref="T:System.Collections.Generic.SortedDictionary`2"/> 
            or a hashtable such as <see cref="T:System.Collections.Generic.HashSet`1"/> or <see cref="T:System.Collections.Generic.Dictionary`2"/>.</li>
            <li>Other features inherited from <see cref="T:Loyc.Collections.AListBase`1"/></li>
            </ul>
            Please note, however, that <see cref="T:Loyc.Collections.BList`1"/> is generally slower than
            <see cref="T:System.Collections.Generic.Dictionary`2"/> and <see cref="T:System.Collections.Generic.HashSet`1"/>, so you should
            only use it when you need a sorted list of items, or when you need its
            special features such as <see cref="M:Loyc.Collections.BList`1.FindLowerBound(`0)"/> or observability.
            <para/>
            Caution: items must not be modified in a way that affects their sort order 
            after they are added to the list. If the list ever stops being sorted, it
            will malfunction, as it will no longer be possible to find some of the 
            items.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.BList`1.#ctor">
            <summary>Initializes an empty BList.</summary>
            <remarks>By default, elements of the list will be compared using
            <see cref="P:System.Collections.Generic.Comparer`1.Default"/>.Compare.</remarks>
        </member>
        <member name="M:Loyc.Collections.BList`1.#ctor(System.Int32)">
            <inheritdoc cref="M:Loyc.Collections.BList`1.#ctor(System.Func{`0,`0,System.Int32},System.Int32,System.Int32)"/>
        </member>
        <member name="M:Loyc.Collections.BList`1.#ctor(System.Int32,System.Int32)">
            <inheritdoc cref="M:Loyc.Collections.BList`1.#ctor(System.Func{`0,`0,System.Int32},System.Int32,System.Int32)"/>
        </member>
        <member name="M:Loyc.Collections.BList`1.#ctor(System.Func{`0,`0,System.Int32})">
            <inheritdoc cref="M:Loyc.Collections.BList`1.#ctor(System.Func{`0,`0,System.Int32},System.Int32,System.Int32)"/>
        </member>
        <member name="M:Loyc.Collections.BList`1.#ctor(System.Func{`0,`0,System.Int32},System.Int32)">
            <inheritdoc cref="M:Loyc.Collections.BList`1.#ctor(System.Func{`0,`0,System.Int32},System.Int32,System.Int32)"/>
        </member>
        <member name="M:Loyc.Collections.BList`1.#ctor(System.Func{`0,`0,System.Int32},System.Int32,System.Int32)">
            <summary>Initializes an empty BList.</summary>
            <param name="compareItems">A method that compares two items and returns 
            -1 if the first item is smaller than the second item, 0 if it is equal,
            and 1 if it is greater.</param>
            <param name="maxLeafSize">Maximum number of elements to place in a leaf node of the B+ tree.</param>
            <param name="maxInnerSize">Maximum number of elements to place in an inner node of the B+ tree.</param>
            <remarks>
            If present, the compareKeys parameter must be a "Func" delegate instead 
            of the more conventional <see cref="T:System.Comparison`1"/> delegate for an 
            obscure technical reason (specifically, it is the type required by 
            <see cref="F:Loyc.Collections.Impl.AListSingleOperation`2.CompareToKey"/>). You should not 
            notice any difference between the two, but the stupid .NET type system 
            insists that the two types are not compatible. So, if (for some reason) 
            you already happen to have a <see cref="T:System.Comparison`1"/> delegate, you
            must explicitly convert it to a Func delegate with code such as 
            "new Func&lt;T,T,int&gt;(comparisonDelegate)".
            <para/>
            If you leave out the compareKeys parameter, <see cref="P:System.Collections.Generic.Comparer`1.Default"/>.Compare
            will be used by default.
            <para/>
            See the documentation of <see cref="T:Loyc.Collections.AListBase`2"/> for a discussion
            about node sizes.
            <para/>
            An empty BList is created with no root node, so it consumes much less 
            memory than a BList with a single element.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.BList`1.#ctor(Loyc.Collections.BList{`0},System.Boolean)">
            <inheritdoc cref="M:Loyc.Collections.BList`1.Clone(System.Boolean)"/>
            <param name="items">A list of items to be cloned.</param>
        </member>
        <member name="F:Loyc.Collections.BList`1._compareItems">
            <summary>Compares two items. See <see cref="T:System.Comparison`1"/>.</summary>
            <remarks>Not marked readonly because the derived class constructor for BMultiMap needs to change it.</remarks>
        </member>
        <member name="M:Loyc.Collections.BList`1.Remove(`0)">
            <summary>Removes a single instance of the specified item.</summary>
        </member>
        <member name="M:Loyc.Collections.BList`1.RemoveAll(`0)">
            <summary>Removes all instances of the specified item.</summary>
            <param name="item">Item to remove</param>
            <returns>The number of instances removed (0 if none).</returns>
            <remarks>This method is not optimized. It takes twice as long as 
            <see cref="M:Loyc.Collections.BList`1.Remove(`0)"/> if there is only one instance, because the 
            tree is searched twice.</remarks>
        </member>
        <member name="M:Loyc.Collections.BList`1.Do(Loyc.Collections.AListOperation,`0@)">
            <summary>Adds, removes, or replaces an item in the list.</summary>
            <param name="mode">Indicates the operation to perform.</param>
            <param name="item">An item to be added or removed in the list. If the
            item is passed by reference, and a matching item existed in the tree
            already, this method returns the old version of the item via this 
            parameter.</param>
            <returns>Returns the change in Count: 1 if the item was added, -1 if
            the item was removed, and 0 if the item replaced an existing item or 
            if nothing happened.</returns>
        </member>
        <member name="M:Loyc.Collections.BList`1.Do(Loyc.Collections.AListOperation,`0)">
            <inheritdoc cref="M:Loyc.Collections.BList`1.Do(Loyc.Collections.AListOperation,`0)"/>
        </member>
        <member name="M:Loyc.Collections.BList`1.Loyc#Collections#IAddRange{T}#AddRange(System.Collections.Generic.IReadOnlyCollection{`0})">
            <summary>Adds a set of items to the list, one at a time.</summary>
            <param name="e">A list of items to be added.</param>
            <returns>Returns the number of items that were added.</returns>
            <seealso cref="M:Loyc.Collections.BList`1.DoRange(Loyc.Collections.AListOperation,System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Loyc.Collections.BList`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>Adds a set of items to the list, one at a time.</summary>
            <param name="e">A list of items to be added.</param>
            <returns>Returns the number of items that were added.</returns>
            <seealso cref="M:Loyc.Collections.BList`1.DoRange(Loyc.Collections.AListOperation,System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Loyc.Collections.BList`1.RemoveRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>Removes a set of items from the list, one at a time.</summary>
            <param name="e">A list of items to be removed.</param>
            <returns>Returns the number of items that were found and removed.</returns>
            <seealso cref="M:Loyc.Collections.BList`1.DoRange(Loyc.Collections.AListOperation,System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Loyc.Collections.BList`1.DoRange(Loyc.Collections.AListOperation,System.Collections.Generic.IEnumerable{`0})">
            <summary>Performs the same operation for each item in a series.
            Equivalent to calling <see cref="M:Loyc.Collections.BList`1.Do(Loyc.Collections.AListOperation,`0)"/> on each item.</summary>
            <param name="mode">Indicates the operation to perform.</param>
            <param name="e">A list of items to act upon.</param>
            <returns>Returns the change in Count: positive if items were added,
            negative if items were removed, and 0 if all items were unchanged or
            replaced.</returns>
        </member>
        <member name="M:Loyc.Collections.BList`1.Clone">
            <inheritdoc cref="M:Loyc.Collections.BList`1.Clone(System.Boolean)"/>
        </member>
        <member name="M:Loyc.Collections.BList`1.Clone(System.Boolean)">
            <summary>Clones a BList.</summary>
            <param name="keepListChangingHandlers">If true, ListChanging handlers
            will be copied from the existing list of items to the new list. Note: 
            if it exists, the NodeObserver is never copied. 
            <see cref="!:NodeObserver"/> will be null in the new list.</param>
            <remarks>
            Cloning is performed in O(1) time by marking the tree root as frozen 
            and sharing it between the two lists. However, the new list itself will 
            not be frozen, even if the original list was marked as frozen. Instead,
            nodes will be copied on demand when you modify the new list.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.BList`1.IndexOf(`0)">
            <summary>Finds the lowest index of an item that is equal to or greater than the specified item.</summary>
            <param name="item">Item to find.</param>
            <returns>The lower-bound index, or Count if the item is greater than all items in the list.</returns>
        </member>
        <member name="M:Loyc.Collections.BList`1.Contains(`0)">
            <summary>Returns true if the list contains the specified item, and false if not.</summary>
        </member>
        <member name="M:Loyc.Collections.BList`1.FindLowerBound(`0)">
            <summary>Finds the lowest index of an item that is equal to or greater than the specified item.</summary>
            <param name="item">The item to find. If passed by reference, when this 
            method returns, item is set to the item that was found, or to the next 
            greater item if the item was not found. If the item passed in is higher 
            than all items in the list, it will be left unchanged when this method 
            returns.</param>
            <param name="found">Set to true if the item was found, false if not.</param>
            <returns>The index of the item that was found, or of the next
            greater item, or Count if the given item is greater than all items 
            in the list.</returns>
        </member>
        <member name="M:Loyc.Collections.BList`1.FindLowerBound(`0,System.Boolean@)">
            <inheritdoc cref="M:Loyc.Collections.BList`1.FindLowerBound(`0)"/>
        </member>
        <member name="M:Loyc.Collections.BList`1.FindLowerBound(`0@)">
            <inheritdoc cref="M:Loyc.Collections.BList`1.FindLowerBound(`0)"/>
        </member>
        <member name="M:Loyc.Collections.BList`1.FindLowerBound(`0@,System.Boolean@)">
            <inheritdoc cref="M:Loyc.Collections.BList`1.FindLowerBound(`0)"/>
        </member>
        <member name="M:Loyc.Collections.BList`1.FindUpperBound(`0)">
            <summary>Finds the index of the first item in the list that is greater 
            than the specified item.</summary>
            <param name="item">The item to find. If passed by reference, when this 
            method returns, item is set to the next greater item than the item you 
            searched for, or left unchanged if there is no greater item.</param>
            <param name="index">The index of the next greater item that was found,
            or Count if the given item is greater than all items in the list.</param>
            <returns></returns>
        </member>
        <member name="M:Loyc.Collections.BList`1.IndexOfExact(`0)">
            <summary>
            Specialized search function that finds the index of an item that not 
            only compares equal to the specified item according to the comparison 
            function for this collection, but is also equal according to 
            <see cref="M:System.Object.Equals(System.Object)"/>. This function works properly even if 
            duplicate items exist in addition that do NOT compare equal according 
            to <see cref="M:System.Object.Equals(System.Object)"/>.
            </summary>
            <remarks>
            This method is useful when the items in this collection are sorted by
            hashcode, or when they are sorted by key but not sorted by value. In 
            such cases, two items may be equal according to the comparison function 
            but unequal in reality.
            <para/>
            Implementation note: this method does a scan across the equal items to
            find the correct one, unlike the search technique controlled by
            <see cref="F:Loyc.Collections.Impl.AListSingleOperation`2.RequireExactMatch"/>, which is
            not guaranteed to work in case of duplicates.
            </remarks>
        </member>
        <member name="F:Loyc.Collections.Impl.BListInner`2._highestKey">
            <summary>Stores the highest key that applies to the node with the same index.</summary>
        </member>
        <member name="M:Loyc.Collections.Impl.BListInner`2.BinarySearchK(`0,System.Func{`0,`0,System.Int32})">
            <summary>Performs a binary search for a key.</summary>
            <remarks>If the key matches one of the values of _aggregateKey, this
            method returns the index of the lowest node that contains that key so 
            that non-add operations work correctly. If we were concerned ONLY with 
            plain Add operations, it would be acceptable to return index i+1 
            when key equals _aggregateKey[i] (and perhaps preferable, because it
            guarantees that _aggregateKey[i] won't have to be updated).</remarks>
        </member>
        <member name="T:Loyc.Collections.Impl.BListLeaf`2">
            <summary>
            Leaf node of <see cref="T:Loyc.Collections.BList`1"/>.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Loyc.Collections.Impl.BListLeaf`2.SplitAndAdd(Loyc.Collections.Impl.AListSingleOperation{`0,`1}@,Loyc.Collections.Impl.AListNode{`0,`1}@,Loyc.Collections.Impl.AListNode{`0,`1}@)">
            <summary>Called by DoSingleOperation to split a full node, then retry the add operation.</summary>
            <remarks>Same arguments and return value as DoSingleOperation.</remarks>
        </member>
        <member name="T:Loyc.Collections.BMultiMap`2">
            <summary>
            An sorted dictionary that allows multiple values to be associated with a
            single key. Note: both keys and values must be comparable.
            </summary>
            <remarks>
            Often when people want to be able to associate multiple values with a 
            single key, they use a Dictionary with values of type <see cref="T:System.Collections.Generic.List`1"/>.
            This approach is very inefficient (in terms of memory use) if most keys are 
            only associated with one or two values; this class solves the problem using
            a single sorted B+ tree for all keys and all values. It requires, however,
            that both the keys and values are totally ordered (i.e. are sortable).
            <para/>
            By default, keys and values are sorted using <see cref="P:System.Collections.Generic.Comparer`1.Default"/>.
            This will work provided that the keys and values both implement the
            <see cref="T:System.IComparable`1"/> interface. If they don't, you can pass custom 
            comparison functions to the constructor instead (one comparison function for
            keys, and a second one for values).
            <para/>
            Since it is derived from <see cref="T:Loyc.Collections.BList`1"/>, this class enjoys the space 
            efficiency of a B+ tree and capabilities of a <see cref="T:Loyc.Collections.AListBase`2"/>, 
            although it tends to be slower than <see cref="T:System.Collections.Generic.Dictionary`2"/>.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.BMultiMap`2.AddIfUnique(`0,`1)">
            <summary>Adds a key-value pair if there is not already a pair that compares equal to the new one.</summary>
            <returns>True if the pair was added, or false if it already existed.</returns>
        </member>
        <member name="M:Loyc.Collections.BMultiMap`2.ContainsKey(`0)">
            <summary>Finds out whether the specified key is present.</summary>
            <param name="key">Key to search for</param>
            <returns>Returns true if the dictionary contains at least one key-
            value pair in which the key compares equal to the specified key.</returns>
        </member>
        <member name="M:Loyc.Collections.BMultiMap`2.FirstIndexOf(`0)">
            <summary>Finds the lowest index of an item with the specified key.</summary>
            <param name="key">Key to search for</param>
            <returns>The index of the item that was found, or -1 if there is no such item.</returns>
            <remarks>This method is like <see cref="M:Loyc.Collections.BMultiMap`2.FindLowerBound(`0)"/> except that 
            it returns -1 if the key was not found.</remarks>
        </member>
        <member name="M:Loyc.Collections.BMultiMap`2.RemoveAny(`0)">
            <summary>Removes one pair from the collection that matches the specified key.</summary>
            <returns>True if a pair was removed, or false if the key was not found.</returns>
        </member>
        <member name="M:Loyc.Collections.BMultiMap`2.Remove(`0,System.Int32)">
            <summary>Removes up to a specified number of items from the collections 
            that have the specified key.</summary>
            <param name="key">The key to remove.</param>
            <param name="maxToRemove">Maximum number of items to remove.</param>
            <returns>The number of items removed.</returns>
        </member>
        <member name="M:Loyc.Collections.BMultiMap`2.RemoveAll(`0)">
            <summary>Removes all the items from the collection whose key compares 
            equal to the specified key.</summary>
            <param name="key">The key to remove.</param>
            <returns>The number of items removed.</returns>
        </member>
        <member name="M:Loyc.Collections.BMultiMap`2.TryGetValue(`0,`1@)">
            <summary>Finds a value associated with the specified key.</summary>
            <param name="key">Key to find</param>
            <param name="value">Set to the first (lowest) value associated with the
            key, or default(V) if the key was not found.</param>
            <returns>True if the key was found, false if not.</returns>
        </member>
        <member name="M:Loyc.Collections.BMultiMap`2.FindLowerBound(`0)">
            <summary>Finds the lowest index of an item that is equal to or greater than the specified item.</summary>
            <param name="key">The key to find.</param>
            <param name="value">The first value associated with the specified key,
            if the key was found, or default(V) if not.</param>
            <param name="found">Set to true if the item was found, false if not.</param>
            <returns>The index of the item that was found, or of the next greater
            item, or Count if the given key is greater than the keys of all items 
            in the list.</returns>
        </member>
        <member name="M:Loyc.Collections.BMultiMap`2.FindLowerBound(`0,System.Boolean@)">
            <inheritdoc cref="M:Loyc.Collections.BMultiMap`2.FindLowerBound(`0)"/>
        </member>
        <member name="M:Loyc.Collections.BMultiMap`2.FindLowerBound(`0,`1@,System.Boolean@)">
            <inheritdoc cref="M:Loyc.Collections.BMultiMap`2.FindLowerBound(`0)"/>
        </member>
        <member name="M:Loyc.Collections.BMultiMap`2.FindUpperBound(`0)">
            <summary>Finds the index of the first item in the list that is greater 
            than the specified item.</summary>
            <param name="item">The item to find. If passed by reference, when this 
            method returns, item is set to the next greater item than the item you 
            searched for, or left unchanged if there is no greater item.</param>
            <param name="index">The index of the next greater item that was found,
            or Count if the given item is greater than all items in the list.</param>
            <returns></returns>
        </member>
        <member name="M:Loyc.Collections.BMultiMap`2.FindLowerBoundExact(`0@,`1@,System.Boolean@)">
            <summary>Does the same thing as <see cref="M:Loyc.Collections.BMultiMap`2.IndexOfExact(`0)"/>, but with 
            the same set of arguments as <see cref="M:Loyc.Collections.BMultiMap`2.FindLowerBound(`0)"/> including
            the value associated with the matching key.</summary>
            <returns>Lowest index of a matching item if found, or the same return 
            value as <see cref="M:Loyc.Collections.BMultiMap`2.FindLowerBound(`0)"/> if not found.</returns>
        </member>
        <member name="M:Loyc.Collections.BMultiMap`2.IndexOfExact(`0)">
            <summary>
            Specialized search function that finds the first index of an item whose 
            key compares equal to the specified key, not only according to the 
            comparison function for this collection, but also according to 
            <see cref="M:System.Object.Equals(System.Object)"/>. This function works properly even if 
            duplicate keys exist in addition that do NOT compare equal according 
            to <see cref="M:System.Object.Equals(System.Object)"/>.
            </summary>
            <remarks>
            This method is useful when the items in this collection are sorted by
            hashcode (which is usually a bad idea, but occasionally useful).
            </remarks>
        </member>
        <member name="P:Loyc.Collections.BMultiMap`2.Item(`0)">
            <summary>Gets a collection associated with the specified key.</summary>
            <param name="key"></param>
            <returns>A synthetic collection associated with the specified key.</returns>
            <remarks>This property always succeeds and does not actually search
            for the key you requested. It returns an object that represents the
            set of values associated with a key, but those values are not actually
            retrieved from the collection until you enumerate the collection.</remarks>
            <seealso cref="T:Loyc.Collections.BMultiMap`2.Values"/>
        </member>
        <member name="T:Loyc.Collections.BMultiMap`2.Values">
            <summary>Represents the set of values associated with a particular key 
            in a <see cref="T:Loyc.Collections.BMultiMap`2"/> collection.</summary>
        </member>
        <member name="M:Loyc.Collections.BMultiMap`2.Values.Add(`1)">
            <summary>Adds a new item associated with the key that this object 
            represents. Allows duplicate values.</summary>
            <param name="item">Value to add.</param>
        </member>
        <member name="T:Loyc.Collections.Impl.EmptySpace`1">
            <summary>Represents a list of default(T) values.</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Loyc.Collections.Impl.AListTreeObserverExt">
            <summary>Helper methods for <see cref="T:Loyc.Collections.Impl.IAListTreeObserver`2"/>.</summary>
        </member>
        <member name="T:Loyc.Collections.IndexedAList`1">
            <summary>
            A simple wrapper around AList that includes an <see cref="T:Loyc.Collections.Impl.AListIndexer`2"/> 
            that can be used to find items relatively quickly in a large list. When an
            index is built and the list is large, it accelerates IndexOf(item), 
            Contains(item) and Remove(item).
            </summary>
            <remarks>
            The <see cref="M:Loyc.Collections.IndexedAList`1.IndexOf(`0)"/>, <see cref="!:Remove"/> and <see cref="!:Contains"/>
            methods are accelerated by the indexer, but please note that the indexer
            is expensive in terms of memory usage and CPU time. In total, once the 
            index has been built, IndexedAList typically uses about three times as
            much memory as a plain <see cref="T:Loyc.Collections.AList`1"/>. Moreover, changing the list 
            takes at least twice as much time, since the indexer must be updated to 
            reflect every change.
            <para/>
            An IndexedAList is indexed by default, but if necessary the index can be 
            disabled in the constructor or by settings the <see cref="P:Loyc.Collections.IndexedAList`1.IsIndexed"/> 
            property to false.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.IndexedAList`1.IndexOf(`0)">
            <summary>Finds an index of an item in the list.</summary>
            <param name="item">An item for which to search.</param>
            <returns>An index of the item. If the list contains duplicates of the 
            item, this method does not necessarily return the lowest index of the 
            item.</returns>
            <remarks>
            If IsIndexed is false, an index is created unless the list is short 
            (specifically, an index is created if the root node is not a leaf.)
            </remarks>
        </member>
        <member name="M:Loyc.Collections.IndexedAList`1.IndexesOf(`0,System.Boolean)">
            <summary>Returns a list of indexes at which the specified item can be found.</summary>
            <param name="item">Item to find in the list</param>
            <param name="sorted">Whether to sort the list of indexes before returning it.</param>
            <remarks>If IsIndexed is false, an index is created.</remarks>
        </member>
        <member name="M:Loyc.Collections.IndexedAList`1.VerifyCorrectness">
            <inheritdoc cref="M:Loyc.Collections.Impl.AListIndexer`2.VerifyCorrectness"/>
        </member>
        <member name="P:Loyc.Collections.IndexedAList`1.IsIndexed">
            <summary>Indicates whether the AList is indexed.</summary>
            <remarks>
            You can set this property to false to discard the index if it has been 
            built, or set it to true to create a new index if it has not yet been
            built (which takes O(N log N) where N is the <see cref="!:Count"/> of 
            this list).
            </remarks>
        </member>
        <member name="T:Loyc.Collections.SparseAList`1">
            <summary>A sparse A-List that implements <see cref="T:Loyc.Collections.ISparseList`1"/>.</summary>
            <remarks>
            The sparse A-List is implemented similarly to a normal A-List; the main 
            difference is that leaf nodes have a list of (int, T) pairs rather than
            a list of T values. The integers represent the relative index of each T
            value, as an offset from the beginning of the node. This allows an 
            arbitrary amount of empty space to exist between each T value in the
            list, making it sparse.
            <para/>
            <c>SparseAList</c> is a precise sparse list, meaning that you can rely on 
            it to keep track of which indexes are "set" and which are "empty" (the 
            <see cref="M:Loyc.Collections.SparseAList`1.IsSet(System.Int32)"/> method tells you which).
            </remarks>
        </member>
        <member name="M:Loyc.Collections.SparseAList`1.Swap(Loyc.Collections.SparseAList{`0})">
            <summary>Swaps the contents of two <see cref="T:Loyc.Collections.SparseAList`1"/>s in O(1) time.</summary>
            <remarks>Any observers are also swapped.</remarks>
        </member>
        <member name="M:Loyc.Collections.SparseAList`1.Append(Loyc.Collections.SparseAList{`0})">
            <inheritdoc cref="M:Loyc.Collections.AList`1.Append(Loyc.Collections.AList{`0},System.Boolean)"/>
        </member>
        <member name="M:Loyc.Collections.SparseAList`1.Append(Loyc.Collections.SparseAList{`0},System.Boolean)">
            <inheritdoc cref="M:Loyc.Collections.AList`1.Append(Loyc.Collections.AList{`0},System.Boolean)"/>
        </member>
        <member name="M:Loyc.Collections.SparseAList`1.Prepend(Loyc.Collections.SparseAList{`0})">
            <summary>Prepends an AList to this list in sublinear time.</summary>
            <param name="other">A list of items to be added to the front of this list (at index 0).</param>
            <inheritdoc cref="M:Loyc.Collections.SparseAList`1.Append(Loyc.Collections.SparseAList{`0},System.Boolean)"/>
        </member>
        <member name="M:Loyc.Collections.SparseAList`1.Prepend(Loyc.Collections.SparseAList{`0},System.Boolean)">
            <summary>Prepends an AList to this list in sublinear time.</summary>
            <param name="other">A list of items to be added to the front of this list (at index 0).</param>
            <inheritdoc cref="M:Loyc.Collections.SparseAList`1.Append(Loyc.Collections.SparseAList{`0},System.Boolean)"/>
        </member>
        <member name="M:Loyc.Collections.Impl.CPNode`1.MoveFirst(Loyc.Collections.Impl.CPEnumerator{`0})">
            <summary>Sets up the specified enumerator to point at the first item in
            this node.</summary>
            <remarks>
            On entry to the method, e.Key.Buffer[0..e.Key.Offset] specifies the
            prefix on all keys in the node. On exit, e.Key.Offset should remain the
            same unless MoveFirst was called on a child node.
            <para/>
            This method
            (1) Add()s an Entry to e.Stack pointing to the first (lowest) item in 
                the node, using e.Key.Offset as the value of Entry.KeyOffset;
            (2) extracts the key to e.Key such that e.Key.Offset+e.Key.Left is the
                length of the complete key (if e.Key.Buffer is too small, it is
                copied to a larger buffer as needed);
            (3) if the current item points to a child, this method advances e.Key 
                to the end of the key so that e.Key.Left is 0, and calls MoveFirst 
                on the child;
            (4) otherwise, this method leaves e.Key.Offset equal to
                e.Stack.Last.KeyOffset, so that e.Key.Left is the number of bytes
                of the key that are stored in this node.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.Impl.CPNode`1.MoveLast(Loyc.Collections.Impl.CPEnumerator{`0})">
            <summary>Does the same thing as MoveFirst except that the last item is
            retrieved instead of the first one.</summary>
        </member>
        <member name="M:Loyc.Collections.Impl.CPNode`1.MoveNext(Loyc.Collections.Impl.CPEnumerator{`0})">
            <summary>Moves to the next item in the node.</summary>
            <returns>Returns true if the next item was extracted or false if the 
            end of the node was reached.</returns>
            <remarks>
            Upon entry to this method, e.Stack.Last.Node == this
                                   and e.Stack.Last.KeyOffset == e.Key.Offset.
            <para/>
            This method
            (1) increases e.Stack.Last.Index to point to the next item in the node;
            (2) returns false if Index has advanced past the last item in the node;
            (3) otherwise, repeats steps (2)-(4) in the documentation of
                MoveFirst() and returns true.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.Impl.CPNode`1.MovePrev(Loyc.Collections.Impl.CPEnumerator{`0})">
            <summary>Does the same thing as MovePrev except that it moves to the
            previous item instead of the next item.</summary>
        </member>
        <member name="M:Loyc.Collections.Impl.CPBitArrayLeaf`1.MoveFirst(Loyc.Collections.Impl.CPEnumerator{`0})">
            (1) Add()s an Entry to e.Stack pointing to the first (lowest) item in 
                the node, using e.Key.Offset as the value of Entry.KeyOffset;
            (2) extracts the key to e.Key such that e.Key.Offset+e.Key.Left is the
                length of the complete key (if e.Key.Buffer is too small, it is
                copied to a larger buffer as needed);
            (3) if the current item points to a child, this method advances e.Key 
                to the end of the key so that e.Key.Left is 0, and calls MoveFirst 
                on the child;
            (4) otherwise, this method leaves e.Key.Offset equal to
                e.Stack.Last.KeyOffset, so that e.Key.Left is the number of bytes
                of the key that are stored in this node.
        </member>
        <member name="T:Loyc.Collections.Impl.CPBNode`1">
            <summary>This CPTrie "bitmap" node splits the 8-bit alphabet space into 8
            buckets of 5 bytes each; a CPSNode is used to store the keys in each
            bucket.</summary>
            <typeparam name="T">Type of values associated with each key</typeparam>
        </member>
        <member name="F:Loyc.Collections.Impl.CPBNode`1._zlk">
            <summary>The value associated with a zero-length key, if any, is stored
            here directly rather than in any of the children.</summary>
        </member>
        <member name="T:Loyc.Collections.Impl.CPByteTrie`1">
            <summary>A compact patricia trie that uses byte arrays as keys.</summary>
            <typeparam name="TValue">Type of value associated with each key.</typeparam>
        </member>
        <member name="T:Loyc.Collections.CPTrie`1">
            <summary>Compact patricia tree class that stores keys as byte arrays.
            This class is intended to be use as a base class; a derived class can
            give meaning to the byte arrays, e.g. CPStringTrie encodes strings into
            byte arrays so they can be placed in the trie.</summary>
            <typeparam name="T">Type of values to be associated with the keys. CPTrie
            can save memory if many or all values are null; therefore, if you wish
            to store a set rather than a dictionary, set T=object and associate null
            with every key.</typeparam>
        </member>
        <member name="M:Loyc.Collections.CPTrie`1.StringToBytes(System.String)">
            <summary>Converts a string to a sequence of bytes suitable for use in 
            the trie. For speed, a simplified UTF-8 encoding is used, where 
            surrogate pairs are not specially handled.</summary>
            <param name="key">Key to convert to bytes.</param>
            <returns>The key encoded in bytes.</returns>
        </member>
        <member name="M:Loyc.Collections.CPTrie`1.BytesToString(System.Byte[],System.Int32)">
            <summary>Converts a sequence of bytes (key[0..keyLength-1]) that was 
            previously encoded with StringToBytes to a string</summary>
            <remarks>The buffer length is not relevant, as this method may store 
            the key in a scratch buffer that is longer than the key; therefore
            the second parameter specifies the length.</remarks>
        </member>
        <member name="M:Loyc.Collections.CPTrie`1.Find(Loyc.Collections.Impl.KeyWalker@,`0@)">
            <summary>
            Retrieves the value associated with the specified key; does nothing if
            the key does not exist.
            </summary>
            <returns>Returns true if the key was found.</returns>
        </member>
        <member name="M:Loyc.Collections.CPTrie`1.Set(Loyc.Collections.Impl.KeyWalker@,`0@,Loyc.Collections.Impl.CPMode)">
            <summary>
            Associates the specified value with the specified key.
            </summary>
            <param name="key">A key to find or create; if key.Offset > 0, bytes
            before that offset are ignored.</param>
            <param name="value">Value to assign to the node, depending on the value
            of mode. On return, value is set to the previous value for the given key.</param>
            <param name="mode">Specifies whether to create an entry if the key is
            not present, and whether to change an existing entry. If mode is Find,
            Set() only retrieves an existing value; it does not change the trie.</param>
            <returns>Returns true if the specified key already existed and false if 
            it did not.</returns>
        </member>
        <member name="M:Loyc.Collections.CPTrie`1.Remove(Loyc.Collections.Impl.KeyWalker@,`0@)">
            <summary>
            Removes the specified key and associated value.
            </summary>
            <param name="key">Key to find; if key.Offset > 0, bytes before that 
            offset are ignored.</param>
            <param name="value">If the key was found, its associated value is
            stored in this parameter; otherwise, the parameter is left unchanged.</param>
            <returns>Returns true if the specified key was found and removed.</returns>
        </member>
        <member name="M:Loyc.Collections.CPTrie`1.CountMemoryUsage(System.Int32)">
            <summary>Calculates the memory usage of this object, assuming a 32-bit
            architecture.</summary>
            <param name="sizeOfT">Size of data type T. CountMemoryUsage doesn't use
            sizeof(T), as it would force the code to be marked "unsafe".</param>
            <returns>Estimated number of bytes used by this object</returns>
        </member>
        <member name="M:Loyc.Collections.Impl.CPByteTrie`1.Add(System.Byte[],`0)">
            <summary>Adds the specified key-value pair to the trie, throwing an
            exception if the key is already present.</summary>
        </member>
        <member name="M:Loyc.Collections.Impl.CPByteTrie`1.Add(System.Byte[],System.Int32,System.Int32,`0)">
            <summary>Adds the specified key-value pair to the trie, throwing an
            exception if the key is already present.</summary>
            <param name="key">An array that contains the key to add. The offset
            and length parameters specify a substring of this array to use as the key.</param>
        </member>
        <member name="M:Loyc.Collections.Impl.CPByteTrie`1.TryAdd(System.Byte[],`0)">
            <summary>Adds the specified key-value pair only if the specified key is
            not already present in the trie.</summary>
            <param name="value">A value to associate with the specified key if the
            key does not already exist.</param>
            <returns>Returns true if the key-value pair was added or false if
            the key already existed. In the false case, the trie is not modified.</returns>
        </member>
        <member name="M:Loyc.Collections.Impl.CPByteTrie`1.TryAdd(System.Byte[],System.Int32,System.Int32,`0@)">
            <summary>Adds the specified key-value pair only if the specified key is
            not already present in the trie.</summary>
            <param name="key">An array that contains the key to find. The offset
            and length parameters specify a substring of this array to use as the key.</param>
            <param name="value">On entry, value specifies the value to associate
            with the specified key, but if the key already exists, value is changed
            to the value associated with the existing key.</param>
            <returns>Returns true if the key-value pair was added or false if
            the key already existed. In the false case, the trie is not modified.</returns>
        </member>
        <member name="M:Loyc.Collections.Impl.CPByteTrie`1.ContainsKey(System.Byte[])">
            <summary>Searches for the specified key, returning true if it is
            present in the trie.</summary>
        </member>
        <member name="M:Loyc.Collections.Impl.CPByteTrie`1.ContainsKey(System.Byte[],System.Int32,System.Int32)">
            <summary>Searches for the specified key, returning true if it is
            present in the trie.</summary>
            <param name="key">An array that contains the key to find. The offset
            and length parameters specify a substring of this array to use as the key.</param>
        </member>
        <member name="M:Loyc.Collections.Impl.CPByteTrie`1.Remove(System.Byte[])">
            <summary>Removes the specified key and associated value, returning true
            if the entry was found and removed.</summary>
        </member>
        <member name="M:Loyc.Collections.Impl.CPByteTrie`1.Remove(System.Byte[],System.Int32,System.Int32,`0@)">
            <summary>Removes the specified key and associated value, returning true
            if the entry was found and removed.</summary>
            <param name="key">An array that contains the key to find. The offset
            and length parameters specify a substring of this array to use as the key.</param>
            <param name="oldValue">If the key is found, the associated value is
            assigned to this parameter. Otherwise, this parameter is not changed.</param>
        </member>
        <member name="M:Loyc.Collections.Impl.CPByteTrie`1.TryGetValue(System.Byte[],`0@)">
            <summary>Finds the specified key and gets its associated value,
            returning true if the key was found.</summary>
        </member>
        <member name="P:Loyc.Collections.Impl.CPByteTrie`1.Item(System.Byte[],`0)">
            <summary>Finds the specified key and returns its associated value. If 
            the key did not exist, TryGetValue returns defaultValue instead.</summary>
        </member>
        <member name="P:Loyc.Collections.Impl.CPEnumerator`1.IsValid">
            <summary>Returns true if this enumerator points to an item and Current
            is valid.</summary>
        </member>
        <member name="T:Loyc.Collections.Impl.CPIntTrie`1">
            <summary>A trie that supports signed and unsigned keys with sizes up to 64
            bits. Special encodings are used to preserve the sort order among integers
            of different sizes while using variable-length keys.</summary>
            <typeparam name="TValue">Type of value associated with each key.</typeparam>
            <remarks>This trie allows you to insert integers of different sizes. Two
            integers of different sizes that have the same value are considered
            equivalent. You can insert a key as an Int16, then extract it as an Int32,
            for example.
            <para/>
            This collection implements two versions of IDictionary: one using Int32
            keys and another using Int64 keys. When calling a method on the class
            itself (i.e. not on an interface), Int64 is used in case of ambiguity (for
            example, GetEnumerator() doesn't know if you want to decode the keys into
            Int32 or Int64, so it uses Int64.) When not accessing CPIntTrie through an
            interface, most methods accept any of the following integer types: Int16,
            UInt16, Int32, UInt32, Int64, UInt64.
            <para/>
            The trie does not choose the key length based on an integer's size (e.g.
            Int32 or Int64), rather it is chosen based on the key's magnitude. Keys
            ranging from -0x10000 to 0xFAFFFF are encoded most compactly (usually in one
            4-byte cell); 40-bit keys as low as -0xFFFFFFFFFF and as high as
            0xFFFFFFFFFF are usually encoded in 2 cells; and all larger keys require 3 
            cells.
            <para/>
            I say "usually" because normally CPSNode can hold 3 bytes per cell, but
            keys whose low-order byte is 0xFD, 0xFE or 0xFF require one extra cell.
            <para/>
            Negative 64-bit numbers can be held in the same trie as unsigned 64-bit 
            numbers; therefore, there is no way to represent all keys using a single
            primitive data type. The LongEnumerator returns Int64s, and you will find 
            that if a huge unsigned number like 0x8877665544332211 is in the trie, it 
            will come out as a negative Int64. To find out whether the long number is 
            signed or unsigned, call ContainsKey(Int64) - if it returns true, the
            number is signed, otherwise it is unsigned (so its signed representation
            was not found). If it is unsigned, convert the key returned by the
            enumerator to UInt64.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.Impl.CPIntTrie`1.TryAdd(System.Int32,`0)">
            <summary>Adds the specified key-value pair only if the specified key is
            not already present in the trie.</summary>
            <param name="value">A value to associate with the specified key if the
            key does not already exist.</param>
            <returns>Returns true if the key-value pair was added or false if
            the key already existed. In the false case, the trie is not modified.</returns>
        </member>
        <member name="M:Loyc.Collections.Impl.CPIntTrie`1.TryAdd(System.Int32,`0@)">
            <summary>Adds the specified key-value pair only if the specified key is
            not already present in the trie.</summary>
            <param name="value">On entry, value specifies the value to associate
            with the specified key, but if the key already exists, value is changed
            to the value associated with the existing key.</param>
            <returns>Returns true if the key-value pair was added or false if
            the key already existed. In the false case, the trie is not modified.</returns>
        </member>
        <member name="M:Loyc.Collections.Impl.CPIntTrie`1.Add(System.Int32,`0)">
            <summary>Adds the specified key-value pair to the trie, throwing an
            exception if the key is already present.</summary>
        </member>
        <member name="M:Loyc.Collections.Impl.CPIntTrie`1.ContainsKey(System.Int32)">
            <summary>Searches for the specified key, returning true if it is
            present in the trie.</summary>
        </member>
        <member name="M:Loyc.Collections.Impl.CPIntTrie`1.Remove(System.Int32)">
            <summary>Removes the specified key and associated value, returning true
            if the entry was found and removed.</summary>
        </member>
        <member name="M:Loyc.Collections.Impl.CPIntTrie`1.Remove(System.Int32,`0@)">
            <summary>Removes the specified key and associated value, returning true
            if the entry was found and removed.</summary>
            <param name="key">Key to remove.</param>
            <param name="oldValue">If the key is found, the associated value is
            assigned to this parameter. Otherwise, this parameter is not changed.</param>
        </member>
        <member name="M:Loyc.Collections.Impl.CPIntTrie`1.TryGetValue(System.Int32,`0@)">
            <summary>Finds the specified key and gets its associated value,
            returning true if the key was found.</summary>
        </member>
        <member name="P:Loyc.Collections.Impl.CPIntTrie`1.Item(System.Int32,`0)">
            <summary>Finds the specified key and returns its associated value. If 
            the key did not exist, returns defaultValue instead.</summary>
        </member>
        <member name="T:Loyc.Collections.Impl.SCell">
            <summary>Standard cell, used to encode keys in a CPSNode</summary>
        </member>
        <member name="T:Loyc.Collections.Impl.CPSNode`1">
            <summary>This CPTrie "sparse" or "standard" node stores up to 34 keys or
            partial keys and their associated values. See my CPTrie article on 
            CodeProject.com for more information.</summary>
            <typeparam name="T">Type of values associated with each key</typeparam>
        </member>
        <member name="M:Loyc.Collections.Impl.CPSNode`1.PrepareSpace(System.Int32,Loyc.Collections.Impl.CPNode{`0}@)">
            <summary>
            Makes sure there is a free cell at _count, and that there are enough 
            free cells for a new key of the specified length. Child node(s) are 
            created if necessary; in the worst case, the whole node is converted
            to a bitmap node.
            </summary>
            <param name="keyLeft"></param>
            <param name="self"></param>
            <returns>Returns the first index affected by any modifications, or -1 
            if 'self' changed</returns>
            <remarks>
            Sparse nodes are "reorganized" when they run out of free space, when
            Count reaches MaxCount, or when the number of values reaches 32.
            <para/>
            Well, actually if we run out of free space we can either reorganize, or
            allocate more space, unless the number of cells reaches MaxCells.
            <para/>
            Another problem that this method must address is what to do if there are
            enough free cells, but the cell at _count is in use. This problem only 
            occurs if there is fragmentation in the free cell list.  In that case an
            O(_count+_extraCellsUsed) scan would be needed to find who is using the 
            cell and relocate it, but it's easier (and not much slower) just to do 
            the same compaction process that is done when enlarging _cells.
            <para/>
            Compaction moves all free cells to the middle of the array, which helps
            ensure that when _count needs to increase, _cells[_count] is free.
            <para/>
            There are two "reorganizing" options:
            1. Create a child node to free up space (can be done repeatedly)
            2. Convert this node to a JPBitmap node (TODO)
            <para/>
            </remarks>
        </member>
        <member name="M:Loyc.Collections.Impl.CPSNode`1.ExtractKey(System.Int32,Loyc.Collections.Impl.KeyWalker@,System.Int32@)">
            <summary>Appends the key at the specified index to kw, allocating new 
            buffer space if needed.</summary>
            <param name="index">Index of the key to extract</param>
            <param name="kw">The key is written to kw starting at kw.Buffer[kw.Offset]</param>
            <param name="finalP">The value of LCell.P in the key's final cell.</param>
            <remarks>kw.Left is 0 on exit.</remarks>
        </member>
        <member name="M:Loyc.Collections.Impl.CPSNode`1.FindCommonPrefix(System.Int32@,System.Int32@,System.Int32@)">
            <summary>Finds the "best" common prefix to factor out into a child node.</summary>
            <param name="bestIndex">First index of a range of items with a common prefix</param>
            <param name="bestLength">Number of items with a common prefix (minimum 2)</param>
            <param name="bestPrefixBytes">Number of bytes this range of items has in common</param>
            <returns>An estimate of the number of cells that will be freed up by 
            creating a child node, or 0 if there are no common prefixes in this 
            node.</returns>
        </member>
        <member name="P:Loyc.Collections.Impl.CPSNode`1.CellInfo">
            <summary>Debugging aid: spits out the contents of each 4-byte cell</summary>
        </member>
        <member name="T:Loyc.Collections.CPStringTrie`1">
            <summary>A compact patricia trie that uses strings as keys.</summary>
            <typeparam name="TValue">Type of value associated with each key.</typeparam>
        </member>
        <member name="M:Loyc.Collections.CPStringTrie`1.TryAdd(System.String,`0)">
            <summary>Adds the specified key-value pair only if the specified key is
            not already present in the trie.</summary>
            <returns>Returns true if the key-value pair was added or false if
            the key already existed. In the false case, the trie is not modified.</returns>
        </member>
        <member name="M:Loyc.Collections.CPStringTrie`1.TryAdd(System.String,`0@)">
            <summary>Adds the specified key-value pair only if the specified key is
            not already present in the trie.</summary>
            <param name="value">On entry, value specifies the value to associate
            with the specified key, but if the key already exists, value is changed
            to the value associated with the existing key.</param>
            <returns>Returns true if the key-value pair was added or false if
            the key already existed. In the false case, the trie is not modified.</returns>
        </member>
        <member name="T:Loyc.Collections.CPStringTrie`1.Enumerator">
            <summary>Enumerates key-value pairs in a CPStringTrie.</summary>
            <remarks>Reading the key is more expensive than reading the value
            because the key must be decoded from the bytes it is made up of.
            If you call CurrentValue instead of Current or CurrentKey, the
            work of decoding the key will be avoided. If you only need to
            enumerate the values, enumerate the Values collection instead of 
            the trie class itself.
            </remarks>
        </member>
        <member name="T:Loyc.Collections.CPStringTrie`1.KeyEnumerator">
            <summary>Enumerates keys of a CPStringTrie.</summary>
            <remarks>
            Avoid calling Current more than once per key, as each call requires the
            key to be decoded from the bytes it is made up of.
            </remarks>
        </member>
        <member name="T:Loyc.Collections.CPValueCollection`1">
            <summary>Provides read-only access to the values of a CPTrie.</summary>
            <typeparam name="T">Type of values in the collection</typeparam>
        </member>
        <member name="M:Loyc.Collections.CPTrieBenchmark.GetIntClusters(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>Builds a set of clustered keys for benchmarking CPIntTrie.
            "clustered" means that keys come in groups called clusters. Keys in a
            cluster are near one other.</summary>
            <param name="clusterMax">Number of keys per cluster will be in the range clusterMax/2..clusterMax.</param>
            <param name="spacerMax">Each cluster is separated by a spacer of size 1..spacerMax.</param>
            <param name="clusterSpread">Difference between consecutive keys within the cluster is 1..clusterSpread.</param>
            <param name="numKeys">Number of keys total</param>
            <returns></returns>
        </member>
        <member name="M:Loyc.Collections.CPTrieBenchmark.GetLongClusters(System.Int32,System.Int32,System.Int64,System.Int32,System.Int64)">
            <summary>Same as GetIntClusters, but gets longs instead.</summary>
        </member>
        <member name="T:Loyc.Collections.CPTrieTests">
            <summary>
            Test suite for CPStringTrie, CPByteTrie and CPIntTrie
            </summary>
            <remarks>
            This is a fairly basic set of tests. Quite a few methods are untested,
            incuding the entire CPValueCollection, CPStringTrie.KeyCollection and
            CPByteTrie.KeyCollection classes. Also, the benchmark (CPTrieBenchmark) is
            meant to serve as a large-scale stress test, but there is no stress test
            for CPBNode, as the alphabet in the benchmark is not large enough to cause
            CPSNode to split into CPBNode.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.ByteArrayComparer.Compare(System.Byte[],System.Byte[])">
            <summary>Compares two byte arrays, returning -1 if A is less than B and
            1 if A is greater than B.</summary>
            <remarks>null is considered "less" than any non-null array.</remarks>
        </member>
        <member name="T:Loyc.Collections.Bijection`2">
            <summary>A bijection is a one-to-one function and its inverse. It is 
            implemented with a pair of dictionaries, one that maps K1 to K2 and
            another that maps K2 to K1.</summary>
            <typeparam name="K1">Default key.</typeparam>
            <typeparam name="K2">Inverse key.</typeparam>
            <remarks>
            The Bijection object that you first create is a dictionary from K1 to K2.
            Call the <see cref="P:Loyc.Collections.Bijection`2.Inverse"/> property to get the inverse dictionary from
            K2 back to K1. Whenever you modify one of the dictionaries, the other 
            dictionary is also modified in the same way. 
            <para/>
            For example, if you do this:
            <code>
              var map = new Bijection&lt;int,string&gt;() { { 1, "one" }, {2, "two"} };
              map.Add(3, "three");
              map.Inverse.Add("four", 4);
              map.Inverse.Remove("two");
            </code>
            Then the bijection will contain three pairs: <c>{1, "one"}, {3, "three"}</c> 
            and <c>{4, "four"}</c>. The inverse bijection object map.Inverse is "first-
            class" and can be used just like the original map. The two interfaces, <c>map</c>
            and <c>map.Inverse</c>, are linked to each other, so 
            <c>map.Inverse.Inverse == map</c>.
            <para/>
            This collection itself is not safe for multithreaded access, even if it is 
            constructed out of two <see cref="!:ConcurrentDictionary&lt;K,V&gt;"/> objects.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.Bijection`2.#ctor">
            <summary>Constructs a bijection out of two <see cref="T:System.Collections.Generic.Dictionary`2"/> objects.</summary>
        </member>
        <member name="M:Loyc.Collections.Bijection`2.#ctor(System.Int32)">
            <summary>Constructs a bijection out of two <see cref="T:System.Collections.Generic.Dictionary`2"/> 
            objects, each with the specified capacity.</summary>
        </member>
        <member name="M:Loyc.Collections.Bijection`2.#ctor(System.Collections.Generic.IReadOnlyCollection{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>Constructs a bijection out of two <see cref="T:System.Collections.Generic.Dictionary`2"/> 
            objects, copying the specified initial contents, and using the initial 
            Count as the capacity.</summary>
            <exception cref="T:Loyc.Collections.KeyAlreadyExistsException">The input had a duplicate key or value.</exception>
            <remarks>The bijection is mutable even though the input is not.</remarks>
        </member>
        <member name="M:Loyc.Collections.Bijection`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Int32)">
            <summary>Constructs a bijection out of two <see cref="T:System.Collections.Generic.Dictionary`2"/> 
            objects, copying the specified initial contents.</summary>
            <exception cref="T:Loyc.Collections.KeyAlreadyExistsException">The input had a duplicate key or value.</exception>
        </member>
        <member name="M:Loyc.Collections.Bijection`2.#ctor(System.Collections.Generic.IDictionary{`0,`1},System.Collections.Generic.IDictionary{`1,`0})">
            <summary>Constructs a bijection out of two existing dictionaries.</summary>
            <remarks>
            To save time, the constructor does not verify that the two dictionaries 
            are a proper bijection; instead it works "on the honor system", and only
            checks to ensure that the two dictionaries have the same <c>Count</c>. 
            The two dictionaries must already be a bijection (one-to-one maps into 
            each other) and should not be modified after they are attached to this
            object. Of course, you can supply two empty dictionaries of any type.
            </remarks>
        </member>
        <member name="P:Loyc.Collections.Bijection`2.Inverse">
            <summary>Returns the inverse dictionary. Note: <c>this.Inverse.Inverse == this</c>.</summary>
        </member>
        <member name="T:Loyc.Utilities.BloomFilterM64K2">
             <summary>A bloom filter for very small sets.</summary>
             <remarks>
             Please see the following article for an introduction to the bloom filter:
             
             http://www.devsource.com/c/a/Languages/Bloom-Filters-in-C/
             
             This bloom filter's parameters are m=64 and k=2, so it contains just a
             single long value. If item hashes are random, the false positive rate (p)
             is under 5% if the set contains no more than 8 items, and under 10% if the
             set holds no more than 12 items. This is according to the calculator at 
             
             http://www-static.cc.gatech.edu/~manolios/bloom-filters/calculator.html
            
             The two 6-bit hashes this filter uses are simply the lowest 12 bits of the
             hashcode.
             
             If this filter is used to hold Symbols, it should be noted that the IDs 
             are not random but sequentially allocated, so it is likely to have
             a different false positive rate. Tentatively, I believe the number of bits
             set will be higher, leading to a worse false positive rate on random
             membership tests; but when testing related inputs, the false positive rate
             should be lower than the worst case.
             
             In any case, this filter performs increasing poorly as the number of
             elements increases: at 40 items, p exceeds 50%.
             </remarks>
        </member>
        <member name="T:Loyc.Collections.Impl.KeylessHashtable`1">
            <summary>
            A fairly obscure space-saving hashtable that offers no built-in way to 
            store keys, only values. Because there are no keys, the hashtable cannot
            be rehashed when it is full, and searching for a given key finds all
            values in the same bucket, some of which may be unrelated.
            </summary>
            <remarks>
            My primary primary motivation for this data structure is compactness. It's 
            comparable to a "counting bloom filter", in that searching for a key can
            find false positives, but not false negatives, but it offers the additional
            feature that one or more values can be associated with each key.
            <para/>
            The size per entry dependends on the size of the hashtable. This data 
            structure is the most compact when its size is limited to 65536 entries and 
            buckets; its overhead doubles when you exceed this limit, since "shorts" 
            become "ints".
            <para/>
            The Count is allowed to exceed the Capacity, but it is not allowed to cross
            a size threshold (255 or 65535). Capacity returns the number of buckets,
            so if Count exceeds Capacity, it simply means there are more items than 
            buckets, so there will be a larger-than-normal amount of "false positives" 
            (multiple items will typically be returned from a search).
            <para/>
            The size requirement per entry is 2 bytes (plus sizeof(T)) for a table of
            size 255 or less, 4 bytes (plus sizeof(T)) for a table of size 65535 or 
            less, and 8 bytes (plus sizeof(T)) for larger tables. Prime number sizes
            are generally preferred for best performance.
            <para/>
            The memory for buckets (1-4 bytes) is allocated up-front, but other memory
            is allocated on-demand. For example, if you create a new hashtable with 
            capacity 251 and add 50 items, 251 bytes are allocated up-front, but less
            than 100 * (1+sizeof(T)) additional bytes are allocated.
            <para/>
            By its very nature, KeylessHashtable allows multiple values to be 
            associated with a single key.
            <para/>
            A normal hashtable could theoretically be built on top of this one by
            storing the key and value together in type T.
            </remarks>
        </member>
        <member name="T:Loyc.Collections.Impl.KeylessHashtable`3">
            <summary>The concrete implementation of <see cref="T:Loyc.Collections.Impl.KeylessHashtable`1"/>.
            Do not use directly; instead, call <see cref="M:Loyc.Collections.Impl.KeylessHashtable`1.New(System.Int32)"/>.</summary>
        </member>
        <member name="T:Loyc.Collections.SimpleCache`1">
            <summary>A cache designed to save memory by sharing instances of identical 
            strings and other immutable objects.</summary>
            <typeparam name="T"></typeparam>
            <remarks>
            SimpleCache is not thread safe. However, G.Cache() is.
            <para/>
            SimpleCache is used simply by calling Cache(). For example, if C is a 
            SimpleCache(of string), then C.Cache("Hello") adds the string "Hello" to 
            the cache if it is not present already, or returns the existing string if 
            it is.
            <para/>
            I'll describe SimpleCache as a two-way set associative hash cache. An object 
            O with some hashcode X is always located at one of two locations in the 
            cache: X%S or (X+1)%S, where S is the size of the hashtable. If C.Cache(O) 
            is called and O is not in the cache, O is always placed at position X%S. 
            If another object P with hash Y is added, and Y%S == X%S, then O is moved 
            to position (X+1)%S so that P can take the position. Thus, an object is only
            located in the "plus one" position if it was less recently used, and the 
            cache will choose to discard that object when necessary.
            <para/>
            The cache size doubles when the number of objects discarded (replacements) 
            reaches the cache size, provided that the cache is at least 50% used. The 
            initial size is normally 32, and the maximum size can be specified in the 
            constructor (default: 1024). Note that regardless of cache size, it is 
            impossible for three objects to be in the cache at the same time if they
            all share the same hash code. But on the plus side, if you alternate between 
            calling Cache(A) and Cache(B), for any A and B, you are guaranteed to get 
            only cache hits in steady-state. (To prove this, by the way, one must 
            consider not only when A and B have the same hash code, but when 
            A.GetHashCode() == B.GetHashCode() + 1).
            <para/>
            The algorithm is pretty simple--Cache() has no loops--so it should be quite 
            fast as well.
            <para/>
            TODO: try supporting hashtables with non-power-of-2 sizes for possible speedup.
            </remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Loyc.Collections.Impl.InternalSet`1" -->
        <member name="F:Loyc.Collections.Impl.InternalSet`1.Empty">
            <summary>An empty set.</summary>
            <remarks>This property comes with a frozen, empty root node,
            which <see cref="T:Loyc.Collections.Set`1"/> uses as an "initialized" flag.</remarks>
        </member>
        <member name="F:Loyc.Collections.Impl.InternalSet`1.DefaultComparer">
            <summary>This is <see cref="P:System.Collections.Generic.EqualityComparer`1.Default"/>, or
            null if T implements <see cref="T:Loyc.IReferenceComparable"/>.</summary>
        </member>
        <member name="M:Loyc.Collections.Impl.InternalSet`1.CloneFreeze">
            <summary>Freezes the hashtrie so that any further changes require paths 
            in the tree to be copied.</summary>
            <remarks>This is an O(1) operation. It causes all existing copies of 
            this <see cref="T:Loyc.Collections.Impl.InternalSet`1"/>, as well as any other copies you make
            in the future, to become independent of one another so that 
            modifications to one copy do not affect any of the others.
            <para/>
            To unfreeze the hashtrie, simply modify it as usual with (for example)
            a call to <see cref="M:Loyc.Collections.Impl.InternalSet`1.Add(`0@,System.Collections.Generic.IEqualityComparer{`0},System.Boolean)"/> or <see cref="M:Loyc.Collections.Impl.InternalSet`1.Remove(`0@,System.Collections.Generic.IEqualityComparer{`0})"/>, or call 
            <see cref="M:Loyc.Collections.Impl.InternalSet`1.Thaw"/>. Frozen parts of the trie are copied on-demand.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.Impl.InternalSet`1.Thaw">
            <summary>Thaws a frozen root node by duplicating it, or creates the 
            root node if the set doesn't have one.</summary>
            <remarks>Since <see cref="T:Loyc.Collections.Impl.InternalSet`1"/> is a structure rather
            than a class, it's not immediately obvious what the happens when you 
            copy it with the '=' operator. The <see cref="T:Loyc.Collections.Impl.InternalList`1"/> 
            structure, for example, it is unsafe to copy (in general) because
            as the list length changes, the two (or more) copies immediately
            go "out of sync" because each copy has a separate Count property 
            and a separate array pointer--and yet they will share the same array,
            at least temporarily, which can produce strange results.
            <para/>
            It is mostly safe to copy InternalSet instances, however, because 
            they only contain a single piece of data (a reference to the root
            node), and the root node only changes in two situations:
            <ol>
            <li>When the root node is null and you call <see cref="M:Loyc.Collections.Impl.InternalSet`1.Add(`0@,System.Collections.Generic.IEqualityComparer{`0},System.Boolean)"/> or this method</li>
            <li>When the root node is frozen and you modify the set or call this method</li>
            </ol>
            In the second case, when you have frozen a set with <see cref="M:Loyc.Collections.Impl.InternalSet`1.CloneFreeze"/>,
            all existing copies are frozen, and further changes affect only 
            the specific copy that you change. You can also call <see cref="M:Loyc.Collections.Impl.InternalSet`1.Thaw"/>
            if you need to make copies that are kept in sync, without 
            actually modifying the set first.
            <para/>
            This method has no effect if the root node is already thawed.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.Impl.InternalSet`1.Add(`0@,System.Collections.Generic.IEqualityComparer{`0},System.Boolean)">
            <summary>Tries to add an item to the set, and retrieves the existing item if present.</summary>
            <returns>true if the item was added, false if it was already present.</returns>
        </member>
        <member name="M:Loyc.Collections.Impl.InternalSet`1.Remove(`0@,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>Removes an item from the set.</summary>
            <returns>true if the item was removed, false if it was not found.</returns>
        </member>
        <member name="M:Loyc.Collections.Impl.InternalSet`1.UnionWith(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0},System.Boolean)">
            <summary>Adds the contents of 'other' to this set.</summary>
            <param name="thisComparer">The comparer for this set (not for 'other', 
            which is simply enumerated).</param>
            <param name="replaceIfPresent">If items in 'other' match items in this 
            set, this flag causes those items in 'other' to replace the items in
            this set.</param>
        </member>
        <member name="M:Loyc.Collections.Impl.InternalSet`1.UnionWith(Loyc.Collections.Impl.InternalSet{`0},System.Collections.Generic.IEqualityComparer{`0},System.Boolean)">
            <inheritdoc cref="M:Loyc.Collections.Impl.InternalSet`1.UnionWith(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0},System.Boolean)"/>
        </member>
        <member name="M:Loyc.Collections.Impl.InternalSet`1.IntersectWith(Loyc.Collections.Impl.InternalSet{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>Removes all items from this set that are not present in 'other'.</summary>
            <param name="other">The set whose members should be kept in this set.</param>
            <param name="otherComparer">The comparer for 'other' (not for this set,
            which is simply enumerated).</param>
            <returns>Returns the number of items that were removed from the set.</returns>
        </member>
        <member name="M:Loyc.Collections.Impl.InternalSet`1.IntersectWith(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>Removes all items from this set that are not present in 'other'.</summary>
            <param name="other">The set whose members should be kept in this set.</param>
            <returns>Returns the number of items that were removed.</returns>
            <remarks>
            This method is costly if 'other' is not a set; a temporary set will be 
            constructed to answer the query. Also, this overload has the same subtle 
            assumption as the other overload.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.Impl.InternalSet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>Removes all items from this set that are present in 'other'.</summary>
            <param name="other">The set whose members should be removed from this set.</param>
            <param name="otherComparer">The comparer for this set (not for 'other',
            which is simply enumerated).</param>
            <returns>Returns the number of items that were removed.</returns>
        </member>
        <member name="M:Loyc.Collections.Impl.InternalSet`1.ExceptWith(Loyc.Collections.Impl.InternalSet{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <inheritdoc cref="M:Loyc.Collections.Impl.InternalSet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})"/>
        </member>
        <member name="M:Loyc.Collections.Impl.InternalSet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0},System.Boolean)">
            <summary>Modifies the current set to contain only elements that were
            present either in this set or in the other collection, but not both.</summary>
            <param name="xorDuplicates">Controls this function's behavior in case
            'other' contains duplicates. If xorDuplicates is true, an even number
            of duplicates has no overall effect and an odd number is treated the 
            same as if there were a single instance of the item. Setting 
            xorDuplicates to false is costly, since a temporary set is constructed 
            in order to eliminate any duplicates. The same comparer is used for 
            the temporary set as for this set.</param>
            <remarks>Returns the change in set size (positive if items were added,
            negative if items were removed)</remarks>
        </member>
        <member name="M:Loyc.Collections.Impl.InternalSet`1.IsSubsetOf(System.Collections.Generic.ISet{`0},System.Int32)">
            <summary>Returns true if all items in this set are present in the other set.</summary>
            <param name="myMinCount">Specifies the minimum number of items that this set contains (use 0 if unknown)</param>
        </member>
        <member name="M:Loyc.Collections.Impl.InternalSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0},System.Int32)">
            <summary>Returns true if all items in the other set are present in this set.</summary>
        </member>
        <member name="M:Loyc.Collections.Impl.InternalSet`1.Overlaps(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>Returns true if this set contains at least one item from 'other'.</summary>
        </member>
        <member name="M:Loyc.Collections.Impl.InternalSet`1.IsProperSubsetOf(System.Collections.Generic.ISet{`0},System.Int32)">
            <summary>Returns true if all items in this set are present in the other set, 
            and the other set has at least one item that is not in this set.</summary>
            <remarks>
            This implementation assumes that if the two sets use different
            definitions of equality (different <see cref="T:System.Collections.Generic.IEqualityComparer`1"/>s),
            that neither set contains duplicates from the point of view of the other
            set. If this rule is broken--meaning, if either of the sets were 
            constructed with the comparer of the other set, that set would shrink--
            then the results of this method are unreliable. If both sets use the 
            same comparer, though, you have nothing to worry about.</remarks>
        </member>
        <member name="M:Loyc.Collections.Impl.InternalSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0},System.Int32)">
            <summary>Returns true if all items in this set are present in the other set, 
            and the other set has at least one item that is not in this set.</summary>
            <remarks>
            This method is costly if 'other' is not a set; a temporary set will be 
            constructed to answer the query. Also, this overload has the same subtle 
            assumption as the other overload.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.Impl.InternalSet`1.IsProperSupersetOf(System.Collections.Generic.ISet{`0},System.Collections.Generic.IEqualityComparer{`0},System.Int32)">
            <summary>Returns true if all items in the other set are present in this set, 
            and this set has at least one item that is not in the other set.</summary>
            <remarks>
            This implementation assumes that if the two sets use different
            definitions of equality (different <see cref="T:System.Collections.Generic.IEqualityComparer`1"/>s),
            that neither set contains duplicates from the point of view of the other
            set. If this rule is broken--meaning, if either of the sets were 
            constructed with the comparer of the other set, that set would shrink--
            then the results of this method are unreliable. If both sets use the 
            same comparer, though, you have nothing to worry about.</remarks>
        </member>
        <member name="M:Loyc.Collections.Impl.InternalSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0},System.Int32)">
            <summary>Returns true if all items in the other set are present in this set, 
            and this set has at least one item that is not in the other set.</summary>
            <remarks>
            This method is costly if 'other' is not a set; a temporary set will be 
            constructed to answer the query. Also, this overload has the same subtle 
            assumption as the other overload.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.Impl.InternalSet`1.SetEquals(System.Collections.Generic.ISet{`0},System.Int32)">
            <summary>Returns true if this set and the other set have the same items.</summary>
            <remarks>
            This implementation assumes that if the two sets use different
            definitions of equality (different <see cref="T:System.Collections.Generic.IEqualityComparer`1"/>s),
            that neither set contains duplicates from the point of view of the other
            set. If this rule is broken--meaning, if either of the sets were 
            constructed with the comparer of the other set, that set would shrink--
            then the results of this method are unreliable. If both sets use the 
            same comparer, though, you have nothing to worry about.</remarks>
        </member>
        <member name="M:Loyc.Collections.Impl.InternalSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0},System.Int32)">
            <summary>Returns true if this set and the other set have the same items.</summary>
            <remarks>
            This method is costly if 'other' is not a set; a temporary set will be 
            constructed to answer the query. Also, this overload has the same subtle 
            assumption as the other overload.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.Impl.InternalSet`1.CountMemory(System.Int32)">
            <summary>Measures the total size of all objects allocated to this 
            collection, in bytes, including the size of <see cref="T:Loyc.Collections.Impl.InternalSet`1"/> 
            itself (which is one word).</summary>
            <param name="sizeOfT">Size of each T. C# provides no way to get this 
            number so it must be supplied as a parameter. If T is a reference type 
            such as String, IntPtr.Size tells you the size of each reference; 
            please note that this method is does not look "inside" each T, it 
            just measures the "shallow" size of the collection. For instance, if 
            this is a set of strings, then <c>CountMemory(IntPtr.Size)</c> is
            the size of the set including the references to the strings, but not
            including the strings themselves.</param>
            <returns></returns>
        </member>
        <member name="M:Loyc.Collections.Impl.InternalSet`1.CountMemory(System.Int32,Loyc.Collections.Impl.InternalSetStats@)">
            <summary>Measures the total size of all objects allocated to this 
            collection, in bytes, and counts the number of nodes of different
            types.</summary>
        </member>
        <member name="M:Loyc.Collections.Impl.InternalSet`1.Node.ClearTAt(System.Int32)">
            <summary>Clears the value at _items[i] and updates the bookkeeping
            information in _used and _counter.
            </summary>
        </member>
        <member name="M:Loyc.Collections.Impl.InternalSet`1.Node.CountMemory(System.Int32,Loyc.Collections.Impl.InternalSetStats@)">
            <summary>Gets the size in bytes of this node and its children.</summary>
        </member>
        <member name="M:Loyc.Collections.Impl.InternalSet`1.Enumerator.SetCurrentValue(`0,Loyc.Collections.Impl.InternalSet{`0}@,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>Changes the value associated with the current key.</summary>
            <param name="comparer">Optional. If comparer!=null, it is used to
            verify that the new value is equal to the old value.</param>
            <exception cref="T:System.ArgumentException">According to the comparer 
            provided, the new value is not "equal" to the old value.</exception>
            <remarks>The new value must compare equal to the old value, since
            the new value is placed at the same location in the trie. If a
            value is placed in the wrong location, it becomes irretrievable
            (except via enumerator), as search methods will be looking 
            elsewhere for it.</remarks>
        </member>
        <member name="M:Loyc.Collections.Impl.InternalSet`1.Enumerator.RemoveCurrent(Loyc.Collections.Impl.InternalSet{`0}@)">
            <summary>Removes the current item from the set, and moves to the 
            next item.</summary>
            <returns>As with <see cref="M:Loyc.Collections.Impl.InternalSet`1.Enumerator.MoveNext"/>, returns true if there is 
            another item after the current one and false if not.</returns>
            <remarks>
            Efficiency note: a normal Remove operation can delete a child node 
            when there are still two items left in the child (the items can be
            transferred to the parent node). RemoveCurrent, however, only 
            deletes child nodes that become completely empty, because it would 
            be very difficult to implement MoveNext() correctly (meaning, it
            would be very difficult to enumerate every item exactly once) if 
            the tree were "rebalanced" like this during enumeration.
            <para/>
            Therefore, in rare cases, a set whose size decreases via this 
            method will use significantly more memory than necessary. And in
            general, adding new items later will not re-use the mostly-empty 
            nodes unless the new items used to be in the set (or have similar
            hashcodes).
            </remarks>
        </member>
        <member name="F:Loyc.Collections.Impl.InternalSetStats.NodeCount">
            <summary>Total number of nodes.</summary>
        </member>
        <member name="F:Loyc.Collections.Impl.InternalSetStats.LeafCount">
            <summary>Number of nodes that don't have a child array.</summary>
        </member>
        <member name="F:Loyc.Collections.Impl.InternalSetStats.MaxDepthNodes">
            <summary>Number of nodes that have an overflow list.</summary>
        </member>
        <member name="F:Loyc.Collections.Impl.InternalSetStats.ItemCount">
            <summary>Number of items in the set.</summary>
        </member>
        <member name="F:Loyc.Collections.Impl.InternalSetStats.ItemsInOverflow">
            <summary>Number of items that are in overflow lists. Note that if a 
            single item is in an overflow list, it implies that five items share 
            the same hashcode; larger numbers than 1 are harder to interpret, 
            but generally.</summary>
        </member>
        <member name="T:Loyc.Collections.Impl.InternalSet_LUT">
            <summary>Lookup tables used by <see cref="T:Loyc.Collections.Impl.InternalSet`1"/>.</summary>
        </member>
        <member name="T:Loyc.Collections.InvertibleSet`1">
            <summary>An immutable set that can be inverted. For example, an 
            <c>InvertibleSet&lt;int&gt;</c> could contain "everything except 4 and 10",
            or it could contain a positive set such as "1, 2, and 3".</summary>
            <remarks>
            <c>InvertibleSet</c> is implemented as a normal <see cref="T:Loyc.Collections.Set`1"/> plus
            an <see cref="P:Loyc.Collections.InvertibleSet`1.IsInverted"/> flag. The original (non-inverted) set can
            be retrieved from the <see cref="P:Loyc.Collections.InvertibleSet`1.BaseSet"/> property
            <para/>
            <b>Note:</b> this class is designed with the assumption that there are an
            infinite number of possible T objects, and under certain conditions the
            set-testing operations such as Equals() and IsSubsetOf() can return false
            when they should return true. For example, consider two sets of bytes:
            one set holds the numbers 0..100, and the other contains 101..255 but is
            marked as inverted. Arguably, Equals() and IsSubsetOf() should return true
            when comparing these sets, but they return false because they are unaware 
            of the finite nature of a byte.
            <para/>
            Performance warning: GetHashCode() XORs the hashcodes of all items in the
            set, while Equals() is a synonym for SetEquals(). Be aware that these 
            methods are very slow for large sets.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.InvertibleSet`1.IsSubsetOf(Loyc.Collections.InvertibleSet{`0})">
            <summary>Returns true if all items in this set are present in the other set.</summary>
        </member>
        <member name="M:Loyc.Collections.InvertibleSet`1.IsSupersetOf(Loyc.Collections.InvertibleSet{`0})">
            <summary>Returns true if all items in the other set are present in this set.</summary>
        </member>
        <member name="M:Loyc.Collections.InvertibleSet`1.Overlaps(Loyc.Collections.InvertibleSet{`0})">
            <summary>Returns true if this set contains at least one item from 'other'.</summary>
        </member>
        <member name="M:Loyc.Collections.InvertibleSet`1.IsProperSubsetOf(Loyc.Collections.InvertibleSet{`0})">
            <inheritdoc cref="!:InternalSet&lt;T&gt;.IsProperSubsetOf(ISet&lt;T&gt;, int)"/>
        </member>
        <member name="M:Loyc.Collections.InvertibleSet`1.IsProperSupersetOf(Loyc.Collections.InvertibleSet{`0})">
            <inheritdoc cref="!:InternalSet&lt;T&gt;.IsProperSupersetOf(ISet&lt;T&gt;, IEqualityComparer&lt;T&gt;, int)"/>
        </member>
        <member name="T:Loyc.Collections.MapOrMMap`2">
            <summary>Common base class that contains code shared between 
            <see cref="T:Loyc.Collections.Map`2"/> and <see cref="T:Loyc.Collections.MMap`2"/>.</summary>
            <remarks>You might notice that although <see cref="T:Loyc.Collections.Map`2"/> and 
            <see cref="T:Loyc.Collections.MMap`2"/> have a common base class, <see cref="T:Loyc.Collections.Set`1"/> and
            <see cref="T:Loyc.Collections.MSet`1"/> do not, and this is a mere implementation detail. 
            Since <see cref="T:Loyc.Collections.Set`1"/> is immutable, and small, and its fields can 
            safely be initialized to 0 or null, its default value is a valid set and 
            it makes sense to implement is as a struct. The same observation would 
            apply to <see cref="T:Loyc.Collections.Map`2"/> except for one problem: the comparer. The
            user can supply a comparer of type <c>IEqualityComparer&lt;K&gt;</c>, but
            but <see cref="T:Loyc.Collections.Map`2"/> contains a set of type 
            <c>InternalSet&lt;KeyValuePair&lt;K,V&gt;&gt;</c>, which requires a comparer of 
            type <c>IEqualityComparer&lt;KeyValuePair&lt;K,V&gt;&gt;</c>. In general, a 
            wrapper object is necessary to provide this comparer, and I decided to use
            the set itself as the wrapper object. Therefore, <see cref="T:Loyc.Collections.Map`2"/> 
            implements this interface, and it must be a class so that it is not boxed
            every time it is converted to this interface.
            <para/>
            Finally, since <see cref="T:Loyc.Collections.Map`2"/> and <see cref="T:Loyc.Collections.MMap`2"/> are both 
            classes and share some of the same code, I decided to factor out the 
            common code into this base class. The end.
            </remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Loyc.Collections.MapOrMMap`2.System#Collections#Generic#IEqualityComparer{System#Collections#Generic#KeyValuePair{K@V}}#Equals(System.Collections.Generic.KeyValuePair{`0,`1},System.Collections.Generic.KeyValuePair{`0,`1})" -->
        <member name="M:Loyc.Collections.MapOrMMap`2.System#Collections#Generic#IEqualityComparer{System#Collections#Generic#KeyValuePair{K@V}}#GetHashCode(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>Not intended to be called by users.</summary>
        </member>
        <member name="M:Loyc.Collections.MapOrMMap`2.TryGetValue(`0,`1)">
            <summary>Synonym for this[key, defaultValue].</summary>
        </member>
        <member name="M:Loyc.Collections.MapOrMMap`2.CountMemory(System.Int32)">
            <summary>Measures the total size of all objects allocated to this 
            collection, in bytes, including the size of this object itself; see
            <see cref="M:Loyc.Collections.Impl.InternalSet`1.CountMemory(System.Int32)"/>.</summary>
        </member>
        <member name="P:Loyc.Collections.MapOrMMap`2.Item(`0,`1)">
            <summary>Retrieves the value associated with the specified key,
            or returns <c>defaultValue</c> if the key is not found.</summary>
        </member>
        <member name="T:Loyc.Collections.Map`2">
            <summary>
            An immutable dictionary.
            </summary>
            <remarks>
            This class is a read-only dictionary, known in comp-sci nerd speak as a 
            "persistent" data structure (not to be confused with the normal meaning
            of "persistent" as something that is saved to disk--this data structure
            is designed only to exist in memory). <c>Map</c> allows modification only 
            by creating new dictionaries. To create new dictionaries, this class 
            provides the following methods:
            <ul>
            <li><see cref="M:Loyc.Collections.Map`2.Union(Loyc.Collections.MapOrMMap{`0,`1})"/>, <see cref="M:Loyc.Collections.Map`2.Intersect(Loyc.Collections.MapOrMMap{`0,`1})"/>, <see cref="M:Loyc.Collections.Map`2.Except(Loyc.Collections.MapOrMMap{`0,`1})"/> 
            and <see cref="M:Loyc.Collections.Map`2.Xor(Loyc.Collections.MapOrMMap{`0,`1})"/> combine two dictionaries to create a new 
            dictionary, without modifying either of the original dictionaries.</li>
            <li><see cref="M:Loyc.Collections.Map`2.With(`0,`1,System.Boolean)"/> and <see cref="M:Loyc.Collections.Map`2.Without(`0)"/> create a new 
            dictionary with a single item added or removed.</li>
            <li>A C# cast operator is provided to convert a Map into an 
            <see cref="T:Loyc.Collections.MMap`2"/>.</li>
            </ul>
            See <see cref="T:Loyc.Collections.MMap`2"/> and <see cref="T:Loyc.Collections.Impl.InternalSet`1"/> for more
            information.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.Map`2.#ctor">
            <summary>Creates an empty map. Consider using <see cref="F:Loyc.Collections.Map`2.Empty"/> instead.</summary>
            <remarks>This is marked <c>Obsolete</c> instead of <c>protected</c> so 
            that this class is compatible with the generic constraint known in C# 
            as <c>new()</c>.</remarks>
        </member>
        <member name="M:Loyc.Collections.Map`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>Creates an empty map with the specified key comparer.</summary>
        </member>
        <member name="M:Loyc.Collections.Map`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>Creates a map with the specified elements.</summary>
        </member>
        <member name="M:Loyc.Collections.Map`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>Creates a map with the specified elements and key comparer.</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Loyc.Collections.Map`2.With(`0,`1,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:Loyc.Collections.Map`2.Without(`0)" -->
        <member name="M:Loyc.Collections.Map`2.Union(Loyc.Collections.MapOrMMap{`0,`1})">
            <summary>Returns a copy of the current map with the specified items 
            added; each item is added only if the key is not already present.</summary>
        </member>
        <member name="M:Loyc.Collections.Map`2.Union(Loyc.Collections.MapOrMMap{`0,`1},System.Boolean)">
            <summary>Returns a copy of the current map with the specified items added.</summary>
            <param name="replaceWithValuesFromOther">When a key is present in both maps, 
            the values from 'other' replace the values in the current map. If this is
            false, the values in this map are not replaced.</param>
        </member>
        <member name="M:Loyc.Collections.Map`2.Intersect(Loyc.Collections.MapOrMMap{`0,`1})">
            <summary>Returns a copy of the current map with all keys removed from 
            this map that are not present in the other map. The <see cref="P:Loyc.Collections.Map`2.Values"/>
            in 'other' are ignored.</summary>
        </member>
        <member name="M:Loyc.Collections.Map`2.Except(Loyc.Collections.MapOrMMap{`0,`1})">
            <summary>Returns a copy of the current map with all keys removed from 
            this map that are present in the other map. The <see cref="P:Loyc.Collections.Map`2.Values"/>
            in 'other' are ignored.</summary>
        </member>
        <member name="M:Loyc.Collections.Map`2.Xor(Loyc.Collections.MapOrMMap{`0,`1})">
            <summary>Duplicates the current map and then modifies it so that it 
            contains only keys that are present either in the current map or in 
            the specified other map, but not both.</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Loyc.Collections.MMap`2" -->
        <member name="M:Loyc.Collections.MMap`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>Creates an empty map with the specified key comparer.</summary>
        </member>
        <member name="M:Loyc.Collections.MMap`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>Creates a map with the specified elements.</summary>
        </member>
        <member name="M:Loyc.Collections.MMap`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>Creates a map with the specified elements and key comparer.</summary>
        </member>
        <member name="M:Loyc.Collections.MMap`2.Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>Removes a pair from the map.</summary>
            <remarks>The removal occurs only if the value provided matches the 
            value that is already associated with the key (value comparison is 
            performed using object.Equals()).</remarks>
            <returns>True if the pair was removed, false if not.</returns>
        </member>
        <member name="M:Loyc.Collections.MMap`2.Clone">
            <summary>Creates a copy of this map in O(1) time, by marking the current
            root node as frozen.</summary>
        </member>
        <member name="M:Loyc.Collections.MMap`2.AddRange(Loyc.Collections.MMap{`0,`1},System.Boolean)">
            <summary>Merges the contents of the specified map into this map.</summary>
            <param name="replaceIfPresent">If true, values in the other collection
            replace values in this one. If false, the existing pairs in this map
            are not overwritten.</param>
            <returns>The number of items that were added.</returns>
        </member>
        <member name="M:Loyc.Collections.MMap`2.AddRange(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Boolean)">
            <summary>Merges the contents of the specified sequence into this map.</summary>
            <param name="replaceIfPresent">If true, values in the other collection
            replace values in this one. If false, the existing pairs in this map
            are not overwritten.</param>
            <returns>The number of items that were added.</returns>
            <remarks>Duplicates are allowed in the source data. If 
            <c>replaceIfPresent</c> is true, later values take priority over 
            earlier values, otherwise earlier values take priority.</remarks>
        </member>
        <member name="M:Loyc.Collections.MMap`2.AddIfNotPresent(`0,`1)">
            <summary>Adds an item to the map if the key is not present. If the 
            key is already present, this method has no effect.</summary>
            <returns>True if the pair was added, false if not.</returns>
        </member>
        <member name="M:Loyc.Collections.MMap`2.AddOrFind(System.Collections.Generic.KeyValuePair{`0,`1}@,System.Boolean)">
            <summary>Adds an item to the map if it is not present, retrieves 
            the existing key-value pair if the key is present, and optionally
            replaces the existing pair with a new pair.</summary>
            <param name="pair">When calling this method, pair.Key specifies the
            key that you want to search for in the map. If the key is not found
            then the pair is added to the map; if the key is found, the pair is
            replaced with the existing pair that was found in the map.</param>
            <param name="replaceIfPresent">This parameter specifies what to do
            if the key is found in the map. If this parameter is true, the 
            existing pair is replaced with the specified new pair (in fact the
            pair in the map is swapped with the <c>pair</c> parameter). If this
            parameter is false, the existing pair is left unmodified and a copy
            of it is stored in the <c>pair</c> parameter.</param>
            <returns>True if the pair's key did NOT exist and was added, false 
            if the key already existed.</returns>
        </member>
        <member name="M:Loyc.Collections.MMap`2.GetAndRemove(`0,`1@)">
            <summary>Gets the value associated with the specified key, then
            removes the pair with that key from the dictionary.</summary>
            <param name="key">Key to search for.</param>
            <param name="valueRemoved">The value that was removed. If the key 
            is not found, the value of this parameter is left unchanged.</param>
            <returns>True if a pair was removed, false if not.</returns>
        </member>
        <member name="M:Loyc.Collections.MMap`2.GetAndRemove(System.Collections.Generic.KeyValuePair{`0,`1}@)">
            <summary>Gets the pair associated with <c>pair.Key</c>, then
            removes the pair with that key from the dictionary.</summary>
            <param name="pair">Specifies the key to search for. On return, if the
            key was found, this holds both the key and value that used to be in
            the dictionary.</param>
            <returns>True if a pair was removed, false if not.</returns>
        </member>
        <member name="M:Loyc.Collections.MMap`2.With(`0,`1,System.Boolean)">
            <inheritdoc cref="M:Loyc.Collections.Map`2.With(`0,`1,System.Boolean)"/>
        </member>
        <member name="M:Loyc.Collections.MMap`2.Without(`0)">
            <inheritdoc cref="M:Loyc.Collections.Map`2.Without(`0)"/>
        </member>
        <member name="M:Loyc.Collections.MMap`2.Union(Loyc.Collections.MapOrMMap{`0,`1})">
            <inheritdoc cref="M:Loyc.Collections.Map`2.Union(Loyc.Collections.MapOrMMap{`0,`1})"/>
        </member>
        <member name="M:Loyc.Collections.MMap`2.Union(Loyc.Collections.MapOrMMap{`0,`1},System.Boolean)">
            <inheritdoc cref="M:Loyc.Collections.Map`2.Union(Loyc.Collections.MapOrMMap{`0,`1})"/>
        </member>
        <member name="M:Loyc.Collections.MMap`2.Intersect(Loyc.Collections.MapOrMMap{`0,`1})">
            <inheritdoc cref="M:Loyc.Collections.Map`2.Intersect(Loyc.Collections.MapOrMMap{`0,`1})"/>
        </member>
        <member name="M:Loyc.Collections.MMap`2.Except(Loyc.Collections.MapOrMMap{`0,`1})">
            <inheritdoc cref="M:Loyc.Collections.Map`2.Except(Loyc.Collections.MapOrMMap{`0,`1})"/>
        </member>
        <member name="M:Loyc.Collections.MMap`2.Xor(Loyc.Collections.MapOrMMap{`0,`1})">
            <inheritdoc cref="M:Loyc.Collections.Map`2.Xor(Loyc.Collections.MapOrMMap{`0,`1})"/>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Loyc.Collections.MSet`1" -->
        <member name="M:Loyc.Collections.MSet`1.AddUnique(`0)">
            <summary>Adds the specified item to the set, or throws an exception if
            a matching item is already present.</summary>
            <exception cref="T:System.ArgumentException">The item already exists in the set.</exception>
        </member>
        <member name="M:Loyc.Collections.MSet`1.Find(`0@)">
            <summary>Searches for an item. If the item is found, the copy in the 
            set is returned in the 'item' parameter. Note: there is no reason to 
            call this method in a <see cref="!:SymbolSet"/> because the item reference
            will never change; call <see cref="M:Loyc.Collections.MSet`1.Contains(`0)"/> instead.</summary>
            <returns>true if the item was found, false if not.</returns>
        </member>
        <member name="M:Loyc.Collections.MSet`1.AddOrFind(`0@,System.Boolean)">
            <summary>Adds the specified item to the set, and retrieves an existing 
            copy of the item if one existed. Note: there is no reason to call this
            method in a <see cref="!:SymbolSet"/> because if an item is found, it 
            will always be the exact same object that you searched for.</summary>
            <param name="item">An object to search for. If this method returns false,
            this parameter is changed to the existing value that was found in the
            collection.</param>
            <param name="replaceIfPresent">If true, and a matching item exists in
            the set, that item will be replaced with the specified new item. The
            old value will be returned in the 'item' parameter.</param>
            <returns>True if a new item was added, false if the item already 
            existed in the set.</returns>
        </member>
        <member name="M:Loyc.Collections.MSet`1.Add(`0,System.Boolean)">
            <summary>Adds the specified item to the set.</summary>
            <param name="replaceIfPresent">If true, and a matching item is 
            already present in the set, the specified item replaces the existing 
            copy. If false, the existing copy is left alone. This parameter
            has no effect in a <see cref="!:SymbolSet"/>.</param>
            <returns>true if the item was new, false if it was already present.</returns>
        </member>
        <member name="M:Loyc.Collections.MSet`1.Clone">
            <summary>Fast-clones the set in O(1) time.</summary>
            <remarks>
            Once the set is cloned, modifications to both sets take
            longer because portions of the set must be duplicated. See 
            <see cref="!:InternalSet&lt;T&gt;"/> for details about the fast-
            cloning technique.</remarks>
        </member>
        <member name="M:Loyc.Collections.MSet`1.Add(`0)">
            <summary>Adds the specified item to the set if it is not present.</summary>
            <returns>true if the item was new, false if it was not added because
            it was already present.</returns>
        </member>
        <member name="M:Loyc.Collections.MSet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>Adds all items in the other set to this set.</summary>
            <remarks>Any items that are already present are left unmodified.</remarks>
        </member>
        <member name="M:Loyc.Collections.MSet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>Removes all items from this set that are present in 'other'.</summary>
            <param name="other">The set whose members should be removed from this set.</param>
        </member>
        <member name="M:Loyc.Collections.MSet`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="!:InternalSet&lt;T&gt;.IntersectWith(IEnumerable&lt;T&gt;, IEqualityComparer&lt;T&gt;)"/>
        </member>
        <member name="M:Loyc.Collections.MSet`1.IntersectWith(Loyc.Collections.Set{`0})">
            <summary>Removes all items from this set that are not present in 'other'.</summary>
        </member>
        <member name="M:Loyc.Collections.MSet`1.IntersectWith(Loyc.Collections.MSet{`0})">
            <summary>Removes all items from this set that are not present in 'other'.</summary>
        </member>
        <member name="M:Loyc.Collections.MSet`1.IntersectWith(System.Collections.Generic.ISet{`0})">
            <summary>Removes all items from this set that are not present in 'other'.</summary>
        </member>
        <member name="M:Loyc.Collections.MSet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>Modifies the current set to contain only elements that were
            present either in this set or in the other collection, but not both.</summary>
        </member>
        <member name="M:Loyc.Collections.MSet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0},System.Boolean)">
            <inheritdoc cref="!:InternalSet&lt;T&gt;.SymmetricExceptWith(IEnumerable&lt;T&gt;, IEqualityComparer&lt;T&gt;, bool)"/>
        </member>
        <member name="M:Loyc.Collections.MSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>Returns true if all items in this set are present in the other set.</summary>
        </member>
        <member name="M:Loyc.Collections.MSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>Returns true if all items in the other set are present in this set.</summary>
        </member>
        <member name="M:Loyc.Collections.MSet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
            <summary>Returns true if this set contains at least one item from 'other'.</summary>
        </member>
        <member name="M:Loyc.Collections.MSet`1.IsProperSubsetOf(Loyc.Collections.Set{`0})">
            <inheritdoc cref="!:InternalSet&lt;T&gt;.IsProperSubsetOf(ISet&lt;T&gt;, int)"/>
        </member>
        <member name="M:Loyc.Collections.MSet`1.IsProperSubsetOf(Loyc.Collections.MSet{`0})">
            <inheritdoc cref="!:InternalSet&lt;T&gt;.IsProperSubsetOf(ISet&lt;T&gt;, int)"/>
        </member>
        <member name="M:Loyc.Collections.MSet`1.IsProperSubsetOf(System.Collections.Generic.ISet{`0})">
            <inheritdoc cref="!:InternalSet&lt;T&gt;.IsProperSubsetOf(ISet&lt;T&gt;, int)"/>
        </member>
        <member name="M:Loyc.Collections.MSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="!:InternalSet&lt;T&gt;.IsProperSubsetOf(IEnumerable&lt;T&gt;, IEqualityComparer&lt;T&gt;, int)"/>
        </member>
        <member name="M:Loyc.Collections.MSet`1.IsProperSupersetOf(Loyc.Collections.Set{`0})">
            <inheritdoc cref="!:InternalSet&lt;T&gt;.IsProperSupersetOf(ISet&lt;T&gt;, IEqualityComparer&lt;T&gt;, int)"/>
        </member>
        <member name="M:Loyc.Collections.MSet`1.IsProperSupersetOf(Loyc.Collections.MSet{`0})">
            <inheritdoc cref="!:InternalSet&lt;T&gt;.IsProperSupersetOf(ISet&lt;T&gt;, IEqualityComparer&lt;T&gt;, int)"/>
        </member>
        <member name="M:Loyc.Collections.MSet`1.IsProperSupersetOf(System.Collections.Generic.ISet{`0})">
            <inheritdoc cref="!:InternalSet&lt;T&gt;.IsProperSupersetOf(ISet&lt;T&gt;, IEqualityComparer&lt;T&gt;, int)"/>
        </member>
        <member name="M:Loyc.Collections.MSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="!:InternalSet&lt;T&gt;.IsProperSupersetOf(IEnumerable&lt;T&gt;, IEqualityComparer&lt;T&gt;, int)"/>
        </member>
        <member name="M:Loyc.Collections.MSet`1.SetEquals(Loyc.Collections.Set{`0})">
            <inheritdoc cref="!:InternalSet&lt;T&gt;.SetEquals(ISet&lt;T&gt;, int)"/>
        </member>
        <member name="M:Loyc.Collections.MSet`1.SetEquals(Loyc.Collections.MSet{`0})">
            <inheritdoc cref="!:InternalSet&lt;T&gt;.SetEquals(ISet&lt;T&gt;, int)"/>
        </member>
        <member name="M:Loyc.Collections.MSet`1.SetEquals(System.Collections.Generic.ISet{`0})">
            <inheritdoc cref="!:InternalSet&lt;T&gt;.SetEquals(ISet&lt;T&gt;, int)"/>
        </member>
        <member name="M:Loyc.Collections.MSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="!:InternalSet&lt;T&gt;.SetEquals(IEnumerable&lt;T&gt;, IEqualityComparer&lt;T&gt;, int)"/>
        </member>
        <member name="M:Loyc.Collections.MSet`1.RemoveWhere(System.Predicate{`0})">
            <summary>Removes all elements that match the conditions defined by the 
            specified predicate from this collection.</summary>
            <returns>The number of elements that were removed from the set.</returns>
        </member>
        <member name="M:Loyc.Collections.MSet`1.Toggle(`0)">
            <summary>Toggle's an object's presence in the set.</summary>
            <returns>true if the item was added, false if the item was removed.</returns>
        </member>
        <member name="M:Loyc.Collections.MSet`1.CountMemory(System.Int32)">
            <summary>Measures the total size of all objects allocated to this 
            collection, in bytes, including the size of this object itself; see
            <see cref="!:InternalSet&lt;T&gt;.CountMemory"/>.</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Loyc.Collections.Set`1" -->
        <member name="M:Loyc.Collections.Set`1.Find(`0@)">
            <inheritdoc cref="M:Loyc.Collections.MSet`1.Find(`0@)"/>
        </member>
        <member name="M:Loyc.Collections.Set`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>Returns true if all items in this set are present in the other set.</summary>
        </member>
        <member name="M:Loyc.Collections.Set`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>Returns true if all items in the other set are present in this set.</summary>
        </member>
        <member name="M:Loyc.Collections.Set`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
            <summary>Returns true if this set contains at least one item from 'other'.</summary>
        </member>
        <member name="M:Loyc.Collections.Set`1.IsProperSubsetOf(Loyc.Collections.Set{`0})">
            <inheritdoc cref="!:InternalSet&lt;T&gt;.IsProperSubsetOf(ISet&lt;T&gt;, int)"/>
        </member>
        <member name="M:Loyc.Collections.Set`1.IsProperSubsetOf(Loyc.Collections.MSet{`0})">
            <inheritdoc cref="!:InternalSet&lt;T&gt;.IsProperSubsetOf(ISet&lt;T&gt;, int)"/>
        </member>
        <member name="M:Loyc.Collections.Set`1.IsProperSubsetOf(System.Collections.Generic.ISet{`0})">
            <inheritdoc cref="!:InternalSet&lt;T&gt;.IsProperSubsetOf(ISet&lt;T&gt;, int)"/>
        </member>
        <member name="M:Loyc.Collections.Set`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="!:InternalSet&lt;T&gt;.IsProperSubsetOf(IEnumerable&lt;T&gt;, IEqualityComparer&lt;T&gt;, int)"/>
        </member>
        <member name="M:Loyc.Collections.Set`1.IsProperSupersetOf(Loyc.Collections.Set{`0})">
            <inheritdoc cref="!:InternalSet&lt;T&gt;.IsProperSupersetOf(ISet&lt;T&gt;, IEqualityComparer&lt;T&gt;, int)"/>
        </member>
        <member name="M:Loyc.Collections.Set`1.IsProperSupersetOf(Loyc.Collections.MSet{`0})">
            <inheritdoc cref="!:InternalSet&lt;T&gt;.IsProperSupersetOf(ISet&lt;T&gt;, IEqualityComparer&lt;T&gt;, int)"/>
        </member>
        <member name="M:Loyc.Collections.Set`1.IsProperSupersetOf(System.Collections.Generic.ISet{`0})">
            <inheritdoc cref="!:InternalSet&lt;T&gt;.IsProperSupersetOf(ISet&lt;T&gt;, IEqualityComparer&lt;T&gt;, int)"/>
        </member>
        <member name="M:Loyc.Collections.Set`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="!:InternalSet&lt;T&gt;.IsProperSupersetOf(IEnumerable&lt;T&gt;, IEqualityComparer&lt;T&gt;, int)"/>
        </member>
        <member name="M:Loyc.Collections.Set`1.SetEquals(Loyc.Collections.Set{`0})">
            <inheritdoc cref="!:InternalSet&lt;T&gt;.SetEquals(ISet&lt;T&gt;, int)"/>
        </member>
        <member name="M:Loyc.Collections.Set`1.SetEquals(Loyc.Collections.MSet{`0})">
            <inheritdoc cref="!:InternalSet&lt;T&gt;.SetEquals(ISet&lt;T&gt;, int)"/>
        </member>
        <member name="M:Loyc.Collections.Set`1.SetEquals(System.Collections.Generic.ISet{`0})">
            <inheritdoc cref="!:InternalSet&lt;T&gt;.SetEquals(ISet&lt;T&gt;, int)"/>
        </member>
        <member name="M:Loyc.Collections.Set`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="!:InternalSet&lt;T&gt;.SetEquals(IEnumerable&lt;T&gt;, IEqualityComparer&lt;T&gt;, int)"/>
        </member>
        <member name="M:Loyc.Collections.Set`1.Where(System.Predicate{`0})">
            <summary>Returns a new set that contains only items that match the 
            specified predicate (i.e. for which the predicate returns true).</summary>
        </member>
        <member name="M:Loyc.Collections.Set`1.CountMemory(System.Int32)">
            <summary>Measures the total size of all objects allocated to this 
            collection, in bytes, including the size of this object itself; see
            <see cref="!:InternalSet&lt;T&gt;.CountMemory"/>.</summary>
        </member>
        <member name="T:Loyc.Collections.Set`1.Enumerator">
            <summary>Enumerator for <see cref="T:Loyc.Collections.MSet`1"/>.</summary>
            <remarks>This is a wrapper of <see cref="!:InternalSet&lt;T&gt;.Enumerator"/> 
            that blocks editing functionality.</remarks>
        </member>
        <member name="T:Loyc.Collections.AListTestBase`2">
            <summary>
            Contains tests common to AList, BList and BDictionary.
            </summary>
        </member>
        <member name="M:Loyc.Collections.AListTestBase`2.AddToBoth(`0,System.Collections.Generic.List{`1},System.Int32,System.Int32)">
            <summary>Adds an item to an AList and then to a List at the same place.</summary>
            <param name="preferredIndex">Index to use if alist is an AList. 
            If it is a B+ tree then the item is always added in sorted order.</param>
        </member>
        <member name="M:Loyc.Collections.AListTestBase`2.Add(`0,System.Int32,System.Int32)">
            <summary>Adds an item to an AList.</summary>
        </member>
        <member name="M:Loyc.Collections.AListTestBase`2.RemoveAtInBoth(`0,System.Collections.Generic.List{`1},System.Int32)">
            <summary>Remove an item from an AList and then from a List at the same location.</summary>
        </member>
        <member name="T:Loyc.Collections.Impl.ListCollectionTests`1">
            <summary>A test class for collections that implement IListSource{int} and 
            are cloneable, such as AList, BList and DList.</summary>
        </member>
        <member name="T:Loyc.Collections.AddRangeTest`1">
            <summary>Tests the IAddRange interface of a list class.</summary>
        </member>
        <member name="T:Loyc.Collections.ListRangeTests`1">
            <summary>Tests the IAddRange and IListRangeMethod interfaces of a list class.</summary>
        </member>
        <member name="T:Loyc.Collections.Impl.ListTests`1">
            <summary>A test class for unsorted list classes that implement IList{int} 
            and are cloneable, such as AList and DList.</summary>
        </member>
        <member name="T:Loyc.Collections.Impl.SetTestItem">
            <summary>An class used for testing purposes with three parts: a hashcode,
            a mutable value (ignored for equality testing) and an extended key int
            which affects equality but not the hashcode.</summary>
        </member>
        <member name="T:Loyc.Collections.FVList`1">
            <summary>
            A reference to a FVList, a so-called persistent list data structure.
            </summary>
            <remarks>See the remarks of <see cref="T:Loyc.Collections.VListBlock`1"/> for more information
            about VLists. Items are normally added to, and removed from, the front of a 
            FVList or to the back of an RVList; adding, removing or changing items at any 
            other position is inefficient. You can call ToRVList() to convert a FVList to 
            its equivalent RVList, which is a reverse-order view of the same list that 
            shares the same memory.</remarks>
        </member>
        <member name="M:Loyc.Collections.FVList`1.op_Equality(Loyc.Collections.FVList{`0},Loyc.Collections.FVList{`0})">
            <summary>Returns whether the two list references are the same.
            Does not compare the contents of the lists.</summary>
        </member>
        <member name="M:Loyc.Collections.FVList`1.op_Inequality(Loyc.Collections.FVList{`0},Loyc.Collections.FVList{`0})">
            <summary>Returns whether the two list references are different.
            Does not compare the contents of the lists.</summary>
        </member>
        <member name="M:Loyc.Collections.FVList`1.Equals(System.Object)">
            <summary>Returns whether the two list references are the same.
            Does not compare the contents of the lists.</summary>
        </member>
        <member name="M:Loyc.Collections.FVList`1.Pop">
            <summary>Removes the front item (at index 0) from the list and returns it.</summary>
        </member>
        <member name="M:Loyc.Collections.FVList`1.Push(`0)">
            <summary>Synonym for Add(); adds an item to the front of the list.</summary>
        </member>
        <member name="M:Loyc.Collections.FVList`1.op_Explicit(Loyc.Collections.FVList{`0})~Loyc.Collections.RVList{`0}">
            <summary>Returns this list as an RVList, which effectively reverses the
            order of the elements.</summary>
            <remarks>This is a trivial operation; the RVList shares the same memory.</remarks>
        </member>
        <member name="M:Loyc.Collections.FVList`1.ToRVList">
            <summary>Returns this list as an RVList, which effectively reverses the
            order of the elements.</summary>
            <returns>This is a trivial operation; the RVList shares the same memory.</returns>
        </member>
        <member name="M:Loyc.Collections.FVList`1.op_Explicit(Loyc.Collections.FVList{`0})~Loyc.Collections.FWList{`0}">
            <summary>Returns this list as a FWList.</summary>
            <remarks>The list contents are not copied until you modify the FWList.</remarks>
        </member>
        <member name="M:Loyc.Collections.FVList`1.ToWList">
            <summary>Returns this list as a FWList.</summary>
            <remarks>The list contents are not copied until you modify the FWList.</remarks>
        </member>
        <member name="M:Loyc.Collections.FVList`1.op_Explicit(Loyc.Collections.FVList{`0})~Loyc.Collections.RWList{`0}">
            <summary>Returns this list as a RWList, which effectively reverses the
            order of the elements.</summary>
            <remarks>The list contents are not copied until you modify the RWList.</remarks>
        </member>
        <member name="M:Loyc.Collections.FVList`1.ToRWList">
            <summary>Returns this list as a RWList, which effectively reverses the
            order of the elements.</summary>
            <remarks>The list contents are not copied until you modify the RWList.</remarks>
        </member>
        <member name="M:Loyc.Collections.FVList`1.ToArray">
            <summary>Returns the FVList converted to an array.</summary>
        </member>
        <member name="M:Loyc.Collections.FVList`1.SmartAdd(`0,Loyc.Collections.FVList{`0})">
            <summary>Adds the specified item to the list, or 
            original.WithoutFirst(original.Count - Count - 1) 
            if doing so is equivalent.</summary>
            <param name="item">Item to add</param>
            <param name="original">An old version of the list</param>
            <returns>Returns this.</returns>
            <remarks>
            This method helps write functional code in which you process an input 
            list and produce an output list that may or may not be the same as the 
            input list. In case the output list is identical, you would prefer
            to return the original input list rather than wasting memory on a new 
            list. SmartAdd() helps you do this. The following method demonstrates
            SmartAdd() by removing all negative numbers from a list:
            <example>
            FVList&lt;int&gt; RemoveNegative(FVList&lt;int&gt; input)
            {
                var output = FVList&lt;int&gt;.Empty;
                // Enumerate tail-to-head
                foreach (int n in (RVList&lt;int&gt;)input)
                    if (n >= 0)
                        output.SmartAdd(n, input);
                return output;
            }
            </example>
            You could also do the same thing with input.Filter(delegate(int i) { return i; } >= 0)
            </remarks>
        </member>
        <member name="M:Loyc.Collections.FVList`1.IndexOf(`0)">
             <summary>Searches for the specified object and returns the zero-based
             index of the first occurrence (lowest index) within the entire
             FVList.</summary>
             <param name="item">Item to locate (can be null if T can be null)</param>
             <returns>Index of the item, or -1 if it was not found.</returns>
             <remarks>This method determines equality using the default equality
             comparer EqualityComparer.Default for T, the type of values in the list.
            
             This method performs a linear search; therefore, this method is an O(n)
             operation, where n is Count.
             </remarks>
        </member>
        <member name="M:Loyc.Collections.FVList`1.System#Collections#Generic#ICollection{T}#Add(`0)">
            <summary>Inserts an item at the front (index 0) of the FVList.</summary>
        </member>
        <member name="M:Loyc.Collections.FVList`1.Add(`0)">
            <summary>Inserts an item at the front (index 0) of the FVList.</summary>
        </member>
        <member name="M:Loyc.Collections.FVList`1.Where(System.Predicate{`0})">
            <summary>Applies a filter to a list, to exclude zero or more items.</summary>
            <param name="keep">A function that chooses which items to include
            (exclude items by returning false).</param>
            <returns>The list after filtering has been applied. The original FVList
            structure is not modified.</returns>
            <remarks>
            If the predicate keeps the first N items it is passed (which are the
            last items in a FVList), those N items are typically not copied, but 
            shared between the existing list and the new one.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.FVList`1.SmartSelect(System.Func{`0,`0})">
            <summary>Maps a list to another list of the same length.</summary>
            <param name="map">A function that transforms each item in the list.</param>
            <returns>The list after the map function is applied to each item. The 
            original FVList structure is not modified.</returns>
            <remarks>
            This method is called "Smart" because of what happens if the map
            doesn't do anything. If the map function returns the first N items
            unmodified, those N items are typically not copied, but shared between
            the existing list and the new one. This is useful for functional code
            that sometimes processes a list without modifying it at all.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.FVList`1.Select``1(System.Func{`0,``0})">
            <summary>Maps a list to another list of the same length.</summary>
            <param name="map">A function that transforms each item in the list.</param>
            <returns>The list after the map function is applied to each item. The 
            original FVList structure is not modified.</returns>
        </member>
        <member name="M:Loyc.Collections.FVList`1.Transform(Loyc.Collections.VListTransformer{`0})">
            <summary>Transforms a list (combines filtering with selection and more).</summary>
            <param name="x">Method to apply to each item in the list</param>
            <returns>A list formed from transforming all items in the list</returns>
            <remarks>
            This is my attempt to make an optimized multi-purpose routine for
            transforming a FVList or RVList. It is slightly cumbersome to use,
            but allows you to do several common operations in one transformer
            method.
            <para/>
            The VListTransformer method takes two arguments: an item and its index 
            in the FVList or RVList. It can modify the item if desired, and then it
            returns a XfAction value, which indicates the action to take. Most
            often you will return XfAction.Drop, XfAction.Keep, XfAction.Change, 
            which, repectively, drop the item from the output list, copy the item 
            to the output list unchanged (even if you modified the item), and 
            copy the item to the output list (assuming you changed it).
            <para/>
            Transform() needs to know if the item changed, at least at first,
            because if the first items are kept without changes, then the output
            list can share a common tail with the input list. If the transformer
            method returns XfAction.Keep for every element, then the output list
            is exactly the same (operator== returns true).
            <para/>
            Of course, it would have been simpler just to return a boolean
            indicating whether to keep the item, and the Transform method itself 
            could check whether the item changed. But checking for equality is
            a tad slow in the .NET framework, because there is no bitwise 
            equality operator in .NET, so a virtual function would have to be 
            called instead to test equality, which is especially slow if T is a 
            value type that does not implement IEquatable(of T).
            <para/>
            The final possible action, XfAction.Repeat, is like XfAction.Change 
            except that Transform() calls the VListTransformer again. The second 
            call has the form x(~i, ref item), where ~i is the bitwise NOT of the 
            index i, and item is the same item that x returned the first time it 
            was called. On the second call, x() can return XfAction.Change again 
            to get a third call, if it wants.
            <para/>
            XfAction.Repeat is best explained by example. In the following
            examples, assume "list" is an RVList holding the numbers (1, 2, 3):
            <example>
            output = list.Transform((i, ref n) => {
                // This example produces (1, 1, 2, 2, 3, 3)
                return i >= 0 ? XfAction.Repeat : XfAction.Keep;
            });
            
            output = list.Transform((i, ref n) => {
                // This example produces (1, 10, 2, 20, 3, 30)
                if (i >= 0) 
                    return XfAction.Repeat;
                n *= 10;
                return XfAction.Change;
            });
            
            output = list.Transform((i, ref n) => {
                // This example produces (10, 1, 20, 2, 30, 3)
                if (i >= 0) {
                    n *= 10;
                    return XfAction.Repeat;
                }
                return XfAction.Keep;
            });
            
            output = list.Transform((i, ref n) => {
                // This example produces (10, 100, 1000, 20, 200, 30, 300)
                n *= 10;
                if (n > 1000)
                    return XfAction.Drop;
                return XfAction.Repeat;
            });
            </example>
            And now for some examples using XfAction.Keep, XfAction.Drop and
            XfAction.Change. Assume list is an RVList holding the following 
            integers: (-1, 2, -2, 13, 5, 8, 9)
            <example>
            output = list.Transform((i, ref n) =>
            {   // Keep every second item: (2, 13, 8)
                return (i % 2) == 1 ? XfAction.Keep : XfAction.Drop;
            });
            
            output = list.Transform((i, ref n) =>
            {   // Keep odd numbers: (-1, 13, 5, 9)
                return (n % 2) != 0 ? XfAction.Keep : XfAction.Drop;
            });
            
            output = list.Transform((i, ref n) =>
            {   // Keep and square all odd numbers: (1, 169, 25, 81)
                if ((n % 2) != 0) {
                    n *= n;
                    return XfAction.Change;
                } else
                    return XfAction.Drop;
            });
            
            output = list.Transform((i, ref n) =>
            {   // Increase each item by its index: (-1, 3, 0, 16, 9, 13, 15)
                n += i;
                return i == 0 ? XfAction.Keep : XfAction.Change;
            });
            </example>
            </remarks>
        </member>
        <member name="P:Loyc.Collections.FVList`1.Tail">
            <summary>Returns a list without the first item. If the list is empty, 
            an empty list is retured.</summary>
        </member>
        <member name="P:Loyc.Collections.FVList`1.First">
            <summary>Returns the front item of the list (at index 0), which is the head of the list.</summary>
        </member>
        <member name="P:Loyc.Collections.FVList`1.BlockChainLength">
            <summary>Gets the number of blocks used by this list.</summary>
            <remarks>You might look at this property when optimizing your program,
            because the runtime of some operations increases as the chain length 
            increases. This property runs in O(BlockChainLength) time. Ideally,
            BlockChainLength is proportional to log_2(Count), but certain FVList 
            usage patterns can produce long chains.</remarks>
        </member>
        <member name="P:Loyc.Collections.FVList`1.Item(System.Int32,`0)">
            <summary>Gets an item from the list at the specified index; returns 
            defaultValue if the index is not valid.</summary>
        </member>
        <member name="T:Loyc.Collections.FVList`1.Enumerator">
            <summary>Enumerator for FVList; also used by FWList.</summary>
        </member>
        <member name="T:Loyc.Collections.FWList`1">
            <summary>
            FWList is the mutable variant of the FVList data structure.
            </summary>
            <remarks>See the remarks of <see cref="T:Loyc.Collections.VListBlock`1"/> for more information
            about VLists and WLists. It is most efficient to add items to the front of
            a FWList (at index 0) or the back of an RWList (at index Count-1).</remarks>
        </member>
        <member name="T:Loyc.Collections.WListBase`1">
            <summary>Shared base class of FWList and RWList.</summary>
            <typeparam name="T">The type of elements in the list</typeparam>
        </member>
        <member name="T:Loyc.Collections.WListProtected`1">
            <summary>WList implementation in which the WList operations are only 
            accessible to a derived class.</summary>
            <typeparam name="T">The type of elements in the list</typeparam>
            <remarks>
            This base class is used in the same way one would use protected inheritance 
            in C++: it provides the derived class with access to a FWList/RWList, but it
            does not allow users of the derived class to access the list.
            <para/>
            I plan to use this base class as an optimization, to implement ITags in 
            Loyc AST nodes. It is important that AST nodes, which are immutable, use as 
            little memory as possible so that copies can be made as quickly as possible
            (and so that Loyc isn't a memory hog). By using WListProtected as a base 
            class, AST nodes can have extra attributes attached to them without 
            allocating a separate heap object that would have to be cloned every time 
            the node's immutable attributes change. Consequently, nodes use 12 bytes 
            less memory and can be copied faster.
            <para/>
            Besides that, WListProtected provides an extra byte of storage in UserByte 
            that AstNode uses to optimize access to a tag without enlarging the object.
            <para/>
            By default, the list will act like a FWList. If you want the list to act 
            like an RWList instead, override AdjustWListIndex and GetWListEnumerator 
            as follows:
            <code>
            protected override int AdjustWListIndex(int index, int size) 
            	{ return Count - size - index; }
            protected virtual IEnumerator&lt;T> GetWListEnumerator() 
            	{ return GetRVListEnumerator(); }
            </code>
            </remarks>
        </member>
        <member name="M:Loyc.Collections.WListProtected`1.AdjustWListIndex(System.Int32,System.Int32)">
            <summary>This method implements the difference between FWList and RWList:
            In FWList it returns <c>index</c>, but in RWList it returns 
            <c>Count-size-index</c>.</summary>
            <param name="index">Index to adjust</param>
            <param name="size">Number of elements being accessed or removed</param>
            <remarks>Solely as an optimization, FWList and RWList also have separate 
            versions of this[], InsertAt and RemoveAt.</remarks>
        </member>
        <member name="M:Loyc.Collections.WListProtected`1.GetAt(System.Int32)">
            <summary>Gets an item from a FWList or RWList at the specified index.</summary>
        </member>
        <member name="M:Loyc.Collections.WListProtected`1.SetAt(System.Int32,`0)">
            <summary>Sets an item in a FWList or RWList at the specified index.</summary>
        </member>
        <member name="M:Loyc.Collections.WListProtected`1.Add(`0)">
            <summary>Inserts an item at the "front" of the list, 
            which is index 0 for FWList, or Count for RWList.</summary>
        </member>
        <member name="M:Loyc.Collections.WListProtected`1.Clear">
            <summary>Clears the list and frees the memory it used.</summary>
        </member>
        <member name="M:Loyc.Collections.WListProtected`1.IndexOf(`0)">
             <summary>Searches for the specified object and returns the zero-based
             index of the first occurrence (lowest index) within the entire
             FVList.</summary>
             <param name="item">Item to locate (can be null if T can be null)</param>
             <returns>Index of the item, or -1 if it was not found.</returns>
             <remarks>This method determines equality using the default equality
             comparer EqualityComparer.Default for T, the type of values in the list.
            
             This method performs a linear search; therefore, this method is an O(n)
             operation, where n is Count.
             </remarks>
        </member>
        <member name="M:Loyc.Collections.WListProtected`1.GetAtDff(System.Int32)">
            <summary>Gets an item WITHOUT doing a range check</summary>
        </member>
        <member name="M:Loyc.Collections.WListProtected`1.SetAtDff(System.Int32,`0)">
            <summary>Sets an item WITHOUT doing a range or mutability check</summary>
        </member>
        <member name="M:Loyc.Collections.WListProtected`1.ToFVList">
            <summary>Returns this list as a FVList; if this is a RWList, the order 
            of the elements is reversed at the same time.</summary>
            <remarks>This operation marks the items of the FWList or RWList as 
            immutable. You can still modify the list afterward, but some or all
            of the list may have to be copied.</remarks>
        </member>
        <member name="M:Loyc.Collections.WListProtected`1.ToRVList">
            <summary>Returns this list as an RVList; if this is a FWList, the order 
            of the elements is reversed at the same time.</summary>
            <remarks>This operation marks the items of the FWList or RWList as 
            immutable. You can still modify the list afterward, but some or all
            of the list may have to be copied.</remarks>
        </member>
        <member name="P:Loyc.Collections.WListProtected`1.Block">
            <summary>Reference to VListBlock that contains items at the "front" 
            of the list. _block can be null if the list is empty.</summary>
        </member>
        <member name="P:Loyc.Collections.WListProtected`1.LocalCount">
            <summary>Number of items in _block that belong to this list.</summary>
        </member>
        <member name="P:Loyc.Collections.WListProtected`1.IsOwner">
            <summary>Specifies whether this object owns the mutable part of _block.</summary>
            <remarks>
            Two WLists can have pointers to the same mutable block, but only one 
            can be the owner. The non-owner must not modify the block.
            <para/>
            This flag is false if _block.IsMutable is false.</remarks>
        </member>
        <member name="P:Loyc.Collections.WListProtected`1.UserByte">
            <summary>An additional byte that the derived class can optionally use.</summary>
            <remarks>Used by Loyc.</remarks>
        </member>
        <member name="P:Loyc.Collections.WListProtected`1.InternalVList">
            <summary>Returns this list as a FVList without marking all items as 
            immutable. This is for internal use only; a FVList with mutable items 
            is never returned from a public method.</summary>
        </member>
        <member name="P:Loyc.Collections.WListProtected`1.BlockChainLength">
            <summary>Gets the number of blocks used by this list.</summary>
            <remarks>You might look at this property when optimizing your program,
            because the runtime of some operations increases as the chain length 
            increases. This property runs in O(BlockChainLength) time. Ideally,
            BlockChainLength is proportional to log_2(Count), but if you produced 
            the FWList by converting it from a FVList, certain FVList usage patterns 
            can produce long chains.</remarks>
        </member>
        <member name="M:Loyc.Collections.WListBase`1.Push(`0)">
            <summary>Synonym for Add(); adds an item to the front of the list.</summary>
        </member>
        <member name="M:Loyc.Collections.WListBase`1.op_Explicit(Loyc.Collections.WListBase{`0})~Loyc.Collections.FVList{`0}">
            <summary>Returns this list as a FVList; if this is a RWList, the order 
            of the elements is reversed at the same time.</summary>
            <remarks>This operation marks the items of the FWList or RWList as 
            immutable. You can still modify the list afterward, but some or all
            of the list may have to be copied.</remarks>
        </member>
        <member name="M:Loyc.Collections.WListBase`1.op_Explicit(Loyc.Collections.WListBase{`0})~Loyc.Collections.RVList{`0}">
            <summary>Returns this list as an RVList; if this is a FWList, the order 
            of the elements is reversed at the same time.</summary>
            <remarks>This operation marks the items of the FWList or RWList as 
            immutable. You can still modify the list afterward, but some or all
            of the list may have to be copied.</remarks>
        </member>
        <member name="M:Loyc.Collections.FWList`1.Where(System.Predicate{`0})">
            <summary>Applies a filter to a list, to exclude zero or more
            items.</summary>
            <param name="keep">A function that chooses which items to include
            (exclude items by returning false).</param>
            <returns>The list after filtering has been applied. The original RVList
            structure is not modified.</returns>
            <remarks>
            If the predicate keeps the first N items it is passed (which are the
            last or "tail" items in a FWList), those N items are typically not 
            copied, but shared between the existing list and the new one.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.FWList`1.SmartSelect(System.Func{`0,`0})">
            <summary>Maps a list to another list of the same length.</summary>
            <param name="map">A function that transforms each item in the list.</param>
            <returns>The list after the map function is applied to each item. The 
            original RVList structure is not modified.</returns>
            <remarks>
            This method is called "Smart" because of what happens if the map
            doesn't do anything. If the map function returns the first N items
            unmodified (the items at the tail of the FWList), those N items are 
            typically not copied, but shared between the existing list and the 
            new one.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.FWList`1.Select``1(System.Func{`0,``0})">
            <summary>Maps a list to another list of the same length.</summary>
            <param name="map">A function that transforms each item in the list.</param>
            <returns>The list after the map function is applied to each item. The 
            original RVList structure is not modified.</returns>
        </member>
        <member name="M:Loyc.Collections.FWList`1.Transform(Loyc.Collections.VListTransformer{`0})">
            <summary>Transforms a list (combines filtering with selection and more).</summary>
            <param name="x">Method to apply to each item in the list</param>
            <returns>A list formed from transforming all items in the list</returns>
            <remarks>See the documentation of FVList.Transform() for more information.</remarks>
        </member>
        <member name="M:Loyc.Collections.FWList`1.Pop">
            <summary>Removes the front item (at index 0) from the list and returns it.</summary>
        </member>
        <member name="M:Loyc.Collections.FWList`1.op_Explicit(Loyc.Collections.FWList{`0})~Loyc.Collections.RWList{`0}">
            <summary>Returns this list as an RWList, which effectively reverses 
            the order of the elements.</summary>
            <remarks>This operation marks the items of the list as immutable.
            You can modify either list afterward, but some or all of the list 
            may have to be copied.</remarks>
        </member>
        <member name="M:Loyc.Collections.FWList`1.ToRWList">
            <summary>Returns this list as an RWList, which effectively reverses 
            the order of the elements.</summary>
            <remarks>This operation marks the items of the list as immutable.
            You can modify either list afterward, but some or all of the list 
            may have to be copied.</remarks>
        </member>
        <member name="M:Loyc.Collections.FWList`1.ToArray">
            <summary>Returns the FWList converted to an array.</summary>
        </member>
        <member name="P:Loyc.Collections.FWList`1.Item(System.Int32,`0)">
            <summary>Gets an item from the list at the specified index; returns 
            defaultValue if the index is not valid.</summary>
        </member>
        <member name="P:Loyc.Collections.FWList`1.Front">
            <summary>Returns the front item of the list (at index 0).</summary>
        </member>
        <member name="T:Loyc.Collections.RVList`1">
            <summary>
            RVList represents a reference to a reverse-order FVList.
            </summary><remarks>
            FVList is a persistent list data structure described in Phil Bagwell's 2002
            paper "Fast Functional Lists, Hash-Lists, Deques and Variable Length
            Arrays". RVList is the name I (DLP) give to a variant of this structure in
            which new elements are efficiently added to the end of the list rather 
            than to the beginning. See the remarks of <see cref="T:Loyc.Collections.VListBlock`1"/> for a 
            more detailed description.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.RVList`1.op_Equality(Loyc.Collections.RVList{`0},Loyc.Collections.RVList{`0})">
            <summary>Returns whether the two list references are the same.
            Does not compare the contents of the lists.</summary>
        </member>
        <member name="M:Loyc.Collections.RVList`1.op_Inequality(Loyc.Collections.RVList{`0},Loyc.Collections.RVList{`0})">
            <summary>Returns whether the two list references are different.
            Does not compare the contents of the lists.</summary>
        </member>
        <member name="M:Loyc.Collections.RVList`1.Equals(System.Object)">
            <summary>Returns whether the two list references are the same.
            Does not compare the contents of the lists.</summary>
        </member>
        <member name="M:Loyc.Collections.RVList`1.Pop">
            <summary>Removes the last item (at index Count-1) from the list and returns it.</summary>
        </member>
        <member name="M:Loyc.Collections.RVList`1.Push(`0)">
            <summary>Synonym for Add(); adds an item to the front of the list.</summary>
        </member>
        <member name="M:Loyc.Collections.RVList`1.op_Explicit(Loyc.Collections.RVList{`0})~Loyc.Collections.FVList{`0}">
            <summary>Returns this list as a FVList, which effectively reverses the
            order of the elements.</summary>
            <remarks>This is a trivial operation; the FVList shares the same memory.</remarks>
        </member>
        <member name="M:Loyc.Collections.RVList`1.ToFVList">
            <summary>Returns this list as a FVList, which effectively reverses the
            order of the elements.</summary>
            <returns>This is a trivial operation; the FVList shares the same memory.</returns>
        </member>
        <member name="M:Loyc.Collections.RVList`1.op_Explicit(Loyc.Collections.RVList{`0})~Loyc.Collections.FWList{`0}">
            <summary>Returns this list as a FWList, which effectively reverses the
            order of the elements.</summary>
            <remarks>The list contents are not copied until you modify the FWList.</remarks>
        </member>
        <member name="M:Loyc.Collections.RVList`1.ToWList">
            <summary>Returns this list as a FWList, which effectively reverses the
            order of the elements.</summary>
            <remarks>The list contents are not copied until you modify the FWList.</remarks>
        </member>
        <member name="M:Loyc.Collections.RVList`1.op_Explicit(Loyc.Collections.RVList{`0})~Loyc.Collections.RWList{`0}">
            <summary>Returns this list as an RWList.</summary>
            <remarks>The list contents are not copied until you modify the RWList.</remarks>
        </member>
        <member name="M:Loyc.Collections.RVList`1.ToRWList">
            <summary>Returns this list as an RWList.</summary>
            <remarks>The list contents are not copied until you modify the RWList.</remarks>
        </member>
        <member name="M:Loyc.Collections.RVList`1.ToArray">
            <summary>Returns the RVList converted to an array.</summary>
        </member>
        <member name="M:Loyc.Collections.RVList`1.IndexOf(`0)">
             <summary>Searches for the specified object and returns the zero-based
             index of the first occurrence (lowest index) within the entire
             RVList.</summary>
             <param name="item">Item to locate (can be null if T can be null)</param>
             <returns>Index of the item, or -1 if it was not found.</returns>
             <remarks>This method determines equality using the default equality
             comparer EqualityComparer.Default for T, the type of values in the list.
            
             This method performs a linear search, and is typically an O(n)
             operation, where n is Count. However, because the list is searched
             upward from index 0 to Count-1, if the list's blocks do not increase in
             size exponentially (due to the way that the list has been modified in
             the past), the search can have worse performance; the (unlikely) worst
             case is O(n^2). FVList(of T).IndexOf() doesn't have this problem.
             </remarks>
        </member>
        <member name="M:Loyc.Collections.RVList`1.System#Collections#Generic#ICollection{T}#Add(`0)">
            <summary>Inserts an item at the back (index Count) of the RVList.</summary>
        </member>
        <member name="M:Loyc.Collections.RVList`1.Add(`0)">
            <summary>Inserts an item at the back (index Count) of the RVList.</summary>
        </member>
        <member name="M:Loyc.Collections.RVList`1.Where(System.Predicate{`0})">
            <summary>Applies a filter to a list, to exclude zero or more
            items.</summary>
            <param name="keep">A function that chooses which items to include
            (exclude items by returning false).</param>
            <returns>The list after filtering has been applied. The original RVList
            structure is not modified.</returns>
            <remarks>
            If the predicate keeps the first N items it is passed, those N items are
            typically not copied, but shared between the existing list and the new 
            one.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.RVList`1.SmartSelect(System.Func{`0,`0})">
            <summary>Maps a list to another list of the same length.</summary>
            <param name="map">A function that transforms each item in the list.</param>
            <returns>The list after the map function is applied to each item. The 
            original RVList structure is not modified.</returns>
            <remarks>
            This method is called "Smart" because of what happens if the map
            doesn't do anything. If the map function returns the first N items
            unmodified, those N items are typically not copied, but shared between
            the existing list and the new one. This is useful for functional code
            that sometimes processes a list without modifying it at all.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.RVList`1.Select``1(System.Func{`0,``0})">
            <summary>Maps a list to another list of the same length.</summary>
            <param name="map">A function that transforms each item in the list.</param>
            <returns>The list after the map function is applied to each item. The 
            original RVList structure is not modified.</returns>
        </member>
        <member name="M:Loyc.Collections.RVList`1.Transform(Loyc.Collections.VListTransformer{`0})">
            <summary>Transforms a list (combines filtering with selection and more).</summary>
            <param name="x">Method to apply to each item in the list</param>
            <returns>A list formed from transforming all items in the list</returns>
            <remarks>See the documentation of FVList.Transform() for more information.</remarks>
        </member>
        <member name="P:Loyc.Collections.RVList`1.Tail">
            <summary>Returns a list without the last item. If the list is empty, 
            an empty list is retured.</summary>
        </member>
        <member name="P:Loyc.Collections.RVList`1.Last">
            <summary>Returns the last item of the list (at index Count-1), which is the head of the list.</summary>
        </member>
        <member name="P:Loyc.Collections.RVList`1.BlockChainLength">
            <summary>Gets the number of blocks used by this list.</summary>
            <remarks>You might look at this property when optimizing your program,
            because the runtime of some operations increases as the chain length 
            increases. This property runs in O(BlockChainLength) time. Ideally,
            BlockChainLength is proportional to log_2(Count), but certain RVList 
            usage patterns can produce long chains.</remarks>
        </member>
        <member name="P:Loyc.Collections.RVList`1.Item(System.Int32,`0)">
            <summary>Gets an item from the list at the specified index; returns 
            defaultValue if the index is not valid.</summary>
        </member>
        <member name="T:Loyc.Collections.RVList`1.Enumerator">
            <summary>Enumerates through an RVList from index 0 up to index Count-1.
            </summary><remarks>
            Normally, enumerating the list takes O(Count + log(Count)^2) = O(Count)
            time. However, if the list's block chain does not increase in size 
            exponentially (due to the way that the list has been modified in the 
            past), the search can have worse performance; the worst case is O(n^2),
            but this is unlikely. FVList's Enumerator doesn't have this problem 
            because it enumerates in the other direction.</remarks>
        </member>
        <member name="T:Loyc.Collections.RWList`1">
            <summary>
            RWList is the mutable variant of the RVList data structure.
            </summary>
            <remarks>See the remarks of <see cref="T:Loyc.Collections.VListBlock`1"/> for more information
            about VLists and WLists. It is most efficient to add items to the front of
            a FWList (at index 0) or the back of an RWList (at index Count-1).</remarks>
        </member>
        <member name="M:Loyc.Collections.RWList`1.Where(System.Predicate{`0})">
            <summary>Applies a filter to a list, to exclude zero or more
            items.</summary>
            <param name="keep">A function that chooses which items to include
            (exclude items by returning false).</param>
            <returns>The list after filtering has been applied. The original RVList
            structure is not modified.</returns>
            <remarks>
            If the predicate keeps the first N items it is passed (which are the
            last or "tail" items in a WList), those N items are typically not 
            copied, but shared between the existing list and the new one.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.RWList`1.SmartSelect(System.Func{`0,`0})">
            <summary>Maps a list to another list of the same length.</summary>
            <param name="map">A function that transforms each item in the list.</param>
            <returns>The list after the map function is applied to each item. The 
            original RVList structure is not modified.</returns>
            <remarks>
            This method is called "Smart" because of what happens if the map
            doesn't do anything. If the map function returns the first N items
            unmodified (the items at the tail of the WList), those N items are 
            typically not copied, but shared between the existing list and the 
            new one.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.RWList`1.Select``1(System.Func{`0,``0})">
            <summary>Maps a list to another list of the same length.</summary>
            <param name="map">A function that transforms each item in the list.</param>
            <returns>The list after the map function is applied to each item. The 
            original RVList structure is not modified.</returns>
        </member>
        <member name="M:Loyc.Collections.RWList`1.Transform(Loyc.Collections.VListTransformer{`0})">
            <summary>Transforms a list (combines filtering with selection and more).</summary>
            <param name="x">Method to apply to each item in the list</param>
            <returns>A list formed from transforming all items in the list</returns>
            <remarks>See the documentation of FVList.Transform() for more information.</remarks>
        </member>
        <member name="M:Loyc.Collections.RWList`1.Pop">
            <summary>Removes the back item (at index Count-1) from the list and returns it.</summary>
        </member>
        <member name="M:Loyc.Collections.RWList`1.op_Explicit(Loyc.Collections.RWList{`0})~Loyc.Collections.FWList{`0}">
            <summary>Returns this list as a FWList, which effectively reverses 
            the order of the elements.</summary>
            <remarks>This operation marks the items of the list as immutable.
            You can modify either list afterward, but some or all of the list 
            may have to be copied.</remarks>
        </member>
        <member name="M:Loyc.Collections.RWList`1.ToWList">
            <summary>Returns this list as a FWList, which effectively reverses 
            the order of the elements.</summary>
            <remarks>This operation marks the items of the list as immutable.
            You can modify either list afterward, but some or all of the list 
            may have to be copied.</remarks>
        </member>
        <member name="M:Loyc.Collections.RWList`1.ToArray">
            <summary>Returns the RWList converted to an array.</summary>
        </member>
        <member name="M:Loyc.Collections.RWList`1.Resize(System.Int32)">
            <summary>Resizes the list to the specified size.</summary>
            <remarks>If the new size is larger than the old size, empty elements 
            are added to the end. If the new size is smaller, elements are 
            truncated from the end.
            <para/>
            I decided not to offer a Resize() method for the FWList because the 
            natural place to insert or remove items in a FWList is at the beginning.
            For a Resize() method to do so, I felt, would come as too much of a 
            surprise to some programmers.
            </remarks>
        </member>
        <member name="P:Loyc.Collections.RWList`1.Item(System.Int32,`0)">
            <summary>Gets an item from the list at the specified index; returns 
            defaultValue if the index is not valid.</summary>
        </member>
        <member name="P:Loyc.Collections.RWList`1.Back">
            <summary>Returns the last item of the list (at index Count-1).</summary>
        </member>
        <member name="T:Loyc.Collections.VListBlock`1">
            <summary>
            VListBlock implements the core functionality of FVList, RVList, FWList and 
            RWList. It is not intended to be used directly.
            </summary><remarks>
            VList is a persistent list data structure described in Phil Bagwell's 2002
            paper "Fast Functional Lists, Hash-Lists, Deques and Variable Length
            Arrays". I (David P) call the .NET equivalent "FVList" or "forward VList".
            In the forward VList, the "beginning" of the list (index 0) is by far the 
            fastest place to insert items.
            <para/>
            This is unnatural in .NET, so I also created a second data structure, the
            "reverse" VList or RVList, in which the end of the list (index Count-1) is 
            the natural location for adding items. To achieve this, the RVList sees
            the same elements as a FVList, but in reverse order.
            <para/>
            FWList and RWList are the names I picked for the mutable (Writable) 
            variants of FVList and RVList.
            <para/>
            A persistent list is a list that is normally considered immutable, so
            adding an item implies creating a new list rather than changing the one
            you've got. This is fast because persistent lists have a sort of
            copy-on-write semantics, so that "copying" a list is a trivial O(1)
            operation, but modifying a list is sometimes quite inefficient. My 
            implementation of VLists presents a mutable IList(of T) interface, but 
            this is only to adhere to .NET Framework conventions. FVList and RVList 
            are value types that update their own references to the list when they are 
            modified. Thus, "Copying" a list is done with a simple assignment 
            statement. For example:
            <code lang="C#">
            RVList&lt;int&gt; a = new RVList&lt;int&gt;(), b = new RVList&lt;int&gt;();
            a.Add(1);
            a.Add(2);
            b = a;             // copy the list
            a.Add(3);          // a[0] is 1, a[1] is 2, a[2] is 3
            b.Add(97);         // b[0] is 1, b[1] is 2, b[2] is 97
            </code>
            Traditionally, this kind of behavior was accomplished with singly-linked
            lists, but FVList does it with (in essence) a singly-linked list of arrays
            and thereby saves memory while allowing some operations to be done faster
            than they were done with linked lists. In pathological cases, however, FVList
            can use much more memory than a linked list and degenerate so that its
            performance characteristics are almost as bad as a linked list. One major 
            problem that comes to mind is if you keep changing the last item:
            <code lang="C#">
            RVList&lt;int&gt; list = new RVList&lt;int&gt;();
            ... add some items to list ...
            for(int n;; n++)
                list[list.Count-1] = n;
            </code>
            Unlike, for example, a C++-based FVList implementation, it is impossible for
            the FVList or RVList, which are value types, to know if the list has been 
            "copied" or not. In case the list has been copied, changing any element 
            requires a copy to be made of the VListBlock that contains that element, as 
            well as any subsequent blocks (in this example, only the last block must be 
            copied). Thus, the above example produces a lot of garbage very quickly; in 
            fact the rate of garbage production is (very roughly) proportional to the 
            list length. The performance will be equally bad if you repeatedly remove 
            the last item and then re-add it.
            <para/>
            Since this kind of problem tends to get worse as the list gets larger, Phil
            Bagwell proposed using a two- or three-dimentional list arrangement so that
            no single block could exceed a certain size. I have not implemented that
            suggestion due to lack of free time and because I did not understand the
            details of his suggested implementation, but I have placed a size limit of
            1024 elements on any given block. Unfortunately, this means that some
            operations listed below degrade toward O(N) when the list is large, most 
            notably including the indexer, which requires over 1000 iterations to look 
            up element zero in an RVList that has one million elements.
            <para/>
            Due to the slow performance you get from operations like this, I decided 
            to implement FWList, a mutable version of the FVList, which I'll discuss 
            later.
            <para/>
            Similarly to a persistent linked list,
            <ul>
            <li>Adding an item to the front of a VList or the end of an RVList is always
              O(1) in time, and often O(1) in space (though, unlike a linked list, it
              may be much more)</li>
            <li>Removing an item from the front of a VList or the end of an RVList is 
              O(1) in time, although space not necessarily reclaimed.</li>
            <li>Adding or removing an item at the end of a VList or the front of an 
              RVList is O(N) and requires making a copy of the entire list.</li>
            <li>Inserting or removing a list of M items at the end of a VList or the 
              front of an RVList is O(N + M).</li>
            <li>Changing an item at an arbitrary position should be avoided, as it
              performs as poorly as inserting or removing an item at that position.</li>
            </ul>
            VLists, however, offer some operations that singly-linked lists cannot 
            provide efficiently:
            <ul>
            <li>Access by index averages O(1) in ideal conditions</li>
            <li>Getting the list length is typically O(log N), but O(1) in my version</li>
            <li>If a sublist points somewhere within a larger list, its index within the
              larger list can be obtained in between O(1) and O(log N) time.
              Consequently, reverse enumeration is possible without creating a 
              temporary stack or list.</li>
            </ul>
            Also, VLists can (in the best cases) store data almost as compactly as
            ordinary arrays.
            <para/>
            I suspect FVList(of T) and RVList(of T) almost always outperforms 
            LinkedList(of T) in both time and space, if you are always adding and
            removing items at the correct end of the list. And it should perform as 
            well as List(of T) in some situations while providing an illusion of 
            immutability that List(of T) can't. For lists of 0 to 2 items, FVList and 
            RVList use less space than List(of T) (in fact, no object is allocated 
            for an empty FVList or RVList.)
            <para/>
            The FWList is built on the same foundation as the FVList (a linked list of
            VListBlock objects whose size increases exponentially), but it allows 
            you to modify the list just like List&lt;T&gt;. FWList is a hybrid 
            mutable-immutable data structure: a single list can be partly mutable 
            and partly immutable. More specifically, a FWList is conceptually divided 
            into two "halves": the front half is mutable, and the tail half is 
            immutable. The two halves need not be the same size (in fact, very often 
            one half is zero-size).
            <para/>
            Because some or all of a FWList can be immutable, a VList can be converted
            to a FWList, or vice versa, in typically O(log N) time. If you modify a 
            FWList after calling its ToFVList() method, a portion of the list is first 
            copied into a mutable block and then modified, and this copy operation 
            typically takes O(N) time.
            <para/>
            RWList is like FWList except that new items are added at index Count 
            instead of index zero. The head of a FWList is at index 0 and is returned 
            from the First property; the head of an RWList is at index Count-1 and is
            returned from the Last property.
            <para/>
            VListBlock implements a single "node" or "sub-array" within a VList. It
            contains a fixed-size array. When adding a new item to a VListBlock that
            is already full, a new empty VListBlock is created (with a larger array),
            whose _prior reference points to the old VListBlock. See Phil Bagwell's 
            paper (or Wikipedia) for details.
            <para/>
            VListBlock adds one new member to the structure Phil Bagwell described,
            PriorCount, a count of elements in other (smaller) lists to which this list
            is linked. This makes TotalCount an O(1) operation instead of O(log N),
            which is necessary so that RVList[i] and RWList[i] are O(1) on average.
            <para/>
            Independent instances of FVList, RVList, FWList and RWList can be accessed 
            from independent threads even though they may share some of the same 
            memory. Individual instances of these objects, however, are not 
            synchronized.
            <para/>
            A few LINQ-style methods like Select and Where are implemented on the four 
            data structures. These are provided to optimize functional code that takes 
            an input list and produces an output list, but might not actually change 
            the list. If all, or the tail, of the output is the same as the output,
            then the output list will share memory with the input list.
            <para/>
            Note that unlike LINQ methods, these methods are greedy. They perform the 
            requested operation immediately, not as-needed.
            </remarks>
            <typeparam name="T">The type of elements in the list</typeparam>
        </member>
        <member name="F:Loyc.Collections.VListBlock`1._immCount">
            <summary>number of immutable elements in our local array, plus a 
            "mutable" flag in bit 30.</summary>
            <remarks>Aside from the mutable flag, this value only increases, 
            never decreases.
            <para/>
            If the some or all of the block is mutable, _immCount bit 30 is set 
            (0x40000000), and the low bits contain the number of immutable items.
            In that case the total number of items in use, including mutable 
            items, is only known by the FWList or RWList that encapsulates the 
            block.
            <para/>
            The mutable flag is part of this field instead of being a separate 
            flag for two reasons: 
            (1) Saving space. A separate boolean would enlarge the object 4 bytes.
            (2) High-performance thread safety. Instead of using locks, I use 
                interlocked changes to obtain thread safety.
            <para/>
            I don't know how fast or slow .NET locking is, but I assume you can't
            get faster than a single Interlocked.CompareExchange, so I have 
            designed thread safety around _immCount.
            <para/>
            I hate trying to guarantee thread safety because I don't know how to 
            prove correctness. I know that thread safety must be considered for 
            at least the following operations:
            <ul>
            <li>Adding an item at the end of an immutable VListBlock: two VLists 
            on different threads may try to add an item to the "front" of the same 
            block at the same time.</li>
            <li>Reserving mutable items in a list: two threads may do this at once, 
            or an immutable VList may add an item at the same instant.</li>
            </ul>
            Interlocked.CompareExchange() is used in both cases, which ensures 
            that only one thread succeeds and any threads that fail do not alter 
            the value of the field.
            <para/>
            A mutable block can be made immutable again by clearing bit 30. No
            interlocked exchange is required for this, since any thread that 
            notices bit 30 is set will not attempt to modify this field in the 
            first place.
            <para/>
            We need not worry about thread safety in order to obtain the immutable
            tail of a list (or equivalently, to remove items from the "front") 
            because that operation doesn't make use of this field (Remember, each 
            instance of VList has its own private _localCount.) Nor do we need to 
            worry about enumerating or modifying an immutable list (the latter is 
            just an illusion, after all). 
            <para/>
            I have not concerned myself with thread safety when a single VList 
            instance (whether mutable or immutable) is accessed from multiple 
            threads, because doing so is not supported. It occurs to me, however, 
            that there could be security concerns if untrusted code is given 
            access to any kind of VList; e.g. perhaps malicious code could 
            corrupt a VListBlock somehow by exploiting lack of thread safety.
            <para/>
            Theoretically you shouldn't modify an FWList/RWList while it is being
            enumerated, but the danger is limited to an incorrect sequence of 
            items being returned from the enumerator; a "subList is not within 
            list" exception is also possible.
            <para/>
            Important things to note: 
            (1) once items are switched from mutable to immutable, they can never 
                be made mutable again, since there is no way to know if any 
                immutable VList references still exist.
            (2) mutable items always belong to exactly one FWList or one RWList,
                but a VListBlock doesn't know what FWList it belongs to. A FWList 
                or RWList is detached from its VListBlock when Clear() is called,
                making the block immutable again.
            (3) if not all the items in a VListBlock are mutable, then the Prior 
                list is guaranteed to be immutable. In other words, mutable and 
                immutable items are not interleaved; mutable items are always at 
                the "front" and immutable items are always at the "back" (which
                is the beginning of an RVList or end of an FVList).
            (4) When the mutable flag is set, _immCount appears to be a very 
                large number. Code that uses _immCount directly instead of 
                calling ImmCount is taking advantage of that fact.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.VListBlock`1.FGet(System.Int32,System.Int32)">
            <summary>Gets an item at distance 'index' from the front (beginning of an FVList)</summary>
            <remarks>FGet and RGet were added as an optimization, to reduce the 
            minimum number of virtual calls from 2 to 1 and to decrease the number 
            of calculations involved in looking up an item.</remarks>
        </member>
        <member name="M:Loyc.Collections.VListBlock`1.RGet(System.Int32,System.Int32)">
            <summary>Gets an item at distance 'index' from the back (beginning of an RVList)</summary>
        </member>
        <member name="M:Loyc.Collections.VListBlock`1.Add(System.Int32,`0)">
            <summary>Inserts a new item at the "front" of a FVList where localCount
            is the number of items currently in the FVList's first block.
            </summary>
        </member>
        <member name="M:Loyc.Collections.VListBlock`1.Add(Loyc.Collections.VListBlock{`0},System.Int32,`0)">
            <summary>Adds an item to the "front" of an immutable FVList.</summary>
        </member>
        <member name="M:Loyc.Collections.VListBlock`1.SubList(System.Int32)">
            <summary>
            Returns a list in which this[localIndex-1] is the first item.
            Nonpositive indexes are allowed and refer to prior lists; SubList
            returns an empty list if localIndex is so low that it goes past the back
            of the list.
            </summary>
            <remarks>Warning: Normally FVList can only contain a reference to an
            immutable list, but this method can return a reference that includes 
            mutable items.</remarks>
        </member>
        <member name="M:Loyc.Collections.VListBlock`1.Insert(Loyc.Collections.VListBlock{`0},System.Int32,`0,System.Int32)">
            <summary>Inserts a new item in a FVList where localCount is the number
            of items in the FVList's first block and distanceFromFront is the
            insertion position (0=front).
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">distanceFromFront was out of range.</exception>
            <returns>The block resulting from the insert (may or may not be 'this')</returns>
            <remarks>This method is for use by immutable VLists only.</remarks>
        </member>
        <member name="M:Loyc.Collections.VListBlock`1.InsertRange(Loyc.Collections.VListBlock{`0},System.Int32,System.Collections.Generic.IList{`0},System.Int32,System.Boolean)">
            <summary>Inserts a list of items in the middle of a FVList, where
            localCount is the number of items in the FVList's first block and
            distanceFromFront is the insertion position (0=front).
            </summary>
            <param name="isRVList">Indicates the insertion order. If isRVList==true,
            the items[0] is inserted first (which is appropriate for an RVList),
            otherwise it is inserted last (which is appropriate for a FVList)</param>
            <exception cref="T:System.IndexOutOfRangeException">distanceFromFront was out of
            range.</exception>
            <returns>The FVList containing the inserted items.</returns>
            <remarks>This method is for use by immutable VLists only.</remarks>
        </member>
        <member name="M:Loyc.Collections.VListBlock`1.ReplaceAt(System.Int32,`0,System.Int32)">
            <summary>Replaces an item in a FVList with another, where localCount is
            the number of items in the FVList's first block and distanceFromFront is
            the element index to replace (0=front).
            </summary>
            <returns>The list resulting from the change. Note that this operation
            is inefficient; it aways allocates a new block.</returns>
            <remarks>This method is for use by immutable VLists only.</remarks>
        </member>
        <member name="M:Loyc.Collections.VListBlock`1.RemoveAt(System.Int32,System.Int32)">
            <summary>
            Removes the specified number of items from a FVList where localCount is
            the number of items in the FVList's first block, distanceFromFront is the
            first removal position (minimum 0) and count is the number of items to
            remove. Of course, the terminology used here is to be understood in the
            context of a FVList (in which items are inserted at the front of the
            list).
            </summary>
            <returns>The modified list.</returns>
            <remarks>This method is for use by immutable VLists only.</remarks>
        </member>
        <member name="M:Loyc.Collections.VListBlock`1.AddRange(Loyc.Collections.VListBlock{`0},System.Int32,System.Collections.Generic.IEnumerator{`0})">
            <summary>Adds a list of items to an immutable RVList (not a FVList).</summary>
            <remarks>This method is for use by immutable RVLists only.</remarks>
        </member>
        <member name="M:Loyc.Collections.VListBlock`1.AddRange(Loyc.Collections.VListBlock{`0},System.Int32,System.Collections.Generic.IList{`0},System.Boolean)">
            <summary>Adds a list of items to an immutable FVList.</summary>
            <remarks>This method is for use by immutable VLists only.</remarks>
        </member>
        <member name="M:Loyc.Collections.VListBlock`1.AddRange(Loyc.Collections.VListBlock{`0},System.Int32,Loyc.Collections.FVList{`0},Loyc.Collections.FVList{`0})">
            <summary>Adds a range of items to a FVList where localCount is the
            number of items in the FVList's first block, front points to the
            beginning of the range to add and back points to the end of the range.
            </summary>
            <returns>A new list with the specified range added to it.</returns>
            <remarks>
            back.Front is NOT included in the range (in fact back can be an empty
            list) but front.Front is included unless front is also empty.
            
            The elements of the range are inserted in "reverse" (from back to
            front) so that the order of the elements in the range is preserved
            (adding them front-first to our front would reverse their order).
            <para/>
            This method is for use by immutable VLists only.</remarks>
        </member>
        <member name="M:Loyc.Collections.VListBlock`1.AddRange(Loyc.Collections.FVList{`0},Loyc.Collections.FVList{`0})">
            <summary>Appends a range of items to the "front" of this block.</summary>
            <returns>This block, or a new block if a new block had to be allocated.</returns>
            <remarks>This method is for use by immutable VLists only.</remarks>
        </member>
        <member name="M:Loyc.Collections.VListBlock`1.FindNextBlock(Loyc.Collections.FVList{`0}@,Loyc.Collections.FVList{`0},System.Int32@)">
            <summary>
            Finds the block that comes before 'subList' in the direction of the
            larger list, 'list'.
            </summary>
            <param name="subList">Sublist of list, or an empty list.</param>
            <param name="list">The larger, outer list. Can be an empty list if
            subList is empty.</param>
            <param name="localCountOfSubList">The value of
            r._block.Prior._localCount where r is the return value, or, if r is
            empty, the value of list._localCount.</param>
            <returns>The list prior to subList, or an empty block if
            (1) list and subList are in the same block
            (2) list._localCount==0 and list._block.Prior is in the same block as subList</returns>
            <remarks>
            Because of the copy-causing-sharing-failure problem (described in a
            comment in RVListTests.TestSublistProblem()), FindNextBlock may have to
            change subList in certain cases so that it really is a sublist of list.
            Therefore it is a ref argument.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.VListBlock`1.EnsureImmutable(Loyc.Collections.VListBlock{`0},System.Int32)">
            <summary>Returns an immutable FVList with the specified parameters, 
            modifying blocks if necessary.</summary>
            <param name="localCount">Number of items in 'self' that belong to the 
            list that you want to make immutable. Nonpositive values of localCount
            are allowed and refer to blocks prior to 'self'.</param>
            <remarks>This method may change self and/or other blocks in the chain 
            so that the returned FVList contains no mutable items.</remarks>
        </member>
        <member name="M:Loyc.Collections.VListBlock`1.EnsureMutable(Loyc.Collections.WListProtected{`0},System.Int32)">
            <summary>Ensures that at least the specified number of items at the 
            front of a FWList or RWList are mutable and owned by the list.</summary>
            <param name="mutablesNeeded">Number of mutable items required.</param>
        </member>
        <member name="M:Loyc.Collections.VListBlock`1.MuClear(System.Int32)">
            <summary>Clears all mutable items in this chain, and clears the mutable 
            flag. If this block owns mutable items in prior blocks, they are 
            cleared too.</summary>
            <remarks>Clearing items is unnecessary if ImmCount is zero, as there 
            there are no shared copies and the caller is going to discard the block,
            so it'll be garbage anyway.</remarks>
        </member>
        <member name="M:Loyc.Collections.VListBlock`1.MuAddEmpty(Loyc.Collections.WListProtected{`0},System.Int32,System.Int32)">
            <summary>Adds empty item(s) to the front of the list.</summary>
            <param name="w">List that needs items</param>
            <param name="count">Number of items to add</param>
            <param name="newBlockSizeLimit">Limit on size of new block(s); normally
            VListBlockArray.MAX_BLOCK_LEN (this parameter is used by EnsureMutable()).</param>
            <remarks>This method doesn't actually clear the items, because all 
            items that are not in use should already have been set to default(T).
            </remarks>
        </member>
        <member name="M:Loyc.Collections.VListBlock`1.MuAllocBlock(Loyc.Collections.WListProtected{`0},System.Int32)">
            <summary>Used by MuAddEmpty to allocate an empty mutable block.</summary>
            <returns>Capacity of the new block</returns>
            <remarks>w is changed to point to the new block (w._localCount is set to 0)</remarks>
        </member>
        <member name="M:Loyc.Collections.VListBlock`1.MuMove(Loyc.Collections.WListProtected{`0},System.Int32,System.Int32,System.Int32)">
            <summary>Moves a series of elements from one location to another in a 
            mutable block.</summary>
            <param name="w">List to modify</param>
            <param name="dffFrom">Distance from front of the beginning of the block to move</param>
            <param name="dffTo">Distance from front of destination location</param>
            <param name="count">Number of elements to copy</param>
        </member>
        <member name="M:Loyc.Collections.VListBlock`1.Front(System.Int32)">
            <summary>Returns the "front" item in a FVList/FWList associated with 
            this block (or back item of a RVList) where localCount is the 
            number of items in the FVList's first block.
            </summary>
        </member>
        <member name="M:Loyc.Collections.VListBlock`1.ToArray(Loyc.Collections.VListBlock{`0},System.Int32,System.Boolean)">
            <summary>Converts any kind of FVList to an array, quickly.</summary>
        </member>
        <member name="M:Loyc.Collections.VListBlock`1.Transform(Loyc.Collections.VListBlock{`0},System.Int32,Loyc.Collections.VListTransformer{`0},System.Boolean,Loyc.Collections.WListProtected{`0})">
            <summary>Transforms a list (combines filtering with selection and more).</summary>
            <param name="x">Method to apply to each item in the list</param>
            <returns>A list formed from transforming all items in the list</returns>
            <remarks>See the documentation of FVList.Transform() for more information.</remarks>
        </member>
        <member name="P:Loyc.Collections.VListBlock`1.IsMutable">
            <summary>Returns true if part or all of the block is mutable.</summary>
        </member>
        <member name="P:Loyc.Collections.VListBlock`1.PriorCount">
            <summary>Returns the number of immutable items in all previous 
            blocks.</summary>
        </member>
        <member name="P:Loyc.Collections.VListBlock`1.Prior">
            <summary>Returns a FVList representing the tail of the chain of 
            VListBlocks.</summary>
            <remarks>Warning: Normally FVList can only contain a reference to an
            immutable list, but this property may return a reference to a 
            mutable block if the current block is 100% mutable. Be careful with 
            this value, as FVList is not designed to handle mutable contents!</remarks>
        </member>
        <member name="P:Loyc.Collections.VListBlock`1.PriorIsOwned">
            <summary>Returns true if this block has exclusive ownership of mutable 
            items in the prior block. Returns false if the prior block is entirely 
            immutable, if we don't have ownership, or if there is no prior block.</summary>
            <remarks>This one's hard to explain without a diagram. Note: since 
            there is no independent flag to indicate ownership, the logic in this 
            property relies on the fact that a new mutable block is never created 
            until the prior block is full; if one creates a new mutable block when 
            there is free space but no mutable items allocated in the prior block, 
            this property returns false because it assumes the free space was 
            reserved by some other WList than the list that owns this block.</remarks>
        </member>
        <member name="P:Loyc.Collections.VListBlock`1.ImmCount">
            <summary>Gets the number of immutable elements in-use in our local array.</summary>
            <remarks>Mutable items are not included in the count.</remarks>
        </member>
        <member name="P:Loyc.Collections.VListBlock`1.TotalCount">
            <summary>Returns the number of immutable elements in-use in the entire chain</summary>
        </member>
        <member name="P:Loyc.Collections.VListBlock`1.Capacity">
            <summary>Returns the maximum number of elements in this block</summary>
        </member>
        <member name="P:Loyc.Collections.VListBlock`1.Item(System.Int32)">
            <summary>Gets/sets the specified value at the specified index of this
            block's array, or, if localIndex is negative, searches recursively in
            previous blocks for the desired index.</summary>
            <remarks>A FVList computes localIndex as FVList._localCount-1-index.
            <para/>
            FVList/RVList is responsible for checking that the user's index is 
            valid and throwing IndexOutOfRangeException if not.
            <para/>
            The setter can only be called on mutable indices!
            </remarks>
        </member>
        <member name="T:Loyc.Collections.XfAction">
            <summary>Values that can be returned by the VListTransformer function that 
            the user passes to the Transform method in FVList, RVList, FWList or RWList.
            </summary>
        </member>
        <member name="F:Loyc.Collections.XfAction.Drop">
            <summary>Do not include the item in the output list</summary>
        </member>
        <member name="F:Loyc.Collections.XfAction.Keep">
            <summary>Include the original item in the output list</summary>
        </member>
        <member name="F:Loyc.Collections.XfAction.Change">
            <summary>Include the modified item in the output list</summary>
        </member>
        <member name="F:Loyc.Collections.XfAction.Repeat">
            <summary>Include the modified item in the output, and transform it again</summary>
        </member>
        <member name="T:Loyc.Collections.VListTransformer`1">
            <summary>User-supplied list transformer function.</summary>
            <param name="item">An item from the FVList or RVList</param>
            <param name="i">Index of the item</param>
            <returns>See the documentation of FVList.Transform() for
            instructions and possible return values.</returns>
        </member>
        <member name="T:Loyc.Collections.VListBlockArray`1">
            <summary>
            Implementation of VListBlock(of T) that contains an array. It is always
            initialized with at least one item, and items cannot be removed unless 
            the list is mutable.
            </summary>
            <remarks>
            _prior._block is never null because the last block in a chain is always a
            VListBlockOfTwo. _array is never null either and _priorCount is at least 2.
            </remarks>
        </member>
        <member name="F:Loyc.Collections.VListBlockArray`1._priorCount">
            <summary>Combined length of prior blocks</summary>
        </member>
        <member name="F:Loyc.Collections.VListBlockArray`1._prior">
            <summary>The prior list, to which this list adds more items.</summary>
            <remarks>Warning: if the current block is 100% mutable then _prior can 
            include mutable items.
            <para/>
            _prior is never changed if the block contains immutable items.</remarks>
        </member>
        <member name="F:Loyc.Collections.VListBlockArray`1._array">
            <summary>The local array (elements [0.._localCount - 1] are in use).
            _array[_localCount-1] is the "front" of the list according to the
            terminology of a FVList, but it's the back of the list in the
            terminology of a RVList.</summary>
            <remarks>
            The method descriptions here use the terminology of a FVList, so if
            we're talking about _array[i], and i is increasing, then we are getting
            closer to the "front" of the list.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.VListBlockArray`1.#ctor(Loyc.Collections.FVList{`0},`0)">
            <summary>Inits an immutable block with one item.</summary>
        </member>
        <member name="M:Loyc.Collections.VListBlockArray`1.#ctor(Loyc.Collections.FVList{`0},System.Int32,System.Boolean)">
            <summary>Inits an empty block.</summary>
            <param name="localCapacity">Max item count in this block, or zero to 
            let the constructor choose the capacity.</param>
            <remarks>If this constructor is called directly, mutable must be true, 
            because immutable blocks must have at least one item.
            </remarks>
        </member>
        <member name="T:Loyc.Collections.VListBlockOfTwo`1">
            <summary>The tail of a VList contains only one or two items. To improve 
            efficiency slightly, these two-item lists are represented by a
            VListBlockOfTwo, which is more compact than VListBlockArray.</summary>
            <remarks>
            TODO: create a more efficient version using a "fixed T _array2[2]" in an
            unsafe code block (assuming it is generics-compatible).
            </remarks>
        </member>
        <member name="M:Loyc.Collections.VListBlockOfTwo`1.#ctor">
            <summary>Initializes a mutable block with no items.</summary>
        </member>
        <member name="M:Loyc.Collections.VListBlockOfTwo`1.#ctor(`0,`0,System.Boolean)">
            <summary>Initializes a block with two items.</summary>
            <remarks>The secondItem is added second, so it will occupy position [0]
            of a FVList or position [1] of an RVList.</remarks>
        </member>
    </members>
</doc>
