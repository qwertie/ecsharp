<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Loyc.Syntax</name>
    </assembly>
    <members>
        <member name="T:Loyc.Syntax.Les.Les2Lexer">
            <summary>Lexer for EC# source code.</summary>
            <seealso cref="T:Loyc.Syntax.Lexing.ILexer`1"/>
            <seealso cref="T:Loyc.Syntax.Lexing.TokensToTree"/>
        </member>
        <member name="F:Loyc.Syntax.Les.Les2Lexer.SkipValueParsing">
            <summary>Used for syntax highlighting, which doesn't care about token values.
            This option causes the Token.Value to be set to a default, like '\0' for 
            single-quoted strings and 0 for numbers. Operator names are still parsed.</summary>
        </member>
        <member name="M:Loyc.Syntax.Les.Les2Lexer.UnescapeQuotedString(Loyc.UString@,System.Action{System.Int32,System.String},Loyc.UString,System.Boolean)">
            <summary>Parses a normal or triple-quoted string that still includes 
            the quotes. Supports quote types '\'', '"' and '`'.</summary>
            <param name="sourceText">input text</param>
            <param name="onError">Called in case of parsing error (unknown escape sequence or missing end quotes)</param>
            <param name="indentation">Inside a triple-quoted string, any text
            following a newline is ignored as long as it matches this string. 
            For example, if the text following a newline is "\t\t Foo" and this
            string is "\t\t\t", the tabs are ignored and " Foo" is kept.</param>
            <param name="les3TQIndents">Enable EC# triple-quoted string indent
            rules, which allow an additional one tab or three spaces of indent.
            (I'm leaning toward also supporting this in LES; switched on in v3)</param>
            <returns>The decoded string</returns>
            <remarks>This method recognizes LES and EC#-style string syntax.
            Firstly, it recognizes triple-quoted strings (''' """ ```). These 
            strings enjoy special newline handling: the newline is always 
            interpreted as \n regardless of the actual kind of newline (\r and 
            \r\n newlines come out as \n), and indentation following the newline
            can be stripped out. Triple-quoted strings can have escape sequences
            that use both kinds of slash, like so: <c>\n/ \r/ \'/ \"/ \0/</c>.
            However, there are no unicode escapes (\u1234/ is NOT supported).
            <para/>
            Secondly, it recognizes normal strings (' " `). These strings stop 
            parsing (with an error) at a newline, and can contain C-style escape 
            sequences: <c>\n \r \' \" \0</c> etc. C#-style verbatim strings are 
            NOT supported.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.Les.Les2Lexer.UnescapeQuotedString(Loyc.UString@,System.Action{System.Int32,System.String},System.Text.StringBuilder,Loyc.UString,System.Boolean)">
            <summary>Parses a normal or triple-quoted string that still includes 
            the quotes (see documentation of the first overload) into a 
            StringBuilder.</summary>
        </member>
        <member name="M:Loyc.Syntax.Les.Les2Lexer.UnescapeString(Loyc.UString@,System.Char,System.Boolean,System.Action{System.Int32,System.String},System.Text.StringBuilder,Loyc.UString,System.Boolean)">
            <summary>Parses a normal or triple-quoted string whose starting quotes 
            have been stripped out. If triple-quote parsing was requested, stops 
            parsing at three quote marks; otherwise, stops parsing at a single 
            end-quote or newline.</summary>
            <returns>true if parsing stopped at one or three quote marks, or false
            if parsing stopped at the end of the input string or at a newline (in
            a string that is not triple-quoted).</returns>
            <remarks>This method recognizes LES and EC#-style string syntax.</remarks>
        </member>
        <member name="M:Loyc.Syntax.Les.Les2Lexer.ParseIdentifier(Loyc.UString@,System.Action{System.Int32,System.String},System.Boolean@)">
            <summary>Parses an LES-style identifier such as <c>foo</c>, <c>@foo</c>, 
            <c>@`foo`</c> or <c>@--punctuation--</c>.
            </summary>
            <param name="source">Text to parse. On return, the range has been 
            decreased by the length of the token; this method also stops if this
            range becomes empty.</param>
            <param name="onError">A method to call on error</param>
            <param name="checkForNamedLiteral">This is set to true when the input 
            starts with @ but doesn't use backquotes, which could indicate that 
            it is an LES named literal such as @false or @null.</param>
            <returns>The parsed version of the identifier.</returns>
        </member>
        <member name="M:Loyc.Syntax.Les.Les2Lexer.ParseNumberCore(Loyc.UString,System.Boolean,System.Int32,System.Boolean,Loyc.Symbol,System.String@)">
            <summary>Parses the digits of a literal (integer or floating-point),
            not including the radix prefix (0x, 0b) or type suffix (F, D, L, etc.)</summary>
            <param name="source">Digits of the number (not including radix prefix or type suffix)</param>
            <param name="isFloat">Whether the number is floating-point</param>
            <param name="numberBase">Radix. Must be 2 (binary), 10 (decimal) or 16 (hexadecimal).</param>
            <param name="typeSuffix">Type suffix: F, D, M, U, L, UL, or null.</param>
            <param name="error">Set to an error message in case of error.</param>
            <returns>Boxed value of the literal, null if total failure (result 
            is not null in case of overflow), or <see cref="F:Loyc.Syntax.CodeSymbols.Sub"/> (-)
            if isNegative is true but the type suffix is unsigned or the number 
            is larger than long.MaxValue.</returns>
        </member>
        <member name="T:Loyc.Syntax.Les.Les2Parser">
            <summary>Parses LES (Loyc Expression Syntax) code into a sequence of Loyc 
            trees (<see cref="T:Loyc.Syntax.LNode"/>), one per top-level statement.</summary>
            <remarks>
            You can use <see cref="F:Loyc.Syntax.Les.Les2LanguageService.Value"/> with <see cref="M:Loyc.Syntax.ParsingService.Parse(Loyc.Syntax.IParsingService,Loyc.UString,Loyc.IMessageSink,Loyc.Syntax.ParsingMode,System.Boolean)"/>
            to easily parse a text string (holding zero or more LES statements) into a Loyc tree.
            <para/>
            This class expects to receive tokens from <see cref="T:Loyc.Syntax.Les.Les2Lexer"/> that have been 
            preprocessed by <see cref="T:Loyc.Syntax.Lexing.TokensToTree"/>, with whitespace tokens filtered out.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.Les.Les2Parser.Start(Loyc.Holder{Loyc.Syntax.Les.TokenType})">
            <summary>Top-level rule: expects a sequence of statements followed by EOF</summary>
        </member>
        <member name="P:Loyc.Syntax.Les.Les3Lexer.PreferCustomLiterals">
            <summary>If this flag is true, all literals except plain strings and
            true/false/null are stored as CustomLiteral, bypassing number parsing 
            so that all original characters are preserved if the output is written 
            back to text.</summary>
        </member>
        <member name="P:Loyc.Syntax.Les.Les3Lexer.SkipValueParsing">
            <summary>Used for syntax highlighting, which doesn't care about token values.
            This option causes the Token.Value to be set to a default, like '\0' for 
            single-quoted strings and 0 for numbers. Operator names are still parsed.</summary>
        </member>
        <member name="M:Loyc.Syntax.Les.Les3Lexer.GetOperatorTokenType(Loyc.UString)">
            <summary>Under the assumption that <c>op</c> is a sequence of punctuation 
            marks that forms a legal operator, this method decides its TokenType.</summary>
        </member>
        <member name="M:Loyc.Syntax.Les.Les3Parser.Start(Loyc.Holder{Loyc.Syntax.Les.TokenType})">
            <summary>Top-level rule: expects a sequence of statements followed by EOF</summary>
            <param name="separator">If there are multiple expressions, the Value of 
            this Holder is set to the separator between them: Comma or Semicolon.</param>
        </member>
        <member name="T:Loyc.Syntax.Les.Les3PrettyPrinter">
            <summary>
            A variant of <see cref="T:Loyc.Syntax.Les.Les3Printer"/> that adds syntax highlighting 
            in one of three ways: as console output, as HTML output, or as 
            <see cref="T:Loyc.Syntax.Les.LesColorCode"/> control codes. 
            </summary>
            <remarks>
            Create an instance by invoking the constructor, then call 
            <see cref="M:Loyc.Syntax.Les.Les3PrettyPrinter.PrintToConsole(Loyc.Syntax.ILNode,System.Boolean)"/> for console output, <see cref="M:Loyc.Syntax.Les.Les3PrettyPrinter.PrintToHtml(System.Collections.Generic.IEnumerable{Loyc.Syntax.ILNode},System.Text.StringBuilder,System.Boolean,Loyc.IMessageSink,Loyc.Syntax.ILNodePrinterOptions)"/> 
            for HTML output, or <see cref="M:Loyc.Syntax.Les.Les3Printer.Print(System.Collections.Generic.IEnumerable{Loyc.Syntax.ILNode})"/> 
            for just control codes.
            </remarks>
        </member>
        <member name="P:Loyc.Syntax.Les.Les3PrettyPrinter.ColorCodesToCssClasses">
            <summary>The lookup table of strings for control codes (<see cref="T:Loyc.Syntax.Les.LesColorCode"/> 
            values) to HTML classes, used by <see cref="M:Loyc.Syntax.Les.Les3PrettyPrinter.PrintToHtml(System.Collections.Generic.IEnumerable{Loyc.Syntax.ILNode},System.Text.StringBuilder,System.Boolean)"/>.</summary>
            <remarks>This property is null by default, which causes the default 
            table to be used. See <see cref="M:Loyc.Syntax.Les.Les3PrettyPrinter.GetDefaultCssClassTable"/> for more 
            information.</remarks>
        </member>
        <member name="M:Loyc.Syntax.Les.Les3PrettyPrinter.#ctor(Loyc.IMessageSink,Loyc.Syntax.ILNodePrinterOptions)">
            <summary>Creates an instance of this class, which produces plain LES 
            augmented with control codes.</summary>
        </member>
        <member name="M:Loyc.Syntax.Les.Les3PrettyPrinter.#ctor(System.Text.StringBuilder,Loyc.IMessageSink,Loyc.Syntax.ILNodePrinterOptions)">
            <summary>Creates an instance of this class, which produces plain LES 
            augmented with control codes.</summary>
        </member>
        <member name="M:Loyc.Syntax.Les.Les3PrettyPrinter.GetDefaultCssClassTable">
            <summary>The lookup table of strings for control codes (<see cref="T:Loyc.Syntax.Les.LesColorCode"/> values) to HTML classes.</summary>
            <remarks>
            For example, <c>GetDefaultCssClassTable()[(int)LesColorCode.Number]</c> indicates 
            the default CSS class to use for numbers.
            <para/>
            If the entry for a given code is null, no span element is emitted, which 
            shortens the output.
            <para/>
            The default class names are shared with the Pygments syntax highlighting
            system. A list of the CSS classes available in Pygments is available 
            <a href="https://github.com/zeke/pygments-tokens">at this link</a>.
            Only a small subset of these classes are used in this table.
            <para/>
            Here is some suitable CSS:
            <pre>
            .highlight { background-color: #f8f8f8; color: #111; }
            .highlight .c  { color: #5A5; } /* Comment */
            .highlight .n  { color: #111; } /* Name (omitted by default) */
            .highlight .m  { color: #909; } /* Number */
            .highlight .s  { color: #B44; } /* String */
            .highlight .l  { color: #B04; } /* Literal (other) */
            .highlight .kc { color: #41F; } /* Keyword.Constant */
            .highlight .o  { color: #940; } /* Operator */
            .highlight .p  { color: #111; } /* Punctuation (omitted by default) */
            .highlight .kp { color: #33A; } /* Keyword.Pseudo (@attribute) */
            .highlight .nb { color: #007; } /* Name.Builtin (#specialId) */
            .highlight .k  { color: #11F; } /* Keyword (.dotId) */
            .highlight .x  { color: #D00; } /* Other */
            .highlight .pi { color: #B50; } /* Parenthesis Inner (()) */
            </pre>
            <para/>
            Note: LesTokenCode.Opener and LesTokenCode.Closer are handled 
            specially. An opener and its matching closer (e.g. '(' and ')') are always 
            given the same color, but nested parens/brackets are given alternating 
            colors (CSS classes), with the entry for LesTokenCode.Opener used for outer
            parens and the entry for LesTokenCode.Closer used for inner parens. The
            default class name is "pi" for inner parentheses; no class name is used
            for outer parens. "pi" is not a standard name, so if you're using a 
            standard Pygment stylesheet you should add an extra line, e.g.
            <pre>
            .highlight .p { color: #111; } /* Punctuation (includes , ; { }) */
            .highlight .pi { color: #B50; } /* Parenthesis Inner */
            </pre>
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.Les.Les3PrettyPrinter.PrintToHtml(System.Collections.Generic.IEnumerable{Loyc.Syntax.ILNode},System.Text.StringBuilder,System.Boolean,Loyc.IMessageSink,Loyc.Syntax.ILNodePrinterOptions)">
            <summary>Prints an LNode as LESv3 with HTML syntax highlighting elements.</summary>
            <param name="nodes">Syntax trees to print.</param>
            <param name="output">Output StringBuilder for HTML code.</param>
            <param name="addPreCode">Whether to wrap the output in "&lt;pre class='highlight'>&lt;code>" tags.</param>
            <param name="options">Options to control the style for code printing.</param>
            <returns>The output StringBuilder</returns>
        </member>
        <member name="M:Loyc.Syntax.Les.Les3PrettyPrinter.PrintToHtml(System.Collections.Generic.IEnumerable{Loyc.Syntax.ILNode},System.Text.StringBuilder,System.Boolean)">
            <inheritdoc cref="M:Loyc.Syntax.Les.Les3PrettyPrinter.PrintToHtml(System.Collections.Generic.IEnumerable{Loyc.Syntax.ILNode},System.Text.StringBuilder,System.Boolean,Loyc.IMessageSink,Loyc.Syntax.ILNodePrinterOptions)"/>
        </member>
        <member name="M:Loyc.Syntax.Les.Les3PrettyPrinter.PrintToHtml(Loyc.Syntax.ILNode,System.Text.StringBuilder,System.Boolean)">
            <inheritdoc cref="M:Loyc.Syntax.Les.Les3PrettyPrinter.PrintToHtml(System.Collections.Generic.IEnumerable{Loyc.Syntax.ILNode},System.Text.StringBuilder,System.Boolean,Loyc.IMessageSink,Loyc.Syntax.ILNodePrinterOptions)"/>
        </member>
        <member name="M:Loyc.Syntax.Les.Les3PrettyPrinter.PrintToHtmlCore(System.Text.StringBuilder,System.Text.StringBuilder,System.Boolean,System.String,System.String[])">
            <summary>Converts a StringBuilder with <see cref="T:Loyc.Syntax.Les.LesColorCode"/> 
            control codes to HTML with Pygments CSS class codes.</summary>
            <param name="input">Input containing <see cref="T:Loyc.Syntax.Les.LesColorCode"/> control characters.</param>
            <param name="output">Output StringBuilder for HTML code. If null, a new one is created.</param>
            <param name="addPreCode">Whether to wrap the output in "&lt;pre class='highlight'>&lt;code>" tags.</param>
            <param name="newline">What to write to <c>output</c> when '\n' is encountered.</param>
            <param name="colorCodesToCssClasses">CSS class table for span tags, 
            see <see cref="M:Loyc.Syntax.Les.Les3PrettyPrinter.GetDefaultCssClassTable"/>.</param>
            <returns>The output StringBuilder.</returns>
        </member>
        <member name="T:Loyc.Syntax.Les.LesColorCode">
            <summary>These codes are produced as control characters (i.e. cast to char)
            in the output of <see cref="T:Loyc.Syntax.Les.Les3PrettyPrinter"/>.</summary>
            <remarks>
            A note about implementation coupling: <see cref="T:Loyc.Syntax.Les.Les3PrettyPrinter"/> relies 
            on color codes provided to it by the base class <see cref="T:Loyc.Syntax.Les.Les3Printer"/>.
            </remarks>
        </member>
        <member name="P:Loyc.Syntax.Les.Les3Printer.MessageSink">
            <summary>Target for warning messages.</summary>
        </member>
        <member name="F:Loyc.Syntax.Les.Les3Printer._isOneLiner">
            <summary>Indicates whether the <see cref="F:Loyc.Syntax.NodeStyle.OneLiner"/> 
            flag is present on the current node or any of its parents. It 
            suppresses newlines within braced blocks.</summary>
        </member>
        <member name="T:Loyc.Syntax.Les.Les3Printer.Chars">
            <summary>
            Based on these flags, StartToken() and WriteToken() ensure that two 
            adjacent tokens aren't treated like a single token when reparsed, by 
            printing a space between them if necessary.
            </summary>
        </member>
        <member name="T:Loyc.Syntax.Les.Les3Printer.NewlineContext">
            <summary>Used to help keep track of where newline trivia (and single-
            line comments ending in a newline) are permitted, to avoid printing
            newline trivia where it would count as "end of expression".</summary>
        </member>
        <member name="M:Loyc.Syntax.Les.Les3Printer.CanBeBinaryOperator(System.String)">
            <summary>Returns true if the given name can be printed as a binary operator in LESv3.</summary>
        </member>
        <member name="M:Loyc.Syntax.Les.Les3Printer.CanBePrefixOperator(System.String)">
            <summary>Returns true if the given name can be printed as a prefix operator in LESv3.</summary>
        </member>
        <member name="P:Loyc.Syntax.Les.Les3PrinterOptions.SpaceInsideListBrackets">
            <summary>Whether to print a space inside square brackets for lists <c>[ ... ]</c>.</summary>
        </member>
        <member name="P:Loyc.Syntax.Les.Les3PrinterOptions.SpaceInsideArgLists">
            <summary>Whether to print a space inside argument lists like <c>f( ... )</c>.</summary>
        </member>
        <member name="P:Loyc.Syntax.Les.Les3PrinterOptions.SpaceInsideGroupingParens">
            <summary>Whether to print a space inside grouping parentheses <c>( ... )</c>.</summary>
        </member>
        <member name="P:Loyc.Syntax.Les.Les3PrinterOptions.SpaceInsideTuples">
            <summary>Whether to print a space inside tuples like <c>f( ...; )</c>.</summary>
        </member>
        <member name="P:Loyc.Syntax.Les.Les3PrinterOptions.SpaceAfterComma">
            <summary>Whether to print a space after each comma in an argument list.</summary>
            <remarks>Initial value: true</remarks>
        </member>
        <member name="P:Loyc.Syntax.Les.Les3PrinterOptions.AllowExtraParenthesis">
            <summary>Introduces extra parenthesis to express precedence, without
            using an empty attribute list [] to allow perfect round-tripping.</summary>
            <remarks>For example, the Loyc tree <c>x * @+(a, b)</c> will be printed 
            <c>x * (a + b)</c>, which is a slightly different tree (the parenthesis
            add the trivia attribute %inParens.)</remarks>
        </member>
        <member name="P:Loyc.Syntax.Les.Les3PrinterOptions.OmitSpaceTrivia">
            <summary>When this flag is set, space trivia attributes are ignored
            (e.g. <see cref="F:Loyc.Syntax.CodeSymbols.TriviaSpaceAfter"/>).</summary>
        </member>
        <member name="P:Loyc.Syntax.Les.Les3PrinterOptions.WarnAboutUnprintableLiterals">
            <summary>Whether to print a warning when an "unprintable" literal is 
            encountered. In any case the literal is converted to a string, placed 
            in double quotes and prefixed by the unqualified Type of the Value.</summary>
            <remarks>Initial value: true</remarks>
        </member>
        <member name="P:Loyc.Syntax.Les.Les3PrinterOptions.ObeyRawText">
            <summary>Causes raw text to be printed verbatim, as the EC# printer does.
            When this option is false, raw text trivia is printed as a normal 
            attribute.</summary>
        </member>
        <member name="F:Loyc.Syntax.Les.Les3PrinterOptions.SpacesBetweenAppendedStatements">
            <summary>Whether to add a space between multiple statements printed on
            one line (initial value: true).</summary>
        </member>
        <member name="P:Loyc.Syntax.Les.Les3PrinterOptions.UseRedundantSemicolons">
            <summary>If true, a semicolon is used in addition to the usual newline to 
            terminate each expression inside braced blocks and at the top level.</summary>
            <remarks>Regardless of this flag, a semicolon is forced to appear when a 
            node uses <see cref="F:Loyc.Syntax.CodeSymbols.TriviaAppendStatement"/> to put multiple 
            expressions on one line.</remarks>
        </member>
        <member name="P:Loyc.Syntax.Les.Les3PrinterOptions.PrefixNotationOnly">
            <summary>
            Print purely in prefix notation, e.g. <c>`'+`(2,3)</c> instead of <c>2 + 3</c>.
            </summary>
        </member>
        <member name="F:Loyc.Syntax.Les.Les3PrinterOptions.SpaceAroundInfixStopPrecedence">
            <summary>The printer avoids printing spaces around infix (binary) 
            operators that have the specified precedence or higher.</summary>
            <seealso cref="T:Loyc.Syntax.Les.LesPrecedence"/>
        </member>
        <member name="F:Loyc.Syntax.Les.Les3PrinterOptions.SpaceAfterPrefixStopPrecedence">
            <summary>The printer avoids printing spaces after prefix operators 
            that have the specified precedence or higher.</summary>
        </member>
        <member name="P:Loyc.Syntax.Les.Les3PrinterOptions.ForcedLineBreakThreshold">
            <summary>Although the LES3 printer is not designed to insert line breaks
            mid-expression or to keep lines under a certain length, this option can 
            avoid extremely long lines in some cases, by (1) inserting line breaks 
            after commas in argument lists, or after very long attribute lists, and 
            (2) ignoring the <see cref="F:Loyc.Syntax.NodeStyle.OneLiner"/> flag or 
            <see cref="F:Loyc.Syntax.CodeSymbols.TriviaAppendStatement"/> attribute when an 
            expression within a braced block starts after this column on a line.
            </summary>
            <remarks>
            The default value is 120.
            <para/>
            Setting the threshold to zero forces all "statements" (expressions 
            in braces) to appear on a new line. Lines can still be arbitrarily long 
            with this option, since breaks are only added at the end of expressions 
            within a braced block.
            </remarks>
        </member>
        <member name="P:Loyc.Syntax.Les.Les3PrinterOptions.DigitSeparator">
            <summary>Sets the "thousands" or other digit separator for numeric 
            literals. Valid values are null (to disable the separator), underscore (_) 
            and single quote (').</summary>
            <exception cref="T:System.ArgumentException">Invalid property value.</exception>
            <remarks>
            For decimal numbers, this value separates thousands (e.g. 12'345'678).
            For hex numbers, it separates groups of four digits (e.g. 0x1234'5678).
            For binary numbers, it separates groups of eight digits.
            </remarks>
        </member>
        <member name="T:Loyc.Syntax.Les.CustomLiteral">
            <summary>A custom literal is a normal number or string paired with a 
            (typically unrecognized) type prefix or suffix.</summary>
            <remarks>This structure is used as the value of an LESv3 token to 
            represent non-standard numbers and strings such as <c>1.1unum</c> 
            and <c>bytes"ab cd"</c></remarks>
        </member>
        <member name="P:Loyc.Syntax.Les.CustomLiteral.Value">
            <summary>The numeric or string value of the literal.</summary>
        </member>
        <member name="P:Loyc.Syntax.Les.CustomLiteral.TypeMarker">
            <summary>A prefix or suffix on the literal that represents some 
            additional meaning.</summary>
            <remarks>In LESv3, this field becomes the sole parameter <c>s</c> 
            of a <c>`%literalType`(s)</c> attribute attached to the <see cref="T:Loyc.Syntax.LNode"/>
            that represents the literal.</remarks>
        </member>
        <member name="T:Loyc.Syntax.Les.Les2LanguageService">
            <summary>The <see cref="F:Loyc.Syntax.Les.Les2LanguageService.Value"/> property provides easy access to the lexer, 
            parser and printer for Loyc Expression Syntax (LES).</summary>
            <remarks>
            LES overview: http://loyc.net/les
            </remarks>
        </member>
        <member name="T:Loyc.Syntax.Les.LesLanguageService">
            <summary>Alternate name for Les2LanguageService (will change to Les3LanguageService in the future)</summary>
        </member>
        <member name="T:Loyc.Syntax.Les.Les2Printer">
            <summary>Prints a Loyc tree in LES (Loyc Expression Syntax) format.</summary>
            <remarks>Unless otherwise noted, the default value of all options is false.</remarks>
        </member>
        <member name="F:Loyc.Syntax.Les.Les2Printer._isOneLiner">
            <summary>Indicates whether the <see cref="F:Loyc.Syntax.NodeStyle.OneLiner"/> 
            flag is present on the current node or any of its parents. It 
            suppresses newlines within braced blocks.</summary>
        </member>
        <member name="F:Loyc.Syntax.Les.Les2Printer.StartStmt">
            <summary>Context: beginning of main expression (potential superexpression)</summary>
        </member>
        <member name="M:Loyc.Syntax.Les.Les2Printer.IsNormalIdentifier(Loyc.Symbol)">
            <summary>Returns true if the given symbol can be printed as a 
            normal identifier, without an "@" prefix. Note: identifiers 
            starting with "#" still count as normal; call <see cref="P:Loyc.Syntax.LNode.HasSpecialName"/> 
            to detect this.</summary>
        </member>
        <member name="T:Loyc.Syntax.Les.Les2PrinterOptions">
            <summary>Options to control the way Loyc trees are printed by <see cref="T:Loyc.Syntax.Les.Les2Printer"/>.</summary>
        </member>
        <member name="P:Loyc.Syntax.Les.Les2PrinterOptions.AllowChangeParentheses">
            <summary>Introduces extra parenthesis to express precedence, without
            using an empty attribute list [] to allow perfect round-tripping.</summary>
            <remarks>For example, the Loyc tree <c>x * @+(a, b)</c> will be printed 
            <c>x * (a + b)</c>, which is a slightly different tree (the parenthesis
            add the trivia attribute <c>%inParens</c>.)</remarks>
        </member>
        <member name="P:Loyc.Syntax.Les.Les2PrinterOptions.PrintTriviaExplicitly">
            <summary>Causes comments and spaces to be printed as attributes in order 
            to ensure faithful round-trip parsing. By default, only "raw text" and
            unrecognized trivia is printed this way. Note: <c>%inParens</c> is 
            always printed as parentheses, and <see cref="P:Loyc.Syntax.ILNodePrinterOptions.OmitUnknownTrivia"/> 
            has no effect when this flag is true.</summary>
        </member>
        <member name="P:Loyc.Syntax.Les.Les2PrinterOptions.OmitMissingArguments">
            <summary>When an argument to a method or macro has the value <c>@``</c>,
            it will be omitted completely if this flag is set.</summary>
        </member>
        <member name="P:Loyc.Syntax.Les.Les2PrinterOptions.OmitSpaceTrivia">
            <summary>When this flag is set, space trivia attributes are ignored
            (e.g. <see cref="F:Loyc.Syntax.CodeSymbols.TriviaNewline"/>).</summary>
        </member>
        <member name="P:Loyc.Syntax.Les.Les2PrinterOptions.QuoteUnprintableLiterals">
            <summary>When the printer encounters an unprintable literal, it calls
            Value.ToString(). When this flag is set, the string is placed in double
            quotes; when this flag is clear, it is printed as raw text.</summary>
        </member>
        <member name="P:Loyc.Syntax.Les.Les2PrinterOptions.ObeyRawText">
            <summary>Causes raw text to be printed verbatim, as the EC# printer does.
            When this option is false, raw text trivia is printed as a normal 
            attribute.</summary>
        </member>
        <member name="F:Loyc.Syntax.Les.Les2PrinterOptions.SpacesBetweenAppendedStatements">
            <summary>Whether to add a space between multiple statements printed on
            one line (initial value: true).</summary>
        </member>
        <member name="F:Loyc.Syntax.Les.Les2PrinterOptions.SpaceAroundInfixStopPrecedence">
            <summary>The printer avoids printing spaces around infix (binary) 
            operators that have the specified precedence or higher.</summary>
            <seealso cref="T:Loyc.Syntax.Les.LesPrecedence"/>
        </member>
        <member name="F:Loyc.Syntax.Les.Les2PrinterOptions.SpaceAfterPrefixStopPrecedence">
            <summary>The printer avoids printing spaces after prefix operators 
            that have the specified precedence or higher.</summary>
        </member>
        <member name="T:Loyc.Syntax.Les.INodePrinterWriter">
            <summary>This interface is implemented by helper objects that handle the 
            low-level details of node printing. It is used by <see cref="T:Loyc.Syntax.Les.Les2Printer"/>.</summary>
            <remarks>Specifically, INodePrinterWriter objects are in charge of how much
            to indent lines of code, and ensuring that there are spaces between tokens
            whenever omitting a space would screw up parsing.
            <para/>
            Although this interface is also used by EC#, I've kept it in the 
            Les namespace because I'm not yet confident that it's a <i>good</i> design 
            for arbitrary languages.</remarks>
        </member>
        <member name="P:Loyc.Syntax.Les.INodePrinterWriter.Target">
            <summary>Gets the object being written to (TextWriter or StringBuilder)</summary>
        </member>
        <member name="M:Loyc.Syntax.Les.INodePrinterWriter.Reset">
            <summary>Called when a new, separate printing operation begins.</summary>
        </member>
        <member name="T:Loyc.Syntax.Les.NodePrinterWriterBase">
            <summary>Abstract base class for <see cref="T:Loyc.Syntax.Les.INodePrinterWriter"/>. Has an
            protected <c>_indentLevel</c> field that is increased by Indent() and 
            decreased by Dedent().</summary>
        </member>
        <member name="T:Loyc.Syntax.Les.DefaultNodePrinterWriter">
            <summary>Base class for token-printing helper classes.
            See <see cref="T:Loyc.Syntax.Les.INodePrinterWriter"/>.</summary>
        </member>
        <member name="T:Loyc.Syntax.Les.Les2PrinterWriter">
            <summary>Helper class of <see cref="T:Loyc.Syntax.Les.Les2Printer"/> that ensures 
            tokens are spaced apart properly.</summary>
        </member>
        <member name="T:Loyc.Syntax.Les.LesPrecedence">
             <summary>Contains <see cref="T:Loyc.Syntax.Precedence"/> objects that represent the 
             precedence levels of LES.</summary>
             <remarks>
             In LES, the precedence of an operator is decided based simply on the text 
             of the operator. The precedence of each one-character operator is 
             predefined; the precedence of any operator with two or more characters 
             is decided based on the first and last characters (according to
             the rules below). Other characters, if any, do not affect precedence.
             <para/>
             The LES precedence table mostly matches popular programming languages,
             i.e. those in the C family.
             <para/>
             An operator consists of a sequence of the following characters:
             <pre>
                ~ ! % ^ * - + = | &lt; > / ? : . &amp;
             </pre>
             In addition, the $ character is allowed as the first character and, if
             present, it forces the operator to be interpreted as a prefix operator.
             <para/>
             LESv3 also has operators that start with a single quote, which can include
             both letters and punctuation (e.g. <c>'|foo|</c>). The quote itself is 
             ignored for the purpose of choosing precedence. LESv2 has <c>`backquoted`</c> 
             operators instead, whereas in LESv3 backquoted strings are simply 
             identifiers. 
             <para/>
             It is notable that the following punctuation cannot be used in operators:
             <ul>
             <li>"@" is used for multiple other purposes.</li>
             <li>"#" is conventionally used to mark "keywords" (although in LESv2, the 
             parser treats it like an underscore or a letter.)</li>
             <li>"," and ";" are separators, so for example, "?,!" is parsed as three 
             separate tokens.</li>
             <li>The backslash "\" is reserved for future use.</li>
             </ul>
             <para/>
             The following table shows all the precedence levels and associativities
             of the "built-in" LES operators, except a couple of special operators such
             as the "lambda" operator =>, whose precedence is different on the left side 
             than on the right side. Each precedence level has a name, which corresponds 
             to a static field of this class. All binary operators are left-associative 
             unless otherwise specified.
             <ol>
             <li>Substitute: prefix $ . :</li>
             <li>Primary: binary . =:, generic arguments List!(int), suffix ++ --, method calls f(x), indexers a[i]</li>
             <li>NullDot: binary ?. :: (in LESv2, :: is NullDot, in LESv3 it's Primary)</li>
             <li>DoubleBang: binary right-associative !!</li>
             <li>Prefix: prefix ~ ! % ^ * / - + &amp; `backtick` (LESv2 only)</li>
             <li>Power: binary **</li>
             <li>Multiply: binary * / % \ >> &lt;&lt;</li>
             <li>Add: binary + -</li>
             <li>Arrow: binary right-associative -> &lt;-</li>
             <li>PrefixDots: prefix ..</li>
             <li>Range: binary right-associative ..</li>
             <li>Compare: binary != == >= > &lt; &lt;=</li>
             <li>And: binary &amp;&amp;</li>
             <li>Or: binary || ^^</li>
             <li>IfElse: binary right-associative ? :</li>
             <li>LowerKeyword: a lowercase keyword</li>
             <li>PrefixOr: |</li>
             </ol>
             Not listed in table: binary <c>=> ~ = ?? >> ^ | &amp; &lt;&lt; </c>; prefix <c>? = > &lt;</c>;
             non-lowercase keywords.
             <para/>
             Notice that the precedence of an operator depends on how it is used. The 
             prefix operator <c>-</c> has higher precedence than the binary operator 
             <c>-</c>, so for example <c>- y * z</c> is parsed as <c>(- y) * z</c>, 
             while <c>x - y * z</c> is parsed as <c>x - (y * z)</c>.
             <para/>
             Programmers often use the shift operators <c>>></c> and <c>&lt;&lt;</c> 
             in place of multiplication or division, so their <i>natural</i> precedence
             is the same as <c>*</c> and <c>/</c>. However, traditionally the C
             family of languages confusingly give the shift operators a precedence 
             below <c>+</c>. Therefore, LES does not allow mixing of shift operators
             with <c>+ - * /</c>; <c>a >> b + c</c> should produce a parse error.
             This is called immiscibility as explained in the documentation of 
             <see cref="T:Loyc.Syntax.Precedence"/>. Parsing may still complete, but the exact 
             output tree is unspecified (may be <c>(a >> b) + c</c> or 
             <c>a >> (b + c)</c>).
             <para/>
             Likewise, the bitwise <c>^ | &amp;</c> operators cannot be mixed with
             comparison operators as in <c>a | 1 == 3</c>.
             <para/>
             The Lambda operator =>, which is right-associative, has a precedence 
             level above Multiply on the left side, but below Assign on the right 
             side. For example, the expression <c>a = b => c = d</c> is parsed as 
             <c>a = (b => (c = d))</c>, and similarly <c>a + b => c + d</c> is parsed 
             as <c>a + (b => (c + d))</c>, but <c>a ** b => c ** d</c> is parsed
             <c>(a ** b) => (c ** d)</c>. The idea of two different precedences on the
             two sides of an operator may seem strange; see the documentation of 
             <see cref="T:Loyc.Syntax.Precedence"/> for more explanation.
             <para/>
             Similarly, all assignment operators (including compound assignments like
             +=) have a high precedence on the left side and low precedence on the 
             right. This decision was made for WebAssembly, in which an expression like
             <c>2 * i32_store[$f(),4] = 3 * $g()</c> is best parsed as 
             <c>2 * (i32_store[$f(),4] = (3 * $g()))</c> (NOTE: this example will 
             surely be wrong by the time Wasm is released).
             <para/>
             As a nod to functional languages, the arrow operator "->" is right-
             associative and has a precedence below '*' so that <c>int * int -> int</c>
             parses as <c>(int * int) -> int</c> rather than <c>int * (int -> int)</c> 
             as in the C family of languages.
             <para/>
             Some operators like <c>'this-one</c> do not begin with punctuation. These
             "keyword operators" must be used as binary operators. They either start
             with a lowercase letter or they don't. If they do start with a lowercase
             letter, their precedence is LowerKeyword, which is very low, below 
             assignment, so that <c>a = b 'then x = y</c> parses like 
             <c>(a = b) 'then (x = y)</c>.
             <para/>
             If they do not start with a lowercase letter (as in <c>'Foo</c> or 
             <c>'123</c>) then they have an indeterminate precedence, below power
             (**) but above comparison (==). This means that an operator like 'XOR
             or 'Mod cannot be mixed with operators of precedence Multiply, Add, 
             Arrow, AndBits, OrBits, OrIfNull, PrefixDots, and Range operators.
             Mixing operators illegally (e.g. <c>x 'Mod y + z</c>) will produce a 
             parse error.
             <para/>
             After constructing an initial table based on common operators from other
             languages, I noticed that 
             <ul>
             <li>None of the high-precedence operators were right-associative, so I 
             added the !! operator to "fill in the gap".</li>
             <li>There were no prefix operators with low precedence, so I added ".." 
             whose precedence is just above binary "..", and "|" which has a precedence 
             lower than anything except attributes (this "operator" is inspired by
             Nemerle, which uses "|" in pattern matching and variants.)</li>
             </ul>
             I also wanted to have a little "room to grow"--to defer the precedence 
             decision to a future time for some operators. So the precedence of the 
             binary operator ~ has a range of operators with which it cannot be
             mixed, the same range as for uppercase operators without punctuation;
             for example, <c>x ~ y + z</c> is invalid but <c>x ~ y == z</c> is allowed.
             <para/>
             The operators <c>\ ? = > &lt;</c> cannot be used as prefix operators.
             <para/>
             The way that low-precedence prefix operators are parsed deserves some 
             discussion... TODO.
             <para/>
             Most operators can have two roles. Most operators can either be 
             binary operators or prefix operators; for example, <c>!*!</c> is a 
             binary operator in <c>x !*! y</c> but a prefix operator in <c>x + !*! y</c>.
             <para/>
             The operators <c>++ --</c> also have two roles, but different roles: 
             they can be either prefix or suffix operators, but not binary operators.
             For example, <c>-*-</c> is a suffix operator in <c>x -*- + y</c> and a 
             prefix operator in <c>x + -*- y</c>. Please note that <c>x -*- y</c> is 
             ambiguous (it could be parsed as either of two superexpressions, 
             <c>(x -*-) (y)</c> or <c>(x) (-*- y)</c>) and it is illegal.
             <para/>
             Operators that start with $ can only be prefix operators (not binary or 
             suffix). Having only a single role makes these operators unambiguous 
             inside superexpressions (LESv2) or with juxtaposition (LESv3).
             <para/>
             An operator cannot have all three roles (suffix, prefix and binary); that 
             would be overly ambiguous. For example, if "-" could also be a suffix 
             operator then <c>x - + y</c> could be parsed as <c>(x -) + y</c> as well 
             as <c>x - (+ y)</c>. More subtly, LES does not define any operators that
             could take binary or suffix roles, because that would also be ambiguous. 
             For example, suppose <c>|?|</c> is a binary or suffix operator, but not a 
             prefix operator. Clearly <c>x |?| y</c> and <c>x |?| |?| y</c> are 
             unambiguous, but <c>x |?| + y</c> is ambiguous: it could be parsed as 
             <c>(x |?|) + y</c> or <c>x |?| (+ y)</c>. It turns out that a computer 
             language can contain operators that serve as binary and prefix operators, 
             OR it can contain operators that serve as binary and suffix operators, 
             but a language is ambiguous if it has both kinds of operators at the 
             same time.
            
             <h3>How to detect an operator's precedence</h3>
             
             To determine the precedence of any given operator, first you must
             decide, mainly based on the context in which the operator appears and the
             text of the operator, whether it is a prefix, binary, or suffix operator. 
             Suffix operators can only be derived from the operators <c>++, --</c>
             ("derived" means that you can add additional operator characters in the 
             middle, e.g. <c>+++</c> and <c>-%-</c> are can be prefix or suffix 
             operators.)
             <para/>
             If an operator starts with a single quote in LESv3 ('), the quote is not
             considered for the purpose of choosing precedence (rather, it is used to 
             allow letters and digits in the operator name).
             <para/>
             Next, if the operator is only one character, simply find it in the list
             of operators in the previous section to learn its precedence. If the 
             operator is two or more characters, take the first character A and the 
             and the last character Z, and of the following rules, use the <b>first</b>
             rule that applies:
             <ol>
             <li>If AZ is "!=" or "==", or if the operator is exactly two characters 
             long (ignoring the initial single quote) and equal to ">=", or "&lt;=",
             its precedence is Compare. This rule separates comparison operators from 
             assignment operators, so that ">>=" is different from ">=", and "===" 
             counts as a comparison operator.</li>
             <li>If it's an infix operator and Z is '=', the precedence is Assign.</li>
             <li>Look for an operator named AZ from the section above. If it is defined,
             the operator will have the same precedence. For example, binary <c>=|></c>
             has the same precedence as binary "=>".</li>
             <li>Otherwise, look for an entry in the table for Z. For example,
             binary "%+" has the same precedence as binary "+" and unary "-*" has
             the same precedence as unary "*".</li>
             <li>If the operator is not an infix operator, it is illegal
             (e.g. prefix ?? doesn't exist).</li>
             <li>If A is a lowercase letter, the precedence is LowerKeyword.</li>
             <li>Otherwise, the operator's precedence is Other.</li>
             </ol>
             The double-colon :: has the "wrong" precedence according to C# and C++
             rules; <c>a.b::c.d</c> is parsed <c>(a.b)::(c.d)</c> although it would 
             be parsed <c>((a.b)::c).d</c> in C# and C++. The change in precedence 
             allows double colon to be used for variable declarations in LeMP, as 
             in <c>x::System.Drawing.Point</c>. The lower precedence allows this
             to be parsed properly, but it sacrifices full fidelity with C#/C++.
             <para/>
             There are no ternary operators in LES. '?' and ':' are right-associative 
             binary operators, so <c>c ? a : b</c> is parsed as <c>c ? (a : b)</c>.
             The lack of an official ternary operator reduces the complexity of the
             parser.
             <para/>
             LES represents Loyc trees, which do not distinguish operators and 
             functions except by name; <c>x += y</c> is equivalent to the function 
             call <c>`'+=`(x, y)</c> in LESv3 (<c>@'+=(x, y)</c> in LESv2), and 
             the actual name of the function is <c>'+=</c>. Operators that do not
             start with a single quote in LES <b>do</b> start with a single quote
             in the final output (e.g. <c>2 + 2</c> is equivalent to <c>2 '+ 2</c>).
             There is an exception: While prefix ++ and -- are named <c>'++</c> and 
             <c>'--</c>, the suffix versions are named <c>'suf++</c> and 
             <c>'suf--</c> in the output tree. For LESv2 operators surrounded by 
             `backquotes`, the backquotes are not included in the output tree (e.g.
             <c>`sqrt` x</c> is equivalent to <c>sqrt(x)</c>).
             </remarks>
             <seealso cref="T:Loyc.Syntax.Precedence"/>
        </member>
        <member name="T:Loyc.Syntax.Les.Les2PrecedenceMap">
            <summary>This class's main job is to maintain a table of 
            <see cref="T:Loyc.Syntax.Precedence"/> values for LES operators. When you ask about a
            new operator, its precedence is chosen by this class and cached for 
            future reference.</summary>
        </member>
        <member name="M:Loyc.Syntax.Les.Les2PrecedenceMap.Reset">
            <summary>Forgets previously encountered operators to save memory.</summary>
        </member>
        <member name="M:Loyc.Syntax.Les.Les2PrecedenceMap.Find(Loyc.Syntax.OperatorShape,System.Object,System.Boolean,System.Boolean)">
            <summary>Gets the precedence in LES of a prefix, suffix, or infix operator.</summary>
            <param name="shape">Specifies which precedence table and rules to use 
            (Prefix, Suffix or Infix). Note: when this is Suffix, "_" is not expected 
            to be part of the name in <c>op</c>, i.e. op should be a Symbol like "'++" 
            rather than "'_++" (see also <see cref="M:Loyc.Syntax.Les.Les2PrecedenceMap.IsSuffixOperatorName(Loyc.Symbol,Loyc.Symbol@)"/>)</param>
            <param name="op">Parsed form of the operator. op must be a Symbol, but 
            the parameter has type object to avoid casting Token.Value in the parser.</param>
        </member>
        <member name="M:Loyc.Syntax.Les.Les2PrecedenceMap.IsOpChar(System.Char)">
            <summary>Returns true if this character is one of those that operators are normally made out of in LES.</summary>
        </member>
        <member name="M:Loyc.Syntax.Les.Les2PrecedenceMap.IsOpCharEx(System.Char)">
            <summary>Returns true if this character is one of those that can appear 
            in "extended" LESv3 operators that start with an apostrophe.</summary>
        </member>
        <member name="M:Loyc.Syntax.Les.Les2PrecedenceMap.IsNaturalOperator(Loyc.UString)">
            <summary>Returns true if the given Symbol can be printed as an operator 
            without escaping it in LESv2.</summary>
            <remarks>The parser should read something like <c>+/*</c> as an operator
            with three characters, rather than "+" and a comment, but the printer 
            is more conservative, so this function returns false in such a case.</remarks>
        </member>
        <member name="M:Loyc.Syntax.Les.Les2PrecedenceMap.IsNaturalOperatorToken(Loyc.UString)">
            <summary>Like <see cref="M:Loyc.Syntax.Les.Les2PrecedenceMap.IsNaturalOperator(Loyc.UString)"/>, but doesn't expect name[0] is apostrophe.</summary>
        </member>
        <member name="M:Loyc.Syntax.Les.Les2PrecedenceMap.IsExtendedOperatorToken(Loyc.UString)">
            <summary>Returns true if the given Symbol can ever be used as an "extended" 
            binary operator in LESv3.</summary>
            <remarks>A binary operator's length must be between 2 and 255, its name must
            start with an apostrophe, and each remaining character must be punctuation marks 
            from natural operators and/or characters from the set 
            {'#', '_', 'a'..'z', 'A'..'Z', '0'..'9', '$'}.</remarks>
        </member>
        <member name="M:Loyc.Syntax.Les.Les2PrecedenceMap.ToSuffixOpName(System.Object)">
            <summary>Given a normal operator symbol like <c>(Symbol)"'++"</c>, gets
            the suffix form of the name, such as <c>(Symbol)"'suf++"</c>.</summary>
            <remarks>op must be a Symbol, but the parameter has type object to avoid casting Token.Value in the parser.</remarks>
        </member>
        <member name="M:Loyc.Syntax.Les.Les2PrecedenceMap.IsSuffixOperatorName(Loyc.Symbol,Loyc.Symbol@)">
            <summary>Decides whether the name appears to represent a suffix operator.</summary>
            <param name="name">Potential operator name to evaluate.</param>
            <param name="bareName">If the name begins with "'suf", this is the same name with
            "suf" removed, otherwise it is set to <c>name</c> itself. This output is 
            calculated even if the function returns false.</param>
            <remarks>This method doesn't verify that the operator IS a legal suffix 
            operator, just that it has the form of one. More specifically, when
            the function returns true, IsNaturalOperator(bareName.Name) is true.</remarks>
        </member>
        <member name="T:Loyc.Syntax.Les.TokenExt">
            <summary>Provides the <c>Type()</c> extension method required by 
            <see cref="T:Loyc.Syntax.Lexing.Token"/> and the ToString(Token) method to express an LES token
            as a string, for tokens that contain sufficient information to do so.</summary>
        </member>
        <member name="M:Loyc.Syntax.Les.TokenExt.Type(Loyc.Syntax.Lexing.Token)">
            <summary>Converts <c>t.TypeInt</c> to <see cref="T:Loyc.Syntax.Les.TokenType"/>.</summary>
        </member>
        <member name="M:Loyc.Syntax.Les.TokenExt.ToString(Loyc.Syntax.Lexing.Token)">
            <summary>Expresses a token as a string, using LES printers for identifiers and literals.</summary>
            <remarks>Note that some Tokens do not contain enough information to
            reconstruct a useful token string, e.g. comment tokens do not store the 
            comment but merely contain the location of the comment in the source code.
            For performance reasons, a <see cref="T:Loyc.Syntax.Lexing.Token"/> does not have a reference 
            to its source file, so this method cannot return the original string.
            </remarks>
        </member>
        <member name="T:Loyc.Syntax.Lexing.BaseILexer`2">
            <summary>A version of <see cref="T:Loyc.Syntax.Lexing.BaseLexer`1"/> that implements 
            <see cref="T:Loyc.Syntax.Lexing.ILexer`1"/>. You should use this base class if you want to 
            wrap your lexer in a postprocessor such as <see cref="T:Loyc.Syntax.Lexing.IndentTokenGenerator"/> 
            or <see cref="T:Loyc.Syntax.Lexing.TokensToTree"/>. It can also be used with the <see 
            cref="!:LinqToLists.Buffered"/> extension method to help feed data to your parser.
            </summary>
            <remarks>
            Important: the derived class must call <see cref="M:Loyc.Syntax.Lexing.BaseILexer`2.AfterNewline"/> after
            encountering a newline (CR/LF/CRLF), in order to keep the properties 
            <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.LineNumber"/>, <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.LineStartAt"/>,
            <see cref="P:Loyc.Syntax.Lexing.BaseILexer`2.IndentString"/> and <see cref="P:Loyc.Syntax.Lexing.BaseILexer`2.IndentLevel"/> up-to-date.
            See <see cref="M:Loyc.Syntax.Lexing.BaseILexer`2.NextToken"/>.
            <para/>
            Alternately, your lexer can borrow the newline parser built into the base
            class, which is called <see cref="M:Loyc.Syntax.Lexing.BaseLexer`1.Newline"/> and will call 
            <see cref="M:Loyc.Syntax.Lexing.BaseILexer`2.AfterNewline"/> for you. It is possible to have LLLPG treat 
            this method as a rule, and tell LLLPG the meaning of the rule like this:
            <code>
              extern token Newline @{ '\r' '\n'? | '\n' };
              // BaseLexer also defines a Spaces() method, which behaves like this:
              extern token Spaces  @{ (' '|'\t')* }; 
            </code>
            The <c>extern</c> modifier tells LLLPG not to generate code for the
            rule, but the rule must still have a body so that LLLPG can perform 
            prediction.
            </remarks>
            <typeparam name="CharSrc">A class that implements <see cref="T:Loyc.Collections.ICharSource"/>.
            In order to write lexers that can accept any source of characters, set 
            CharSrc=ICharSource. For maximum performance when parsing strings (or
            to avoid memory allocation), set CharSrc=UString (<see cref="T:Loyc.UString"/> 
            is a wrapper around <c>System.String</c> that, among other things, 
            implements <c>ICharSource</c>; please note that C# will implicitly convert 
            normal strings to <see cref="T:Loyc.UString"/> for you).</typeparam>
            <typeparam name="Token">The type of token that your lexer will produce,
            e.g. <see cref="T:Loyc.Syntax.Lexing.Token"/>.</typeparam>
        </member>
        <member name="P:Loyc.Syntax.Lexing.BaseILexer`2.SpacesPerTab">
            <summary>Number of spaces per tab, for the purpose of computing 
            <see cref="P:Loyc.Syntax.Lexing.BaseILexer`2.IndentLevel"/>. Initial value: 4</summary>
        </member>
        <member name="F:Loyc.Syntax.Lexing.BaseILexer`2._current">
            <summary>The token that will be returned from the Current property.</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.BaseILexer`2.IndentString">
            <summary>Gets a string slice that holds the spaces or tabs that were 
            used to indent the current line.</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.BaseILexer`2.IndentLevel">
            <summary>Gets the number of spaces that were used to indent the current
            line, where a tab counts as rounding up to the next multiple of 
            <see cref="P:Loyc.Syntax.Lexing.BaseILexer`2.SpacesPerTab"/> spaces.</summary>
        </member>
        <member name="M:Loyc.Syntax.Lexing.BaseILexer`2.Reset(`0,System.String,System.Int32,System.Boolean)">
            <summary>Reinitializes the object. This method is called by the constructor.</summary>
            <remarks>Compared to the base class version of this function, this 
            method also skips over the UTF BOM '\uFEFF', if present, and it measures
            the indentation of the first line (without skipping over it).
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.Lexing.BaseILexer`2.NextToken">
            <summary>Scans the next token in the character stream and returns the
            token, or null when the end of the text is reached.</summary>
            <remarks>
            The derived class must call <see cref="M:Loyc.Syntax.Lexing.BaseILexer`2.AfterNewline"/> after it
            advances past each newline (CR/LF/CRLF), in order to keep the 
            properties <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.LineNumber"/>, <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.LineStartAt"/>,
            <see cref="P:Loyc.Syntax.Lexing.BaseILexer`2.IndentString"/> and <see cref="P:Loyc.Syntax.Lexing.BaseILexer`2.IndentLevel"/> up-to-date.
            This must be done even when the newline is encountered inside a comment
            or multi-line string. Note that the <see cref="M:Loyc.Syntax.Lexing.BaseLexer`1.Newline"/> rule 
            in the base class will call <see cref="M:Loyc.Syntax.Lexing.BaseILexer`2.AfterNewline"/> for you.
            <para/>
            Also, while returning, the derived class should set the <c>_current</c> 
            field to its own return value so that the <see cref="P:Loyc.Syntax.Lexing.BaseILexer`2.Current"/> property
            works reliably.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.Lexing.BaseILexer`2.SupportDotIndents">
            <summary>The LES and EC# languages support "dot indents", which are 
            lines that start with a dot (.) followed by a tab or spaces. If you
            overload this method to return true, then <see cref="M:Loyc.Syntax.Lexing.BaseILexer`2.AfterNewline"/>
            and <see cref="M:Loyc.Syntax.Lexing.BaseILexer`2.Reset(`0,System.String,System.Int32,System.Boolean)"/> will count dot indents as part of the 
            indentation at the beginning of each line; otherwise, only spaces and
            tabs will be counted.</summary>
            <remarks>
            A dot indent has the syntax <c>('.' ('\t' | ' '+))*</c>. This 
            indentation style is recognized only if a dot is the first character 
            on a line. Each pair of dot+(tab/spaces) prior to the first non-space 
            token is counted the same way as a tab character (\t). Dot indents are 
            useful for posting source code on "bad" blog software or forums that 
            do not preseve indentation.</remarks>
        </member>
        <member name="M:Loyc.Syntax.Lexing.BaseILexer`2.AfterNewline">
            <summary>The lexer must call this method exactly once after it advances 
            past each newline, even inside comments and strings. This method keeps
            the <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.LineNumber"/>, <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.LineStartAt"/>,
            <see cref="P:Loyc.Syntax.Lexing.BaseILexer`2.IndentString"/> and <see cref="P:Loyc.Syntax.Lexing.BaseILexer`2.IndentLevel"/> properties
            updated.</summary>
        </member>
        <member name="M:Loyc.Syntax.Lexing.BaseILexer`2.AfterNewline(System.Boolean,System.Boolean)">
            <inheritdoc cref="M:Loyc.Syntax.Lexing.BaseILexer`2.AfterNewline"/>
            <param name="ignoreIndent">Causes this method not to measure the indent
            at the beginning of this line, and leave the <see cref="P:Loyc.Syntax.Lexing.BaseILexer`2.IndentLevel"/>
            and <see cref="P:Loyc.Syntax.Lexing.BaseILexer`2.IndentString"/> unchanged. You may wish to set this flag 
            when a newline is encountered inside a multiline comment.</param>
            <param name="skipIndent">This method normally scans indentation after 
            the newline character, in order to update the <see cref="P:Loyc.Syntax.Lexing.BaseILexer`2.IndentString"/> 
            and <see cref="P:Loyc.Syntax.Lexing.BaseILexer`2.IndentLevel"/> properties. If this parameter is true,
            the <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.InputPosition"/> will also be increased, skipping past
            those initial spaces. If <c>supportDotIndent</c> is also true, the
            <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.InputPosition"/> will also skip past the dot indent, if any.</param>
        </member>
        <member name="M:Loyc.Syntax.Lexing.BaseILexer`2.ScanIndent(System.Boolean)">
            <summary>Scans indentation at the beginning of a line and updates the
            <see cref="P:Loyc.Syntax.Lexing.BaseILexer`2.IndentLevel"/> and <see cref="P:Loyc.Syntax.Lexing.BaseILexer`2.IndentString"/> properties.
            This function is called automatically by <see cref="M:Loyc.Syntax.Lexing.BaseILexer`2.AfterNewline"/>,
            but should be called manually on the very first line of the file.</summary>
            <remarks>Parameters are documented at <see cref="M:Loyc.Syntax.Lexing.BaseILexer`2.AfterNewline(System.Boolean,System.Boolean)"/></remarks>
        </member>
        <member name="T:Loyc.Syntax.Lexing.TriviaSaver">
            <summary>A lexer wrapper that saves whitespace tokens into a list (<see cref="P:Loyc.Syntax.Lexing.TriviaSaver.TriviaList"/>).</summary>
            <remarks>Typically used with <seealso cref="T:Loyc.Syntax.StandardTriviaInjector"/>.</remarks>
        </member>
        <member name="M:Loyc.Syntax.Lexing.TriviaSaver.#ctor(Loyc.Syntax.Lexing.ILexer{Loyc.Syntax.Lexing.Token},System.Int32)">
            <summary>Initializer.</summary>
            <param name="lexer">Lexer to wrap.</param>
            <param name="newlineTypeInt">This wrapper filters out and saves whitespace 
            tokens (where <see cref="F:Loyc.Syntax.Lexing.Token.Value"/> is <see cref="F:Loyc.Syntax.Lexing.WhitespaceTag.Value"/>) 
            but in some languages, newlines are not considered whitespace but they
            still need to be saved in the trivia list. If the <see cref="F:Loyc.Syntax.Lexing.Token.TypeInt"/> 
            equals this value, the token is saved but NOT filtered out.</param>
        </member>
        <member name="T:Loyc.Syntax.Lexing.IndentTokenGenerator`1">
            <summary>
            A preprocessor usually inserted between the lexer and parser that inserts
            "indent", "dedent", and "end-of-line" tokens at appropriate places in a
            token stream.
            </summary>
            <remarks>This class will not work correctly if the lexer does not implement 
            <see cref="P:Loyc.Syntax.Lexing.ILexer`1.IndentLevel"/> properly.
            <para/>
            This class is abstract because it doesn't know how to classify or create 
            tokens. The derived class must implement <see cref="M:Loyc.Syntax.Lexing.IndentTokenGenerator`1.GetTokenCategory(`0)"/>,
            <see cref="M:Loyc.Syntax.Lexing.IndentTokenGenerator`1.MakeEndOfLineToken(`0,Loyc.Maybe{`0}@,System.Nullable{System.Int32})"/>, <see cref="M:Loyc.Syntax.Lexing.IndentTokenGenerator`1.MakeIndentToken(`0,Loyc.Maybe{`0}@,System.Boolean)"/> and 
            <see cref="M:Loyc.Syntax.Lexing.IndentTokenGenerator`1.MakeDedentToken(`0,Loyc.Maybe{`0}@)"/>. <see cref="T:Loyc.Syntax.Lexing.IndentTokenGenerator"/> is a 
            non-abstract version of this class based on <see cref="T:Loyc.Syntax.Lexing.Token"/> 
            structures, with several properties that can be customized.
            <para/>
            Creation of indent, dedent, and end-of-line tokens can be suppressed inside 
            brackets, i.e. () [] {}. This is accomplished by recognizing brackets inside
            your implementation of <see cref="M:Loyc.Syntax.Lexing.IndentTokenGenerator`1.GetTokenCategory(`0)"/>.
            <para/>
            <see cref="T:Loyc.Syntax.Lexing.TokensToTree"/> can be placed in the pipeline before or after 
            this class; if it is placed afterward, anything between Indent and Dedent
            tokens will be made a child of the Indent token.
            <para/>
            Note: whitespace tokens (<see cref="F:Loyc.Syntax.Lexing.IndentTokenGenerator`1.TokenCategory.Whitespace"/>) are passed 
            through and otherwise unprocessed.
            <para/>
            Note: EOL tokens are not generated for empty or comment lines, and are not 
            generated after a generated indent token, although they could be generated 
            after a pre-existing indent token that was already in the token stream, 
            unless that token is categorized as <see cref="F:Loyc.Syntax.Lexing.IndentTokenGenerator`1.TokenCategory.OpenBracket"/>.
            <para/>
            Partial dedents and unexpected indents, as in
            <code>
              if Condition:
                  print("Hello")
                print("Hello again")
              else:
                  print("Goodbye")
                    print("Goodbye again")
            </code>
            will cause an error message to be written to the <see cref="P:Loyc.Syntax.Lexing.ILexer`1.ErrorSink"/> 
            of the original lexer.
            <para/>
            Please see <see cref="T:Loyc.Syntax.Lexing.IndentTokenGenerator"/> for additional remarks and examples.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.Lexing.IndentTokenGenerator`1.#ctor(Loyc.Syntax.Lexing.ILexer{`0})">
            <summary>Initializes the indent detector.</summary>
            <param name="lexer">Original lexer (either a raw lexer or an instance of another preprocessor such as <see cref="T:Loyc.Syntax.Lexing.TokensToTree"/>.)</param>
        </member>
        <member name="F:Loyc.Syntax.Lexing.IndentTokenGenerator`1.TokenCategory.OpenBracket">
            <summary>An open bracket, inside of which indent triggers should be ignored.</summary>
        </member>
        <member name="F:Loyc.Syntax.Lexing.IndentTokenGenerator`1.TokenCategory.CloseBracket">
            <summary>A close bracket, whch reverses the effect of an open bracket.</summary>
        </member>
        <member name="F:Loyc.Syntax.Lexing.IndentTokenGenerator`1.TokenCategory.IndentTrigger">
            <summary>This token may trigger an indentation token, with an unindent
            token to be generated later, when a line is encountered that is not 
            indented in comparison to this line.</summary>
        </member>
        <member name="F:Loyc.Syntax.Lexing.IndentTokenGenerator`1.TokenCategory.Whitespace">
            <summary>A whitespace token, which should be passed though and 
            otherwise ignored.</summary>
        </member>
        <member name="F:Loyc.Syntax.Lexing.IndentTokenGenerator`1.TokenCategory.Other">
            <summary>None of the other categories apply to this token.</summary>
        </member>
        <member name="M:Loyc.Syntax.Lexing.IndentTokenGenerator`1.GetTokenCategory(`0)">
            <summary>Gets the category of a token for the purposes of indent processing.</summary>
        </member>
        <member name="M:Loyc.Syntax.Lexing.IndentTokenGenerator`1.MakeIndentToken(`0,Loyc.Maybe{`0}@,System.Boolean)">
            <summary>Returns a token to represent indentation, or null to suppress 
            generating an indent-dedent pair at this point.</summary>
            <param name="indentTrigger">The token that triggered this function call.</param>
            <param name="tokenAfterward">The token after the indent trigger, or NoValue at EOF.</param>
            <param name="newlineAfter">true if the next non-whitespace token after 
            <c>indentTrigger</c> is on a different line, or if EOF comes afterward.</param>
        </member>
        <member name="M:Loyc.Syntax.Lexing.IndentTokenGenerator`1.MakeDedentToken(`0,Loyc.Maybe{`0}@)">
            <summary>Returns token(s) to represent un-indentation.</summary>
            <param name="tokenBeforeNewline">The last non-whitespace token before dedent</param>
            <param name="tokenAfterNewline">The first non-whitespace un-indented 
            token after the unindent, or NoValue at the end of the file. The 
            derived class is allowed to change this token, or delete it by 
            changing it to NoValue.</param>
            <remarks>This class considers the indented block to be "over" even if 
            this method returns no tokens.</remarks>
        </member>
        <member name="M:Loyc.Syntax.Lexing.IndentTokenGenerator`1.MakeEndOfLineToken(`0,Loyc.Maybe{`0}@,System.Nullable{System.Int32})">
            <summary>Returns a token to represent the end of a line, or null to
            avoid generating such a token.</summary>
            <param name="tokenBeforeNewline">Final non-whitespace token before the newline was encountered.</param>
            <param name="tokenAfterNewline">First non-whitespace token after newline.</param>
            <param name="deltaIndent">Change of indentation after the newline, or 
            null if a dedent token is about to be inserted after the newline.</param>
            <remarks>This function is also called at end-of-file, unless there are 
            no tokens in the file.</remarks>
        </member>
        <member name="M:Loyc.Syntax.Lexing.IndentTokenGenerator`1.IndentChangedUnexpectedly(`0,Loyc.Maybe{`0}@,System.Int32@)">
            <summary>A method that is called when the indent level changed without
            a corresponding indent trigger.</summary>
            <param name="tokenBeforeNewline">Final non-whitespace token before the newline.</param>
            <param name="tokenAfterNewline">First non-whitespace token after the newline.
            Though it's a <see cref="T:Loyc.Maybe`1"/>, it always has a value, but this 
            function can suppress its emission by setting it to NoValue.Value.</param>
            <param name="deltaIndent">Amount of unexpected indentation (positive or 
            negative). On return, this parameter holds the amount by which to change
            the <see cref="P:Loyc.Syntax.Lexing.IndentTokenGenerator`1.CurrentIndent"/>; the default implementation leaves this
            value unchanged, which means that subsequent lines will be expected to 
            be indented by the same (unexpected) amount.</param>
            <returns>true if <see cref="M:Loyc.Syntax.Lexing.IndentTokenGenerator`1.MakeEndOfLineToken(`0,Loyc.Maybe{`0}@,System.Nullable{System.Int32})"/> should be called as 
            usual, or false to suppress EOL genertion. EOL can only be suppressed
            in case of an unexpected indent (<c>deltaIndent>0</c>), not an unindent.</returns>
            <remarks>The default implementation always returns true. It normally 
            writes an error message, but switches to a warning in case 
            <c>OuterIndents[OuterIndents.Count-1] == OuterIndents[OuterIndents.Count-2]</c>, 
            which this class interprets as a single unindent.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.Lexing.IndentTokenGenerator`1.IndexToMsgContext(`0)">
            <summary>Gets the context for use in error messages, which by convention is a <see cref="T:Loyc.Syntax.SourceRange"/>.</summary>
            <remarks>The base class uses Lexer.InputPosition as a fallback if the token doesn't implement ISimpleToken{int}.</remarks>
        </member>
        <member name="T:Loyc.Syntax.Lexing.IndentTokenGenerator">
            <summary>
            A preprocessor usually inserted between the lexer and parser that inserts
            "indent", "dedent", and "end-of-line" tokens at appropriate places in a
            token stream.
            </summary>
            <remarks>
            Suppose you use an <see cref="P:Loyc.Syntax.Lexing.IndentTokenGenerator.IndentToken"/> and <see cref="P:Loyc.Syntax.Lexing.IndentTokenGenerator.DedentToken"/> 
            that are equal to the token types you've chosen for <c>{ braces }</c> (e.g.  
            (<see cref="F:Loyc.Syntax.Lexing.TokenKind.LBrace"/> and <see cref="F:Loyc.Syntax.Lexing.TokenKind.RBrace"/>), the 
            only indent trigger is a colon (:), and you set <see cref="P:Loyc.Syntax.Lexing.IndentTokenGenerator.EolToken"/> to 
            the token type you're using for semicolons. Then the token stream from 
            input such as
            <code>
            def Sqrt(value):
            	if value == 0: return 0
            	g = 0; bshft = Log2Floor(value) >> 1;
            	b = 1 &lt;&lt; bshft
            	do:
            		temp = (g + g + b) &lt;&lt; bshft
            		if value >= temp: g += b
            			value -= temp
            		b >>= 1
            	while (bshft-- > 0)
            	return g
            </code>
            will be converted to a token stream equivalent to
            <code>
            def Sqrt(value): {
            	if value == 0: { return 0;
            	} g = 0; bshft = Log2Floor(value) >> 1;
            	b = 1 &lt;&lt; bshft;
            	do: {
            		temp = (g + g + b) &lt;&lt; bshft
            		if value >= temp: { g += b;
            			value -= temp;
            		} b >>= 1;
            	} while (bshft-- > 0);
            	return g;
            }</code>
            That is, a semicolon is added to lines that don't already have one, open 
            braces are inserted right after colons, and semicolons are <i>not</i> added 
            right after opening braces.
            <para/>
            If multiple indents occur on a single line, as in
            <code>
            if x: if y:
                Foo(x, y)
            </code>
            The output will be like this:
            <code>
            if x: { if y: {
                Foo(x, y);
            }}
            </code>
            
            <h3>Configuration for Python</h3>
            
            Newlines generally represent the end of a statement, while colons mark 
            places where a "child" block is expected. Inside parenthesis, square 
            brackets, or braces, newlines are ignored:
            <code>
            	s = ("this is a pretty long string that I'd like "
            	  + " to continue writing on the next line")
            </code>
            And, inside brackets, indentation is ignored, so this is allowed:
            <code>
            if foo:
            	s = ("this is a pretty long string that I'd like "
            + " to continue writing on the next line")
            	print(s)
            </code>
            Note that if you don't use brackets, Python 3 doesn't try to figure out if 
            you "really" meant to continue a statement on the next line:
            <code>
            	# SyntaxError after '+': invalid syntax
            	s = "this is a pretty long string that I'd like " + 
            		" to continue writing on the next line"
            </code>
            Thus OpenBrackets and CloseBrackets should be <c>( [ {</c> and <c>) ] }</c>, 
            respectively. IndentType and DedentType should be synthetic Indent and 
            Dedent tokens, since curly braces have a different meaning (they define a 
            dictionary).
            <para/>
            In Python, it appears you can't write two "block" statements on one line, 
            as in this example:
            <code>
              if True: if True: print() # SyntaxError: invalid syntax
            </code>
            You're also not allowed to indent the next line if the block statement on
            the current line is followed by another statement:
            <code>
              if True: print('a')
                  print('b') # IndentationError: unexpected indent
            </code>
            But you can switch style in different branches:
            <code>
              if True:
                  print("t")
              else: print("f")
              try: print("t")
              except: 
                  print("e")
            </code>
            Also, although you can normally separate statements with semicolons:
            <code>
              print("hell", end=""); print("o")
            </code>
            You are not allowed to write this:
            <code>
              print("?"); if True: # SyntaxError: invalid syntax
                 print("t")
            </code>
            Considering these three facts, I would say that the colon should be 
            classified as an EOL indent trigger (EolIndentTriggers), and the parser 
            should 
            1. recognize non-block statements separately from block statements,
            2. expect a colon to be followed by either an indented block or a non-block 
               statement, but
            3. recognize a non-block "statement" as a <i>list</i> of statements 
               separated by semicolons, with an optional semicolon at the end.
            <para/>
            Now, Python doesn't allow a block statement without a <c>pass</c>, e.g.:
            <code>
              if cond: # "do nothing"
              return   # IndentationError: expected an indented block
            </code>
            I'm inclined to treat this as a special case to be detected in the parser.
            And although you can write a semicolon on a line by itself, you can't 
            write any of these lines:
            <code>
              if cond: ;         # SyntaxError: invalid syntax
              print(); ; print() # SyntaxError: invalid syntax
              ; ;                # SyntaxError: invalid syntax
            </code>
            My interpretation is that a semicolon <i>by itself</i> is treated as a block 
            statement (i.e. illegal in a non-block statement context). Since a semicolon
            is not treated the same way as a newline, the <see cref="P:Loyc.Syntax.Lexing.IndentTokenGenerator.EolToken"/> should 
            be a special token, not a semicolon.
            </remarks>
            <seealso cref="T:Loyc.Syntax.Lexing.IndentTokenGenerator`1"/>
        </member>
        <member name="M:Loyc.Syntax.Lexing.IndentTokenGenerator.#ctor(Loyc.Syntax.Lexing.ILexer{Loyc.Syntax.Lexing.Token},System.Int32[],System.Nullable{Loyc.Syntax.Lexing.Token},Loyc.Syntax.Lexing.Token,Loyc.Syntax.Lexing.Token)">
            <summary>Initializes the indent detector.</summary>
            <param name="lexer">Original lexer</param>
            <param name="allIndentTriggers">A list of all token types that could trigger the insertion of an indentation token.</param>
            <param name="eolToken">Prototype token for end-statement markers inserted when
            newlines are encountered, or null to avoid generating such markers.</param>
            <param name="indentToken">Prototype token for indentation markers</param>
            <param name="dedentToken">Prototype token for un-indent markers</param>
        </member>
        <member name="F:Loyc.Syntax.Lexing.IndentTokenGenerator._eolIndentTriggers">
            <summary>A subset of <see cref="P:Loyc.Syntax.Lexing.IndentTokenGenerator.AllIndentTriggers"/> that only take 
            effect at the end of a line.</summary>
            <remarks>If this list includes items that are not in 
            <see cref="P:Loyc.Syntax.Lexing.IndentTokenGenerator.AllIndentTriggers"/>, they have no effect.</remarks>
        </member>
        <member name="P:Loyc.Syntax.Lexing.IndentTokenGenerator.EolToken">
            <summary>Gets or sets the prototype token for end-statement (a.k.a. 
            end-of-line) markers, cast to an integer as required by <see cref="T:Loyc.Syntax.Lexing.Token"/>. 
            Use <c>null</c> to avoid generating such markers.</summary>
            <remarks>Note: if the last token on a line has this same type, this 
            class will not generate an extra newline token.
            <para/>
            The StartIndex is updated for each actual token emitted.</remarks>
        </member>
        <member name="P:Loyc.Syntax.Lexing.IndentTokenGenerator.IndentToken">
            <summary>Gets or sets the prototype token for indentation markers.</summary>
            <remarks>The StartIndex is updated for each actual token emitted.</remarks>
        </member>
        <member name="P:Loyc.Syntax.Lexing.IndentTokenGenerator.DedentToken">
            <summary>Gets or sets the prototype token for unindentation markers.</summary>
            <remarks>The StartIndex is updated for each actual token emitted.</remarks>
        </member>
        <member name="T:Loyc.Syntax.Lexing.WhitespaceFilter`1">
            <summary>Filters out tokens whose <c>Value</c> is <see cref="F:Loyc.Syntax.Lexing.WhitespaceTag.Value"/>.</summary>
        </member>
        <member name="T:Loyc.Syntax.Lexing.WhitespaceFilter">
            <summary>Alias for <c>WhitespaceFilter{Token}</c></summary>
        </member>
        <member name="T:Loyc.Syntax.Lexing.BaseLexer`1">
            <summary>The recommended base class for lexers generated by LLLPG,
            when not using the <c>inputSource</c> option.</summary>
            <remarks>
            If you are using the <c>inputSource</c> and <c>inputClass</c> options of,
            LLLPG, use <see cref="T:Loyc.Syntax.Lexing.LexerSource`1"/> instead. If you want to
            write a lexer that implements <see cref="T:Loyc.Syntax.Lexing.ILexer`1"/> (so it is compatible
            with postprocessors like <see cref="T:Loyc.Syntax.Lexing.IndentTokenGenerator"/> and 
            <see cref="T:Loyc.Syntax.Lexing.TokensToTree"/>), use <see cref="T:Loyc.Syntax.Lexing.BaseILexer`2"/> as 
            your base class instead.
            <para/>
            This class contains many methods required by LLLPG, such as 
            <see cref="M:Loyc.Syntax.Lexing.BaseLexer`1.NewSet(System.Int32[])"/>, <see cref="M:Loyc.Syntax.Lexing.BaseLexer`1.LA(System.Int32)"/>, <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.LA0"/>, 
            <see cref="M:Loyc.Syntax.Lexing.BaseLexer`1.Skip"/>, <see cref="M:Loyc.Syntax.Lexing.BaseLexer`1.Match(System.Collections.Generic.HashSet{System.Int32})"/>(...), and <see 
            cref="M:Loyc.Syntax.Lexing.BaseLexer`1.TryMatch(System.Collections.Generic.HashSet{System.Int32})"/>(...), along with a few properties that are not 
            used by LLLPG that you still might want to have around, such as 
            <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.FileName"/>, <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.CharSource"/> and 
            <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.SourceFile"/>.
            <para/>
            It also implements the caching behavior for which <see cref="T:Loyc.Collections.ICharSource"/>
            was created. See the documentation of <see cref="T:Loyc.Collections.ICharSource"/> for more
            information.
            <para/>
            All lexers derived from BaseLexer should call <see cref="M:Loyc.Syntax.Lexing.BaseLexer`1.AfterNewline"/>
            at the end of their newline rule, in order to increment the current line
            number. Alternately, your lexer can borrow the newline parser built into 
            BaseLexer, which is called <see cref="M:Loyc.Syntax.Lexing.BaseLexer`1.Newline"/> and calls 
            <see cref="M:Loyc.Syntax.Lexing.BaseLexer`1.AfterNewline"/> for you. It is possible to have LLLPG treat 
            this method as a rule, and tell LLLPG the meaning of the rule like this:
            <code>
              extern token Newline @{ '\r' '\n'? | '\n' };
              // BaseLexer also defines a Spaces() method, which behaves like this:
              extern token Spaces  @{ (' '|'\t')* }; 
            </code>
            The <c>extern</c> modifier tells LLLPG not to generate code for the
            rule, but the rule must still have a body so that LLLPG can perform 
            prediction.
            <para/>
            By default, errors are handled by throwing <see cref="T:System.FormatException"/>.
            The recommended way to alter this behavior is to change the 
            <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.ErrorSink"/> property. For example, set it to 
            <see cref="F:Loyc.MessageSink.Console"/> to send errors to the console, or
            use <see cref="M:Loyc.MessageSink.FromDelegate(Loyc.WriteMessageFn,System.Func{Loyc.Severity,System.Boolean})"/> to provide a custom handler.
            </remarks>
            <typeparam name="CharSrc">A class that implements <see cref="T:Loyc.Collections.ICharSource"/>.
            In order to write lexers that can accept any source of characters, set 
            CharSrc=ICharSource. For maximum performance when parsing strings (or
            to avoid memory allocation), set CharSrc=UString (<see cref="T:Loyc.UString"/> 
            is a wrapper around <c>System.String</c> that, among other things, 
            implements <c>ICharSource</c>; please note that C# will implicitly convert 
            normal strings to <see cref="T:Loyc.UString"/> for you).</typeparam>
        </member>
        <member name="M:Loyc.Syntax.Lexing.BaseLexer`1.#ctor(`0,System.String,System.Int32,System.Boolean)">
            <summary>Initializes BaseLexer.</summary>
            <param name="chars">A source of characters, e.g. <see cref="T:Loyc.UString"/>.</param>
            <param name="fileName">A file name associated with the characters, 
            which will be used for error reporting.</param>
            <param name="inputPosition">A location to start lexing (normally 0).
            Careful: If you're starting to lex in the middle of the file, the 
            <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.LineNumber"/> still starts at 1, and (if <c>newSourceFile</c>
            is true) the <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.SourceFile"/> object may or may not discover 
            line breaks prior to the starting point, depending on how it is used.</param>
            <param name="newSourceFile">Whether to create a <see cref="T:Loyc.Syntax.Lexing.LexerSourceFile`1"/>
            object (an implementation of <see cref="T:Loyc.Syntax.ISourceFile"/>) to keep track 
            of line boundaries. The <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.SourceFile"/> property will point
            to this object, and it will be null if this parameter is false. Using 
            'false' will avoid memory allocation, but prevent you from mapping 
            character positions to line numbers and vice versa. However, this
            object will still keep track of the current <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.LineNumber"/> 
            and <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.LineStartAt"/> (the index where the current line started) 
            when this parameter is false.</param>
        </member>
        <member name="M:Loyc.Syntax.Lexing.BaseLexer`1.Reset(`0,System.String,System.Int32,System.Boolean)">
            <summary>Reinitializes the object. This method is called by the constructor.</summary>
            <remarks>
            See the constructor for documentation of the parameters.
            <para/>
            This method can be used to avoid memory allocations when you
            need to parse many small strings in a row. If that's your goal, you 
            should set the <c>newSourceFile</c> parameter to false if possible.</remarks>
        </member>
        <member name="F:Loyc.Syntax.Lexing.BaseLexer`1.LogExceptionErrorSink">
            <summary>Throws LogException when it receives an error. Non-errors
            are sent to <see cref="P:Loyc.MessageSink.Default"/>.</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.BaseLexer`1.ErrorSink">
            <summary>Gets or sets the object to which error messages are sent. The
            default object is <see cref="F:Loyc.Syntax.Lexing.BaseLexer`1.LogExceptionErrorSink"/>, which throws
            an exception if an error occurs.</summary>
        </member>
        <member name="M:Loyc.Syntax.Lexing.BaseLexer`1.Skip">
            <summary>Increments InputPosition. Called by LLLPG when prediction 
            already verified the input (and caller doesn't save LA(0))</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.BaseLexer`1.LineNumber">
            <summary>Current line number. Starts at 1 for the first line, unless derived class changes it.</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.BaseLexer`1.LineStartAt">
            <summary>Index at which the current line started.</summary>
        </member>
        <member name="M:Loyc.Syntax.Lexing.BaseLexer`1.AfterNewline">
            <summary>The lexer must call this method exactly once after it advances 
            past each newline, even inside comments and strings. This method keeps
            the <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.LineNumber"/> and <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.LineStartAt"/> properties
            updated.</summary>
        </member>
        <member name="M:Loyc.Syntax.Lexing.BaseLexer`1.Newline">
            <summary>Default newline parser that matches '\n' or '\r' unconditionally.</summary>
            <remarks>
            You can use this implementation in an LLLPG lexer with "extern", like so:
            <c>extern rule Newline @{ '\r' + '\n'? | '\n' };</c>
            By using this implementation everywhere in the grammar in which a 
            newline is allowed (even inside comments and strings), you can ensure
            that <see cref="M:Loyc.Syntax.Lexing.BaseLexer`1.AfterNewline"/> is called, so that the line number
            is updated properly.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.Lexing.BaseLexer`1.Spaces">
            <summary>Skips past any spaces at the current position. Equivalent to
            <c>rule Spaces @[ (' '|'\t')* ]</c> in LLLPG.</summary>
        </member>
        <member name="T:Loyc.Syntax.Lexing.BaseLexer`1.SavePosition">
            <summary>A helper class used by LLLPG for backtracking.</summary>
        </member>
        <member name="M:Loyc.Syntax.Lexing.BaseLexer`1.Error(System.Int32,System.String)">
            <summary>This method is called to handle errors that occur during lexing.</summary>
            <param name="lookaheadIndex">Index where the error occurred, relative to
            the current InputPosition (i.e. InputPosition + lookaheadIndex is the
            position of the error).</param>
            <param name="message">An error message, not including the error location.</param>
        </member>
        <member name="M:Loyc.Syntax.Lexing.BaseLexer`1.Error(System.Int32,System.String,System.Object[])">
            <summary>This method is called to format and handle errors that occur 
            during lexing. The default implementation sends errors to <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.ErrorSink"/>, 
            which, by default, throws a <see cref="T:System.FormatException"/>.</summary>
            <param name="lookaheadIndex">Index where the error occurred, relative to
            the current InputPosition (i.e. InputPosition + lookaheadIndex is the
            position of the error).</param>
            <param name="format">An error description with argument placeholders.</param>
            <param name="args">Arguments to insert into the error message.</param>
        </member>
        <member name="M:Loyc.Syntax.Lexing.BaseLexer`1.MatchError(System.Boolean,System.Collections.Generic.IList{System.Int32})">
            <summary>Handles an error that occurs during Match(), MatchExcept(), MatchRange() or MatchExceptRange()</summary>
            <param name="inverted">Set inversion flag. If true, then <c>expected</c> is actually a list of things that were NOT expected.</param>
            <param name="ranges">List of ranges of characters that were expected (or unexpected, if <c>inverted</c>)</param>
        </member>
        <member name="M:Loyc.Syntax.Lexing.BaseLexer`1.RangesToString(System.Collections.Generic.IList{System.Int32})">
            <summary>Converts a list of character ranges to a string, e.g. for input
            list {'*','*','a','z'}, the output is "'*' 'a'..'z'".</summary>
        </member>
        <member name="M:Loyc.Syntax.Lexing.BaseLexer`1.PrintChar(System.Int32,System.Text.StringBuilder)">
            <summary>Prints a character as a string, e.g. <c>'a' -> "'a'"</c>, with 
            the special value -1 representing EOF, so PrintChar(-1, ...) == "EOF".</summary>
        </member>
        <member name="T:Loyc.Syntax.Lexing.BaseLexer">
            <summary>Alias for <see cref="T:Loyc.Syntax.Lexing.BaseLexer`1"/> where C is <see cref="T:Loyc.Collections.ICharSource"/>.</summary>
        </member>
        <member name="T:Loyc.Syntax.Lexing.ILexer`1">
            <summary>A standard interface for lexers.</summary>
            <typeparam name="Token">Type of tokens produced by the lexer (usually
            <see cref="T:Loyc.Syntax.Lexing.Token"/>).</typeparam>
        </member>
        <member name="P:Loyc.Syntax.Lexing.ILexer`1.SourceFile">
            <summary>The file being lexed.</summary>
            <remarks>This property should never be null.</remarks>
        </member>
        <member name="M:Loyc.Syntax.Lexing.ILexer`1.NextToken">
            <summary>Scans the next token and returns information about it.</summary>
            <returns>The next token, or null at the end of the source file.</returns>
        </member>
        <member name="P:Loyc.Syntax.Lexing.ILexer`1.ErrorSink">
            <summary>Event handler for errors.</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.ILexer`1.IndentLevel">
            <summary>Indentation level of the current line. This is updated after 
            scanning the first whitespaces on a new line, and may be reset to zero 
            when <see cref="M:Loyc.Syntax.Lexing.ILexer`1.NextToken"/> returns a newline.</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.ILexer`1.IndentString">
            <summary>Gets a string slice that holds the spaces or tabs that were 
            used to indent the current line.</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.ILexer`1.LineNumber">
            <summary>Current line number (1 for the first line).</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.ILexer`1.InputPosition">
            <summary>Current input position (an index into SourceFile.Text).</summary>
        </member>
        <member name="T:Loyc.Syntax.Lexing.LexerWrapper`1">
            <summary>A base class for wrappers that modify lexer behavior.
            Implements the ILexer interface, except for the NextToken() method.</summary>
        </member>
        <member name="M:Loyc.Syntax.Lexing.LexerWrapper`1.NextToken">
            <summary>Returns the next (postprocessed) token. This method should set
            the <c>_current</c> field to the returned value.</summary>
        </member>
        <member name="T:Loyc.Syntax.Lexing.ILllpgApi`3">
            <summary>For reference purposes, this interface is a list of the non-static 
            methods that LLLPG expects to be able to call when it is generating code. 
            LLLPG does not actually need lexers and parsers to implement this interface;
            they simply need to implement the same set of methods as this interface 
            contains.</summary>
            <typeparam name="Token">The return value of the Match methods. LLLPG does 
            not care and does not need to know what this type is. In lexers, these 
            methods typically return the character that was matched (i.e. int, because
            EOF is -1), and in parsers they should return the token that was matched.</typeparam>
            <typeparam name="MatchType">The data type of arguments to Match, 
            MatchExcept, TryMatch and TryMatchExcept. In lexers, MatchType is always 
            int. In parsers, by default, LLLPG generates code as though MatchType is 
            same as LaType, but one often uses int instead, e.g. because enums do not
            implement <see cref="T:System.IEquatable`1"/> as required by 
            <see cref="T:Loyc.Syntax.BaseParser`2"/>. you're using
            <see cref="T:Loyc.Syntax.BaseParser`2"/> with LaType=int token 
            type is an enum, which for some reason does not implement 
            IEquatable{T}. So, often, when using BaseParser{Token you need to use the matchType(int) 
            option to change MatchType to int.</typeparam>
            <typeparam name="LaType">The data type of LA0 and LA(i). This is always int 
            in lexers, but in parsers you can use the laType(...) option to change this 
            type.</typeparam>
            <seealso cref="T:Loyc.Syntax.Lexing.ILllpgLexerApi`1"/>
        </member>
        <member name="T:Loyc.Syntax.Lexing.ILllpgLexerApi`1">
            <summary>For reference purposes, this interface contains the non-static 
            methods that LLLPG expects lexers to implement. LLLPG does not actually 
            expect lexers to implement this interface; they simply need to implement 
            the same set of methods as this interface contains.</summary>
            <typeparam name="Token">The return value of the Match() methods, which is
            the input value (character) actually encountered in the stream. This type 
            is usually int.</typeparam>
        </member>
        <member name="T:Loyc.Syntax.Lexing.LexerSource`1">
            <summary>An implementation of the LLLPG Lexer API, used with the LLLPG
            options <c>inputSource</c> and <c>inputClass</c>.</summary>
            <remarks>
            This derived class simply makes public all of the LLLPG APIs which are 
            marked protected in <see cref="T:Loyc.Syntax.Lexing.BaseLexer`1"/>.
            </remarks>
            <example>
            LLLPG(lexer(inputSource(src), inputClass(LexerSource))) {
            	static rule int ParseInt(string input) {
            		var src = (LexerSource&lt;UString>)input;
            		@[ (d:='0'..'9' {$result = $result * 10 + (d - '0');})+ ];
            	}
            }
            </example>
            <typeparam name="CharSrc">A class that implements ICharSource. In order
            to write lexers that can accept any source of characters, set 
            CharSrc=ICharSource. For maximum performance when parsing strings (or
            to avoid memory allocation), set CharSrc=UString (<see cref="T:Loyc.UString"/> 
            is a wrapper around <c>System.String</c> that, among other things, 
            implements <c>ICharSource</c>; please note that C# will implicitly convert 
            normal strings to <see cref="T:Loyc.UString"/> for you).</typeparam>
        </member>
        <member name="M:Loyc.Syntax.Lexing.LexerSource`1.#ctor(`0,System.String,System.Int32,System.Boolean)">
            <summary>Initializes LexerSource.</summary>
            <param name="source">A source of characters, e.g. <see cref="T:Loyc.UString"/>.</param>
            <param name="fileName">A file name associated with the characters, 
            which will be used for error reporting.</param>
            <param name="inputPosition">A location to start lexing (normally 0).
            Careful: If you're starting to lex in the middle of the file, the 
            <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.LineNumber"/> still starts at 1, and (if <c>newSourceFile</c>
            is true) the <see cref="P:Loyc.Syntax.Lexing.LexerSource`1.SourceFile"/> object may or may not discover 
            line breaks prior to the starting point, depending on how it is used.</param>
            <param name="newSourceFile">Whether to create a <see cref="T:Loyc.Syntax.Lexing.LexerSourceFile`1"/>
            object (an implementation of <see cref="T:Loyc.Syntax.ISourceFile"/>) to keep track 
            of line boundaries. The <see cref="P:Loyc.Syntax.Lexing.LexerSource`1.SourceFile"/> property will point
            to this object, and it will be null if this parameter is false. Using 
            'false' will avoid memory allocation, but prevent you from mapping 
            character positions to line numbers and vice versa. However, this
            object will still keep track of the current <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.LineNumber"/> 
            and <see cref="P:Loyc.Syntax.Lexing.LexerSource`1.LineStartAt"/> (the index where the current line started) 
            when this parameter is false.</param>
        </member>
        <member name="M:Loyc.Syntax.Lexing.LexerSource`1.Reset(`0,System.String,System.Int32,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Loyc.Syntax.Lexing.LexerSource`1.Skip">
            <inheritdoc/>
        </member>
        <member name="P:Loyc.Syntax.Lexing.LexerSource`1.LineStartAt">
            <inheritdoc/>
        </member>
        <member name="M:Loyc.Syntax.Lexing.LexerSource`1.AfterNewline">
            <inheritdoc/>
        </member>
        <member name="M:Loyc.Syntax.Lexing.LexerSource`1.Newline">
            <inheritdoc/>
        </member>
        <member name="M:Loyc.Syntax.Lexing.LexerSource`1.PrintChar(System.Int32,System.Text.StringBuilder)">
            <inheritdoc/>
        </member>
        <member name="T:Loyc.Syntax.Lexing.LexerSourceWorkaround`1">
            <summary>This class only exists to work around a limitation of the C# language:
            "cannot change access modifiers when overriding 'protected' inherited member Error(...)".</summary>
        </member>
        <member name="T:Loyc.Syntax.Lexing.LexerSource">
            <summary>A synonym for <see cref="T:Loyc.Syntax.Lexing.LexerSource`1"/> where C is <see cref="T:Loyc.Collections.ICharSource"/>.</summary>
        </member>
        <member name="T:Loyc.Syntax.Lexing.LexerSourceFile`1">
            <summary>Adds the <see cref="M:Loyc.Syntax.Lexing.LexerSourceFile`1.AfterNewline(System.Int32)"/> method to <see cref="T:Loyc.Syntax.SourceFile"/>.</summary>
            <remarks>
            When implementing a lexer, the most efficient approach to building the list
            of line breaks is to save the location of each newline as it is encountered 
            while lexing, rather than doing a separate pass over the file just to find 
            line breaks. This class supports this optimization.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.Lexing.LexerSourceFile`1.AfterNewline(System.Int32)">
            <summary>Allows a lexer to record the index of the character after 
            each line break, in the order they exist in the file or string.</summary>
            <param name="index">Index of the first character after the newline.</param>
            <remarks>
            A lexer is not required to call this method; if the lexer doesn't call 
            it, the list of line breaks (which is used to map indexes to line 
            numbers and vice versa) will be built on-demand when one calls methods
            such as <c>IndexToLine</c>.
            </remarks>
        </member>
        <member name="T:Loyc.Syntax.Lexing.TokenListAsLexer">
            <summary>Adapter: converts <c>IEnumerable(Token)</c> to the <see cref="T:Loyc.Syntax.Lexing.ILexer`1"/> interface.</summary>
            <remarks>
            The LineNumber property is computed on-demand by the <see cref="T:Loyc.Syntax.ISourceFile"/> provided.
            <para/>
            TODO: IndentLevel, IndentString do not work.
            </remarks>
        </member>
        <member name="T:Loyc.Syntax.Lexing.TokenTree">
            <summary>A list of Token structures along with the <see cref="T:Loyc.Syntax.ISourceFile"/> 
            object that represents the source file that the tokens came from.</summary>
            <remarks>This class is called <c>TokenTree</c> because certain kinds of 
            tokens used by some parsers are formed into trees by using <see cref="T:Loyc.Syntax.Lexing.TokenTree"/> 
            as the type of the <see cref="F:Loyc.Syntax.Lexing.Token.Value"/> of certain tokens. Specifically,
            the LES and EC# parsers expect open-bracket and open-brace tokens ('(', 
            '[' and '{') to have a child <see cref="T:Loyc.Syntax.Lexing.TokenTree"/> that contains all the 
            tokens within a pair of brackets or braces. Typically this tree is not 
            created directly by the lexer, but by a helper class (<see cref="T:Loyc.Syntax.Lexing.TokensToTree"/>).
            <para/>
            Caution: this class is mutable, even though TokenTrees are sometimes stored
            in <see cref="T:Loyc.Syntax.LNode"/>s which are supposed to be immutable. Please do not
            modify token trees that are stored inside LNodes.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.Lexing.TokenTree.Clone">
            <summary>Gets a deep (recursive) clone of the token tree.</summary>
        </member>
        <member name="M:Loyc.Syntax.Lexing.TokenTree.Equals(Loyc.Syntax.Lexing.TokenTree)">
            <summary>Compares the elements of the token tree for equality.</summary>
            <remarks>Because <see cref="T:Loyc.Syntax.LNode"/>s are compared by value and not by 
            reference, and LNodes can contain TokenTrees, TokenTrees should also be
            compared by value.</remarks>
        </member>
        <member name="M:Loyc.Syntax.Lexing.TokenTree.ToLNodes">
            <summary>Converts this list of <see cref="T:Loyc.Syntax.Lexing.Token"/> to a list of <see cref="T:Loyc.Syntax.LNode"/>.</summary>
            <remarks>See <see cref="M:Loyc.Syntax.Lexing.Token.ToLNode(Loyc.Syntax.ISourceFile)"/> for more information.</remarks>
        </member>
        <member name="M:Loyc.Syntax.Lexing.TokenTree.Flatten">
            <summary>Converts a token tree back to a plain list.</summary>
        </member>
        <member name="T:Loyc.Syntax.Lexing.WhitespaceTag">
            <summary><see cref="F:Loyc.Syntax.Lexing.WhitespaceTag.Value"/> can be used as the
            <see cref="F:Loyc.Syntax.Lexing.Token.Value"/> of whitespace tokens, to make whitespace
            easy to filter out.</summary>
        </member>
        <member name="T:Loyc.Syntax.Lexing.Token">
            <summary>
            A common token type recommended for Loyc languages that want to use 
            features such as token literals or the <see cref="T:Loyc.Syntax.Lexing.TokensToTree"/> class.
            </summary>
            <remarks>
            For performance reasons, a Token ought to be a structure rather than
            a class. But if Token is a struct, we have a conundrum: how do we support 
            tokens from different languages? We can't use inheritance since structs
            do not support it. When EC# is ready, we could use a single struct plus
            an alias for each language, but of course this structure predates the 
            implementation of EC#.
            <para/>
            Luckily, tokens in most languages are very similar. A four-word structure
            generally suffices:
            <ol>
            <li><see cref="F:Loyc.Syntax.Lexing.Token.TypeInt"/>: each language can use a different set of token types 
            represented by a different <c>enum</c>. All enums can be converted to 
            an integer, so <see cref="T:Loyc.Syntax.Lexing.Token"/> uses Int32 as the token type. In order
            to support DSLs via token literals (e.g. LLLPG is a DSL inside EC#), the
            TypeInt should be based on <see cref="T:Loyc.Syntax.Lexing.TokenKind"/>.</li>
            <li><see cref="F:Loyc.Syntax.Lexing.Token.Value"/>: this can be any object. For literals, this should 
            be the actual value of the literal, for whitespace it should be 
            <see cref="F:Loyc.Syntax.Lexing.WhitespaceTag.Value"/>, etc. See <see cref="F:Loyc.Syntax.Lexing.Token.Value"/> for 
            the complete list.</li>
            <li><see cref="F:Loyc.Syntax.Lexing.Token.StartIndex"/>: location in the original source file where 
            the token starts.</li>
            <li><see cref="P:Loyc.Syntax.Lexing.Token.Length"/>: length of the token in the source file (24 bits).</li>
            <li><see cref="P:Loyc.Syntax.Lexing.Token.Style"/>: 8 bits for other information.</li>
            </ol>
            Originally I planned to use <see cref="T:Loyc.Symbol"/> as the common token 
            type, because it is extensible and could nicely represent tokens in all
            languages; unfortunately, Symbol may reduce parsing performance because 
            it cannot be used with the switch opcode (i.e. the switch statement in 
            C#), so I decided to switch to integers instead and to introduce the 
            concept of <see cref="T:Loyc.Syntax.Lexing.TokenKind"/>, which is derived from 
            <see cref="T:System.Type"/> using <see cref="F:Loyc.Syntax.Lexing.TokenKind.KindMask"/>.
            Each language should have, in the namespace of that language, an
            extension method <c>public static TokenType Type(this Token t)</c> that 
            converts the TypeInt to the enum type for that language.
            <para/>
            To save space (and because .NET doesn't handle large structures well),
            tokens do not know what source file they came from and cannot convert 
            their location to a line number. For this reason, one should keep a
            reference to the <see cref="T:Loyc.Syntax.ISourceFile"/> and call <see cref="M:Loyc.Syntax.IIndexToLine.IndexToLine(System.Int32)"/> 
            to get the source location.
            <para/>
            A generic token also cannot convert itself to a properly-formatted 
            string. The <see cref="M:Loyc.Syntax.Lexing.Token.ToString"/> method does allow 
            </remarks>
        </member>
        <member name="F:Loyc.Syntax.Lexing.Token.TypeInt">
            <summary>Token type.</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.Token.Kind">
            <summary>Token kind.</summary>
        </member>
        <member name="F:Loyc.Syntax.Lexing.Token.StartIndex">
            <summary>Location in the orginal source file where the token starts, or
            -1 for a synthetic token.</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.Token.Length">
            <summary>Length of the token in the source file, or 0 for a synthetic 
            or implied token.</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.Token.Style">
            <summary>8 bits of nonsemantic information about the token. The style 
            is used to distinguish hex literals from decimal literals, or triple-
            quoted strings from double-quoted strings.</summary>
        </member>
        <member name="F:Loyc.Syntax.Lexing.Token.Value">
            <summary>The parsed value of the token.</summary>
            <remarks>Recommended ways to use this field:
            <ul>
            <li>For strings: the parsed value of the string (no quotes, escape 
            sequences removed), i.e. a boxed char or a string. A backquoted 
            string in EC#/LES is converted to a <see cref="T:Loyc.Symbol"/> because it 
            is a kind of operator.</li>
            <li>For numbers: the parsed value of the number (e.g. 4 => int, 4L => long, 4.0f => float)</li>
            <li>For identifiers: the parsed name of the identifier, as a Symbol 
            (e.g. x => x, @for => for, @`1+1` => <c>1+1</c>)</li>
            <li>For any keyword including AttrKeyword and TypeKeyword tokens: a 
            Symbol containing the name of the keyword, with "#" prefix</li>
            <li>For punctuation and operators: the text of the punctuation as a 
            Symbol.</li>
            <li>For openers (open paren, open brace, etc.): null for normal linear
            parsers. If the tokens have been processed by <see cref="T:Loyc.Syntax.Lexing.TokensToTree"/>,
            this will be a <see cref="T:Loyc.Syntax.Lexing.TokenTree"/>.</li>
            <li>For spaces and comments: for performance reasons, it is not 
            recommended to extract the text of whitespace from the source file; 
            instead, use <see cref="F:Loyc.Syntax.Lexing.WhitespaceTag.Value"/></li>
            <li>When no value is needed (because the Type() is enough): null</li>
            </ul>
            </remarks>
        </member>
        <member name="P:Loyc.Syntax.Lexing.Token.Children">
            <summary>Returns Value as TokenTree (null if not a TokenTree).</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.Token.EndIndex">
            <summary>Returns StartIndex + Length.</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.Token.IsWhitespace">
            <summary>Returns true if Value == <see cref="F:Loyc.Syntax.Lexing.WhitespaceTag.Value"/>.</summary>
        </member>
        <member name="M:Loyc.Syntax.Lexing.Token.Is(System.Int32,System.Object)">
            <summary>Returns true if the specified type and value match this token.</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.Token.ToStringStrategy">
            <summary>Gets or sets the strategy used by <see cref="M:Loyc.Syntax.Lexing.Token.ToString"/>.</summary>
        </member>
        <member name="M:Loyc.Syntax.Lexing.Token.Range(Loyc.Syntax.ISourceFile)">
            <summary>Gets the <see cref="T:Loyc.Syntax.SourceRange"/> of a token, under the 
            assumption that the token came from the specified source file.</summary>
        </member>
        <member name="M:Loyc.Syntax.Lexing.Token.SourceText(Loyc.Collections.ICharSource)">
            <summary>Gets the original source text for a token if available, under the 
            assumption that the specified source file correctly specifies where the
            token came from. If the token is synthetic, returns <see cref="F:Loyc.UString.Null"/>.</summary>
        </member>
        <member name="M:Loyc.Syntax.Lexing.Token.ToString">
            <summary>Reconstructs a string that represents the token, if possible.
            Does not work for whitespace and comments, because the value of these
            token types is stored in the original source file and for performance 
            reasons is not copied to the token.</summary>
            <remarks>
            This does <i>not</i> return the original source text; it uses a language-
            specific stringizer (<see cref="P:Loyc.Syntax.Lexing.Token.ToStringStrategy"/>).
            <para/>
            The returned string, in general, will not match the original
            token, since the <see cref="P:Loyc.Syntax.Lexing.Token.ToStringStrategy"/> does not have access to
            the original source file.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.Lexing.Token.Equals(Loyc.Syntax.Lexing.Token)">
            <summary>Equality depends on TypeInt and Value, but not StartIndex and 
            Length (this is the same equality condition as <see cref="T:Loyc.Syntax.LNode"/>).</summary>
        </member>
        <member name="M:Loyc.Syntax.Lexing.Token.ToLNode(Loyc.Syntax.ISourceFile)">
            <summary>Converts a <see cref="T:Loyc.Syntax.Lexing.Token"/> to a <see cref="T:Loyc.Syntax.LNode"/>.</summary>
            <param name="file">This becomes the <see cref="P:Loyc.Syntax.LNode.Source"/> property.</param>
            <remarks>If you really need to store tokens as LNodes, use this. Only
            the <see cref="P:Loyc.Syntax.Lexing.Token.Kind"/>, not the TypeInt, is preserved. Identifiers 
            (where Kind==TokenKind.Id and Value is Symbol) are translated as Id 
            nodes; everything else is translated as a call, using the TokenKind as
            the <see cref="P:Loyc.Syntax.LNode.Name"/> and the value, if any, as parameters. For
            example, if it has been treeified with <see cref="T:Loyc.Syntax.Lexing.TokensToTree"/>, the
            token list for <c>"Nodes".Substring(1, 3)</c> as parsed by LES might 
            translate to the LNode sequence <c>String("Nodes"), Dot(@@.), 
            Substring, LParam(Number(1), Separator(@@,), Number(3)), RParen()</c>.
            The <see cref="P:Loyc.Syntax.LNode.Range"/> will match the range of the token.
            </remarks>
        </member>
        <member name="T:Loyc.Syntax.Lexing.ISimpleToken`1">
            <summary>Basic information about a token as expected by <see cref="T:Loyc.Syntax.BaseParser`1"/>:
            a token <see cref="P:Loyc.Syntax.Lexing.ISimpleToken`1.Type"/>, which is the type of a "word" in the program 
            (string, identifier, plus sign, etc.), a value (e.g. the name of an 
            identifier), and an index where the token starts in the source file.</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.ISimpleToken`1.Type">
            <summary>The category of the token (integer, keyword, etc.) used as
            the primary value for identifying the token in a parser.</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.ISimpleToken`1.StartIndex">
            <summary>Character index where the token starts in the source file.</summary>
        </member>
        <member name="T:Loyc.Syntax.Lexing.ISimpleToken">
            <summary>Alias for ISimpleToken{int}.</summary>
        </member>
        <member name="T:Loyc.Syntax.Lexing.IToken`1">
            <summary>The methods of <see cref="T:Loyc.Syntax.Lexing.Token"/> in the form of an interface.</summary>
            <typeparam name="TT">Token Type: the data type of the Type property of 
            <see cref="T:Loyc.Syntax.Lexing.ISimpleToken`1"/> (one often uses int).</typeparam>
        </member>
        <member name="T:Loyc.Syntax.Lexing.TokenKind">
            <summary>A list of token categories that most programming languages have.</summary>
            <remarks>
            Some Loyc languages will support the concept of a "token literal" which
            is a <see cref="T:Loyc.Syntax.Lexing.TokenTree"/>, and some DSLs will rely on these token 
            literals for input. However, tokens differ between different languages; 
            for instance the set of operators varies between languages. On the other 
            hand, most languages do have some concept of "an operator" and "an 
            identifier", and the TokenKind reflects this fact.
            <para/>
            When you are using <see cref="T:Loyc.Syntax.Lexing.Token"/> to represent tokens in your language,
            it is recommended to define every value of your "TokenType" enumeration in 
            terms of TokenKind using integer offsets, like this:
            <pre>
            enum MyTokenType {
                EOF         = TokenKind.Spaces,
                Id          = TokenKind.Id,
                IfKeyword   = TokenKind.OtherKeyword,
                ForKeyword  = TokenKind.OtherKeyword + 1,
                LoopKeyword = TokenKind.OtherKeyword + 2,
                ...
                MulOp   = TokenKind.Operator,
                AddOp   = TokenKind.Operator + 1,
                DivOp   = TokenKind.Operator + 2,
                DotOp   = TokenKind.Dot,
                ...
            }
            </pre>
            Using TokenKind is only important if you intend to support DSLs via token
            literals (e.g. LLLPG) in your language.
            <para/>
            A DSL that just needs simple tokens like "strings", "identifiers" and "dots" 
            can write a parser based on values of <see cref="P:Loyc.Syntax.Lexing.Token.Kind"/> alone; if 
            it needs certain specific operators or "keywords" that do not have a 
            dedicated TokenKind, such as + and %, it can further check the Value of the 
            token; meanwhile, the host language put a global <see cref="T:Loyc.Symbol"/> 
            in the <see cref="F:Loyc.Syntax.Lexing.Token.Value"/> to represent operators, keywords and 
            identifiers.
            </remarks>
        </member>
        <member name="F:Loyc.Syntax.Lexing.TokenKind.Other">
            <summary>For token types not covered by other token kinds.</summary>
        </member>
        <member name="F:Loyc.Syntax.Lexing.TokenKind.Comment">
            <summary>Single- and multi-line comments</summary>
            <remarks>Spaces and comments are typically filtered out before parsing and will not appear in token literals.</remarks>
        </member>
        <member name="F:Loyc.Syntax.Lexing.TokenKind.Id">
            <summary>Simple identifiers</summary>
        </member>
        <member name="F:Loyc.Syntax.Lexing.TokenKind.Literal">
            <summary>Literals, such as numbers and strings.</summary>
        </member>
        <member name="F:Loyc.Syntax.Lexing.TokenKind.Dot">
            <summary>Scope operator (dot and dot-like ops such as :: in C++) </summary>
        </member>
        <member name="F:Loyc.Syntax.Lexing.TokenKind.Assignment">
            <summary>Simple or compound assignment</summary>
        </member>
        <member name="F:Loyc.Syntax.Lexing.TokenKind.Operator">
            <summary>All operators except assignment, dot, or separators</summary>
        </member>
        <member name="F:Loyc.Syntax.Lexing.TokenKind.Separator">
            <summary>e.g. semicolon, comma (if not considered an operator)</summary>
        </member>
        <member name="F:Loyc.Syntax.Lexing.TokenKind.AttrKeyword">
            <summary>e.g. public, private, static, virtual</summary>
        </member>
        <member name="F:Loyc.Syntax.Lexing.TokenKind.TypeKeyword">
            <summary>e.g. int, bool, double, void</summary>
        </member>
        <member name="F:Loyc.Syntax.Lexing.TokenKind.OtherKeyword">
            <summary>e.g. sizeof, struct. Does not include literal keywords (true, false, null)</summary>
        </member>
        <member name="F:Loyc.Syntax.Lexing.TokenKind.Spaces">
            <summary>Spaces, tabs, non-semantic newlines, and EOF</summary>
            <remarks>Spaces and comments are typically filtered out before parsing and will not appear in token literals.</remarks>
        </member>
        <member name="F:Loyc.Syntax.Lexing.TokenKind.BracketFlag">
            <summary>Openers and closers all have this bit set.</summary>
        </member>
        <member name="F:Loyc.Syntax.Lexing.TokenKind.CloserFlag">
            <summary>Closers all have this bit set.</summary>
        </member>
        <member name="T:Loyc.Syntax.Lexing.TokensToTree">
            <summary>
            A preprocessor usually inserted between the lexer and parser that converts 
            a token list into a token tree. Everything inside brackets, parens or 
            braces is made a child of the open bracket.
            </summary>
            <remarks>
            The close bracketis not treated as one of the children of the opening bracket.
            </remarks>
        </member>
        <member name="T:Loyc.Syntax.ILNodePrinter">
            <summary>This interface allows serializing <see cref="T:Loyc.Syntax.LNode"/> objects into the
            syntax of a particular programming language.</summary>
            <remarks>The ToString() method of an object that implements this interface should
            return the name of the programming language that it is able to print.</remarks>
        </member>
        <member name="M:Loyc.Syntax.ILNodePrinter.Print(Loyc.Syntax.LNode,System.Text.StringBuilder,Loyc.IMessageSink,Loyc.Syntax.ParsingMode,Loyc.Syntax.ILNodePrinterOptions)">
            <summary>Serializes the specified syntax tree to a StringBuilder in the syntax supported by this object.</summary>
            <param name="node">A syntax tree to print.</param>
            <param name="target">An output buffer, to which output is appended.</param>
            <param name="sink">An object used to print warning and error messages. If 
            this is null, messages are sent to <see cref="P:Loyc.MessageSink.Default"/>.</param>
            <param name="mode">Indicates the context in which the node(s) to be printed 
            should be understood (e.g. is it a statement or an expression?).</param>
            <param name="options">A set of options to control printer behavior. If null,
            an appropriate default set of options should be used. Some languages may
            support additional option interfaces beyond <see cref="T:Loyc.Syntax.ILNodePrinterOptions"/>.</param>
        </member>
        <member name="M:Loyc.Syntax.ILNodePrinter.Print(System.Collections.Generic.IEnumerable{Loyc.Syntax.LNode},System.Text.StringBuilder,Loyc.IMessageSink,Loyc.Syntax.ParsingMode,Loyc.Syntax.ILNodePrinterOptions)">
            <summary>Serializes a list of syntax trees to a StringBuilder in the syntax supported by this object.</summary>
            <param name="nodes">Syntax trees to print.</param>
            <param name="target">An output buffer, to which output is appended.</param>
            <param name="sink">An object used to print warning and error messages. If 
            this is null, messages are sent to <see cref="P:Loyc.MessageSink.Default"/>.</param>
            <param name="mode">Indicates the context in which the node(s) to be printed 
            should be understood (e.g. is it a statement or an expression?).</param>
            <param name="options">A set of options to control printer behavior. If null,
            an appropriate default set of options should be used. Some languages may
            support additional option interfaces beyond <see cref="T:Loyc.Syntax.ILNodePrinterOptions"/>.</param>
            <remarks>Some implementations can simply call <see cref="M:Loyc.Syntax.LNodePrinter.PrintMultiple(Loyc.Syntax.ILNodePrinter,System.Collections.Generic.IEnumerable{Loyc.Syntax.LNode},System.Text.StringBuilder,Loyc.IMessageSink,Loyc.Syntax.ParsingMode,Loyc.Syntax.ILNodePrinterOptions)"/>.</remarks>
        </member>
        <member name="T:Loyc.Syntax.LNodePrinter">
            <summary>Standard extension methods for <see cref="T:Loyc.Syntax.ILNodePrinter"/>.</summary>
        </member>
        <member name="M:Loyc.Syntax.LNodePrinter.Print(Loyc.Syntax.ILNodePrinter,Loyc.Syntax.LNode,Loyc.IMessageSink,Loyc.Syntax.ParsingMode,Loyc.Syntax.ILNodePrinterOptions)">
            <summary>Serializes the specified syntax tree to a string in the 
            syntax supported by the specified <see cref="T:Loyc.Syntax.ILNodePrinter"/>.</summary>
        </member>
        <member name="M:Loyc.Syntax.LNodePrinter.Print(Loyc.Syntax.ILNodePrinter,System.Collections.Generic.IEnumerable{Loyc.Syntax.LNode},Loyc.IMessageSink,Loyc.Syntax.ParsingMode,Loyc.Syntax.ILNodePrinterOptions)">
            <summary>Serializes a list of syntax trees to a string in the 
            syntax supported by the specified <see cref="T:Loyc.Syntax.ILNodePrinter"/>.</summary>
        </member>
        <member name="M:Loyc.Syntax.LNodePrinter.PrintMultiple(Loyc.Syntax.ILNodePrinter,System.Collections.Generic.IEnumerable{Loyc.Syntax.LNode},System.Text.StringBuilder,Loyc.IMessageSink,Loyc.Syntax.ParsingMode,Loyc.Syntax.ILNodePrinterOptions)">
            <summary>Converts a sequences of LNodes to strings, adding a line separator between each.</summary>
            <param name="printer">Printer to be used for each single LNode.</param>
            <remarks>The newline between two nodes is suppressed if the second 
            node has a <c>%appendStatement</c> attribute.</remarks>
        </member>
        <member name="T:Loyc.Syntax.LNodePrinterOptions">
            <summary>A concrete class that users can pass to an <see cref="T:Loyc.Syntax.LNodePrinter"/>.</summary>
        </member>
        <member name="T:Loyc.Syntax.BaseParser`2">
            <summary>
            An base class designed for parsers that use LLLPG (Loyc LL(k) Parser 
            Generator). Note: this is the old (harder to use) base class design. You 
            should use <see cref="T:Loyc.Syntax.BaseParserForList`2"/> instead.
            </summary>
        </member>
        <member name="M:Loyc.Syntax.BaseParser`2.#ctor(Loyc.Syntax.ISourceFile,System.Int32)">
            <summary>Initializes the base class.</summary>
            <param name="file">A source file object that will be returned by the 
            <see cref="P:Loyc.Syntax.BaseParser`2.SourceFile"/> property. By default, this object is used to 
            get the file name, line number and column number shown in parser errors. 
            If your lexer uses <see cref="T:Loyc.Syntax.Lexing.BaseLexer"/> or <see cref="T:Loyc.Syntax.Lexing.LexerSource"/>, 
            you can get this object from the <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.SourceFile"/> 
            property. The <see cref="P:Loyc.Syntax.BaseParser`2.SourceFile"/> property (in this class) will 
            return this value. If this parameter is null, then by default, error 
            messages will only show the character index instead of the file, line 
            number and column number.</param>
            <param name="startIndex">The initial value of <see cref="P:Loyc.Syntax.BaseParser`2.InputPosition"/>.</param>
        </member>
        <member name="F:Loyc.Syntax.BaseParser`2.LogExceptionErrorSink">
            <summary>Throws LogException when it receives an error. Non-errors
            are sent to <see cref="P:Loyc.MessageSink.Default"/>.</summary>
        </member>
        <member name="P:Loyc.Syntax.BaseParser`2.ErrorSink">
            <summary>Gets or sets the object to which error messages are sent. The
            default object is <see cref="F:Loyc.Syntax.BaseParser`2.LogExceptionErrorSink"/>, which throws
            an exception if an error occurs.</summary>
        </member>
        <member name="P:Loyc.Syntax.BaseParser`2.SourceFile">
            <summary>The <see cref="T:Loyc.Syntax.ISourceFile"/> object that was provided to the constructor, if any.</summary>
        </member>
        <member name="P:Loyc.Syntax.BaseParser`2.LT0">
            <summary>Next token to parse (cached; is set to LT(0) whenever InputPosition is changed).</summary>
        </member>
        <member name="P:Loyc.Syntax.BaseParser`2.InputPosition">
            <summary>Current position of the next token to be parsed.</summary>
        </member>
        <member name="M:Loyc.Syntax.BaseParser`2.EofInt">
            <summary>Returns the value used for EOF (normally 0)</summary>
        </member>
        <member name="P:Loyc.Syntax.BaseParser`2.LA0Int">
            <summary>Returns the token type of _lt0 (normally _lt0.TypeInt)</summary>
        </member>
        <member name="M:Loyc.Syntax.BaseParser`2.LT(System.Int32)">
            <summary>Returns the token at lookahead i (e.g. <c>Source[InputPosition + i]</c>
            if the tokens come from a list called Source) </summary>
        </member>
        <member name="M:Loyc.Syntax.BaseParser`2.ToString(`1)">
            <summary>Returns a string representation of the specified token type.
            These strings are used in error messages.</summary>
        </member>
        <member name="M:Loyc.Syntax.BaseParser`2.LaIndexToCharIndex(System.Int32)">
            <summary>Converts a lookahead token index to a character index (used 
            for error reporting).</summary>
            <remarks>
            The default implementation does this by trying to cast 
            <c>LT(lookaheadIndex)</c> to <c>ISimpleToken{MatchType}</c>. Returns -1
            on failure.
            <para/>
            The <c>StartIndex</c> reported by an EOF token is assumed not 
            to be trustworthy (since it is allowed to be a "dummy" token): this 
            method will ensure that the character index returned for EOF is at least 
            as large as <c>SourceFile.Text.Count</c> if a <see cref="P:Loyc.Syntax.BaseParser`2.SourceFile"/> was 
            provided, or, otherwise, at least as large as the last token in the file, 
            by scanning backward to find the last token in the file.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.BaseParser`2.LaIndexToMsgContext(System.Int32)">
            <summary>Converts a lookahead token index to a <see cref="T:Loyc.Syntax.SourceRange"/>
            (or to a string if <see cref="P:Loyc.Syntax.BaseParser`2.SourceFile"/> was initialized to null.)</summary>
            <remarks>The base class can only return a zero-width SourceRange.</remarks>
        </member>
        <member name="M:Loyc.Syntax.BaseParser`2.Error(System.Int32,System.String)">
            <summary>Records an error or throws an exception.</summary>
            <param name="lookaheadIndex">Location of the error relative to the
            current <c>InputPosition</c>. When called by BaseParser, lookaheadIndex 
            is always equal to 0.</param>
            <remarks>
            The default implementation throws a <see cref="T:System.FormatException"/>.
            When overriding this method, you can convert the lookaheadIndex
            to a <see cref="T:Loyc.Syntax.SourcePos"/> using the expression
            <c>SourceFile.IndexToLine(LT(lookaheadIndex).StartIndex)</c>. This only
            works if an <c>ISourceFile</c> object was provided to the constructor of 
            this class, and <c>Token</c> implements <see cref="T:Loyc.Syntax.Lexing.ISimpleToken"/>.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.BaseParser`2.Error(System.Int32,System.String,System.Object[])">
            <inheritdoc cref="M:Loyc.Syntax.BaseParser`2.Error(System.Int32,System.String)"/>
        </member>
        <member name="T:Loyc.Syntax.BaseParser`2.SavePosition">
            <summary>A helper class used by LLLPG for backtracking.</summary>
        </member>
        <member name="M:Loyc.Syntax.BaseParser`2.MatchError(System.Boolean,System.Collections.Generic.IEnumerable{`1})">
            <summary>Handles an error that occurs during Match() or MatchExcept()</summary>
            <param name="inverted">Set inversion flag. If true, then <c>expected</c> is actually a list of things that were NOT expected.</param>
            <param name="expected">List of items that were expected (or unexpected, if <c>inverted</c>)</param>
        </member>
        <member name="T:Loyc.Syntax.BaseParser`1">
            <summary>
            An base class designed for parsers that use LLLPG (Loyc LL(k) Parser 
            Generator). Note: this is the old (harder to use) base class. You should 
            use <see cref="T:Loyc.Syntax.BaseParserForList`2"/> instead. This class is
            now an alias for BaseParser{Token,int}.
            </summary>
        </member>
        <member name="T:Loyc.Syntax.BaseParserForList`3">
            <summary>
            An base class designed for parsers that use LLLPG (Loyc LL(k) Parser 
            Generator) and receive tokens from any <see cref="T:System.Collections.Generic.IEnumerator`1"/>.
            (Potentially also useful for parsers written by hand.)
            </summary>
            <remarks>
            The compiler will ensure that you use this base class correctly. All you 
            have to do is call the base class constructor and override the abstract 
            method <see cref="M:Loyc.Syntax.BaseParserForList`3.ToString(`1)"/>.
            <para/>
            This version of BaseParserForList has <c>List</c> (a token list) as a 
            generic parameter. Compared to using <c>IList{Token}</c> directly, this 
            can increase performance in case the <c>List</c> is a value type (e.g. 
            <c>InternalList&lt;Token></c>).
            </remarks>
            <typeparam name="Token">Data type of complete tokens in the token list. A 
            token contains the type of a "word" in the program (string, identifier, plus 
            sign, etc.), a value (e.g. the name of an identifier), and a range of 
            characters in the source file. See <see cref="T:Loyc.Syntax.Lexing.ISimpleToken`1"/>.
            Note: Token is usually a small struct; this class assumes that it will 
            never be null.</typeparam>
            <typeparam name="MatchType">A data type, usually int, that represents a 
            token type (identifier, operator, etc.) and implements <see cref="T:System.IEquatable`1"/>
            so it can be compared for equality with other token types; this is also the 
            type of the <see cref="P:Loyc.Syntax.Lexing.ISimpleToken`1.Type"/> property. Unfortunately,
            <c>MatchType</c> cannot be an enum because, strangely, an enum does not 
            implement <see cref="T:System.IEquatable`1"/>. So if your token type is an enum, as
            it usually is, set this to <c>int</c> and use <c>matchType: int</c> when you 
            invoke LLLPG: <c>LLLPG(parser(matchType: int, laType: TokenEnum));</c>.</typeparam>
            <typeparam name="List">Data type of the list that contains the tokens (one 
            often uses IList{Token}, but one could use <see cref="T:Loyc.Collections.Impl.InternalList`1"/> 
            for potentially higher performance.)</typeparam>
        </member>
        <member name="M:Loyc.Syntax.BaseParserForList`3.#ctor(`2,`0,Loyc.Syntax.ISourceFile,System.Int32)">
            <summary>Initializes this object to begin parsing the specified tokens.</summary>
            <param name="list">A list of tokens that the derived class will parse.</param>
            <param name="eofToken">A token value to return when the input position 
            reaches the end of the token list. Ideally <c>eofToken.StartIndex</c>
            would contain the position of EOF, but the base class method
            <see cref="M:Loyc.Syntax.BaseParser`2.LaIndexToCharIndex(System.Int32)"/> does not trust this
            value, and will ensure that the character index returned for EOF is at 
            least as large as the character index of the last token in the file. 
            This means that it is safe to set <c>ISimpleToken{MatchType}.StartIndex</c> 
            to 0 in the EOF token, because when an error message involves EOF, the
            base class will find a more accurate EOF position.</param>
            <param name="file">A source file object that will be returned by the 
            <see cref="T:Loyc.Syntax.SourceFile"/> property. By default, this object is used to 
            get the file name, line number and column number shown in parser errors. 
            If your lexer uses <see cref="T:Loyc.Syntax.Lexing.BaseLexer"/> or <see cref="T:Loyc.Syntax.Lexing.LexerSource"/>, 
            you can get this object from the <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.SourceFile"/> 
            property. The <see cref="T:Loyc.Syntax.SourceFile"/> property (in this class) will 
            return this value. If this parameter is null, then by default, error 
            messages will only show the character index instead of the file, line 
            number and column number.</param>
            <param name="startIndex">The initial index from which to start reading
            tokens from the list (normally 0).</param>
        </member>
        <member name="M:Loyc.Syntax.BaseParserForList`3.Reset(`2,`0,Loyc.Syntax.ISourceFile,System.Int32)">
            <summary>Reinitializes the object. This method is called by the constructor.</summary>
            <remarks>See the constructor for documentation of the parameters.</remarks>
        </member>
        <member name="P:Loyc.Syntax.BaseParserForList`3.TokenList">
            <summary>The IList{Token} that was provided to the constructor, if any.</summary>
            <remarks>Note: if you are starting to parse a new source file, you should call 
            <see cref="M:Loyc.Syntax.BaseParserForList`3.Reset(`2,`0,Loyc.Syntax.ISourceFile,System.Int32)"/> instead of setting this property.</remarks>
        </member>
        <member name="M:Loyc.Syntax.BaseParserForList`3.ToString(`1)">
            <summary>Returns a string representation of the specified token type.
            These strings are used in error messages.</summary>
        </member>
        <member name="M:Loyc.Syntax.BaseParserForList`3.Down(`2)">
            <summary>Switches to parsing the specified token list at position zero
            (typically the value of <see cref="P:Loyc.Syntax.Lexing.Token.Children"/> 
            in a token tree produced by <see cref="T:Loyc.Syntax.Lexing.TokensToTree"/>.) The original 
            token list and the original <see cref="P:Loyc.Syntax.BaseParserForList`3.InputPosition"/> are placed on a 
            stack, so you can restore the old list by calling <see cref="M:Loyc.Syntax.BaseParserForList`3.Up"/>.</summary>
            <returns>True if successful, false if <c>children</c> is null.</returns>
        </member>
        <member name="M:Loyc.Syntax.BaseParserForList`3.Up">
            <summary>Returns to the old token list saved by <see cref="M:Loyc.Syntax.BaseParserForList`3.Down(`2)"/>.</summary>
        </member>
        <member name="M:Loyc.Syntax.BaseParserForList`3.Up``1(``0)">
            <summary>Calls <see cref="M:Loyc.Syntax.BaseParserForList`3.Up"/> and returns <c>value</c>.</summary>
        </member>
        <member name="T:Loyc.Syntax.BaseParserForList`2">
            <summary>
            An base class designed for parsers that use LLLPG (Loyc LL(k) Parser 
            Generator) and receive tokens from any <see cref="T:System.Collections.Generic.IEnumerator`1"/>.
            </summary>
            <remarks>
            This base class for LLLPG parsers reads tokens from <see cref="T:System.Collections.Generic.IList`1"/>,
            but you can also pass an <see cref="T:System.Collections.Generic.IEnumerable`1"/> or 
            <see cref="T:System.Collections.Generic.IEnumerator`1"/> to the constructor and it will 
            convert it to a list, lazily, using <see cref="T:Loyc.Collections.BufferedSequence`1"/>.
            <para/>
            Please see additional documentation in the base class.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.BaseParserForList`2.#ctor(System.Collections.Generic.IList{`0},`0,Loyc.Syntax.ISourceFile,System.Int32)">
            <inheridoc/>
        </member>
        <member name="M:Loyc.Syntax.BaseParserForList`2.#ctor(System.Collections.Generic.IEnumerable{`0},`0,Loyc.Syntax.ISourceFile,System.Int32)">
            <inheridoc/>
        </member>
        <member name="M:Loyc.Syntax.BaseParserForList`2.#ctor(System.Collections.Generic.IEnumerator{`0},`0,Loyc.Syntax.ISourceFile,System.Int32)">
            <inheridoc/>
        </member>
        <member name="T:Loyc.Syntax.BaseParserNoBacktracking`2">
            <summary>
            An base class designed for parsers that use LLLPG (Loyc LL(k) Parser 
            Generator) and receive tokens from any <see cref="T:System.Collections.Generic.IEnumerator`1"/>.
            </summary>
            <remarks>
            This base class for LLLPG parsers simply requires an enumerator to work,
            and it has a small buffer to hold lookahead tokens. Old tokens are 
            forgotten, so this base class does not support backtracking (i.e. syntactic 
            predicates), but it can save memory. Please use <see cref="T:Loyc.Syntax.BaseParserForList`2"/> 
            if your input sequence comes in the form of a list.
            <para/>
            This version of BaseParser has Enumerator as a generic parameter. Compared 
            to using IEnumerator{Token} directly, this can increase performance in case 
            Enumerator is a value type (e.g. <c>List&lt;Token>.Enumerator</c>).
            <para/>
            (I wrote this class by mistake... I actually forgot about backtracking!)
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.BaseParserNoBacktracking`2.#ctor(`1,`0,Loyc.Syntax.ISourceFile,System.Int32)">
            <summary>Initializes this object to begin parsing the specified tokens.</summary>
            <param name="sequence">A list of tokens to be parsed.</param>
            <param name="eofToken">A token value to return when the input position 
            reaches the end of the token list.</param>
            <param name="file">A source file object that will be returned by the <see cref="T:Loyc.Syntax.SourceFile"/>
            property. By default, this object is used to get the file name, line 
            number and column number shown in parser errors. If you are using 
            <see cref="T:Loyc.Syntax.Lexing.BaseLexer"/>, you can get this object from the
            <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.SourceFile"/> property. The <see cref="T:Loyc.Syntax.SourceFile"/>.
            property (in this class) will return this value. It can be null, which
            means that default error messages will show the character index instead
            of the file, line number and column number.</param>
            <param name="startIndex">The initial value of the InputPosition property.
            This is informational only, and has no effect on the behavior of this 
            class.</param>
        </member>
        <member name="M:Loyc.Syntax.BaseParserNoBacktracking`2.LT(System.Int32)">
            <summary>Returns the Token at lookahead i, where 0 is the next token.
            This class does not support negative lookahead because old tokens from 
            the IEnumerator are discarded.</summary>
        </member>
        <member name="M:Loyc.Syntax.BaseParserNoBacktracking`2.ToString(System.Int32)">
            <summary>Returns a string representation of the specified token type.
            These strings are used in error messages.</summary>
        </member>
        <member name="P:Loyc.Syntax.BaseParserNoBacktracking`2.InputPosition">
            <summary>Cumulative index of the next token to be parsed.</summary>
            <remarks>This class doesn't care what the absolute InputPosition is, 
            since it reads from an <see cref="T:System.Collections.Generic.IEnumerator`1"/>. This property
            is constrained to always increase, since old tokens are forgotten.</remarks>
        </member>
        <member name="T:Loyc.Syntax.BaseParserNoBacktracking`1">
            <summary>
            An base class designed for parsers that use LLLPG (Loyc LL(k) Parser 
            Generator) and receive tokens from an <see cref="T:System.Collections.Generic.IEnumerator`1"/>.
            </summary>
            <seealso cref="T:Loyc.Syntax.BaseParserNoBacktracking`2"/>
        </member>
        <member name="T:Loyc.Syntax.CodeSymbols">
            <summary>
            A list of common symbols that have special meaning somewhere in Loyc or EC#:
            operators, built-in data types, keywords, trivia, etc.
            </summary>
            <remarks>
            Code that can use symbol forms directly, such as "'!=", tends to be very compact.
            The symbols in this class tend to be abbreviated in order to make usages of this 
            class more compact (e.g. <see cref="F:Loyc.Syntax.CodeSymbols.NotEq"/> is short like its corresponding 
            symbol "'!="). In C# one can access these symbols more easily with 
            <c>using static Loyc.Syntax.CodeSymbols</c> or with
            <c>using S = Loyc.Syntax.CodeSymbols</c> as the Loyc codebase does.
            <para/>
            Some symbols have an alternate name that starts with an underscore. For example,
            <c>_Negate</c> represents the unary minus operator, but in fact it is the same
            symbol as the subtraction operator <c>Sub</c>, <c>'-</c>.
            </remarks>
        </member>
        <member name="F:Loyc.Syntax.CodeSymbols.AltList">
            <summary># is used for lists of things in definition constructs, e.g. 
                <c>#class(Derived, #(Base, IEnumerable), {...})</c>.
            For a time, 'tuple was used for this purpose; the problem is that a
            find-and-replace operation intended to find run-time tuples could 
            accidentally match one of these lists. So I decided to dedicate # 
            for use inside special constructs; its meaning depends on context.
            </summary>
        </member>
        <member name="F:Loyc.Syntax.CodeSymbols.BadCode">
            <summary>An identifier or call with this Name indicates that parsing or 
            analysis failed earlier and that an error message has already been 
            printed.</summary>
            <remarks>When code in a compiler sees this symbol it should be seen as
            a signal to avoid printing further error messages that involve the same
            node. Typically, a node named #badCode should replace the bad code, and 
            it may have an argument that describes the error, which could be printed 
            at runtime if compilation continues to completion.</remarks>
            <example>#badCode("Argument 2: Cannot convert 'string' to 'int'.")</example>
        </member>
        <member name="F:Loyc.Syntax.CodeSymbols.Internal">
            <summary>Provides general access within a library or program (implies
            #protected_in).</summary>
        </member>
        <member name="F:Loyc.Syntax.CodeSymbols.Public">
            <summary>Provides general access, even outside the assembly (i.e. 
            dynamic-link library). Implies #internal, #protectedIn and #protected.</summary>
        </member>
        <member name="F:Loyc.Syntax.CodeSymbols.ProtectedIn">
            <summary>Provides access to derived classes only within the same library
            or program (i.e. assembly). There is no C# equivalent to this keyword,
            which does not provide access outside the assembly.</summary>
        </member>
        <member name="F:Loyc.Syntax.CodeSymbols.Protected">
            <summary>Provides access to all derived classes. Implies #protected_in.
            #protected #internal corresponds to C# "protected internal"</summary>
        </member>
        <member name="F:Loyc.Syntax.CodeSymbols.Private">
            <summary>Revokes access outside the same space and nested spaces. This 
            can be used in spaces in which the default is not private to request
            private as a starting point. Therefore, other flags (e.g. #protected_ex)
            can be added to this flag to indicate what access the user wants to
            provide instead.
            </summary><remarks>
            The name #private may be slightly confusing, since a symbol marked 
            #private is not actually private when there are other access markers
            included at the same time. I considered calling it #revoke instead,
            since its purpose is to revoke the default access modifiers of the
            space, but I was concerned that someone might want to reserve #revoke 
            for some other purpose.
            </remarks>
        </member>
        <member name="F:Loyc.Syntax.CodeSymbols.FilePrivate">
            <summary>Used with #alias to indicate that an alias is local to the
            current source file. <c>[#filePrivate] #alias(X = Y, #())</c> is the long
            form of <c>using X = Y</c> in EC#.</summary>
        </member>
        <member name="F:Loyc.Syntax.CodeSymbols.TriviaWordAttribute">
            "%wordAttribute": in EC#, this trivia is placed on an identifier treated as an attribute (e.g. partial, async).
        </member>
        <member name="F:Loyc.Syntax.CodeSymbols.RawText">
            #rawText must be a call with a single literal argument. The Value of
            the argument is converted to a string and printed out by EcsNodePrinter 
            without any filtering, e.g. `#rawText("Hello")` is printed `Hello`.
        </member>
        <member name="M:Loyc.Syntax.CodeSymbols.IsArrayKeyword(Loyc.Symbol)">
            <summary>Returns true if the symbol is a pair of square brackets with 
            zero or more commas inside, e.g. "[,]", which in EC# represents an array 
            type of a specific number of dimensions.</summary>
        </member>
        <member name="M:Loyc.Syntax.CodeSymbols.CountArrayDimensions(Loyc.Symbol)">
            <summary>Returns the rank of an array symbol when <see cref="M:Loyc.Syntax.CodeSymbols.IsArrayKeyword(Loyc.Symbol)"/> 
            is true, or 0 if the symbol does not represent an array type.</summary>
        </member>
        <member name="M:Loyc.Syntax.CodeSymbols.GetArrayKeyword(System.Int32)">
            <summary>Gets the Symbol for an array with the specified number of 
            dimensions, e.g. <c>GetArrayKeyword(3)</c> returns <c>[,,]</c>.</summary>
        </member>
        <member name="T:Loyc.Syntax.IParsingService">
            <summary>An interface that encapsulates the lexer and parser of a 
            programming language, or a non-programming language that can be 
            represented by Loyc trees.</summary>
            <remarks>
            The simplest way to parse code is with the extension method 
            <c>Parse(string, IMessageSink msgs = null, Symbol inputType = null)</c>.
            The simplest way to print is with <c>Print(LNode, IMessageSink)</c>
            <para/>
            The ToString() method should return a string that indicates the 
            programming language represented by this object, e.g. "Enhanced C#".
            </remarks>
            <seealso cref="T:Loyc.Syntax.ParsingService"/>
        </member>
        <member name="P:Loyc.Syntax.IParsingService.FileExtensions">
            <summary>Standard file extensions for this language, without leading 
            dots, with the first one being the most common.</summary>
        </member>
        <member name="P:Loyc.Syntax.IParsingService.HasTokenizer">
            <summary>Returns true if the <see cref="M:Loyc.Syntax.IParsingService.Tokenize(Loyc.Collections.ICharSource,System.String,Loyc.IMessageSink)"/> method is available.</summary>
        </member>
        <member name="P:Loyc.Syntax.IParsingService.CanPreserveComments">
            <summary>Returns true if the parser supports preserving comments.</summary>
        </member>
        <member name="M:Loyc.Syntax.IParsingService.Tokenize(Loyc.Collections.ICharSource,System.String,Loyc.IMessageSink)">
            <summary>Returns a lexer that is configured to begin reading the specified file.</summary>
            <param name="text">Text to be tokenized (e.g. <see cref="T:Loyc.UString"/>)</param>
            <param name="fileName">File name to be associated with any errors that occur.</param>
            <param name="msgs">Error messages are sent to this object.</param>
            <remarks>
            The returned lexer should be a "simple" tokenizer. If the language uses 
            tree lexing (in which tokens are grouped by parentheses and braces),
            the returned lexer should NOT include the grouping process.
            <para/>
            It is recommended that the implementation of this method filter out 
            spaces (for best performance) but not comments or newlines. 
            If there is a preprocessor, it should not run.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.IParsingService.Parse(Loyc.Collections.ICharSource,System.String,Loyc.IMessageSink,Loyc.Syntax.ParsingMode,System.Boolean)">
            <summary>Parses a source file into one or more Loyc trees.</summary>
            <param name="text">input file or string.</param>
            <param name="fileName">A file name to associate with errors, warnings, and output nodes.</param>
            <param name="msgs">Error and warning messages are sent to this object.</param>
            <param name="mode">Indicates the kind of input, e.g. <c>File</c> 
            (an entire source file), <c>FormalArguments</c> (function parameter list), etc. 
            <c>null</c> is a synonym for <c>File</c>.</param>
            <param name="preserveComments">Whether to preserve comments and newlines 
            by attaching trivia attributes to the output. If the property
            <see cref="P:Loyc.Syntax.IParsingService.CanPreserveComments"/> is false, this parameter will not work.</param>
        </member>
        <member name="M:Loyc.Syntax.IParsingService.Parse(Loyc.Syntax.Lexing.ILexer{Loyc.Syntax.Lexing.Token},Loyc.IMessageSink,Loyc.Syntax.ParsingMode,System.Boolean)">
            <summary>If <see cref="P:Loyc.Syntax.IParsingService.HasTokenizer"/> is true, this method accepts a 
            lexer returned by Tokenize() and begins parsing.</summary>
            <param name="input">A source of tokens.</param>
            <param name="msgs">Error and warning messages are sent to this object. 
            If this parameter is null, messages should be sent to <see cref="P:Loyc.MessageSink.Default"/>.</param>
            <param name="mode">Indicates how the input should be parsed.
            <c>null</c> is a synonym for <see cref="F:Loyc.Syntax.ParsingMode.File"/></param>
            <param name="preserveComments">Whether to preserve comments and newlines 
            by attaching trivia attributes to the output. If the property
            <see cref="P:Loyc.Syntax.IParsingService.CanPreserveComments"/> is false, this parameter will not work.</param>
            <exception cref="T:System.NotSupportedException"><see cref="P:Loyc.Syntax.IParsingService.HasTokenizer"/> is false.</exception>
            <remarks>
            This method adds any preprocessing steps to the lexer (tree-ification 
            or token preprocessing) that are required by this language before it 
            sends the results to the parser. If possible, the output is computed 
            lazily.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.IParsingService.Parse(Loyc.Collections.IListSource{Loyc.Syntax.Lexing.Token},Loyc.Syntax.ISourceFile,Loyc.IMessageSink,Loyc.Syntax.ParsingMode)">
            <summary>Parses a token tree, such as one that came from a token literal.</summary>
            <param name="tokens">List of tokens</param>
            <param name="file">A source file to associate with errors, warnings, and output nodes.</param>
            <param name="msgs">Error and warning messages are sent to this object.
            If this parameter is null, messages should be sent to <see cref="P:Loyc.MessageSink.Default"/>.</param>
            <param name="inputType">Indicates how the input should be parsed.</param>
            <remarks>
            Some languages may offer token literals, which are stored as token trees
            that can be processed by "macros" or compiler plugins. A macro may wish 
            to parse some of the token literal using the host language's parser 
            (e.g. LLLPG needs to do this), so this method is provided for that 
            purpose.
            </remarks>
            <exception cref="T:System.NotSupportedException">This feature is not supported 
            by this parsing service.</exception>
        </member>
        <member name="T:Loyc.Syntax.ParsingService">
            <summary>Standard extension methods for <see cref="T:Loyc.Syntax.IParsingService"/>.</summary>
        </member>
        <member name="P:Loyc.Syntax.ParsingService.Default">
            <summary>Gets or sets the default language service on this thread. If 
            no service has been assigned on this thread, returns <see cref="F:Loyc.Syntax.Les.Les2LanguageService.Value"/>.</summary>
        </member>
        <member name="P:Loyc.Syntax.ParsingService.RegisteredLanguages">
            <summary>Dictionary of registered parsing services, keyed by file extension 
            (without leading dots). The default dictionary contains one pair: 
            <c>("les", LesLanguageService.Value)</c></summary>
        </member>
        <member name="M:Loyc.Syntax.ParsingService.Register(Loyc.Syntax.IParsingService,System.Collections.Generic.IEnumerable{System.String})">
            <summary>Registers a parsing service.</summary>
            <param name="service">Service to register.</param>
            <param name="fileExtensions">File extensions affected (null to use the service's own list)</param>
            <returns>The number of new file extensions registered, or 0 if none.</returns>
            <remarks>This method does not replace existing registrations.</remarks>
        </member>
        <member name="M:Loyc.Syntax.ParsingService.Unregister(Loyc.Syntax.IParsingService,System.Collections.Generic.IEnumerable{System.String})">
            <summary>Unregisters a language service.</summary>
            <param name="service">Service to unregister</param>
            <param name="fileExtensions">File extensions affected (null to use the service's own list)</param>
            <returns>The number of file extensions unregistered, or 0 if none.</returns>
            <remarks>The service for a file extension is not removed unless the given service reference is equal to the registered service.</remarks>
        </member>
        <member name="M:Loyc.Syntax.ParsingService.GetServiceForFileName(System.String)">
            <summary>Finds the language service associated with the longest matching registered file extension.</summary>
            <remarks>Returns null if there is no registered language service for the filename's extension.</remarks>
        </member>
        <member name="M:Loyc.Syntax.ParsingService.PushCurrent(Loyc.Syntax.IParsingService)">
            <summary>Sets the current language service, returning a value suitable 
            for use in a C# using statement, which will restore the old service.</summary>
            <param name="newValue">new value of Current</param>
            <example><code>
            LNode code;
            using (var old = ParsingService.PushCurrent(LesLanguageService.Value))
                code = ParsingService.Current.ParseSingle("This `is` LES_code;");
            </code></example>
        </member>
        <member name="T:Loyc.Syntax.ParsingService.PushedCurrent">
            <summary>Returned by <see cref="M:Loyc.Syntax.ParsingService.PushCurrent(Loyc.Syntax.IParsingService)"/>.</summary>
        </member>
        <member name="M:Loyc.Syntax.ParsingService.Tokenize(Loyc.Syntax.IParsingService,Loyc.UString,Loyc.IMessageSink)">
            <summary>Parses a string by invoking <see cref="M:Loyc.Syntax.IParsingService.Tokenize(Loyc.Collections.ICharSource,System.String,Loyc.IMessageSink)"/> using an empty string as the file name.</summary>
        </member>
        <member name="M:Loyc.Syntax.ParsingService.Parse(Loyc.Syntax.IParsingService,Loyc.UString,Loyc.IMessageSink,Loyc.Syntax.ParsingMode,System.Boolean)">
            <summary>Parses a string by invoking <see cref="M:Loyc.Syntax.IParsingService.Parse(Loyc.Collections.ICharSource,System.String,Loyc.IMessageSink,Loyc.Syntax.ParsingMode,System.Boolean)"/> using an empty string as the file name.</summary>
        </member>
        <member name="M:Loyc.Syntax.ParsingService.ParseSingle(Loyc.Syntax.IParsingService,Loyc.UString,Loyc.IMessageSink,Loyc.Syntax.ParsingMode,System.Boolean)">
            <summary>Parses a string and expects exactly one output.</summary>
            <exception cref="T:System.InvalidOperationException">The output list was empty or contained multiple nodes.</exception>
        </member>
        <member name="M:Loyc.Syntax.ParsingService.ParseSingle(Loyc.Syntax.IParsingService,Loyc.Collections.ICharSource,System.String,Loyc.IMessageSink,Loyc.Syntax.ParsingMode,System.Boolean)">
            <summary>Parses a string and expects exactly one output.</summary>
            <exception cref="T:System.InvalidOperationException">The output list was empty or contained multiple nodes.</exception>
        </member>
        <member name="M:Loyc.Syntax.ParsingService.Parse(Loyc.Syntax.IParsingService,System.IO.Stream,System.String,Loyc.Syntax.ParsingMode,Loyc.IMessageSink,System.Boolean)">
            <summary>Parses a Stream.</summary>
        </member>
        <member name="M:Loyc.Syntax.ParsingService.Tokenize(Loyc.Syntax.IParsingService,System.IO.Stream,System.String,Loyc.IMessageSink)">
            <summary>Parses a Stream.</summary>
        </member>
        <member name="M:Loyc.Syntax.ParsingService.ParseFile(Loyc.Syntax.IParsingService,System.String,Loyc.IMessageSink,Loyc.Syntax.ParsingMode,System.Boolean)">
            <summary>Opens the specified file, parses the entire file, and closes the file.</summary>
        </member>
        <member name="M:Loyc.Syntax.ParsingService.TokenizeFile(Loyc.Syntax.IParsingService,System.String,Loyc.IMessageSink)">
            <summary>Opens the specified file and tokenizes it.</summary>
        </member>
        <member name="T:Loyc.Syntax.IdNode">
            <summary>Base class of all nodes that represent simple identifiers (including special symbols such as #foo).</summary>
        </member>
        <member name="T:Loyc.Syntax.LiteralNode">
            <summary>Base class of all nodes that represent literal values such as 123 and "foo".</summary>
        </member>
        <member name="T:Loyc.Syntax.CallNode">
            <summary>Base class of all nodes that represent calls such as <c>f(x)</c>, 
            operator calls such as <c>x + y</c>, braced blocks, and all other things 
            that are not simple symbols and literals.</summary>
        </member>
        <member name="T:Loyc.Syntax.NodeScanMode">
            <summary>Specifies which children to enumerate when calling <see cref="M:Loyc.Syntax.LNode.Descendants(Loyc.Syntax.NodeScanMode)"/>().</summary>
            <remarks>TODO code review</remarks>
        </member>
        <member name="T:Loyc.Syntax.DescendantsFrame">
            <summary>Helper class used to enumerate <see cref="M:Loyc.Syntax.LNode.Descendants(Loyc.Syntax.NodeScanMode)"/>().</summary>
            <remarks>TODO code review</remarks>
        </member>
        <member name="T:Loyc.Syntax.LNode">
             <summary>All nodes in a Loyc syntax tree share this base class.</summary>
             <remarks>
             Loyc defines only three types of nodes: simple symbols, literals, and calls.
             <ul>
             <li>A <see cref="T:Loyc.Syntax.IdNode"/> is a simple identifier, such as a VariableName</li>
             <li>A <see cref="T:Loyc.Syntax.LiteralNode"/> is a literal constant, such as 123 or "hello"</li>
             <li>A <see cref="T:Loyc.Syntax.CallNode"/> encompasses all other kinds of nodes, such as
             normal function calls like <c>f(x)</c>, generic specifications like <c>f&lt;x></c>
             (represented as <c>@'of(f, x)</c>), braced blocks of statements (represented as
             <c>@`'{}`(stmt1, stmt2, ...)</c>), and so on.</li>
             </ul>
             See http://loyc.net/loyc-trees to learn more about the Loyc tree concept.
             <para/>
             This class provides access to all properties of all three types of nodes,
             in order to make this class easier to access from plain C#, and to avoid
             unnecessary downcasting in some cases. In fact, you never need to use the
             derived classes; you can think of them simply as a way of optimizing the
             implementation.
             <para/>
             Loyc nodes are always immutable.
            
             <h3>Important properties</h3>
             
             The main properties of a node are
             <ol>
             <li><see cref="P:Loyc.Syntax.LNode.Attrs"/>: holds the attributes of the node, if any.</li>
             <li><see cref="P:Loyc.Syntax.LNode.Name"/>: the name of an <see cref="T:Loyc.Syntax.IdNode"/>, or the name 
                of the <see cref="T:Loyc.Syntax.IdNode"/> that is acting as the <see cref="P:Loyc.Syntax.LNode.Target"/> 
                of a <see cref="T:Loyc.Syntax.CallNode"/>.</li>
             <li><see cref="P:Loyc.Syntax.LNode.Value"/>: the value of a <see cref="T:Loyc.Syntax.LiteralNode"/>.</li>
             <li><see cref="P:Loyc.Syntax.LNode.Target"/>: the target of a <see cref="T:Loyc.Syntax.CallNode"/>. It 
                represents a method, macro, or special identifier that is being called.</li>
             <li><see cref="P:Loyc.Syntax.LNode.Args"/>: holds the arguments to a <see cref="T:Loyc.Syntax.CallNode"/>,
                if any. Returns an empty list if the node does not have an argument list.</li>
             <li><see cref="P:Loyc.Syntax.LNode.Range"/>: indicates the source file that the node came from
                and location in that source file.</li>
             <li><see cref="P:Loyc.Syntax.LNode.Style"/>: an 8-bit flag value that is used as a hint to the
                node printer about how the node should be printed. For example, a hex
                literal like 0x10 has the <see cref="F:Loyc.Syntax.NodeStyle.Alternate"/> style to
                distinguish it from decimal literals such as 16. Custom display styles 
                that do not fit in the Style property can be expressed with attributes.</li>
             </ol>
             To learn more about working with LNode, see http://loyc.net/loyc-trees/dotnet.html
             </remarks>
        </member>
        <member name="F:Loyc.Syntax.LNode.Missing">
            <summary>The empty identifier, used to represent missing information.</summary>
        </member>
        <member name="F:Loyc.Syntax.LNode.InParensTrivia">
            <summary>Used by the <c>quote {...}</c> macro.</summary>
        </member>
        <member name="P:Loyc.Syntax.LNode.Range">
            <summary>Returns the location and range in source code of this node.</summary>
            <remarks>
            A parser should record a sufficiently wide range for each parent node, 
            such that all children are fully contained within the range. However, 
            this is not an invariant; macros can splice together syntax trees from 
            different source files or add synthetic nodes, so that the parent range
            does not necessarily include all child ranges. (In fact, in general it 
            is impossible to ensure that parent ranges include child ranges because
            a parent can only specify a single source file, while children can come
            from several source files.)
            </remarks>
        </member>
        <member name="P:Loyc.Syntax.LNode.Source">
            <summary>Returns the source file (shortcut for <c><see cref="P:Loyc.Syntax.LNode.Range"/>.Source</c>).</summary>
        </member>
        <member name="P:Loyc.Syntax.LNode.Loyc#IHasLocation#Location">
            <summary>Returns Range.</summary>
        </member>
        <member name="P:Loyc.Syntax.LNode.Style">
            <summary>Indicates the preferred style to use when printing the node to a text string.</summary>
            <remarks>
            The Style is an 8-bit value that acts as a hint to the node printer about 
            how the node should be printed. Custom display styles that do not fit in 
            the Style property can be expressed with special "trivia" attributes that 
            have a <see cref="P:Loyc.Syntax.LNode.Name"/> starting with <c>%</c>. (trivia attributes, which
            are also used to store comments in the syntax tree, are not printed like
            normal attributes and are normally ignored if the node printer does not 
            specifically recognize them.)
            </remarks>
        </member>
        <member name="P:Loyc.Syntax.LNode.Attrs">
            <summary>Returns the attribute list for this node.</summary>
        </member>
        <member name="P:Loyc.Syntax.LNode.IsFrozen">
            <summary>Returns true if the node is immutable, and false if any part of it can be edited.
            Currently, mutable nodes are not implemented.</summary>
            <remarks>Debugger-hidden until such time as mutable nodes actually exist.</remarks>
        </member>
        <member name="P:Loyc.Syntax.LNode.Kind">
            <summary>Returns the <see cref="T:Loyc.Syntax.LNodeKind"/>: Symbol, Literal, or Call.</summary>
        </member>
        <member name="P:Loyc.Syntax.LNode.Name">
            <summary>Returns the Symbol if <see cref="P:Loyc.Syntax.LNode.IsId"/>. If this node is 
            a call (<see cref="P:Loyc.Syntax.LNode.IsCall"/>) and <c>Target.IsId</c> is true, 
            this property returns <c>Target.Name</c>. In all other cases, the name
            is <see cref="F:Loyc.GSymbol.Empty"/>. Shall not return null.</summary>
            <remarks>Examples (using C#/LES syntax):
            <pre>
            Expression   Kind    Name (blank if empty)
            hello        Id      hello
            @#if         Id      #if
            Foo(x, y)    Call    Foo
            x += y       Call    +=
            x.Foo(y)     Call    
            5.0          Literal 
            </pre>
            </remarks>
        </member>
        <member name="P:Loyc.Syntax.LNode.HasSpecialName">
            <summary>Returns true if <see cref="P:Loyc.Syntax.LNode.Name"/> is a "special" name 
            (i.e. starts with '#' or '\'' or '.' or any character below 48 in ASCII).</summary>
            <remarks>Note that this property returns false for the empty identifier <c>@``</c>.</remarks>
        </member>
        <member name="M:Loyc.Syntax.LNode.IsSpecialName(System.String)">
            <summary>Returns true if <c>name</c> is considered a "special" name that
            starts with any character below 48 in ASCII, such as '#', '\'', and '.'.</summary>
            <remarks>
            This returns false for the empty string or null. 
            <para/>
            In order to keep the check trivially simple, this returns true for '$'
            even though it is <i>not</i> special in some languages (e.g. JavaScript).
            <para/>
            Letters, underscores, digits, and some punctuation do not count as special.
            The full list of specials is <c>! " # $ % &amp; ' ( ) * + , - . /</c> plus
            the space character and the control characters.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.LNode.WithName(Loyc.Symbol)">
            <summary>Creates a node with a new value for Name.</summary>
            <remarks>If IsId, the Name is simply changed. If <see cref="P:Loyc.Syntax.LNode.IsCall"/>, 
            this method returns the equivalent of <c>WithTarget(Target.WithName(name))</c>
            (which may be optimized for the particular call type). If <see 
            cref="P:Loyc.Syntax.LNode.IsLiteral"/>, the <see cref="P:Loyc.Syntax.LNode.Kind"/> changes to <see cref="F:Loyc.Syntax.LNodeKind.Id"/> in
            order to set the name.</remarks>
        </member>
        <member name="P:Loyc.Syntax.LNode.Value">
            <summary>Returns the value of a literal node, or <see cref="F:Loyc.NoValue.Value"/> 
            if this node is not a literal (<see cref="P:Loyc.Syntax.LNode.IsLiteral"/> is false).</summary>
        </member>
        <member name="M:Loyc.Syntax.LNode.WithValue(System.Object)">
            <summary>Creates a new literal node with a different Value than the current literal node.</summary>
            <exception cref="T:System.InvalidOperationException">The node was not a literal already.</exception>
        </member>
        <member name="P:Loyc.Syntax.LNode.Target">
            <summary>Returns the target of a method call, or null if <see cref="P:Loyc.Syntax.LNode.IsCall"/> 
            is false. The target can be a symbol with no name (<see cref="F:Loyc.GSymbol.Empty"/>)
            to represent a parenthesized expression, if there is one argument.</summary>
        </member>
        <member name="P:Loyc.Syntax.LNode.Args">
            <summary>Returns the argument list of this node. Always empty when <c><see cref="P:Loyc.Syntax.LNode.IsCall"/>==false</c>.</summary>
            <remarks>
            Depending on the <see cref="P:Loyc.Syntax.LNode.Target"/>, Args may represent an actual 
            argument list, or it may represent some other kind of list. For 
            example, if the target is "{}" then Args represents a list of 
            statements in a braced block, and if the target is ">=" then Args 
            represents the two arguments to the ">=" operator.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.LNode.WithArgs(Loyc.Collections.VList{Loyc.Syntax.LNode})">
            <summary>Creates a Node with a new argument list. If this node is not a 
            call, a new node is created using this node as its target. Otherwise,
            the existing argument list is replaced.</summary>
            <param name="args">New argument list</param>
        </member>
        <member name="M:Loyc.Syntax.LNode.With(Loyc.Syntax.LNode,Loyc.Collections.VList{Loyc.Syntax.LNode})">
            <summary>Creates a <see cref="T:Loyc.Syntax.CallNode"/> with the same attributes and 
            <see cref="P:Loyc.Syntax.LNode.Range"/>, but a different target and argument list. If the 
            current node is not a CallNode, it becomes one (the Range, Style and 
            attributes of the current node are kept, but the Kind, Value, and 
            Name are discarded.)</summary>
        </member>
        <member name="M:Loyc.Syntax.LNode.With(Loyc.Symbol,Loyc.Collections.VList{Loyc.Syntax.LNode})">
            <summary>Creates a <see cref="T:Loyc.Syntax.CallNode"/> with the same attributes and 
            <see cref="P:Loyc.Syntax.LNode.Range"/>, but a different target and argument list. If the 
            current node is not a CallNode, it becomes one (the Range, Style and 
            attributes of the current node are kept, but the Kind, Value, and 
            Name are discarded.)</summary>
        </member>
        <member name="M:Loyc.Syntax.LNode.Clone">
            <summary>Creates a copy of the node. Since nodes are immutable, there 
            is little reason for an end-user to call this, but Clone() is used 
            internally as a helper method by the WithXyz() methods.</summary>
        </member>
        <member name="P:Loyc.Syntax.LNode.Printer">
            <summary>Gets or sets the default node printer on the current thread,
            which controls how nodes are serialized to text by default.</summary>
            <remarks>The LES printer is the default, and will be used if you try
            to set this property to null.</remarks>
        </member>
        <member name="M:Loyc.Syntax.LNode.PushPrinter(Loyc.Syntax.ILNodePrinter)">
            <summary>Helps you change printers temporarily. Usage in C#: 
            <c>using (LNode.PushPrinter(myPrinter)) { ... }</c></summary>
            <remarks>For example, to switch to the EC# printer, use
            <c>using (LNode.PushPrinter(EcsNodePrinter.Printer)) { ... }</c>.
            This changes the default printer. If you don't want to change the
            default printer, please invoke the printer directly: 
            <code>
                var sb = new StringBuilder();
                EcsNodePrinter.Printer(node, sb, MessageSink.Trace);
            </code>
            </remarks>
        </member>
        <member name="T:Loyc.Syntax.LNode.PushedPrinter">
            <summary>Returned by <see cref="M:Loyc.Syntax.LNode.PushPrinter(Loyc.Syntax.ILNodePrinter)"/>.</summary>
        </member>
        <member name="P:Loyc.Syntax.LNode.TriviaValue">
            <summary>Gets the value of <c>Args[0].Value</c>, if Args[0] exists; 
            otherwise, returns <see cref="F:Loyc.NoValue.Value"/>.</summary>
            <remarks>"Trivia nodes" are used to efficiently represent the value of
            trivia and non-tree <see cref="T:Loyc.Syntax.Lexing.Token"/>s; they can be created by 
            calling the <see cref="M:Loyc.Syntax.LNode.Trivia(Loyc.Symbol,System.Object,Loyc.Syntax.LNode)"/> function. Since an LNode is not 
            allowed to have both a Name and a Value (as there is no syntax in LES 
            or EC# for such a node), a trivia node pretends that there is an 
            argument list with one item, and that one item is always a literal 
            whose Value is the value stored in the trivia node. Thus, a token node 
            is printed out as <c>TokenType(Value)</c> where <c>Value</c> is some 
            literal.
            <para/>
            If you suspect you're dealing with a trivia node, it is wasteful to 
            actually call <c>node.Args[0].Value</c> since this causes a temporary
            token list to be allocated. Instead you should use this property, which
            returns the token value without allocating memory. Of course, if this 
            property is called on a non-trivia node, it simply returns 
            <c>Args[0].Value</c>.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.LNode.Equals(Loyc.Collections.VList{Loyc.Syntax.LNode},Loyc.Collections.VList{Loyc.Syntax.LNode},Loyc.Syntax.LNode.CompareMode)">
            <summary>Compares two lists of nodes for structural equality.</summary>
            <param name="mode">Whether to pay attention to <see cref="P:Loyc.Syntax.LNode.Style"/> and trivia attributes</param>
            <remarks>Position information is not compared.</remarks>
        </member>
        <member name="M:Loyc.Syntax.LNode.Equals(Loyc.Syntax.ILNode,Loyc.Syntax.ILNode,Loyc.Syntax.LNode.CompareMode)">
            <inheritdoc cref="M:Loyc.Syntax.LNode.Equals(Loyc.Syntax.ILNode,Loyc.Syntax.LNode.CompareMode)"/>
        </member>
        <member name="M:Loyc.Syntax.LNode.Equals(Loyc.Syntax.ILNode,Loyc.Syntax.LNode.CompareMode)">
            <summary>Compares two nodes for structural equality. Two nodes are 
            considered equal if they have the same kind, the same name, the same 
            value, the same arguments, and the same attributes.</summary>
            <param name="mode">Whether to pay attention to <see cref="P:Loyc.Syntax.LNode.Style"/> and trivia attributes</param>
            <remarks>Position information (<see cref="P:Loyc.Syntax.LNode.Range"/>) is not compared.</remarks>
        </member>
        <member name="M:Loyc.Syntax.LNode.GetHashCode">
            <summary>Gets the hash code based on the structure of the tree.</summary>
            <remarks>
            If the tree is large, less than the entire tree is scanned to produce 
            the hashcode (in the absolute worst case, about 4000 nodes are examined, 
            but usually it is less than 100).
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.LNode.CallsMin(Loyc.Symbol,System.Int32)">
            <summary>Returns true if this is a call with the specified name and the specified minimum number of arguments.</summary>
        </member>
        <member name="M:Loyc.Syntax.LNode.CallsMin(System.String,System.Int32)">
            <summary>Returns true if this is a call with the specified name and the specified minimum number of arguments.</summary>
        </member>
        <member name="M:Loyc.Syntax.LNode.HasSimpleHead">
            <summary>Returns true if this is not a call, or if the call's Target is an Id or a Literal.</summary>
        </member>
        <member name="M:Loyc.Syntax.LNode.HasSimpleHeadWithoutPAttrs">
            <summary>Returns true if this is not a call, or if the call's Target is an Id or a Literal, and the Target has only trivia attributes.</summary>
        </member>
        <member name="M:Loyc.Syntax.LNode.MergeLists(Loyc.Syntax.LNode,Loyc.Syntax.LNode,Loyc.Symbol)">
            <summary>Some <see cref="T:Loyc.Syntax.CallNode"/>s are used to represent lists. This 
            method merges two nodes, forming or appending a list (see remarks).</summary>
            <param name="node1">First node, list, or null.</param>
            <param name="node2">Second node, list, or null.</param>
            <param name="listName">The <see cref="P:Loyc.Syntax.LNode.Name"/> used to detect whether a 
            node is a list (typically "#splice"). Any other name is considered a 
            normal call, not a list. If this method creates a list from two non-
            lists, this parameter specifies the Name that the list will have.</param>
            <returns>The merged list.</returns>
            <remarks>
            The order of the data is retained (i.e. the data in node1 is inserted
            before the data in node2).
            <ul>
            <li>If either node1 or node2 is null, this method returns the other (node1 ?? node2).</li>
            <li>If both node1 and node2 are lists, this method merges the list 
            into a single list by appending node2's arguments at the end of node1.
            The attributes of node1 are kept and those of node2 are discarded.</li>
            <li>If one of the nodes is a list and the other is not, the non-list
            is inserted into the list's Args.</li>
            <li>If neither node is a list, a list is created with both nodes as 
            its two Args.</li>
            </ul>
            </remarks>
            <seealso cref="M:Loyc.Syntax.LNodeExt.WithSpliced(Loyc.Collections.VList{Loyc.Syntax.LNode},System.Int32,Loyc.Syntax.LNode,Loyc.Symbol)"/>
        </member>
        <member name="M:Loyc.Syntax.LNode.MergeBinary(Loyc.Syntax.LNode,Loyc.Syntax.LNode,Loyc.Symbol)">
            <summary>Combines two nodes using a binary operator or function.</summary>
            <param name="node1">First node, list, or null.</param>
            <param name="node2">Second node, list, or null.</param>
            <param name="binaryOpName">Binary operator to use when the nodes are not null.</param>
            <returns>If either node1 or node2 is null, this method returns the other node
            (node1 ?? node2), otherwise the nodes are joined with the specified operator.</returns>
            <seealso cref="M:Loyc.Syntax.LNode.FlattenBinaryOpSeq(Loyc.Syntax.LNode,Loyc.Symbol,System.Nullable{System.Boolean})"/>
        </member>
        <member name="M:Loyc.Syntax.LNode.FlattenBinaryOpSeq(Loyc.Syntax.LNode,Loyc.Symbol,System.Nullable{System.Boolean})">
            <summary>Converts a sequence of the same operator (e.g. `x+y+z`) to a list (e.g. x, y, z).</summary>
            <param name="expr">An expression that may or may not call the operator.</param>
            <param name="opName">The operator to recognize.</param>
            <param name="rightAssociative">Whether the operator is right associative. 
            If this is null then either or both associativities will work (e.g. 
            <c>(a*b)*(c*d)</c> is flattened to a,b,c,d).</param>
            <returns>A list of subexpressions with the operator removed. If <c>expr</c> 
            does not call the specified binary operator, the list contains a single item 
            which is the original expression.</returns>
            <remarks>This is the reverse operation of <see cref="M:Loyc.Syntax.LNode.MergeBinary(Loyc.Syntax.LNode,Loyc.Syntax.LNode,Loyc.Symbol)"/>.</remarks>
        </member>
        <member name="M:Loyc.Syntax.LNode.Select(System.Func{Loyc.Syntax.LNode,Loyc.Maybe{Loyc.Syntax.LNode}},Loyc.Syntax.LNode.ReplaceOpt)">
            <summary>Transforms the <see cref="P:Loyc.Syntax.LNode.Target"/>, parameters, and optionally
            the attributes of an LNode, returning another LNode of the same Kind. If 
            the selector makes no changes, Select() returns <c>this</c>.</summary>
            <remarks>The selector is not allowed to return null, but it can return
            <c>NoValue.Value</c> to delete a parameter or target. If the current 
            node is a target, it cannot be deleted, so it is replaced with 
            <c>#splice()</c> which, by convention, represents an empty list.
            If you're wondering why we don't use <c>null</c> for deletions, it is 
            because the functionality of this method is actually implemented by 
            <see cref="M:Loyc.Collections.VList`1.WhereSelect(System.Func{`0,Loyc.Maybe{`0}})"/>; since T could be a 
            value type, that method cannot use null as a signal to delete items from 
            the collection.
            <para/>
            It is not possible to delete the <see cref="P:Loyc.Syntax.LNode.Target"/> of a call, and
            if the selector returns <c>NoValue.Value</c> for the Target, the target 
            is replaced with an empty call to <c>#splice()</c>.</remarks>
        </member>
        <member name="F:Loyc.Syntax.LNode.ReplaceOpt.ReplaceRoot">
            <summary>When calling <c>n.ReplaceRecursive</c>, specifies that the 
            selector should be called on <c>n</c> itself, not just its children.</summary>
        </member>
        <member name="F:Loyc.Syntax.LNode.ReplaceOpt.ProcessAttrs">
            <summary>When calling <see cref="M:Loyc.Syntax.LNode.ReplaceRecursive(System.Func{Loyc.Syntax.LNode,Loyc.Maybe{Loyc.Syntax.LNode}},Loyc.Syntax.LNode.ReplaceOpt)"/>
            or <see cref="M:Loyc.Syntax.LNode.Select(System.Func{Loyc.Syntax.LNode,Loyc.Maybe{Loyc.Syntax.LNode}},Loyc.Syntax.LNode.ReplaceOpt)"/>, specifies
            that attributes should be processed rather than left unchanged.</summary>
        </member>
        <member name="F:Loyc.Syntax.LNode.ReplaceOpt.Default">
            <summary>ReplaceRoot and ProcessAttrs</summary>
        </member>
        <member name="M:Loyc.Syntax.LNode.ReplaceRecursive(System.Func{Loyc.Syntax.LNode,Loyc.Maybe{Loyc.Syntax.LNode}},Loyc.Syntax.LNode.ReplaceOpt)">
            <summary>Performs a recursive find-and-replace operation, by attempting
            to replace each child (among <see cref="P:Loyc.Syntax.LNode.Attrs"/>, <see cref="P:Loyc.Syntax.LNode.Target"/>, 
            <see cref="P:Loyc.Syntax.LNode.Args"/>) using the specified selector. This method can also
            be used for simple searching, by giving a selector that always returns 
            null.</summary>
            <param name="matcher">This method is called for each descendant, and
            optionally the root node. If the selector returns a node, the new node 
            replaces the node that was passed to <c>selector</c> and the children of 
            the new node are ignored. If the selector returns null, children of the 
            child are scanned recursively. If the selector returns Maybe{LNode}.NoValue
            then the current node is deleted if it is an argument or attribute. If 
            the current node is a target, it cannot be deleted, so it is replaced 
            with <c>#splice()</c> which, by convention, represents an empty list.
            If you delete the root node then this method returns Maybe{LNode}.NoValue.</param>
            <param name="options">Options, see <see cref="T:Loyc.Syntax.LNode.ReplaceOpt"/>.</param>
            <returns>The new node produced after all replacements have occurred.</returns>
            <remarks>If <c>replaceFunc</c> always returns null (or if <c>replaceRoot</c>
            is false and the root has no children), <c>ReplaceRecursive</c> returns 
            <c>this</c>.</remarks>
        </member>
        <member name="T:Loyc.Syntax.LNodeExt">
            <summary>Standard extension methods for <see cref="T:Loyc.Syntax.LNode"/>.</summary>
        </member>
        <member name="M:Loyc.Syntax.LNodeExt.GetTrailingTrivia(Loyc.Syntax.LNode)">
            <summary>Gets all trailing trivia attached to the specified node.</summary>
        </member>
        <member name="M:Loyc.Syntax.LNodeExt.GetTrailingTrivia(Loyc.Collections.VList{Loyc.Syntax.LNode})">
            <summary>Gets all trailing trivia attached to the specified node.</summary>
            <remarks>Trailing trivia is represented by a call to <c>%trailing</c> in
            a node's attribute list; each argument to %trailing represents one
            piece of trivia. If the attribute list has multiple calls to 
            %trailing, this method combines those lists into a single list.</remarks>
        </member>
        <member name="M:Loyc.Syntax.LNodeExt.WithTrailingTrivia(Loyc.Syntax.LNode,Loyc.Collections.VList{Loyc.Syntax.LNode})">
            <summary>Removes a node's trailing trivia and adds a new list of trailing trivia.</summary>
        </member>
        <member name="M:Loyc.Syntax.LNodeExt.WithTrailingTrivia(Loyc.Collections.VList{Loyc.Syntax.LNode},Loyc.Collections.VList{Loyc.Syntax.LNode})">
            <summary>Removes all existing trailing trivia from an attribute list and adds a new list of trailing trivia.</summary>
            <remarks>This method has a side-effect of recreating the %trailing
            node, if there is one, at the end of the attribute list. If <c>trivia</c>
            is empty then all calls to %trailing are removed.</remarks>
        </member>
        <member name="M:Loyc.Syntax.LNodeExt.WithoutTrailingTrivia(Loyc.Collections.VList{Loyc.Syntax.LNode})">
            <summary>Gets a new list with any %trailing attributes removed.</summary>
        </member>
        <member name="M:Loyc.Syntax.LNodeExt.WithoutTrailingTrivia(Loyc.Collections.VList{Loyc.Syntax.LNode},Loyc.Collections.VList{Loyc.Syntax.LNode}@)">
            <summary>Gets a new list with any %trailing attributes removed. Those trivia are returned in an `out` parameter.</summary>
        </member>
        <member name="M:Loyc.Syntax.LNodeExt.PlusTrailingTrivia(Loyc.Syntax.LNode,Loyc.Collections.VList{Loyc.Syntax.LNode})">
            <summary>Adds additional trailing trivia to a node.</summary>
        </member>
        <member name="M:Loyc.Syntax.LNodeExt.PlusTrailingTrivia(Loyc.Syntax.LNode,Loyc.Syntax.LNode)">
            <summary>Adds additional trailing trivia to a node.</summary>
        </member>
        <member name="M:Loyc.Syntax.LNodeExt.PlusTrailingTrivia(Loyc.Collections.VList{Loyc.Syntax.LNode},Loyc.Collections.VList{Loyc.Syntax.LNode})">
            <summary>Adds additional trailing trivia to an attribute list. Has no effect if <c>trivia</c> is empty.</summary>
            <remarks>
            Trailing trivia is represented by a call to <c>%trailing</c> in a node's 
            attribute list; each argument to %trailing represents one piece of trivia.
            <para/>
            In the current design, this method has a side-effect of recreating the %trailing
            node at the end of the attribute list, and if there are multiple %trailing
            lists, consolidating them into a single list, but only if the specified <c>trivia</c> 
            list is not empty.</remarks>
        </member>
        <member name="M:Loyc.Syntax.LNodeExt.PlusTrailingTrivia(Loyc.Collections.VList{Loyc.Syntax.LNode},Loyc.Syntax.LNode)">
            <summary>Adds additional trailing trivia to an attribute list.</summary>
        </member>
        <member name="M:Loyc.Syntax.LNodeExt.AsList(Loyc.Syntax.LNode,Loyc.Symbol)">
            <summary>Interprets a node as a list by returning <c>block.Args</c> if 
            <c>block.Calls(listIdentifier)</c>, otherwise returning a one-item list 
            of nodes with <c>block</c> as the only item.</summary>
        </member>
        <member name="M:Loyc.Syntax.LNodeExt.AsLNode(Loyc.Collections.VList{Loyc.Syntax.LNode},Loyc.Symbol)">
            <summary>Converts a list of LNodes to a single LNode by using the list 
            as the argument list in a call to the specified identifier, or, if the 
            list contains a single item, by returning that single item.</summary>
            <param name="listIdentifier">Target of the node that is created if <c>list</c>
            does not contain exactly one item. Typical values include "'{}" and "#splice".</param>
            <remarks>This is the reverse of the operation performed by <see cref="M:Loyc.Syntax.LNodeExt.AsList(Loyc.Syntax.LNode,Loyc.Symbol)"/>.</remarks>
        </member>
        <member name="M:Loyc.Syntax.LNodeExt.InParens(Loyc.Syntax.LNode)">
            <summary>Returns the same node with a parentheses attribute added.</summary>
        </member>
        <member name="M:Loyc.Syntax.LNodeExt.InParens(Loyc.Syntax.LNode,Loyc.Syntax.SourceRange)">
            <summary>Returns the same node with a parentheses attribute added.</summary>
            <remarks>The node's range is changed to the provided <see cref="T:Loyc.Syntax.SourceRange"/>.</remarks>
        </member>
        <member name="M:Loyc.Syntax.LNodeExt.InParens(Loyc.Syntax.LNode,Loyc.Syntax.ISourceFile,System.Int32,System.Int32)">
            <summary>Returns the same node with a parentheses attribute added.</summary>
        </member>
        <member name="M:Loyc.Syntax.LNodeExt.WithoutOuterParens(Loyc.Syntax.LNode)">
            <summary>Removes a single pair of parentheses, if the node has a 
            %inParens attribute. Returns the same node when no parens are 
            present.</summary>
        </member>
        <member name="M:Loyc.Syntax.LNodeExt.MatchesPattern(Loyc.Syntax.LNode,Loyc.Syntax.LNode,Loyc.Collections.MMap{Loyc.Symbol,Loyc.Syntax.LNode}@,Loyc.Collections.VList{Loyc.Syntax.LNode}@)">
            <summary>Determines whether one Loyc tree "matches" another. This is 
            different from a simple equality test in that (1) trivia atributes do 
            not have to match, and (2) the pattern can contain placeholders represented
            by calls to $ (the substitution operator) with an identifier as a parameter.
            Placeholders match any subtree, and are saved to the <c>captures</c> map.
            </summary>
            <param name="candidate">A node that you want to compare with a 'pattern'.</param>
            <param name="pattern">A syntax tree that may contain placeholders. A 
            placeholder is a call to the $ operator with one parameter, which must 
            be either (A) a simple identifier, or (B) the ".." operator with a simple
            identifier as its single parameter. Otherwise, the $ operator is treated 
            literally as something that must exist in <c>candidate</c>). The subtree 
            in <c>candidate</c> corresponding to the placeholder is saved in 
            <c>captures</c>.</param>
            <param name="captures">A table that maps placeholder names from 
            <c>pattern</c> to subtrees in <c>candidate</c>. You can set your map to 
            null and a map will be created for you if necessary. If you already have
            a map, you should clear it before calling this method.</param>
            <param name="unmatchedAttrs">On return, a list of trivia attributes in 
            <c>candidate</c> that were not present in <c>pattern</c>.</param>
            <returns>true if <c>pattern</c> matches <c>candidate</c>, false otherwise.</returns>
            <remarks>
            Attributes in patterns are not yet supported.
            <para/>
            This method supports multi-part captures, which are matched to 
            placeholders whose identifier either (A) has a #params attribute or
            (B) has the unary ".." operator applied to it (for example, if 
            the placeholder is called p, this is written as <c>$(params p)</c> in 
            EC#.) A placeholder that looks like this can match multiple arguments or
            multiple statements in the <c>candidate</c> (or <i>no</i> arguments, or
            no statements), and will become a #splice(...) node in <c>captures</c>
            if it matches multiple items. Multi-part captures are often useful for
            getting lists of statements before and after some required element,
            e.g. <c>{ $(params before); MatchThis($something); $(params after); }</c>
            <para/>
            If the same placeholder appears twice then the two matching items are 
            combined into a single output node (calling #splice).
            <para/>
            If matching is unsuccessful, <c>captures</c> and <c>unmatchedAttrs</c>
            may contain irrelevant information gathered during the attempt to match.
            <para/>
            In EC#, the quote(...) macro can be used to create the LNode object for 
            a pattern.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.LNodeExt.GetCaptureIdentifier(Loyc.Syntax.LNode,System.Boolean)">
            <summary>Checks if <c>pattern</c> matches one of the syntax trees 
            <c>$x</c> or <c>$(..x)</c> or <c>$(...x)</c> for some identifier <c>x</c>.
            These are conventionally used to represent partial syntax trees.</summary>
            <returns>The matched identifier (<c>x</c> in the examples above), or null 
            if <c>pattern</c> was not a match.</returns>
        </member>
        <member name="M:Loyc.Syntax.LNodeExt.ToLNode(Loyc.Syntax.ILNode)">
            <summary>Converts <see cref="T:Loyc.Syntax.ILNode"/> to <see cref="T:Loyc.Syntax.LNode"/> recursively.</summary>
        </member>
        <member name="T:Loyc.Syntax.LNodeFactory">
            <summary>Contains helper methods for creating <see cref="T:Loyc.Syntax.LNode"/>s.
            An LNodeFactory holds a reference to the current source file (<see cref="P:Loyc.Syntax.LNodeFactory.File"/>) 
            so that it does not need to be repeated every time you create a node.
            </summary>
        </member>
        <member name="M:Loyc.Syntax.LNodeFactory.OnNewLine(Loyc.Syntax.LNode)">
            <summary>Adds a leading newline to the node if the first attribute isn't a newline.</summary>
            <remarks>By convention, in Loyc languages, top-level nodes and nodes within 
            braces have an implicit newline, such that a leading blank line appears
            if you add <see cref="F:Loyc.Syntax.CodeSymbols.TriviaNewline"/>. For all other nodes,
            this method just ensures there is a line break.</remarks>
        </member>
        <member name="M:Loyc.Syntax.LNodeFactory.Trivia(System.String,System.Object)">
            <summary>Creates a trivia node named <c>"%" + suffix</c> with the 
            specified Value attached.</summary>
            <remarks>This method only adds the prefix <c>%</c> if it is not 
            already present in the 'suffix' argument.</remarks>
        </member>
        <member name="M:Loyc.Syntax.LNodeFactory.Trivia(Loyc.Symbol,System.Object,System.Int32,System.Int32)">
            <summary>Creates a trivia node with the specified Value attached.</summary>
            <seealso cref="M:Loyc.Syntax.LNode.Trivia(Loyc.Symbol,System.Object,Loyc.Syntax.LNode)"/>
        </member>
        <member name="T:Loyc.Syntax.LNodeVisitor">
            <summary>Base class for people that want to implement the visitor pattern with <see cref="T:Loyc.Syntax.LNode"/>.</summary>
        </member>
        <member name="T:Loyc.Syntax.ILNodeVisitor">
            <summary>Interface for people that want to implement the visitor pattern with <see cref="T:Loyc.Syntax.LNode"/>.
            If your visitor does not need a base class, use <see cref="T:Loyc.Syntax.LNodeVisitor"/> as the base class.</summary>
        </member>
        <member name="T:Loyc.Syntax.StdTriviaNode">
            <summary>A simple call node with a single literal argument. </summary>
            <remarks>
            Essentially, this is a special kind of node with both a name and a value.
            Since there is no syntax (or <see cref="T:Loyc.Syntax.LNodeKind"/>) for a node that has
            both a Name and a Value, the node pretends that it is has a single argument,
            Args[0], which allows this node to be printed as if it were a normal call
            node. For example, if this node has Name=(Symbol)"PI" and Value=3.1415,
            it will be printed as <c>PI(3.1415)</c>. The <see cref="P:Loyc.Syntax.StdTriviaNode.TriviaValue"/>
            property returns this value (in this case, (object)3.1415). Please note
            that the normal <see cref="P:Loyc.Syntax.LNode.Value"/> is still <see cref="F:Loyc.NoValue.Value"/>
            so that if the node is printed and reparsed, it doesn't behave differently.
            <para/>
            This node type is used to represent tokens and trivia nodes with values.
            </remarks>
        </member>
        <member name="T:Loyc.Syntax.OperatorShape">
            <summary>An enum of common operator formats.</summary>
            <remarks>It is intentional that the absolute value of each OperatorShape
            (except Other) is the arity of (number of arguments to) that shape.</remarks>
        </member>
        <member name="T:Loyc.Syntax.ParseHelpers">
            <summary>Static methods that help with common parsing jobs, such as 
            parsing integers, floats, and strings with C escape sequences.</summary>
            <seealso cref="T:Loyc.Syntax.PrintHelpers"/>
        </member>
        <member name="M:Loyc.Syntax.ParseHelpers.TryParseHex(Loyc.UString,System.Int32@)">
            <summary>A simple method to parse a sequence of hex digits, without
            overflow checks or other features supported by methods like 
            <see cref="M:Loyc.Syntax.ParseHelpers.TryParseInt(System.String,System.Int32@,System.Int32@,System.Int32,System.Boolean)"/>.</summary>
            <returns><c>true</c> iff the entire string was consumed and the string was nonempty.</returns>
        </member>
        <member name="M:Loyc.Syntax.ParseHelpers.TryParseHex(Loyc.UString@,System.Int32@)">
            <summary>A simple method to parse a sequence of hex digits, without
            overflow checks or other features supported by methods like 
            <see cref="M:Loyc.Syntax.ParseHelpers.TryParseInt(System.String,System.Int32@,System.Int32@,System.Int32,System.Boolean)"/>.</summary>
            <returns>The number of digits parsed</returns>
        </member>
        <member name="M:Loyc.Syntax.ParseHelpers.HexDigitValue(System.Char)">
            <summary>Gets the integer value for the specified hex digit, or -1 if 
            the character is not a hex digit.</summary>
        </member>
        <member name="M:Loyc.Syntax.ParseHelpers.Base36DigitValue(System.Char)">
            <summary>Gets the integer value for the specified digit, where 'A' maps 
            to 10 and 'Z' maps to 35, or -1 if the character is not a digit or
            letter.</summary>
        </member>
        <member name="M:Loyc.Syntax.ParseHelpers.UnescapeCStyle(Loyc.UString,System.Boolean)">
            <summary>Unescapes a string that uses C-style escape sequences, e.g. 
            "\\\n\\\r" becomes "\n\r".</summary>
        </member>
        <member name="M:Loyc.Syntax.ParseHelpers.UnescapeCStyle(Loyc.UString,Loyc.Syntax.EscapeC@,System.Boolean)">
            <summary>Unescapes a string that uses C-style escape sequences, e.g. 
            "\\\n\\\r" becomes "\n\r".</summary>
            <param name="encountered">Returns information about whether escape 
            sequences were encountered, and which categories.</param>
            <param name="removeUnnecessaryBackslashes">Causes the backslash before 
            an unrecognized escape sequence to be removed, e.g. "\z" => "z".</param>
            <remarks>See <see cref="M:Loyc.Syntax.ParseHelpers.UnescapeChar(Loyc.UString@,Loyc.Syntax.EscapeC@)"/> for details.</remarks>
        </member>
        <member name="M:Loyc.Syntax.ParseHelpers.UnescapeChar(Loyc.UString@,Loyc.Syntax.EscapeC@)">
            <summary>Unescapes a single character of a string. Returns the 
            first character if it is not a backslash, or <c>\</c> if it is a 
            backslash but no escape sequence could be discerned.</summary>
            <param name="s">Slice of a string to be unescaped. When using a
            <c>ref UString</c> overload of this method, <c>s</c> will be shorter upon
            returning from this method, as the parsed character(s) are clipped 
            from the beginning (<c>s.InternalStart</c> is incremented by one 
            normally and more than one in case of an escape sequence.)</param>
            <param name="encountered">Bits of this parameter are set according
            to which escape sequence is encountered, if any.</param>
            <remarks>
            This function also decodes (non-escaped) surrogate pairs.
            <para/>
            Code points with 5 or 6 digits such as \u1F4A9 are supported.
            \x escapes must be two digits and set the EscapeC.BackslashX flag.
            \u escapes must be 4 to 6 digits. If a \u escape has more than 4 
            digits, the EscapeC.HasLongEscapes flag is set. Invalid 6-digit 
            escapes like \u123456 are "made valid" by being treated as 5 digits
            (the largest valid escape is <c>\u10FFFF</c>.)
            <para/>
            Supported escapes: <c>\u \x \\ \n \r \0 \' \" \` \t \a \b \f \v</c>
            </remarks>
            <example>
            EscapeC e = 0; 
            UString str = @"\nfoo";
            char c = UnescapeChar(ref str, ref e);
            Contract.Assert(str == "foo");
            Contract.Assert(e == EscapeC.HasEscapes);
            </example>
        </member>
        <member name="M:Loyc.Syntax.ParseHelpers.TryParseInt(System.String,System.Int32@,System.Int32@,System.Int32,System.Boolean)">
            <summary>Tries to parse a string to an integer. Unlike <see cref="M:System.Int32.TryParse(System.String,System.Int32@)"/>,
            this method allows parsing to start at any point in the string, it 
            allows non-numeric data after the number, and it can parse numbers that
            are not in base 10.</summary>
            <param name="radix">Number base, e.g. 10 for decimal and 2 for binary.
            Must be in the range 2 to 36.</param>
            <param name="index">Location at which to start parsing</param>
            <param name="flags"><see cref="T:Loyc.Syntax.ParseNumberFlag"/>s that affect parsing behavior.</param>
            <param name="skipSpaces">Whether to skip spaces before parsing. Only 
            the ' ' and '\t' characters are treated as spaces. No space is allowed 
            between '-' and the digits of a negative number, even with this flag.</param>
            <returns>True if a number was found starting at the specified index
            and it was successfully converted to a number, or false if not.</returns>
            <remarks>
            This method never throws. If parsing fails, index is left unchanged, 
            except that spaces are still skipped if you set the skipSpaces flag. 
            If base>36, parsing can succeed but digits above 35 (Z) cannot occur 
            in the output number. If the input number cannot fit in 'result', the 
            return value is false but index increases anyway, and 'result' is a 
            bitwise truncated version of the number.
            <para/>
            When parsing input such as "12.34", the parser stops and returns true
            at the dot (with a result of 12 in this case).
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.ParseHelpers.TryParseInt(Loyc.UString@,System.Int32@,System.Int32,Loyc.Syntax.ParseNumberFlag)">
            <inheritdoc cref="M:Loyc.Syntax.ParseHelpers.TryParseInt(System.String,System.Int32@,System.Int32@,System.Int32,System.Boolean)"/>
        </member>
        <member name="M:Loyc.Syntax.ParseHelpers.TryParseInt(Loyc.UString@,System.Int64@,System.Int32,Loyc.Syntax.ParseNumberFlag)">
            <inheritdoc cref="M:Loyc.Syntax.ParseHelpers.TryParseInt(System.String,System.Int32@,System.Int32@,System.Int32,System.Boolean)"/>
        </member>
        <member name="M:Loyc.Syntax.ParseHelpers.TryParseUInt(Loyc.UString@,System.UInt64@,System.Int32,Loyc.Syntax.ParseNumberFlag)">
            <summary>Tries to parse a string to an unsigned integer.</summary>
            <param name="s">A slice of a string to be parsed.</param>
            <param name="radix">Number base, e.g. 10 for decimal and 2 for binary.
            Normally in the range 2 to 36.</param>
            <param name="flags"><see cref="T:Loyc.Syntax.ParseNumberFlag"/>s that affect parsing behavior.</param>
            <returns>True if a number was found starting at the specified index
            and it was successfully converted to a number, or false if not.</returns>
            <remarks>
            This method never throws. It shrinks the slice <c>s</c> as it parses,
            so if parsing fails, <c>s[0]</c> will be the character at which parsing 
            fails. If base>36, parsing can succeed but digits above 35 (Z) cannot 
            be represented in the input string. If the number cannot fit in 
            <c>result</c>, the return value is false and the method's exact behavior
            depends on whether you used <see cref="F:Loyc.Syntax.ParseNumberFlag.StopBeforeOverflow"/>.
            <para/>
            When parsing input such as "12.34", the parser stops and returns true
            at the dot (with a result of 12 in this case).
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.ParseHelpers.TryParseUInt(Loyc.UString@,System.Numerics.BigInteger@,System.Int32,Loyc.Syntax.ParseNumberFlag)">
            <inheritdoc cref="M:Loyc.Syntax.ParseHelpers.TryParseUInt(Loyc.UString@,System.UInt64@,System.Int32,Loyc.Syntax.ParseNumberFlag)"/>
        </member>
        <member name="M:Loyc.Syntax.ParseHelpers.TryParseFloatParts(Loyc.UString@,System.Int32,System.Boolean@,System.UInt64@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,Loyc.Syntax.ParseNumberFlag)">
            <summary>Low-level method that identifies the parts of a float literal
            of arbitrary base (typically base 2, 10, or 16) with no prefix or 
            suffix, such as <c>2.Cp0</c> (which means 2.75 in base 16).</summary>
            <param name="radix">Base of the number to parse; must be between 2
            and 36.</param>
            <param name="mantissa">Integer magnitude of the number.</param>
            <param name="exponentBase2">Base-2 exponent to apply, as specified by
            the 'p' suffix, or 0 if there is no 'p' suffix..</param>
            <param name="exponentBase10">Base-10 exponent to apply, as specified by
            the 'e' suffix, or 0 if there is no 'e' suffix..</param>
            <param name="exponentBaseR">Base-radix exponent to apply. This number
            is based on the front part of the number only (not including the 'p' or
            'e' suffix). Negative values represent digits after the decimal point,
            while positive numbers represent 64-bit overflow. For example, if the
            input is <c>12.3456</c> with <c>radix=10</c>, the output will be 
            <c>mantissa=123456</c> and <c>exponentBaseR=-4</c>. If the input is 
            <c>0123_4567_89AB_CDEF_1234.5678</c> with <c>radix=16</c>, the mantissa 
            overflows, and the result is <c>mantissa = 0x1234_5678_9ABC_DEF1</c> 
            with <c>exponentBaseR=3</c>.</param>
            <param name="numDigits">Set to the number of digits in the number, not 
            including the exponent part.</param>
            <param name="flags">Alters parsing behavior, see <see cref="T:Loyc.Syntax.ParseNumberFlag"/>.</param>
            <remarks>
            The syntax required is
            <code>
              ( '+'|'-' )?
              ( Digits ('.' Digits?)? | '.' Digits )
              ( ('p'|'P') ('-'|'+')? DecimalDigits+ )?
              ( ('e'|'E') ('-'|'+')? DecimalDigits+ )?
            </code>
            where Digits refers to one or more digits in the requested base, 
            possibly including underscores or spaces if the flags allow it; similarly, 
            DecimalDigits refers to base-10 digits and is also affected by the
            flags.
            <para/>
            Returns false if there was an error interpreting the input.
            <para/>
            To keep the parser relatively simple, it does not roll back in case of 
            error the way the int parser does. For example, given the input "23p", 
            the 'p' is consumed and causes the method to return false, even though
            the parse could have been successful if it had ignored the 'p'.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.ParseHelpers.TryParseFloatParts(Loyc.UString@,System.Int32,System.Boolean@,System.UInt64@,System.Int32@,System.Int32@,System.Int32@,Loyc.Syntax.ParseNumberFlag)">
            <summary>Parses the parts of a floating-point string. See the other 
            overload for details.</summary>
            <param name="radix">Base of the number to parse; must be 2 (binary), 
            4, 8 (octal), 10 (decimal), 16 (hexadecimal) or 32.</param>
            <param name="negative">true if the string began with '-'.</param>
            <param name="mantissa">Integer magnitude of the number.</param>
            <param name="exponentBase2">Base-2 exponent to apply.</param>
            <param name="exponentBase10">Base-10 exponent to apply.</param>
            <param name="numDigits">Set to the number of digits in the number, not including the exponent part.</param>
            <param name="flags">Alters parsing behavior, see <see cref="T:Loyc.Syntax.ParseNumberFlag"/>.</param>
            <remarks>
            This method is a wrapper around the other overload that combines 
            the 'exponentBaseR' parameter with 'exponentBase2' or 'exponentBase10'
            depending on the radix. For example, when radix=10, this method 
            adds <c>exponentBaseR</c> to <c>exponentBase10</c>.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.ParseHelpers.TryParseDouble(Loyc.UString@,System.Int32,Loyc.Syntax.ParseNumberFlag)">
            <summary>Parses a string to a double-precision float, returning NaN on 
            failure or an infinity value on overflow.</summary>
            <param name="radix">Base of the number to parse; must be 2 (binary), 
            4, 8 (octal), 10 (decimal), 16 (hexadecimal) or 32.</param>
            <param name="flags">Alters parsing behavior, see <see cref="T:Loyc.Syntax.ParseNumberFlag"/>.</param>
        </member>
        <member name="M:Loyc.Syntax.ParseHelpers.TryParseFloat(Loyc.UString@,System.Int32,Loyc.Syntax.ParseNumberFlag)">
            <summary>Parses a string to a single-precision float, returning NaN on 
            failure or an infinity value on overflow.</summary>
            <param name="radix">Base of the number to parse; must be 2 (binary), 
            4, 8 (octal), 10 (decimal), 16 (hexadecimal) or 32.</param>
            <param name="flags">Alters parsing behavior, see <see cref="T:Loyc.Syntax.ParseNumberFlag"/>.</param>
        </member>
        <member name="M:Loyc.Syntax.ParseHelpers.SkipSpaces(Loyc.UString)">
            <summary>Returns a string with any spaces and tabs removed from the beginning.</summary>
            <remarks>Only ' ' and '\t' are treated as spaces.</remarks>
        </member>
        <member name="T:Loyc.Syntax.ParseNumberFlag">
            <summary>Flags that can be used with 
            <see cref="M:Loyc.Syntax.ParseHelpers.TryParseUInt(Loyc.UString@,System.UInt64@,System.Int32,Loyc.Syntax.ParseNumberFlag)"/>
            </summary>
        </member>
        <member name="F:Loyc.Syntax.ParseNumberFlag.SkipSpacesInFront">
            <summary>Skip spaces before the number. Without this flag, initial spaces make parsing fail.</summary>
        </member>
        <member name="F:Loyc.Syntax.ParseNumberFlag.SkipSpacesInsideNumber">
            <summary>Skip spaces inside the number. Without this flag, spaces make parsing stop.</summary>
        </member>
        <member name="F:Loyc.Syntax.ParseNumberFlag.StopBeforeOverflow">
            <summary>Changes overflow handling behavior when parsing an integer,
            so that the result does not overflow (wrap), and the digit(s) at the 
            end of the string, that would have caused overflow, are ignored. In 
            this case, the return value is still false.</summary>
        </member>
        <member name="F:Loyc.Syntax.ParseNumberFlag.SkipUnderscores">
            <summary>Skip underscores inside number. Without this flag, underscores make parsing stop.</summary>
        </member>
        <member name="F:Loyc.Syntax.ParseNumberFlag.SkipSingleQuotes">
            <summary>Skip single quotes inside number. Without this flag, single quotes make parsing stop.</summary>
        </member>
        <member name="F:Loyc.Syntax.ParseNumberFlag.AllowCommaDecimalPoint">
            <summary>Whether to treat comma as a decimal point when parsing a float. 
            The dot '.' is always treated as a decimal point.</summary>
        </member>
        <member name="T:Loyc.Syntax.StandardTriviaInjector">
            <summary>Encapsulates an algorithm that consumes trivia (comments and 
            newlines) from a list and adds it as trivia attributes into LNodes. This
            makes it possible to preserve comments and newlines independently of the
            language parser, so that the parser need not be specifically designed to 
            preserve them.</summary>
            <remarks>
            Usage: Call the constructor, then call <see cref="M:Loyc.Syntax.AbstractTriviaInjector`1.Run(System.Collections.Generic.IEnumerator{Loyc.Syntax.LNode})"/>.
            See <see cref="T:Loyc.Syntax.AbstractTriviaInjector`1"/> for more information.
            <para/>
            In brief, given input code with C-style comments like
            <pre>
            {
            	// Leading Comment 1
            	/* Leading Comment 2 * /
            	/* Leading Comment 3 * / x = y; // Trailing Comment 1
            	/* Trailing Comment 2 * /
            	
            	y = z; TheEnd();
            }
            </pre>
            [NOTE: the space in "* /" is a workaround for a serious bug in Doxygen, the html doc generator]
            
            The output, expressed in LESv2, is
            <pre>
            {
            	@[@%SLComment(" Leading Comment 1"),
            	  @%MLComment(" Leading Comment 2 "),
            	  @%newline,
            	  @%MLComment(" Leading Comment 3 "),
            	  @%trailing(
            	    @%SLComment(" Trailing Comment 1"),
            	    @%MLComment(" Trailing Comment 2 "),
            	    @%newline)]
            	x = y;
            	y = z;
            	@[@%appendStatement] TheEnd();
            }
            </pre>
            By default, printers should add newlines between statements within a braced 
            block. Therefore, this class does not add trivia to mark a single newline 
            between statements; instead, it adds an %appendStatement attribute 
            when the expected newline prior to a statement in a braced block was NOT 
            present. Also, a newline is expected after a single-line comment and no 
            <c>%newline</c> is created for the expected newline.
            <para/>
            Finally, since printers typically add a newline before the closing brace by
            default, this class avoids adding an attribute for that newline, if present.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.StandardTriviaInjector.#ctor(Loyc.Collections.IListSource{Loyc.Syntax.Lexing.Token},Loyc.Syntax.ISourceFile,System.Int32,System.String,System.String,System.String)">
            <summary>Initializes <see cref="T:Loyc.Syntax.StandardTriviaInjector"/>.</summary>
            <param name="sortedTrivia">A list of trivia that will be injected into the 
            nodes passed to <see cref="M:Loyc.Syntax.AbstractTriviaInjector`1.Run(System.Collections.Generic.IEnumerator{Loyc.Syntax.LNode})"/>. Normally,
            text of comments is extracted from the provided <see cref="T:Loyc.Syntax.ISourceFile"/>,
            but comment tokens could instead store their text as a string in their
            <see cref="F:Loyc.Syntax.Lexing.Token.Value"/>.</param>
            <param name="sourceFile">This is used as the source file of the <see cref="P:Loyc.Syntax.LNode.Range"/> of all trivia attributes that the algorithm injects.</param>
            <param name="newlineTypeInt">A token is interpreted as a newline when this value equals <see cref="F:Loyc.Syntax.Lexing.Token.TypeInt"/>.</param>
            <param name="mlCommentPrefix">If a token's text begins with this prefix it is assumed to be a multi-line comment and the prefix is removed.</param>
            <param name="mlCommentSuffix">If a multi-line comment's text ends with this suffix, the suffix is removed.</param>
            <param name="slCommentPrefix">If a token's text begins with this prefix it is assumed to be a single-line comment and the prefix is removed.</param>
        </member>
        <member name="M:Loyc.Syntax.StandardTriviaInjector.HasImplicitLeadingNewline(Loyc.Syntax.LNode,Loyc.Syntax.LNode,System.Int32)">
            <summary>Called to find out if a newline is to be added implicitly 
            before the current child of the specified node.</summary>
            <returns>By default, returns true if the node is a braced block.</returns>
        </member>
        <member name="M:Loyc.Syntax.StandardTriviaInjector.MakeTriviaAttribute(Loyc.Syntax.Lexing.Token)">
            <summary>Called to transform a trivia token into a trivia attribute.</summary>
            <remarks>If a trivia token is not recognized, null is returned to ignore the trivia.</remarks>
        </member>
        <member name="T:Loyc.Syntax.AbstractTriviaInjector`1">
             <summary>Encapsulates an algorithm that consumes trivia (comments and 
             newlines) from a list and adds it as trivia attributes into LNodes.</summary>
             <remarks>
             Call <see cref="M:Loyc.Syntax.AbstractTriviaInjector`1.Run(System.Collections.Generic.IEnumerator{Loyc.Syntax.LNode})"/> to invoke the algorithm. One must also write a
             derived class that knows how to interpret the trivia and associate it with
             a specific <see cref="T:Loyc.Syntax.LNode"/>, or use the standard derived class 
             <see cref="T:Loyc.Syntax.StandardTriviaInjector"/>.
             <para/>
             The algorithm is designed to postprocess output from a parser that works in
             a typical way. The lexer for your language needs to follow the following rules:
             
             <ul>
             <li>It must not include the newline character in the range of a single-line 
             comment.</li>
             <li>Generally, newlines (including the newline after a single-line comment)
             should be included in the trivia list, as the algorithm relies on newline trivia
             to notice when a new line is starting. Notably, a comment/trivia right after a 
             statement (e.g. on the same line) should normally be associated with that
             statement; if this class is unaware of the newline it will be associated with
             the next statement instead.</li>
             </ul>
             
             Typically one will wrap the lexer in <see cref="T:Loyc.Syntax.Lexing.TriviaSaver"/>, which 
             saves trivia while filtering out whitespace so that the parser doesen't see it.
             <para/>
             Your language's parser needs to follow the following rules:
             
             <ul>
             <li>The parser should assign minimal boundaries to each node: the 
             <see cref="P:Loyc.Syntax.LNode.Range"/> should not be wider than necessary. If there is 
             a comment before an expression like <c>/* ! * / x + y</c>, the parser should 
             not include the comment as part of the range unless it wants the comment to 
             be associated with a child node (<c>x</c>) instead of with the entire 
             expression (<c>x + y</c>).</li>
             <li>However, if a node has normal (non-trivia) attributes attached to it, 
             the Range of the node must include those attributes. If your parser fails 
             to do this, one symptom can be that a newline after an attribute "moves up" 
             in the attribute list so it appears before the attribute.</li>
             <li>The parser should use <see cref="M:Loyc.Syntax.LNodeFactory.InParens(Loyc.Syntax.LNode)"/> to place a
             node in parentheses and include the index of the opening and closing parens.</li>
             <li>If an expression/statement is terminated by a semicolon/comma, it's 
             best (but not crucial) to include the semicolon/comma in the LNode.Range, 
             but if a statement is terminated by a newline, the newline should not be 
             included in the range. If general, when the terminator is included in the 
             range, then any comment that appears before the terminator is attached
             to the final child node rather than to the node as a whole. (e.g. in 
             <c>x = y /*y* /;</c>, the comment is associated with <c>y</c> if the
             comment is within the range of the statement as a whole.)</li>
             </ul>
             This example shows how comments are associated with nodes:
             [NOTE: the space in "* /" is a workaround for a serious bug in Doxygen, the html doc generator]
             <pre>
             // Comment attached to block
             {
               // Comment attached to Foo() call
               Foo(
            		// Comment attached to argument1 + 1. Note that the comma is 
            		// generally invisible to the injector since it is not part of the LNode 
            		// tree, so the 1st and 2nd comments will both be attached to the sum-
            		// expression as a whole.
            		argument1 + 1 /*1st comment* /, // 2nd comment
            		// Comment attached to argument2 + 2
            		argument2 + 2); // Comment attached to Foo() call
            	  Area = 3.14159265/*PI* /  *  /*radius* /r**2;
            	  // Comment attached to Area = statement, preceded by newline trivia?
            
            	  // Comment attached to Bar()
            	  @BarAttr // Comment attached to BarAttr attribute
            	  Bar();
            	  
            	  // Comment attached to Bar() because there are no statements afterward
             }
             </pre>
             When there is a single newline between two nodes, <see cref="M:Loyc.Syntax.AbstractTriviaInjector`1.Run(System.Collections.Generic.IEnumerator{Loyc.Syntax.LNode})"/> will
             associate it with the second one. When there is a blank line between two 
             nodes (two newlines), the first newline (and any before) is associated with 
             the first node and the second newline (and any following) is associated with 
             the second.
             </remarks>
        </member>
        <member name="P:Loyc.Syntax.AbstractTriviaInjector`1.SortedTrivia">
            <summary>List of trivia to be injected by <see cref="M:Loyc.Syntax.AbstractTriviaInjector`1.Run(System.Collections.Generic.IEnumerator{Loyc.Syntax.LNode})"/>. Must be sorted.</summary>
        </member>
        <member name="P:Loyc.Syntax.AbstractTriviaInjector`1.NextIndex">
            <summary>Index of next trivia to be injected.</summary>
        </member>
        <member name="M:Loyc.Syntax.AbstractTriviaInjector`1.#ctor(Loyc.Collections.IListSource{`0})">
            <summary>Initializes the <see cref="P:Loyc.Syntax.AbstractTriviaInjector`1.SortedTrivia"/> property.</summary>
        </member>
        <member name="M:Loyc.Syntax.AbstractTriviaInjector`1.AttachTriviaTo(Loyc.Syntax.LNode@,Loyc.Collections.IListSource{`0},Loyc.Syntax.AbstractTriviaInjector{`0}.TriviaLocation,Loyc.Syntax.LNode,System.Int32)">
            <summary>Derived class should associate the given list of trivia with the 
            specified node. Leading trivia will be attached to a given node before 
            trailing trivia.</summary>
            <param name="node">The node.</param>
            <param name="trivia">Trivia to be associated with <c>node</c>.</param>
            <param name="loc">Location of the trivia. For a given node, the base class
            calls this method at most once for each value of <see cref="T:Loyc.Syntax.AbstractTriviaInjector`1.TriviaLocation"/>.
            </param>
            <param name="parent">(Original version of) parent of <c>node</c>.</param>
            <param name="indexInParent">Index of <c>node</c> within <c>parent</c>.</param>
            <returns>The same node with trivia attributes added. If loc indicates trailing
            trivia, the derived class can say "I don't want trivia to be associated with 
            this node" by returning null; the base class will, if possible, associate it 
            with the next node instead, but this doesn't work for the last child in a 
            sequence; in that case this method is called again with the same trivia and
            loc is set to TriviaLocation.TrailingExtra.</returns>
            <remarks>This method may STILL called for a given node when there is no trivia 
            associated with that node, IF the node is at the top level or its sibling 
            nodes in the same parent have associated trivia.</remarks>
        </member>
        <member name="F:Loyc.Syntax.AbstractTriviaInjector`1.TriviaLocation.Leading">
            <summary>Trivia that appeared before a node</summary>
        </member>
        <member name="F:Loyc.Syntax.AbstractTriviaInjector`1.TriviaLocation.Trailing">
            <summary>Trivia associated with a node that came before it</summary>
        </member>
        <member name="F:Loyc.Syntax.AbstractTriviaInjector`1.TriviaLocation.TrailingExtra">
            <summary>Trivia attached to the last node in an argument list or last statement in a block</summary>
        </member>
        <member name="F:Loyc.Syntax.AbstractTriviaInjector`1.TriviaLocation.Ambiguous">
            <summary>The trivia begins within the range of an identifier or literal. 
            This occurs, for example, if a list of arguments or attributes includes a
            comma in the range of each argument, and there is trivia before the comma,
            e.g. in <c>Foo(x/* trivia * /, y);</c>, this occurs if the range of <c>x</c> 
            includes the comma token. The trivia injector is not aware of <c>x</c> or
            the comma; all it knows is that the trivia is "inside" the range of <c>x</c>.</summary>
        </member>
        <member name="M:Loyc.Syntax.AbstractTriviaInjector`1.MarkOneLiner(Loyc.Syntax.LNode@)">
            <summary>This method is called when a node has no newlines or comments within it
            (although the node may still have a leading or trailing comment). It informs the
            derived class that <see cref="T:Loyc.Syntax.AbstractTriviaInjector`1"/> will not traverse 
            into the node.</summary>
            <remarks>The default implementation sets the <see cref="F:Loyc.Syntax.NodeStyle.OneLiner"/> 
            style flag.</remarks>
        </member>
        <member name="M:Loyc.Syntax.AbstractTriviaInjector`1.GetRange(`0)">
            <summary>Gets the <see cref="T:Loyc.Syntax.SourceRange"/> for an element of trivia.</summary>
        </member>
        <member name="M:Loyc.Syntax.AbstractTriviaInjector`1.IsNewline(`0)">
            <summary>Returns true if the trivia represents a newline, false otherwise.</summary>
        </member>
        <member name="M:Loyc.Syntax.AbstractTriviaInjector`1.GetEmptyResultSet">
            <summary>A method called to create a virtual node to apply trivia to an empty source file.</summary>
            <remarks>Default implementation attaches all trivia to a "missing" node 
            (zero-length identifier). If this method returns null then the result is discarded.</remarks>
        </member>
        <member name="M:Loyc.Syntax.AbstractTriviaInjector`1.DoneAttaching(Loyc.Syntax.LNode,Loyc.Syntax.LNode,System.Int32)">
            <summary>This method is called after a node has been processed and any 
            applicable trivia was attached.</summary>
            <param name="node">Node (after trivia attached)</param>
            <param name="parent">Parent of <c>node</c> (old version, before changes to children are applied)</param>
            <param name="indexInParent">Index of <c>node</c> within <c>parent</c>.</param>
            <returns>Should return <c>node</c> or an altered version of <c>node</c>.</returns>
            <remarks>This method gives the derived class one final chance to 
            rearrange or alter the interpretation of the attached trivia. Note
            that this method may be called on some nodes to which trivia was
            not attached, when siblings of the same parent had trivia attached.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.AbstractTriviaInjector`1.Run(System.Collections.Generic.IEnumerator{Loyc.Syntax.LNode})">
            <summary>Attaches trivia to the input nodes provided.</summary>
            <param name="nodes">List of input nodes. This method calls nodes.MoveNext()
            before calling nodes.Current.</param>
            <remarks>Trailing trivia after all nodes is attached to the final node. If 
            <c>nodes</c> is empty then <see cref="M:Loyc.Syntax.AbstractTriviaInjector`1.GetEmptyResultSet"/> is called to
            create a dummy node and attach all trivia to it.</remarks>
        </member>
        <member name="M:Loyc.Syntax.AbstractTriviaInjector`1.RunCore(System.Collections.Generic.IEnumerator{Loyc.Pair{Loyc.Syntax.LNode,System.Int32}},Loyc.Syntax.LNode)">
            <summary>Core trivia associaton algorithm.</summary>
            <remarks>
            NOTE: the enumerator may DRIVE lexing and actually cause the trivia list
            (SortedTrivia) to increase in size. For this reason, this algorithm is careful
            to call nodes.MoveNext() BEFORE getting the current trivia. I'm not sure if this
            precaution is sufficient to preserve trivia in all "streaming" cases, but it
            seems to work in at least most cases.
            </remarks>
        </member>
        <member name="T:Loyc.Syntax.ParserSource`3">
            <summary>An implementation of the LLLPG Parser API, used with the LLLPG
            options <c>inputSource</c> and <c>inputClass</c>.</summary>
            <remarks>
            This derived class simply makes public all of the LLLPG APIs which are 
            marked protected in <see cref="T:Loyc.Syntax.BaseParserForList`3"/>.
            </remarks>
            <typeparam name="Token">Data type of complete tokens in the token list. A 
            token contains the type of a "word" in the program (string, identifier, plus 
            sign, etc.), a value (e.g. the name of an identifier), and a range of 
            characters in the source file. See <see cref="T:Loyc.Syntax.Lexing.ISimpleToken`1"/>.
            Note: Token is usually a small struct; this class does not expect it to
            ever be null.</typeparam>
            <typeparam name="MatchType">A data type, usually int, that represents a 
            token type (identifier, operator, etc.) and implements <see cref="T:System.IEquatable`1"/>
            so it can be compared for equality with other token types; this is also the 
            type of the <see cref="P:Loyc.Syntax.Lexing.ISimpleToken`1.Type"/> property.</typeparam>
            <typeparam name="List">Data type of the list that contains the tokens (one 
            often uses IList{Token}, but one could use <see cref="T:Loyc.Collections.Impl.InternalList`1"/> 
            for potentially higher performance.)</typeparam>
        </member>
        <member name="M:Loyc.Syntax.ParserSource`3.#ctor(`2,`0,Loyc.Syntax.ISourceFile,System.Int32)">
            <inheridoc/>
        </member>
        <member name="M:Loyc.Syntax.ParserSource`3.Reset(`2,`0,Loyc.Syntax.ISourceFile,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="P:Loyc.Syntax.ParserSource`3.TokenTypeToString">
            <summary>Converts from MatchType (usually integer) to string (used in 
            error messages).</summary>
        </member>
        <member name="M:Loyc.Syntax.ParserSource`3.Skip">
            <inheritdoc/>
        </member>
        <member name="T:Loyc.Syntax.ParserSource`2">
            <summary>Alias for ParserSource{Token, int, IList{Token}}.</summary>
            <typeparam name="Token">Token type (one often uses <see cref="T:Loyc.Syntax.Lexing.Token"/>).</typeparam>
            <typeparam name="MatchType">Data type of the Type property of 
            <see cref="T:Loyc.Syntax.Lexing.ISimpleToken`1"/> (often set to int).</typeparam>
        </member>
        <member name="M:Loyc.Syntax.ParserSource`2.#ctor(System.Collections.Generic.IList{`0},`0,Loyc.Syntax.ISourceFile,System.Int32)">
            <inheridoc/>
        </member>
        <member name="M:Loyc.Syntax.ParserSource`2.#ctor(System.Collections.Generic.IEnumerable{`0},`0,Loyc.Syntax.ISourceFile,System.Int32)">
            <inheridoc/>
        </member>
        <member name="M:Loyc.Syntax.ParserSource`2.#ctor(System.Collections.Generic.IEnumerator{`0},`0,Loyc.Syntax.ISourceFile,System.Int32)">
            <inheridoc/>
        </member>
        <member name="T:Loyc.Syntax.ParserSource`1">
            <summary>Alias for ParserSource{Token, int, IList{Token}}.</summary>
            <typeparam name="Token">Token type (one often uses <see cref="T:Loyc.Syntax.Lexing.Token"/>).</typeparam>
        </member>
        <member name="M:Loyc.Syntax.ParserSource`1.#ctor(System.Collections.Generic.IList{`0},`0,Loyc.Syntax.ISourceFile,System.Int32)">
            <inheridoc/>
        </member>
        <member name="M:Loyc.Syntax.ParserSource`1.#ctor(System.Collections.Generic.IEnumerable{`0},`0,Loyc.Syntax.ISourceFile,System.Int32)">
            <inheridoc/>
        </member>
        <member name="M:Loyc.Syntax.ParserSource`1.#ctor(System.Collections.Generic.IEnumerator{`0},`0,Loyc.Syntax.ISourceFile,System.Int32)">
            <inheridoc/>
        </member>
        <member name="T:Loyc.Syntax.Precedence">
            <summary>A four-byte tuple that represents the precedence and miscibility 
            of an operator.</summary>
            <remarks>
            Precedences encode knowledge like the fact that <c>x &amp; y == z</c> will 
            be parsed as <c>x &amp; (y == z)</c> in C#. An operator's precedence is 
            encoded in the two numbers, <see cref="F:Loyc.Syntax.Precedence.Left"/> and <see cref="F:Loyc.Syntax.Precedence.Right"/>.  
            For typical operators which are left-associative, Left and Right are the 
            same. However, some operators have different precedence on the left than 
            on the right, a prime example being the => operator: <c>x = a => y = a</c> 
            is parsed <c>x = (a => (y = a))</c>; it has very high precedence on the 
            left, but very low precedence on the right.
            <para/>
            To understand how this works, remember that a parser scans from left to 
            right. Each time it encounters a new operator, it needs to figure out 
            whether to include that operator in the current (inner) expression or 
            whether to "complete" the inner expression and bind the operator to an
            outer expression instead. The concept of a "precedence floor" can be used 
            to make this decision.
            <para/>
            For example, suppose we start parsing the expression <c>-a.b + c * d + e</c>.
            The parser sees "-" first, which must be a prefix operator since there is 
            no expression on the left. The <see cref="F:Loyc.Syntax.Precedence.Right"/> precedence of unary 
            '-' is 90 in EC#, so that will be the "precedence floor" to parse the 
            right-hand side. Operators above 90 will be permitted in the right-hand 
            side; operators at 90 or below will not.
            <para/>
            The next token is 'a', which is an expression by itself and doesn't have 
            any precedence, so it becomes the initial right-hand expression of '-'.
            Next we have '.', which has a <see cref="F:Loyc.Syntax.Precedence.Left"/> precedence of 100, which 
            is above the precedence floor of 90 so it can be bound to 'a'. The 
            precedence floor (PF) is raised to 100, and the next token 'b' is bound to 
            '.'.
            <para/>
            However, the next token '+' (which must be the binary operator rather than 
            the prefix operator, because there is an expression on the left) cannot be 
            accepted with its precedence of 60. Therefore the expression "a.b" is 
            deemed complete, and the PF is lowered back to 90. Again 60 is less than 
            90, so the expression "-a.b" is also deemed complete and the PF drops to 
            int.MinValue. This expression becomes the left-hand side of the '+' 
            operator. The PF rises to 60, and "c * d" becomes a subexpression because
            the precedence of '*' is 70 > 60. However, next we have '+' with 
            precedence 60, which is not above the PF of 60. Therefore, the 
            subexpression "c * d" is deemed complete and the PF lowers to int.MinValue
            again. Now the '+' can be accepted with a left-hand side of <c>(-(a.b)) + 
            (c * d)</c>, and the right-hand side is, of course, 'e', so the completed
            expression is <c>((-(a.b)) + (c * d)) + e</c>. Hope that helps!
            <para/>
            Notice that <c>a + b + c</c> is parsed <c>(a + b) + c</c>, not 
            <c>a + (b + c)</c>. This is the natural result when the operator's 
            precedence is the same on the left and on the right. However, <c>a = b = c</c>
            is parsed <c>a = (b = c)</c>, because its precedence is 1 on the left and 
            0 on the right. When the parser sees the first '=' it sets the PF to 0 
            because it is about to parse the right side. When it encounters the second 
            '=', the precedence of the Left side of that operator is 1 which is higher 
            than the current PF (0) so it is included in the right-hand side of the 
            first '='. This behavior is called "right associativity"; 
            <see cref="P:Loyc.Syntax.Precedence.IsRightAssociative"/> returns true when <c>Left > Right</c>.
            <para/>
            Prefix and suffix operators only have one "side"; you can imagine that the 
            unused side (e.g. the left side of prefix -) has infinite precedence, so 
            that EC# could parse $-x as $(-x) even though the precedence of '-' is 
            supposedly lower than '$'.
            <para/>
            Some languages have a conditional operator (a?b:c) with three parts. In 
            the middle part, the PF must drop to Precedence.MinValue so that it is 
            possible to parse <c>a?b=x:c</c> even though '=' supposedly has lower 
            precedence than the conditional operator. Note that <c>a=b ? c=d : e=f</c> 
            is interpreted <c>a=(b ? c=d : e)=f</c>, so you can see that the precedence 
            of the conditional operator is higher at the "edges".
            <para/>
            The above explanation illustrates the meaning of Left and Right from the
            perspective of a parser, but an actual parser may or may not use the PF 
            concept and <c>Precedence</c> objects.
            <para/>
            In summary: <see cref="F:Loyc.Syntax.Precedence.Left"/> and <see cref="F:Loyc.Syntax.Precedence.Right"/> represent the 
            precedence of the left and right side of a binary operator. A parser can 
            keep track of a number called the "precedence floor" or PF, which has its 
            minimum value when parsing starts. When a binary operator <c>Op</c> is 
            encountered, the parser should "accept" the operator when <c>O.Left > PF</c>
            and, if it accepts the operator, set <c>PF = O.Right</c> temporarily as it 
            parses the right side of the operator.
            <para/>
            This struct contains two other numbers, <see cref="F:Loyc.Syntax.Precedence.Lo"/> and <see cref="F:Loyc.Syntax.Precedence.Hi"/>,
            which are a precedence range that determines whether and how the operator 
            can be mixed with other operators, as explained below.
            <para/>
            A printer (which writes a syntax tree as text) has a different way of analyzing
            precedence. It starts with a known parse tree and then has to figure out 
            how to output something that the parser will reconstruct into the original
            tree. This is more difficult if perfect round-tripping is required: parentheses
            are encoded in the Loyc tree as a <c>%inParens</c> attribute, so if perfect
            round-tripping is desired, the printer cannot simply put everything in parens 
            "just to be safe".
            <para/>
            The LES and EC# printers have two ways of printing any expression tree: (1) 
            with operators (e.g. a+b), and (2) with prefix notation (e.g. `'+`(a, b)).
            The tree <c>`'+`(`'*`(a, b), c)</c> will be printed as "a*b+c" (unless prefix
            notation is specifically requested) because the precedence rules allow it,
            but <c>`'*`(`'+`(a, b), c)</c> will be printed as <c>`'+`(a, b)*c</c> because 
            both "a+b*c" and "(a+b)*c" are different from the original tree.
            <para/>
            While a parser proceeds from left to right, a printer proceeds from parents
            to children. So the printer for `'*`(`'+`(a, b), c) starts at <c>`'*`</c> with no 
            precedence restrictions, and roughly speaking will set the precedence floor
            to <see cref="T:Loyc.Syntax.Les.LesPrecedence"/>.Multiply in order to print its two children.
            Since the precedence of `'+` (Add) is below Multiply, the + operator is not
            allowed in that context.
            <para/>
            Printing has numerous "gotchas"; the ones related to precedence are
            <ol>
            <li>Although <see cref="T:Loyc.Syntax.Les.LesPrecedence"/>.Add has the "same" precedence on the
                Left and Right, <c>`'-`(`'-`(a, b), c)</c> can be printed <c>a - b - c</c> but
                <c>`'-`(a, `'-`(b, c))</c> would have to be printed <c>a - `'-`(b, c)</c> 
                instead. Clearly, the left and right sides must be treated somehow
                differently.</li>
            <li>Similarly, the different arguments in <c>a?b:c</c> and <c>a=>b</c> must
                be treated differently. And careful handling is needed for the dot 
                operator in particular due to its high precedence; e.g. <c>`'.`(a(b))</c> 
                cannot be printed <c>.a(b)</c> because that would mean <c>`'.`(a)(b)</c>.</li>
            <li>The LES parser, at least, allows a prefix operator to appear on the 
                right-hand side of any infix or prefix operator, regardless of the 
                precedence of the two operators; "$ ++x" is permitted even though ++ has
                lower precedence than $. Another example is that <c>a.-b.c</c> can be 
                parsed with the interpretation <c>a.(-b).c</c>, even though '- has 
                lower precedence than '$. Ideally the printer would replicate this 
                rule, but whether it does ot not, it also must take care that 
                <c>`'.`(a, -b.c)</c> is not printed as <c>a.-b.c</c> even though the 
                similar expression <c>`'*`(a, `'-`(b.c))</c> can be printed as <c>a*-b.c</c>.</li>
            <li>Prefix notation is needed when an operator's arguments have attributes;
                <c>`'+`([Foo] a, b)</c> cannot be printed <c>[Foo] a + b</c> because
                that would mean <c>[Foo] `'+`(a, b)</c>.</li>
            </ol>
            
            <h3>Printing and parsing are different</h3>
            
            This type contains different methods for printers and parsers. A basic 
            difference between them is that printers must make decisions (of whether
            an operator is allowed or not in a given context) based on both sides of
            the operator and both sides of the context (Left and Right), while parsers
            only have to worry about one side. For example, consider the following 
            expression:
            <code>
                a = b + c ?? d
            </code>
            When the parser encounters the "+" operator, it only has to consider 
            whether the precedence of the <i>left-hand side</i> of the "+" operator
            is above the <i>right-hand side</i> of the "=" operator. The fact that
            there is a "??" later on is irrelevant. In contrast, when printing the 
            expression "b + c", both sides of the subexpression and both sides of the 
            context must be considered. The right-hand side is relevant because if 
            the right-hand operator was "*" instead of "??", the following printout 
            would be wrong:
            <code>
                a = b + c * d   // actual syntax tree: a = `'+`(b, c) * d
            </code>
            The same reasoning applies to the left-hand side (imagine if "=" was 
            "*" instead.)
            <para/>
            So, naturally there are different methods for parsing and printing.
            For printing you can use <see cref="M:Loyc.Syntax.Precedence.CanAppearIn(Loyc.Syntax.Precedence)"/>, <see 
            cref="M:Loyc.Syntax.Precedence.LeftContext(Loyc.Syntax.Precedence)"/> and <see cref="M:Loyc.Syntax.Precedence.RightContext(Loyc.Syntax.Precedence)"/>, while for parsing you 
            only need <see cref="M:Loyc.Syntax.Precedence.CanParse(Loyc.Syntax.Precedence)"/> (to raise the precedence floor, simply
            replace the current <see cref="T:Loyc.Syntax.Precedence"/> value with that of the new 
            operator). If one chooses to use this type to represent the precedence 
            floor in a parser, the "current" precedence is represented by <see 
            cref="F:Loyc.Syntax.Precedence.Right"/>; the value of <see cref="F:Loyc.Syntax.Precedence.Left"/> doesn't matter.
            <para/>
            Both printers and parsers can use <see cref="M:Loyc.Syntax.Precedence.CanMixWith(Loyc.Syntax.Precedence)"/>.
            
            <h3>Miscibility (mixability)</h3>
            
            <see cref="F:Loyc.Syntax.Precedence.Lo"/> and <see cref="F:Loyc.Syntax.Precedence.Hi"/> don't affect how operators are
            parsed into a tree, but are used to request a warning or error if operators
            are mixed improperly. If one operator's range overlaps another AND (the 
            ranges are not equal OR <c>Lo > Hi</c>), then the two operators are 
            immiscible. For example, == and != have the same precedence in EC#, 38..39, 
            so they can be mixed with each other, but they cannot be mixed with &amp; 
            which has the overlapping range 32..45 (this will be explained below.)
            Normally Lo and Hi are set to <c>Min(Left,Right)</c> and <c>Max(Left,Right)</c>
            respectively, but this is not required--in particular, any pair where
            <c>Lo > Hi</c> is used to indicate that the operator cannot be mixed with 
            other operators of the same precedence, even though it can (perhaps) be 
            mixed with others of different precedence. This is called non-associativity. 
            For example, in PHP are not allowed to write an expression such as 
            <c>x > y >= z</c>; to represent this, operators <c>></c> and <c>>=</c> 
            should make <c>Lo > Hi</c>.
            <para/>
            Certain operators should not be mixed because their precedence was originally 
            chosen incorrectly, e.g. x &amp; 3 == 1 should be parsed (x &amp; 3) == 1 but is 
            actually parsed x &amp; (3 == 1). To allow the precedence to be repaired 
            eventually, expressions like x &amp; y == z are deprecated in EC#: the parser will 
            warn you if you have mixed operators improperly. PrecedenceRange describes 
            both precedence and miscibility with a simple range of integers. As mentioned
            before, two operators are immiscible if their ranges overlap but are not 
            identical.
            <para/>
            In LES, the precedence range feature (a.k.a. immiscibility) is also used to 
            indicate that a specific precedence has not been chosen for an operator. 
            If a precedence is chosen in the future, it will be somewhere within the 
            range.
            
            <h3>Overall Range</h3>
            
            By convention, precedence scales range from about 0 to about 100.
            The precedence numbers are stored in this structure as <c>sbyte</c>s, so 
            <c>Left</c>, <c>Right</c>, <c>Lo</c>, and <c>Hi</c> must be between -128 
            and 127.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.Precedence.#ctor(System.Int32)">
            <summary>Initializes a left-associative operator with the specified precedence.</summary>
        </member>
        <member name="M:Loyc.Syntax.Precedence.#ctor(System.Int32,System.Int32)">
            <summary>Initializes an operator with different precedence on the left 
            and right sides. For a right associative operator, conventionally 
            <c>right = left-1</c>.</summary>
        </member>
        <member name="M:Loyc.Syntax.Precedence.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>Initializes an operator with the given precedence on the
            left and right sides, and the given immiscibility range (see 
            documentation of this type).</summary>
        </member>
        <member name="F:Loyc.Syntax.Precedence.Lo">
            <summary>Lo and Hi specify the miscibility of an operator; see the 
            remarks of <see cref="T:Loyc.Syntax.Precedence"/> for details.</summary>
        </member>
        <member name="F:Loyc.Syntax.Precedence.Hi">
            <summary>Lo and Hi specify the miscibility of an operator; see the 
            remarks of <see cref="T:Loyc.Syntax.Precedence"/> for details.</summary>
        </member>
        <member name="F:Loyc.Syntax.Precedence.Left">
            <summary>Left and Right denote the precedence level on the left and 
            right sides of an operator; see the remarks of <see cref="T:Loyc.Syntax.Precedence"/> 
            for details.</summary>
        </member>
        <member name="F:Loyc.Syntax.Precedence.Right">
            <summary>Left and Right denote the precedence level on the left and 
            right sides of an operator; see the remarks of <see cref="T:Loyc.Syntax.Precedence"/> 
            for details.</summary>
        </member>
        <member name="M:Loyc.Syntax.Precedence.LeftContext(Loyc.Syntax.Precedence)">
            <summary>For use in printers. Auto-raises the precedence floor to 
            prepare to print an expression on the left side of an operator.</summary>
            <param name="outerContext"></param>
            <returns></returns>
        </member>
        <member name="M:Loyc.Syntax.Precedence.RightContext(Loyc.Syntax.Precedence)">
            <summary>For use in printers. Auto-raises the precedence floor to 
            prepare to print an expression on the right side of an operator.</summary>
            <param name="outerContext">Context in which this operator is being printed</param>
            <returns></returns>
        </member>
        <member name="P:Loyc.Syntax.Precedence.IsRightAssociative">
            <summary>Returns true if this object represents a right-associative 
            operator such as equals (x = (y = z)), in contrast to left-
            associative operators such as division ((x / y) / z).</summary>
        </member>
        <member name="M:Loyc.Syntax.Precedence.CanAppearIn(Loyc.Syntax.Precedence)">
            <summary>For use in printers. Returns true if an infix operator 
            with this precedence can appear in the specified context.</summary>
            <remarks>Miscibility must be checked separately (<see cref="M:Loyc.Syntax.Precedence.CanMixWith(Loyc.Syntax.Precedence)"/>).</remarks>
        </member>
        <member name="M:Loyc.Syntax.Precedence.CanAppearIn(Loyc.Syntax.Precedence,System.Boolean)">
            <summary>For use in printers. Returns true if an operator with 
            this precedence can appear in the specified context (ignoring 
            miscibility).</summary>
            <param name="prefix">It is assumed that the left side of a 
            prefix operator has "infinite" precedence so when this flag is
            true, only the right side is checked.</param>
            <remarks>This prefix rule is used by the EC# printer but is not 
            allowed by all languages (if in doubt, set prefix=false).</remarks>
        </member>
        <member name="M:Loyc.Syntax.Precedence.CanMixWith(Loyc.Syntax.Precedence)">
            <summary>Returns true if an operator with this precedence is miscible
            without parenthesis with the specified other operator.</summary>
            <remarks><see cref="M:Loyc.Syntax.Precedence.CanAppearIn(Loyc.Syntax.Precedence)"/> is for parsability, 
            this method is to detect a deprecated or undefined mixing of operators.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.Precedence.CanParse(Loyc.Syntax.Precedence)">
            <summary>For use in parsers. Returns true if 'rightOp', an operator
            on the right, has higher precedence than the current operator 'this'.</summary>
            <returns><c>rightOp.Left > this.Right</c></returns>
        </member>
        <member name="T:Loyc.Syntax.Impl.PrinterState">
            <summary>A helper type for printer objects. Its primary purposes are to
            manage indentation and to "revoke" newlines; it also tracks the current 
            line/column number.</summary>
            <remarks>
            Be careful not to duplicate this structure.
            <para/>
            When pretty-printing any language as text, it's a challenge to decide
            where to place newlines. You may want to break up long lines into
            shorter ones, as in
            <pre>
            if (ReallyLongIdentifier[Fully.Qualified.Name(multiple, parameters)] 
               > SomeConstant)
            {
               return ReallyLongIdentifier[firstThing + secondThing] 
                  + thirdThing + fourthThing;
            }
            </pre>
            Conversely, you may want to print something on one line that you would
            ordinarily print on two:
            <pre>
                if (c) break;
            </pre>
            Of course, the problem is, you don't know how long the syntax tree 
            will be in text form until after you try to print it.
            <para/>
            My first idea to solve this problem was to use a 
            <a href="https://en.wikipedia.org/wiki/Rope_(data_structure)">rope</a> 
            tree data structure - inner syntax trees would produce small strings 
            that could be "roped" together to produce a bigger tree. But ropes tend
            not to use memory efficiently, and there was the challenge, which I 
            didn't see how to solve, of how to keep the tree balanced efficiently 
            (for this particular application perhaps a balanced tree wasn't needed,
            but as a perfectionist I didn't want to implement a "half-baked" data 
            structure.)
            <para/>
            Next I thought of the solution used here, a simpler solution based on an 
            ordinary StringBuilder. My idea was to insert newlines "pessimistically" 
            - insert them everywhere in which they might be needed - and then 
            selectively "revoke" them later if they turn out to be unnecessary. Only 
            the most recently-written newline(s) can be revoked, which keeps the 
            implementation simple and also limits the performance cost of deleting 
            the newlines.
            <para/>
            To use, call Newline() to write a newline (with indentation). To make 
            a decision about whether to keep or revoke the most recent newline(s), 
            call RevokeOrCommitNewlines(cp, maxLineLength) where cp is a "checkpoint"
            representing some point before the first newline want to potentially
            revoke, and maxLineLength is the line length threshold: if the line length 
            after combining lines, starting at the line on which the checkpoint is 
            located, does not exceed maxLineLength, then the newlines are revoked, 
            otherwise ALL newlines are committed (so earlier newlines can no longer 
            be revoked.)
            <para/>
            This design allows a potentially long series of newlines to be deleted
            in the reverse order that they were created, but if any newline is kept
            then previous ones can no longer be deleted.
            <para/>
            For an example of how this is used, see the JSON printer in LLLPG samples
            or look at the implementation of the LESv3 printer.
            </remarks>
        </member>
        <member name="P:Loyc.Syntax.Impl.PrinterState.Length">
            <summary>Current length of the output string</summary>
        </member>
        <member name="M:Loyc.Syntax.Impl.PrinterState.Newline(System.Int32)">
            <summary>Writes a newline and the appropriate amount of indentation afterward.</summary>
            <param name="changeIndentLevel">Amount by which to change <see cref="F:Loyc.Syntax.Impl.PrinterState.IndentLevel"/> before writing the newline</param>
            <returns>A <see cref="T:Loyc.Syntax.Impl.PrinterState.Checkpoint"/> that can be used to revoke the newline</returns>
            <remarks>Note that "revoking" a newline does NOT restore the original indent level.</remarks>
        </member>
        <member name="M:Loyc.Syntax.Impl.PrinterState.RevokeOrCommitNewlines(Loyc.Syntax.Impl.PrinterState.Checkpoint,System.Int32)">
            <summary>Revokes or commits newlines added since the specified 
            checkpoint. Recent newlines are revoked if the combined line length 
            after revokation does not exceed <c>maxLineWidth</c>, otherwise ALL
            newlines are committed permanently.</summary>
            <returns>0 if the method had no effect, -N if N newlines were 
            revoked, and +N if N newlines were committed.</returns>
            <remarks>This method does not affect the indent level.</remarks>
        </member>
        <member name="M:Loyc.Syntax.Impl.PrinterState.Revoke(Loyc.Syntax.Impl.PrinterState.Revokable)">
            <summary>Revokes (deletes) the last newline created, and its indent.</summary>
            <param name="r">Object returned from Newline()</param>
            <remarks>Only the most recent newline can be revoked, and of course, 
            it can only be revoked once. Multiple newlines can be revoked if 
            they are revoked in the reverse order in which they were created.</remarks>
        </member>
        <member name="T:Loyc.Syntax.IndexPositionMapper`1">
            <summary>
            Helper class for mapping from indexes to SourcePos and back.
            </summary><remarks>
            This class's job is to keep track of the locations of line breaks in order
            to map from indices to SourcePos objects or vice versa. Converting indexes 
            to SourcePos is commonly needed for error reporting; lexers, parsers and 
            code analyzers typically use indexes (simple integers) internally, but must
            convert to SourcePos in order to communicate with the end user. Occasionally
            one may wish to convert in the reverse direction also (SourcePos to index).
            <para/>
            Line breaks themselves are classified as being at the end of each line.
            So if the file is "Bob\nJoe", <c>IndexToLine(3).Line == 1</c>, not 2.
            <para/>
            The outputs are immutable and this class assumes the input file never 
            changes. However, this class is not entirly multi-thread-safe until the 
            entire input file or string has been scanned, since the list of line breaks
            is built on-demand, without locking.
            </remarks>
            <typeparam name="CharSource">A type that implements <c>IListSource(Char)</c>.
            Originally this class did not have any type parameters and dealt with
            <c>IListSource(Char)</c>, but it was made generic so that one could wrap
            value types such as <c>UString</c> without boxing.
            </typeparam>
        </member>
        <member name="M:Loyc.Syntax.IndexPositionMapper`1.#ctor(`0,Loyc.Syntax.SourcePos)">
            <summary>Initializes CharIndexPositionMapper.</summary>
            <param name="source">An immutable list of characters.</param>
            <param name="startingPos">Optional. The first character of <c>source</c> 
            will be considered to have the file name and line number specified by 
            this object. If this is null, IndexToLine() will return a blank file 
            name ("").</param>
        </member>
        <member name="M:Loyc.Syntax.IndexPositionMapper`1.Reset(`0,System.String)">
            <summary>Reinitializes the object (as though the constructor were called again).</summary>
        </member>
        <member name="T:Loyc.Syntax.IndexPositionMapper">
            <summary>Synonym for <c>IndexPositionMapper&lt;IListSource&lt;char>></c>.</summary>
        </member>
        <member name="T:Loyc.Syntax.SourceFile`1">
            <summary>A default implementation of ISourceFile based on <see cref="T:Loyc.Syntax.IndexPositionMapper"/>.</summary>
        </member>
        <member name="T:Loyc.Syntax.SourceFileWithLineRemaps">
            <summary>An wrapper around ISourceFile that applies line remapping 
            information (if the source file uses it).</summary>
            <remarks>
            A preprocessor that supports #line may wrap the original <see 
            cref="T:Loyc.Syntax.ISourceFile"/> in one of these, even when the source file 
            doesn't use #line.
            <para/>
            Call Remaps.AddRemap() and, optionally, Remaps.EndRemap(), to add each
            mapping.
            <para/>
            <see cref="T:Loyc.Syntax.ISourceFile"/> includes <see cref="T:Loyc.Syntax.IIndexPositionMapper"/>
            which allows reverse-mapping from line/position back to index. However,
            a position derived from #line information may be ambiguous (does not 
            always have a unique reverse mapping), and I'd rather avoid the work of 
            reverse mapping anyway. So this class does not perform reverse mapping,
            but forward mappings return <see cref="T:Loyc.Syntax.SourcePosAndIndex"/> which are
            automatically recognized by <see cref="M:Loyc.Syntax.SourceFileWithLineRemaps.LineToIndex(System.Int32)"/> which thereby 
            recovers the original index.
            </remarks>
        </member>
        <member name="T:Loyc.Syntax.SourcePosAndIndex">
            <summary>A <see cref="T:Loyc.Syntax.SourcePos"/> that also includes the original index 
            from which the Line and PosInLine were derived.</summary>
            <remarks>Returned by <see cref="M:Loyc.Syntax.SourceFileWithLineRemaps.IndexToLine(System.Int32)"/>.</remarks>
        </member>
        <member name="T:Loyc.Syntax.LineRemapper">
            <summary>A small helper class for languages such as C# and C++ that permit 
            the locations reported by error messages to be remapped. This class stores
            and applies such commands (#line in C#/C++)</summary>
            <remarks>
            This is part of <see cref="T:Loyc.Syntax.SourceFileWithLineRemaps"/>.
            One LineRemapper should be created per real source file.</remarks>
        </member>
        <member name="M:Loyc.Syntax.LineRemapper.AddRemap(System.Int32,System.Int32,System.String)">
            <summary>Adds a mapping that starts on the specified real line.</summary>
            <remarks>In C++ and C#, a directive like "#line 200" affects the line 
            after the preprocessor directive. So if "#line 200" is on line 10, 
            you'd call AddRemap(11, 200) or possibly AddRemap(10, 199).</remarks>
        </member>
        <member name="M:Loyc.Syntax.LineRemapper.EndRemap(System.Int32)">
            <summary>Corresponds to <c>#line default</c> in C#.</summary>
        </member>
        <member name="M:Loyc.Syntax.LineRemapper.Remap(System.Int32@,System.String@)">
            <summary>Remaps the specified line number, if a remapping has been created that applies to it.</summary>
            <param name="line">On entry, a real line number. On exit, a remapped line number</param>
            <param name="fileName">This is changed to the user-specified file name 
            string, if and only if a file-name remapping exists and applies here.</param>
            <returns>true if a remapping exists and was applied, false if not.</returns>
        </member>
        <member name="T:Loyc.Syntax.StreamCharSource">
            <summary>
            Exposes a stream as an ICharSource, as though it were an array of 
            characters. The stream must support seeking, and if a text decoder 
            is specified, it must meet certain constraints.
            </summary><remarks>
            This class reads small blocks of bytes from a stream, reloading 
            blocks from the stream when necessary. Data is cached with a pair 
            of character buffers, and a third buffer is used to read from the
            stream. A Stream is required rather than a TextReader because
            TextReader doesn't support seeking.
            <para/>
            This class assumes the underlying stream never changes.
            <para/>
            The stream does not (and probably cannot, if I understand the 
            System.Text.Decoder API correctly) save the decoder state at each block 
            boundary. Consequently, only encodings that meet special constraints
            will work with StreamCharSource. These include Encoding.Unicode,
            Encoding.UTF8, and Encoding.UTF32, but not Encoding.UTF7. Using 
            unsupported encodings will cause exceptions and/or or corrupted data 
            output while reading from the StreamCharSource.
            <para/>
            The decoder must meet the following constraints:
            1. Characters must be divided on a byte boundary. UTF-7 doesn't work 
               because some characters are encoded using Base64.
            2. Between characters output by the decoder, the decoder must be 
               stateless. Therefore, encodings that support compression generally 
               won't work.
            3. The decoder must produce at least one character from a group of 
               8 bytes (StreamCharSource.MaxSeqSize).
            </remarks>
        </member>
        <member name="F:Loyc.Syntax.StreamCharSource._blkOffsets">
            <summary>A sorted list of mappings between byte positions and character 
            indexes. In each Pair(of A,B), A is the character index and B is the byte 
            index. This list is built on-demand.
            </summary>
        </member>
        <member name="F:Loyc.Syntax.StreamCharSource._reachedEnd">
            <summary>Set true when the last block has been scanned. If true, then
            _eofIndex and _eofPosition indicate the Count and the size of the 
            stream, respectively.</summary>
        </member>
        <member name="F:Loyc.Syntax.StreamCharSource._eofIndex">
            <summary>_eofIndex is the character index of EOF if it has been reached 
            or, if not, the index of the first unscanned character. _eofIndex 
            equals _blkOffsets[_blkOffsets.Count-1].A.</summary>
        </member>
        <member name="F:Loyc.Syntax.StreamCharSource._eofPosition">
            <summary>_eofPosition is the byte position of EOF if it has been reached 
            or, if not, the position of the first unscanned character. _eofPosition 
            equals _blkOffsets[_blkOffsets.Count-1].B.</summary>
        </member>
        <member name="T:LeMP.IMacroContext">
            <summary>This interface provides services offered by the lexical macro processor (LeMP).</summary>
            <remarks>Macros receive this as their second argument (see <see cref="T:LeMP.LexicalMacro"/>)</remarks>
        </member>
        <member name="P:LeMP.IMacroContext.Sink">
            <summary>Returns the message sink, used for writing warnings and errors.</summary>
            <remarks>For backward compatibility, IMacroContext itself implements 
            IMessageSink also.</remarks>
        </member>
        <member name="P:LeMP.IMacroContext.ScopedProperties">
            <summary>Returns a table of "properties" (arbitrary key-value pairs)
            that exist in the current scope. This dictionary is "persistent" in the
            computer science sense; any changes to these properties affect only the
            current scope and child scopes. When the current scope ends, the set of 
            properties that existed in the parent scope are restored.</summary>
            <remarks>
            Scopes are bounded by curly brace nodes (Call nodes named "{}").
            </remarks>
        </member>
        <member name="P:LeMP.IMacroContext.Ancestors">
            <summary>Returns a list of ancestors of the current node being 
            processed. Normally Ancestors[0] is a #splice node that contains a list 
            of all top-level statements in the file, and Ancestors.Last() is the
            current node.</summary>
            <remarks>You would expect that Ancestors[N] would contain Ancestors[N+1]
            as part of the attributes, target or arguments, but this is not always
            true. The ancestor list contains original versions of each node; when a
            child node is changed by a macro, the parent is not updated in this 
            list, but macro processing continues for the descendants of that child,
            so the ancestor list may occasionally seem incoherent.</remarks>
        </member>
        <member name="P:LeMP.IMacroContext.Parent">
            <summary>Gets the logical parent of the current node, which is 
            <c>Ancestors[Ancestors.Count - 2]</c>, or null if the current node
            is the root node.</summary>
            <remarks>Please note that the current node may not actually exist in 
            the parent node due to changes made earlier to the current node by 
            other macros (or even the same macro); the Parent property still 
            returns the old version of the parent node.</remarks>
        </member>
        <member name="M:LeMP.IMacroContext.PreProcessChildren">
            <summary>Applies all available macros to the current node's children 
            and returns the result.</summary>
            <remarks>
            This method only processes children once. If this method is called 
            again for the same node, it returns a cached result.
            <para/>
            If the currently-running macro fails, the result may be thrown away
            and the effort of processing the children will have been wasted. If
            the macro succeeds, and its <see cref="T:LeMP.LexicalMacroAttribute"/> uses
            the default <c>MacroMode.Normal</c> processing mode, the children 
            will (normally) be processed again after the macro returns.
            </remarks>
        </member>
        <member name="P:LeMP.IMacroContext.RemainingNodes">
            <summary>Gets a list of the remaining nodes (arguments/statements or 
            attributes) after this point in the code stream.</summary>
            <remarks>
            The list is null when processing a target node.
            <para/>
            For example, if your macro is called "macro" and it appears in the
            following context:
            <code>{
              a();
              macro(b());
              c();
              d();
            }</code>
            Then this list will contain two items, c() and d(). Similarly, if
            the context is <c>[a, b, macro(c), d, e]</c> then the list will contain
            the items d and e.
            </remarks>
        </member>
        <member name="P:LeMP.IMacroContext.IsAttribute">
            <summary>Returns true if the current node is in the attribute list of 
            its immediate parent.</summary>
        </member>
        <member name="P:LeMP.IMacroContext.IsTarget">
            <summary>Returns true if the current node is the target of its parent
            call node.</summary>
        </member>
        <member name="P:LeMP.IMacroContext.DropRemainingNodes">
            <summary>Gets or sets a value that indicates whether to drop all 
            remaining node after the current one when the current macro returns.
            This property has no effect if the macro rejects the input by returning 
            null.</summary>
            <remarks>See remarks at <see cref="M:LeMP.MacroContext.GetArgsAndBody(LeMP.IMacroContext,System.Boolean)"/>.</remarks>
        </member>
        <member name="M:LeMP.IMacroContext.PreProcess(Loyc.Collections.VList{Loyc.Syntax.LNode},System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Runs the macro processor on the specified node(s).</summary>
            <param name="input">The node or node list to process.</param>
            <param name="asRoot">If false, the nodes are treated as children of the 
            current node (using the current list of ancestors as a basis); if true,
            the list of parent nodes is cleared.</param>
            <param name="resetOpenNamespaces">If false, the set of open namespaces
            stays the same; if true it is cleared to the set of pre-opened 
            namespaces (<see cref="!:MacroProcessor.PreOpenedNamespaces"/>) and
            macros defined with <see cref="M:LeMP.IMacroContext.RegisterMacro(LeMP.MacroInfo)"/> are forgotten.</param>
            <param name="resetProperties">If true, <see cref="P:LeMP.IMacroContext.ScopedProperties"/>
            is reset to contain only predefined properties.</param>
            <remarks>The node(s)</remarks>
        </member>
        <member name="M:LeMP.IMacroContext.PreProcess(Loyc.Syntax.LNode,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <inheritdoc cref="M:LeMP.IMacroContext.PreProcess(Loyc.Collections.VList{Loyc.Syntax.LNode},System.Boolean,System.Boolean,System.Boolean,System.Boolean)"/>
        </member>
        <member name="P:LeMP.IMacroContext.AllKnownMacros">
            <summary>Gets information about all macros registered with the macro 
            processor, including macros whose namespace has not been opened with
            <c>#importMacros</c>.</summary>
        </member>
        <member name="P:LeMP.IMacroContext.NextTempCounter">
            <summary>Gets the next number to use as a suffix for temporary variables (without incrementing).</summary>
        </member>
        <member name="M:LeMP.IMacroContext.IncrementTempCounter">
            <summary>Gets the next number to use as a suffix for temporary variables, then increments it.</summary>
        </member>
        <member name="M:LeMP.IMacroContext.RegisterMacro(LeMP.MacroInfo)">
            <summary>Registers a new macro in the current scope.</summary>
            <param name="macroInfo"></param>
            <remarks>The macro will be forgotten at the end of the current scope. Macros 
            in child scopes do not shadow macros in outer scopes; if there are macros 
            with the same name in the outer scope, conflicts are handled in the same way 
            as with groups of macros that are imported in the same scope. For example,
            <c>Mode = <see cref="F:LeMP.MacroMode.PriorityOverride"/></c> can be used to make 
            macros that override normal-priority macros.</remarks>
        </member>
        <member name="T:LeMP.MacroContext">
            <summary>Standard extension methods for <see cref="T:LeMP.IMacroContext"/>.</summary>
        </member>
        <member name="M:LeMP.MacroContext.GetArgsAndBody(LeMP.IMacroContext,System.Boolean)">
            <summary>Splits the current node into a pair of "argument" and "body" 
            lists, potentially treating ctx.RemainingNodes as the "body" list.</summary>
            <param name="ctx">Context of the current macro.</param>
            <param name="orRemainingNodes">Whether to use ctx.RemainingNodes as
            the second list if there is no {braces node} at the end of 
            ctx.CurrentNode().Args.</param>
            <returns>A pair where the first item is "arguments" and the second is 
            the "body". If no body was detected then the second list is empty and
            the first list is simply ctx.CurrentNode().Args.</returns>
            <remarks>
            EC# supports a syntax specially designed for macro calls: 
            <code>macroName(args) { stmts; }</code>
            This is stored as a call node with a body, in braces, as its final parameter,
            i.e. it is equivalent to
            <code>macroName(args, { stmts; });</code>
            A similar, but more general feature called "superexpressions" exists in LES.
            <para/>
            Some macros would additionally like to apply themselves to all remaining
            nodes in the current list of statements or expressions, i.e.
            <code>macroName(args); stmts;</code>
            LeMP supports this through the <see cref="P:LeMP.IMacroContext.DropRemainingNodes"/>
            and <see cref="P:LeMP.IMacroContext.RemainingNodes"/> APIs. If your macro wants
            to apply itself to all remaining statements or expressions in the 
            current sequence of nodes, it can set the DropRemainingNodes property 
            to true and then simply incorporate RemainingNodes into its own output
            (if you need to return multiple statements from your macro, use 
            <c>list.AsLNode(CodeSymbols.Splice)</c> to convert a VList{LNode} to an 
            LNode.)
            <para/>
            This extension method helps you by detecting whether the current node
            has a body in braces or not. If the braces are present, the returned
            pair consists of the args shortened by one (i.e.
            <c>ctx.CurrentNode().Args.WithoutLast(1)</c>) and the Args of the "{}"
            braces node. Otherwise, <c>ctx.CurrentNode().Args</c> is the first item
            in the pair.
            <para/>
            In the latter case, if <c>orRemainingNodes</c> then this method sets
            <c>ctx.DropRemainingNodes</c> to true and uses <c>ctx.RemainingNodes</c>
            as the second list. Otherwise the second list is left blank.
            </remarks>
        </member>
        <member name="M:LeMP.MacroContext.GetOptions(Loyc.Collections.VList{Loyc.Syntax.LNode})">
            <summary>Transforms an option list in the format <c>option1(v1), option2(v2)</c> 
            or <c>option1: v1, option2: v2</c> into a sequence of (key, value) pairs.
            If the format of a given node is invalid, this function yields <c>(node, null)</c>.</summary>
            <remarks>
            <c>option1: v1, option2: v2</c> is parsed into <c>@`'::=`(option1, v1), 
            @`'::=`(option2, v2)</c> in EC# or <c>@`':`(option1, v1), @`':`(option2, v2)</c> in LES.
            </remarks>
        </member>
        <member name="T:LeMP.LexicalMacro">
            <summary>Method signature of an LeMP macro.</summary>
            <param name="node">The node that caused the macro to be invoked (includes 
            the name of the macro itself, and any attributes applied to the macro)</param>
            <param name="context">This is a dual-purpose object. Firstly, this object
            implements <see cref="T:Loyc.IMessageSink"/>. if the input does not have a valid 
            form, the macro rejects it by returning null. Before returning null, the 
            macro should explain the reason for the rejection (including a pattern that 
            the macro accepts) by writinga message to this object. Secondly, this 
            object contains additional information including the ancestors of the 
            current node and a list of "scoped properties" (see <see cref="T:LeMP.IMacroContext"/>.)
            </param>
            <returns>A node to replace the original <c>node</c>, or null if this 
            macro rejects the input node. Returning null can allow a different macro 
            to accept the node instead.</returns>
            <remarks>If there are multiple macros in scope with the same name, they 
            are <i>all</i> called. Macro expansion succeeds if exactly one macro accepts 
            the input. If no macros accept the input, the error message given by each
            macro is printed; if multiple macros accept the input, an ambiguity error
            is printed.
            <para/>
            When the macro processor scans an assembly looking for macros, it requires
            <see cref="T:LeMP.ContainsMacrosAttribute"/> on the containing class, and 
            <see cref="T:LeMP.LexicalMacroAttribute"/> on each macro in the class. The macros 
            must be public static methods.
            </remarks>
        </member>
        <member name="T:LeMP.ContainsMacrosAttribute">
            <summary>Marks a class to be searched for macros.</summary>
            <remarks>The method signature of a macro must be <see cref="T:LeMP.LexicalMacro"/> and
            it must be marked with <see cref="T:LeMP.LexicalMacroAttribute"/>.</remarks>
        </member>
        <member name="T:LeMP.LexicalMacroAttribute">
            <summary>Marks a method as a LeMP lexical macro.</summary>
            <remarks>
            To be recognized as a macro, the method must be public and static and its 
            signature must be <see cref="T:LeMP.LexicalMacro"/>. A class will not be automatically
            searched for macros unless the class is marked with <see cref="T:LeMP.ContainsMacrosAttribute"/>.</remarks>
        </member>
        <member name="M:LeMP.LexicalMacroAttribute.#ctor(System.String,System.String,System.String[])">
            <summary>LexicalMacroAttribute constuctor.</summary>
            <param name="syntax">A string that shows the expected syntax used to call the node.</param>
            <param name="description"></param>
            <param name="names"></param>
        </member>
        <member name="T:LeMP.MacroMode">
            <summary>Flags that affect the way that <see cref="!:LeMP.MacroProcessor"/>
            uses a LexicalMacro.</summary>
        </member>
        <member name="F:LeMP.MacroMode.Normal">
            <summary>The macro's result is reprocessed directly (this is the default behavior).</summary>
        </member>
        <member name="F:LeMP.MacroMode.NoReprocessing">
            <summary>The macro's result (including children) is not processed further. 
            This flag only takes effect when the macro accepts the input by returning a non-null result.</summary>
        </member>
        <member name="F:LeMP.MacroMode.ProcessChildrenAfter">
            <summary>The macro's result is not reprocessed, but the result's children are processed. 
            This flag only takes effect when the macro accepts the input by returning a non-null result.</summary>
        </member>
        <member name="F:LeMP.MacroMode.ProcessChildrenBefore">
            <summary>The result is pre-processed before calling the macro, and not processed afterward
            (if the macro accepts the input by returning a non-null result).</summary>
        </member>
        <member name="F:LeMP.MacroMode.Passive">
            <summary>It is normal for this macro not to change the code, so a warning should not be printed when the macro "rejects" the input by returning null.</summary>
        </member>
        <member name="F:LeMP.MacroMode.AllowDuplicates">
            <summary>If this macro is ambiguous with one or more macro of the same priority, this flag blocks the ambiguity error message if all the macros produce equivalent results.</summary>
        </member>
        <member name="F:LeMP.MacroMode.DropRemainingListItems">
            <summary>If this macro succeeds, all nodes after this one in the current attribute or statement/argument list are dropped.</summary>
            <remarks>This option may be used by macros that splice together the list of <see cref="P:LeMP.IMacroContext.RemainingNodes"/> into their own result.
            It is more common, however, to set the <see cref="P:LeMP.IMacroContext.DropRemainingNodes"/> property inside the macro.</remarks>
        </member>
        <member name="F:LeMP.MacroMode.MatchIdentifier">
            <summary>If this flag is present, the macro can match a plain identifier. By default, only calls can be treated as macros.</summary>
            <remarks>This flag does <i>not</i> prevent the macro from matching calls.</remarks>
        </member>
        <member name="F:LeMP.MacroMode.PriorityFallbackMin">
            <summary>Lowest priority. If this macro is ambiguous with another macro that doesn't have this flag, the results produced by the other macro are used (note: only one priority flag can be used at a time).</summary>
        </member>
        <member name="F:LeMP.MacroMode.PriorityFallback">
            <summary>Low priority. If this macro is ambiguous with another macro that doesn't have this flag nor FallbackMin, the results produced by the other macro are used (note: only one priority flag can be used at a time).</summary>
        </member>
        <member name="F:LeMP.MacroMode.PriorityInternalFallback">
            <summary>Used to order behavior of standard macros.</summary>
        </member>
        <member name="F:LeMP.MacroMode.PriorityNormal">
            <summary>Normal priority (this is the default and does not need to be specified.)</summary>
        </member>
        <member name="F:LeMP.MacroMode.PriorityInternalOverride">
            <summary>Used to order behavior of standard macros.</summary>
        </member>
        <member name="F:LeMP.MacroMode.PriorityOverride">
            <summary>High priority. If this macro is ambiguous with another macro that doesn't have this flag nor OverrideAll, this macro takes precedence (note: only one priority flag can be used at a time).</summary>
        </member>
        <member name="F:LeMP.MacroMode.PriorityOverrideMax">
            <summary>Highest priority. If this macro is ambiguous with another macro that doesn't have this flag, the results produced by this macro are used (note: only one priority flag can be used at a time).</summary>
        </member>
        <member name="F:LeMP.MacroMode.PriorityMask">
            <summary>For internal use to isolate the priority of a macro.</summary>
        </member>
        <member name="T:LeMP.MacroInfo">
            <summary>Data returned from <see cref="P:LeMP.IMacroContext.AllKnownMacros"/></summary>
        </member>
        <member name="M:LeMP.MacroInfo.GetMacros(System.Type,Loyc.IMessageSink,Loyc.Symbol,System.Object)">
            <summary>Uses reflection to find a list of macros within the specified 
            type by searching for (static) methods that
            (1) are marked with <see cref="T:LeMP.LexicalMacroAttribute"/> and
            (2) take no parameters and return a list (IEnumerable) of 
                <see cref="T:LeMP.MacroInfo"/>. Such methods are called to get macros.
            </summary>
            <param name="type">The type to search for macros.</param>
            <param name="namespace">Optionally overrides the namespace associated 
            with macros marked with <see cref="T:LeMP.LexicalMacroAttribute"/>. Does not
            affect macros returned in a list of <see cref="T:LeMP.MacroInfo"/>.</param>
            <param name="errorSink">An object in which to send error messages
            (<see cref="F:Loyc.Severity.Warning"/> is used because unavailability of a macro
            should not appear as an error when compiling something with LeMP.)</param>
            <param name="instance">An optional object of the same type as <c>type</c>, 
            which will be used to bind instance methods. If this is null, only static
            methods are discovered.</param>
            <returns></returns>
        </member>
    </members>
</doc>
