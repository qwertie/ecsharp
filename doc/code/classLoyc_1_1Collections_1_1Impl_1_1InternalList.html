<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>Enhanced C#: Loyc.Collections.Impl.InternalList Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Enhanced C#
   </div>
   <div id="projectbrief">Language of your choice: library documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Events</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceLoyc.html">Loyc</a></li><li class="navelem"><a class="el" href="namespaceLoyc_1_1Collections.html">Collections</a></li><li class="navelem"><a class="el" href="namespaceLoyc_1_1Collections_1_1Impl.html">Impl</a></li><li class="navelem"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1InternalList.html">InternalList</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classLoyc_1_1Collections_1_1Impl_1_1InternalList-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Loyc.Collections.Impl.InternalList Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Contains static methods to help manage raw arrays with even less overhead than InternalList{T}.  
 <a href="classLoyc_1_1Collections_1_1Impl_1_1InternalList.html#details">More...</a></p>
<hr/><b>Source file</b>:<ul>
<li><a href='https://github.com/qwertie/ecsharp/tree/master/Core/Loyc.Essentials/Collections/Implementations/InternalList.cs'>/Core/Loyc.Essentials/Collections/Implementations/InternalList.cs</a></li>
</ul>
<a name="details" id="details"></a><h2 class="groupheader">Remarks</h2>
<div class="textblock"><p>Contains static methods to help manage raw arrays with even less overhead than InternalList{T}. </p>
<p>The methods of this class are used by some data structures that contain arrays but, for whatever reason, don't use InternalList{T}. These methods are also used by InternalList(T) itself. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a81e3bc6b3affa8ac84dc135bdddca8c3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1InternalList.html">InternalList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1InternalList.html#a81e3bc6b3affa8ac84dc135bdddca8c3">AsInternalList&lt; T &gt;</a> (this T[] array)</td></tr>
<tr class="memdesc:a81e3bc6b3affa8ac84dc135bdddca8c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an array to <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1InternalList.html" title="Contains static methods to help manage raw arrays with even less overhead than InternalList{T}. ">InternalList</a> (exists to help infer type params) <a href="#a81e3bc6b3affa8ac84dc135bdddca8c3">More...</a><br /></td></tr>
<tr class="separator:a81e3bc6b3affa8ac84dc135bdddca8c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac20a5441804605612161c4a53040780f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac20a5441804605612161c4a53040780f"></a>
static <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1InternalList.html">InternalList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>AsInternalList&lt; T &gt;</b> (this T[] array, int count)</td></tr>
<tr class="separator:ac20a5441804605612161c4a53040780f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d266d22382c0f4d03180e8218510586"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d266d22382c0f4d03180e8218510586"></a>
static T[]&#160;</td><td class="memItemRight" valign="bottom"><b>CopyToNewArray&lt; T &gt;</b> (T[] _array, int _count, int newCapacity)</td></tr>
<tr class="separator:a6d266d22382c0f4d03180e8218510586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedf36702f4317f3da5686e5df7da450c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aedf36702f4317f3da5686e5df7da450c"></a>
static T[]&#160;</td><td class="memItemRight" valign="bottom"><b>CopyToNewArray&lt; T &gt;</b> (T[] array)</td></tr>
<tr class="separator:aedf36702f4317f3da5686e5df7da450c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a403fc790956e4a63f42c6ab3f542387a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a403fc790956e4a63f42c6ab3f542387a"></a>
static <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Fill&lt; T &gt;</b> (T[] array, T value)</td></tr>
<tr class="separator:a403fc790956e4a63f42c6ab3f542387a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba84d0fb186c39c0d0258854433c3ada"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba84d0fb186c39c0d0258854433c3ada"></a>
static <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Fill&lt; T &gt;</b> (T[] array, int start, int count, T value)</td></tr>
<tr class="separator:aba84d0fb186c39c0d0258854433c3ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fcef99532671b036c58aa630dc918d9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0fcef99532671b036c58aa630dc918d9"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>BinarySearch&lt; T &gt;</b> (T[] array, int count, T k, Comparer&lt; T &gt; comp, bool lowerBound)</td></tr>
<tr class="separator:a0fcef99532671b036c58aa630dc918d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af532934af0a67a3b220dec9f408c2002"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1InternalList.html#af532934af0a67a3b220dec9f408c2002">BinarySearch&lt; T, K &gt;</a> (T[] _array, int _count, K k, Func&lt; T, K, int &gt; compare, bool lowerBound)</td></tr>
<tr class="memdesc:af532934af0a67a3b220dec9f408c2002"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a binary search with a custom comparison function. <a href="#af532934af0a67a3b220dec9f408c2002">More...</a><br /></td></tr>
<tr class="separator:af532934af0a67a3b220dec9f408c2002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0384fdf592153047a308fd892264b87"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1InternalList.html#ae0384fdf592153047a308fd892264b87">BinarySearchByIndex&lt; Anything &gt;</a> (Anything data, int count, Func&lt; int, Anything, int &gt; compare, bool lowerBound)</td></tr>
<tr class="memdesc:ae0384fdf592153047a308fd892264b87"><td class="mdescLeft">&#160;</td><td class="mdescRight">A binary search function that knows nothing about the list being searched. <a href="#ae0384fdf592153047a308fd892264b87">More...</a><br /></td></tr>
<tr class="separator:ae0384fdf592153047a308fd892264b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67237483d2a46817b1110819e55a47b2"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1InternalList.html#a67237483d2a46817b1110819e55a47b2">NextLargerSize</a> (int than)</td></tr>
<tr class="memdesc:a67237483d2a46817b1110819e55a47b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">As an alternative to the typical enlarging pattern of doubling the array size when it overflows, this function proposes a 75% size increase instead (100% when the array is small), while ensuring that the array length stays even. <a href="#a67237483d2a46817b1110819e55a47b2">More...</a><br /></td></tr>
<tr class="separator:a67237483d2a46817b1110819e55a47b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c4dda441e29fb723f65a1169f82ba57"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1InternalList.html#a7c4dda441e29fb723f65a1169f82ba57">NextLargerSize</a> (int than, int capacityLimit)</td></tr>
<tr class="memdesc:a7c4dda441e29fb723f65a1169f82ba57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1InternalList.html#a67237483d2a46817b1110819e55a47b2" title="As an alternative to the typical enlarging pattern of doubling the array size when it overflows...">NextLargerSize(int)</a>, but allows you to specify a capacity limit, to avoid wasting memory when a collection has a known maximum size. <a href="#a7c4dda441e29fb723f65a1169f82ba57">More...</a><br /></td></tr>
<tr class="separator:a7c4dda441e29fb723f65a1169f82ba57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ea24143424405445f89bcf7a83e2fac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ea24143424405445f89bcf7a83e2fac"></a>
static T[]&#160;</td><td class="memItemRight" valign="bottom"><b>Insert&lt; T &gt;</b> (int index, T item, T[] array, int count)</td></tr>
<tr class="separator:a3ea24143424405445f89bcf7a83e2fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a700dd61170e15f7541e7f9868db68683"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a700dd61170e15f7541e7f9868db68683"></a>
static T[]&#160;</td><td class="memItemRight" valign="bottom"><b>InsertRangeHelper&lt; T &gt;</b> (int index, int spaceNeeded, T[] array, int count)</td></tr>
<tr class="separator:a700dd61170e15f7541e7f9868db68683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58ed3a809f5d1dfc6dc925850633636c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a58ed3a809f5d1dfc6dc925850633636c"></a>
static T[]&#160;</td><td class="memItemRight" valign="bottom"><b>AutoRaiseCapacity&lt; T &gt;</b> (T[] array, int count, int more, int capacityLimit)</td></tr>
<tr class="separator:a58ed3a809f5d1dfc6dc925850633636c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ca8281a123a177ccc846e9ec84e5fa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a29ca8281a123a177ccc846e9ec84e5fa"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>RemoveAt&lt; T &gt;</b> (int index, T[] array, int count)</td></tr>
<tr class="separator:a29ca8281a123a177ccc846e9ec84e5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bd513b5766651a8e373d1da8ce0e088"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8bd513b5766651a8e373d1da8ce0e088"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>RemoveAt&lt; T &gt;</b> (int index, int removeCount, T[] array, int count)</td></tr>
<tr class="separator:a8bd513b5766651a8e373d1da8ce0e088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1d1e6ac6833a36cae1b167847728960"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae1d1e6ac6833a36cae1b167847728960"></a>
static <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Move&lt; T &gt;</b> (T[] array, int from, int to)</td></tr>
<tr class="separator:ae1d1e6ac6833a36cae1b167847728960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7596078fa469550e50b8842f98f5fdb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1InternalList.html#aa7596078fa469550e50b8842f98f5fdb">Sort&lt; T &gt;</a> (T[] array, int index, int count, Comparison&lt; T &gt; comp)</td></tr>
<tr class="memdesc:aa7596078fa469550e50b8842f98f5fdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a quicksort using a Comparison function. <a href="#aa7596078fa469550e50b8842f98f5fdb">More...</a><br /></td></tr>
<tr class="separator:aa7596078fa469550e50b8842f98f5fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebed4469557e373d41f07381b76da675"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1InternalList.html#aebed4469557e373d41f07381b76da675">InsertionSort&lt; T &gt;</a> (T[] array, int index, int count, Comparison&lt; T &gt; comp)</td></tr>
<tr class="memdesc:aebed4469557e373d41f07381b76da675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an insertion sort. <a href="#aebed4469557e373d41f07381b76da675">More...</a><br /></td></tr>
<tr class="separator:aebed4469557e373d41f07381b76da675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a680c095155a9da633cb557aadd8e0d6a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a680c095155a9da633cb557aadd8e0d6a"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>AllEqual&lt; T &gt;</b> (this <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1InternalList.html">InternalList</a>&lt; T &gt; a, <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1InternalList.html">InternalList</a>&lt; T &gt; b)</td></tr>
<tr class="separator:a680c095155a9da633cb557aadd8e0d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aa6d3d8ea701ddeceb37fef402104e1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3aa6d3d8ea701ddeceb37fef402104e1"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>AllEqual&lt; T &gt;</b> (T[] a, T[] b, int count)</td></tr>
<tr class="separator:a3aa6d3d8ea701ddeceb37fef402104e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a81e3bc6b3affa8ac84dc135bdddca8c3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1InternalList.html">InternalList</a>&lt;T&gt; Loyc.Collections.Impl.InternalList.AsInternalList&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">this T[]&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts an array to <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1InternalList.html" title="Contains static methods to help manage raw arrays with even less overhead than InternalList{T}. ">InternalList</a> (exists to help infer type params)</p>

</div>
</div>
<a class="anchor" id="af532934af0a67a3b220dec9f408c2002"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int Loyc.Collections.Impl.InternalList.BinarySearch&lt; T, K &gt; </td>
          <td>(</td>
          <td class="paramtype">T[]&#160;</td>
          <td class="paramname"><em>_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">K&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; T, K, int &gt;&#160;</td>
          <td class="paramname"><em>compare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lowerBound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a binary search with a custom comparison function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_array</td><td>Array to search</td></tr>
    <tr><td class="paramname">_count</td><td>Number of elements used in the array</td></tr>
    <tr><td class="paramname">k</td><td>A key to compare with elements of the array</td></tr>
    <tr><td class="paramname">compare</td><td>Lambda function that knows how to compare Ts with Ks (T and K can be the same). It is passed a series of elements from the array. It must return 0 if the element has the desired value, 1 if the supplied element is higher than desired, and -1 if it is lower than desired.</td></tr>
    <tr><td class="paramname">lowerBound</td><td>Whether to find the "lower bound" in case there are duplicates in the list. If duplicates exist of the search key k, the lowest index of a matching duplicate is returned. This search mode may be slightly slower when a match exists.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the matching array entry, if found. If no exact match was found, this method returns the bitwise complement of an insertion location that would preserve the order.</dd></dl>
<p>// The first 6 elements are sorted. The seventh is invalid, // and must be excluded from the binary search. int[] array = new int[] { 0, 10, 20, 30, 40, 50, -1 }; // The result will be 2, because array[2] == 20. int a = InternalList.BinarySearch(array, 6, i =&gt; i.CompareTo(20)); // The result will be ~2, which equals -3, because index 2 would // be the correct place to insert 17 to preserve the sort order. int b = InternalList.BinarySearch(array, 6, i =&gt; i.CompareTo(17)); </p>

</div>
</div>
<a class="anchor" id="ae0384fdf592153047a308fd892264b87"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int Loyc.Collections.Impl.InternalList.BinarySearchByIndex&lt; Anything &gt; </td>
          <td>(</td>
          <td class="paramtype">Anything&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; int, Anything, int &gt;&#160;</td>
          <td class="paramname"><em>compare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lowerBound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A binary search function that knows nothing about the list being searched.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Anything</td><td>Any data type relevant to the caller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>State information to be passed to compare()</td></tr>
    <tr><td class="paramname">count</td><td>Number of items in the list being searched</td></tr>
    <tr><td class="paramname">compare</td><td>Comparison method that is given the current index to examine and the state parameter "data".</td></tr>
    <tr><td class="paramname">lowerBound</td><td>Whether to find the "lower bound" in case there are duplicates in the list. If duplicates exist of the search key k exist, the lowest index of a matching duplicate is returned. This search mode may be slightly slower when a match exists.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the matching index, if found. If no exact match was found, this method returns the bitwise complement of an insertion location that would preserve the sort order.</dd></dl>

</div>
</div>
<a class="anchor" id="aebed4469557e373d41f07381b76da675"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structLoyc_1_1void.html">void</a> Loyc.Collections.Impl.InternalList.InsertionSort&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">T[]&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparison&lt; T &gt;&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs an insertion sort.</p>
<p>The insertion sort is a stable sort algorithm that is slow in general (O(N^2)). It should be used only when (a) the list to be sorted is short (less than about 20 elements) or (b) the list is very nearly sorted already.</p>
<dl class="section see"><dt>See also</dt><dd>ListExt.InsertionSort</dd></dl>

</div>
</div>
<a class="anchor" id="a67237483d2a46817b1110819e55a47b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int Loyc.Collections.Impl.InternalList.NextLargerSize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>than</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>As an alternative to the typical enlarging pattern of doubling the array size when it overflows, this function proposes a 75% size increase instead (100% when the array is small), while ensuring that the array length stays even.</p>
<p>With a seed of 0, 2, or 4: 0, 2, 4, 8, 16, 30, 54, 96, 170, 298, 522...<br />
 With a seed of 1: 1, 2, 4, 8, 16, 30, 54, 96, 170, 298, 522...<br />
 With a seed of 3: 3, 6, 12, 22, 40, 72, 128, 226, 396...<br />
 With a seed of 5: 5, 10, 18, 32, 58, 102, 180, 316, 554...<br />
 With a seed of 7: 7, 14, 26, 46, 82, 144, 254, 446, 782... </p>
<p>75% size increases require 23.9% more allocations than size doubling (1.75 to the 1.239th power is about 2.0), but memory utilization is increased. With size doubling, the average list uses 2/3 of its entries, but with this resizing pattern, the average list uses 72.72% of its entries. The average size of a list is 8.3% lower. Originally I used 50% size increases, but they required 71% more allocations, which seemed like too much. </p>

</div>
</div>
<a class="anchor" id="a7c4dda441e29fb723f65a1169f82ba57"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int Loyc.Collections.Impl.InternalList.NextLargerSize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>than</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>capacityLimit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1InternalList.html#a67237483d2a46817b1110819e55a47b2" title="As an alternative to the typical enlarging pattern of doubling the array size when it overflows...">NextLargerSize(int)</a>, but allows you to specify a capacity limit, to avoid wasting memory when a collection has a known maximum size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">than</td><td>Return value will be larger than this number.</td></tr>
    <tr><td class="paramname">capacityLimit</td><td>Maximum value to return. This parameter is ignored if it than &gt;= capacityLimit.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Produces the same result as <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1InternalList.html#a67237483d2a46817b1110819e55a47b2" title="As an alternative to the typical enlarging pattern of doubling the array size when it overflows...">NextLargerSize(int)</a> unless the return value would be near capacityLimit (and capacityLimit <blockquote class="doxtable">
<p>than). If the return value would be more than capacityLimit, </p>
</blockquote>
capacityLimit is returned instead. If the return value would be slightly less than capacityLimit (within 20%) then capacityLimit is returned, to ensure that another reallocation will not be required later.</dd></dl>

</div>
</div>
<a class="anchor" id="aa7596078fa469550e50b8842f98f5fdb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structLoyc_1_1void.html">void</a> Loyc.Collections.Impl.InternalList.Sort&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">T[]&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparison&lt; T &gt;&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a quicksort using a Comparison function.</p>
<p>Normally one uses Array.Sort for sorting arrays. This method exists because there is no Array.Sort overload that accepts both a Comparison and a range (index, count), nor does the .NET framework provide access to its internal adapter that converts Comparison to IComparer. </p>
<p>This quicksort algorithm uses a best-of-three pivot so that it remains performant (fast) if the input is already sorted. It is designed to perform reasonably well in case the data contains many duplicates (not verified). It is also designed to avoid using excessive stack space if a worst-case input occurs that requires O(N^2) time. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Mar 24 2016 09:04:52 for Enhanced C# by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
