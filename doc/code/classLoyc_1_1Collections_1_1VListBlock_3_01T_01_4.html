<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>Loyc: Loyc.Collections.VListBlock&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Loyc
   </div>
   <div id="projectbrief">Language of your choice: library documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Events</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceLoyc.html">Loyc</a></li><li class="navelem"><a class="el" href="namespaceLoyc_1_1Collections.html">Collections</a></li><li class="navelem"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock_3_01T_01_4.html">VListBlock< T ></a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#properties">Properties</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected fields</a> &#124;
<a href="classLoyc_1_1Collections_1_1VListBlock_3_01T_01_4-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Loyc.Collections.VListBlock&lt; T &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>VListBlock implements the core functionality of FVList, RVList, FWList and RWList. It is not intended to be used directly.  
 <a href="classLoyc_1_1Collections_1_1VListBlock_3_01T_01_4.html#details">More...</a></p>
<hr/>Source code:<ul>
<li><a href='https://github.com/qwertie/Loyc/blob/master/Src/Loyc.Collections/VLists/VListBlock.cs'>/Src/Loyc.Collections/VLists/VListBlock.cs</a></li>
</ul>
<div class="dynheader">
Inheritance diagram for Loyc.Collections.VListBlock&lt; T &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classLoyc_1_1Collections_1_1VListBlock_3_01T_01_4.png" usemap="#Loyc.Collections.VListBlock&lt; T &gt;_map" alt=""/>
  <map id="Loyc.Collections.VListBlock&lt; T &gt;_map" name="Loyc.Collections.VListBlock&lt; T &gt;_map">
<area href="classLoyc_1_1Collections_1_1VListBlockArray_3_01T_01_4.html" title="Implementation of VListBlock(of T) that contains an array. It is always initialized with at least one..." alt="Loyc.Collections.VListBlockArray&lt; T &gt;" shape="rect" coords="0,56,237,80"/>
<area href="classLoyc_1_1Collections_1_1VListBlockOfTwo_3_01T_01_4.html" title="The tail of a VList contains only one or two items. To improve efficiency slightly, these two-item lists are represented by a VListBlockOfTwo, which is more compact than VListBlockArray." alt="Loyc.Collections.VListBlockOfTwo&lt; T &gt;" shape="rect" coords="247,56,484,80"/>
</map>
 </div></div>
<a name="details" id="details"></a><h2 class="groupheader">Remarks</h2>
<div class="textblock"><p>VListBlock implements the core functionality of FVList, RVList, FWList and RWList. It is not intended to be used directly. </p>
<p>VList is a persistent list data structure described in Phil Bagwell's 2002 paper "Fast Functional Lists, Hash-Lists, Deques and Variable Length
Arrays". I (David P) call the .NET equivalent "FVList" or "forward VList". In the forward VList, the "beginning" of the list (index 0) is by far the fastest place to insert items. </p>
<p>This is unnatural in .NET, so I also created a second data structure, the "reverse" VList or RVList, in which the end of the list (index Count-1) is the natural location for adding items. To achieve this, the RVList sees the same elements as a FVList, but in reverse order. </p>
<p>FWList and RWList are the names I picked for the mutable (Writable) variants of FVList and RVList. </p>
<p>A persistent list is a list that is normally considered immutable, so adding an item implies creating a new list rather than changing the one you've got. This is fast because persistent lists have a sort of copy-on-write semantics, so that "copying" a list is a trivial O(1) operation, but modifying a list is sometimes quite inefficient. My implementation of VLists presents a mutable IList(of T) interface, but this is only to adhere to .NET Framework conventions. FVList and RVList are value types that update their own references to the list when they are modified. Thus, "Copying" a list is done with a simple assignment statement. For example: </p><div class="fragment"><div class="line">RVList&amp;lt;<span class="keywordtype">int</span>&amp;gt; a = <span class="keyword">new</span> RVList&amp;lt;<span class="keywordtype">int</span>&amp;gt;(), b = <span class="keyword">new</span> RVList&amp;lt;<span class="keywordtype">int</span>&amp;gt;();</div>
<div class="line">a.Add(1);</div>
<div class="line">a.Add(2);</div>
<div class="line">b = a;             <span class="comment">// copy the list</span></div>
<div class="line">a.Add(3);          <span class="comment">// a[0] is 1, a[1] is 2, a[2] is 3</span></div>
<div class="line">b.Add(97);         <span class="comment">// b[0] is 1, b[1] is 2, b[2] is 97</span></div>
</div><!-- fragment --><p> Traditionally, this kind of behavior was accomplished with singly-linked lists, but FVList does it with (in essence) a singly-linked list of arrays and thereby saves memory while allowing some operations to be done faster than they were done with linked lists. In pathological cases, however, FVList can use much more memory than a linked list and degenerate so that its performance characteristics are almost as bad as a linked list. One major problem that comes to mind is if you keep changing the last item: </p><div class="fragment"><div class="line">RVList&amp;lt;<span class="keywordtype">int</span>&amp;gt; list = <span class="keyword">new</span> RVList&amp;lt;<span class="keywordtype">int</span>&amp;gt;();</div>
<div class="line">... add some items to list ...</div>
<div class="line">for(<span class="keywordtype">int</span> n;; n++)</div>
<div class="line">    list[list.Count-1] = n;</div>
</div><!-- fragment --><p> Unlike, for example, a C++-based FVList implementation, it is impossible for the FVList or RVList, which are value types, to know if the list has been "copied" or not. In case the list has been copied, changing any element requires a copy to be made of the VListBlock that contains that element, as well as any subsequent blocks (in this example, only the last block must be copied). Thus, the above example produces a lot of garbage very quickly; in fact the rate of garbage production is (very roughly) proportional to the list length. The performance will be equally bad if you repeatedly remove the last item and then re-add it. </p>
<p>Since this kind of problem tends to get worse as the list gets larger, Phil Bagwell proposed using a two- or three-dimentional list arrangement so that no single block could exceed a certain size. I have not implemented that suggestion due to lack of free time and because I did not understand the details of his suggested implementation, but I have placed a size limit of 1024 elements on any given block. Unfortunately, this means that some operations listed below degrade toward O(N) when the list is large, most notably including the indexer, which requires over 1000 iterations to look up element zero in an RVList that has one million elements. </p>
<p>Due to the slow performance you get from operations like this, I decided to implement FWList, a mutable version of the FVList, which I'll discuss later. </p>
<p>Similarly to a persistent linked list, </p><ul>
<li>
Adding an item to the front of a VList or the end of an RVList is always O(1) in time, and often O(1) in space (though, unlike a linked list, it may be much more) </li>
<li>
Removing an item from the front of a VList or the end of an RVList is O(1) in time, although space not necessarily reclaimed. </li>
<li>
Adding or removing an item at the end of a VList or the front of an RVList is O(N) and requires making a copy of the entire list. </li>
<li>
Inserting or removing a list of M items at the end of a VList or the front of an RVList is O(N + M). </li>
<li>
Changing an item at an arbitrary position should be avoided, as it performs as poorly as inserting or removing an item at that position. </li>
</ul>
<p>VLists, however, offer some operations that singly-linked lists cannot provide efficiently: </p><ul>
<li>
Access by index averages O(1) in ideal conditions </li>
<li>
Getting the list length is typically O(log N), but O(1) in my version </li>
<li>
If a sublist points somewhere within a larger list, its index within the larger list can be obtained in between O(1) and O(log N) time. Consequently, reverse enumeration is possible without creating a temporary stack or list. </li>
</ul>
<p>Also, VLists can (in the best cases) store data almost as compactly as ordinary arrays. </p>
<p>I suspect FVList(of T) and RVList(of T) almost always outperforms LinkedList(of T) in both time and space, if you are always adding and removing items at the correct end of the list. And it should perform as well as List(of T) in some situations while providing an illusion of immutability that List(of T) can't. For lists of 0 to 2 items, FVList and RVList use less space than List(of T) (in fact, no object is allocated for an empty FVList or RVList.) </p>
<p>The FWList is built on the same foundation as the FVList (a linked list of VListBlock objects whose size increases exponentially), but it allows you to modify the list just like List&lt;T&gt;. FWList is a hybrid mutable-immutable data structure: a single list can be partly mutable and partly immutable. More specifically, a FWList is conceptually divided into two "halves": the front half is mutable, and the tail half is immutable. The two halves need not be the same size (in fact, very often one half is zero-size). </p>
<p>Because some or all of a FWList can be immutable, a VList can be converted to a FWList, or vice versa, in typically O(log N) time. If you modify a FWList after calling its ToFVList() method, a portion of the list is first copied into a mutable block and then modified, and this copy operation typically takes O(N) time. </p>
<p>RWList is like FWList except that new items are added at index Count instead of index zero. The head of a FWList is at index 0 and is returned from the First property; the head of an RWList is at index Count-1 and is returned from the Last property. </p>
<p>VListBlock implements a single "node" or "sub-array" within a VList. It contains a fixed-size array. When adding a new item to a VListBlock that is already full, a new empty VListBlock is created (with a larger array), whose _prior reference points to the old VListBlock. See Phil Bagwell's paper (or Wikipedia) for details. </p>
<p>VListBlock adds one new member to the structure Phil Bagwell described, PriorCount, a count of elements in other (smaller) lists to which this list is linked. This makes TotalCount an O(1) operation instead of O(log N), which is necessary so that RVList[i] and RWList[i] are O(1) on average. </p>
<p>Independent instances of FVList, RVList, FWList and RWList can be accessed from independent threads even though they may share some of the same memory. Individual instances of these objects, however, are not synchronized. </p>
<p>A few LINQ-style methods like Select and Where are implemented on the four data structures. These are provided to optimize functional code that takes an input list and produces an output list, but might not actually change the list. If all, or the tail, of the output is the same as the output, then the output list will share memory with the input list. </p>
<p>Note that unlike LINQ methods, these methods are greedy. They perform the requested operation immediately, not as-needed. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of elements in the list</td></tr>
  </table>
  </dd>
</dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:a2d0e20dd071804020979bbf9f391f494"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock_3_01T_01_4.html#a2d0e20dd071804020979bbf9f391f494">IsMutable</a><code> [get]</code></td></tr>
<tr class="memdesc:a2d0e20dd071804020979bbf9f391f494"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if part or all of the block is mutable. <a href="#a2d0e20dd071804020979bbf9f391f494">More...</a><br /></td></tr>
<tr class="separator:a2d0e20dd071804020979bbf9f391f494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb4d8a9e1a8956c2a7e2787c2c9d51b"><td class="memItemLeft" align="right" valign="top">abstract int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock_3_01T_01_4.html#a8fb4d8a9e1a8956c2a7e2787c2c9d51b">PriorCount</a><code> [get]</code></td></tr>
<tr class="memdesc:a8fb4d8a9e1a8956c2a7e2787c2c9d51b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of immutable items in all previous blocks. <a href="#a8fb4d8a9e1a8956c2a7e2787c2c9d51b">More...</a><br /></td></tr>
<tr class="separator:a8fb4d8a9e1a8956c2a7e2787c2c9d51b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d182adfa580c9bad2a83ff7f283f638"><td class="memItemLeft" align="right" valign="top">abstract FVList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock_3_01T_01_4.html#a2d182adfa580c9bad2a83ff7f283f638">Prior</a><code> [get]</code></td></tr>
<tr class="memdesc:a2d182adfa580c9bad2a83ff7f283f638"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a FVList representing the tail of the chain of VListBlocks. <a href="#a2d182adfa580c9bad2a83ff7f283f638">More...</a><br /></td></tr>
<tr class="separator:a2d182adfa580c9bad2a83ff7f283f638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addccb8008354ac5f384a5aeeb4292aae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="addccb8008354ac5f384a5aeeb4292aae"></a>
VListBlock&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>PriorBlock</b><code> [get]</code></td></tr>
<tr class="separator:addccb8008354ac5f384a5aeeb4292aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af463776794eda5255e20c7c2fafe1d1b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock_3_01T_01_4.html#af463776794eda5255e20c7c2fafe1d1b">PriorIsOwned</a><code> [get]</code></td></tr>
<tr class="memdesc:af463776794eda5255e20c7c2fafe1d1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this block has exclusive ownership of mutable items in the prior block. Returns false if the prior block is entirely immutable, if we don't have ownership, or if there is no prior block. <a href="#af463776794eda5255e20c7c2fafe1d1b">More...</a><br /></td></tr>
<tr class="separator:af463776794eda5255e20c7c2fafe1d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0bc940741d25d07658612451c536999"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock_3_01T_01_4.html#ab0bc940741d25d07658612451c536999">ImmCount</a><code> [get]</code></td></tr>
<tr class="memdesc:ab0bc940741d25d07658612451c536999"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of immutable elements in-use in our local array. <a href="#ab0bc940741d25d07658612451c536999">More...</a><br /></td></tr>
<tr class="separator:ab0bc940741d25d07658612451c536999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67b1b97c42810868da1509858ba1b6f1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock_3_01T_01_4.html#a67b1b97c42810868da1509858ba1b6f1">TotalCount</a><code> [get]</code></td></tr>
<tr class="memdesc:a67b1b97c42810868da1509858ba1b6f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of immutable elements in-use in the entire chain <a href="#a67b1b97c42810868da1509858ba1b6f1">More...</a><br /></td></tr>
<tr class="separator:a67b1b97c42810868da1509858ba1b6f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bdf1a2c6f51876cfece605688c7350f"><td class="memItemLeft" align="right" valign="top">abstract int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock_3_01T_01_4.html#a1bdf1a2c6f51876cfece605688c7350f">Capacity</a><code> [get]</code></td></tr>
<tr class="memdesc:a1bdf1a2c6f51876cfece605688c7350f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of elements in this block <a href="#a1bdf1a2c6f51876cfece605688c7350f">More...</a><br /></td></tr>
<tr class="separator:a1bdf1a2c6f51876cfece605688c7350f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dba15afaf79204759b1d66bc1df1302"><td class="memItemLeft" align="right" valign="top">abstract T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock_3_01T_01_4.html#a5dba15afaf79204759b1d66bc1df1302">this[int localIndex]</a><code> [get, set]</code></td></tr>
<tr class="memdesc:a5dba15afaf79204759b1d66bc1df1302"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets/sets the specified value at the specified index of this block's array, or, if localIndex is negative, searches recursively in previous blocks for the desired index. <a href="#a5dba15afaf79204759b1d66bc1df1302">More...</a><br /></td></tr>
<tr class="separator:a5dba15afaf79204759b1d66bc1df1302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadbb65c85d15521452fe85788c172b16"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aadbb65c85d15521452fe85788c172b16"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ChainLength</b><code> [get]</code></td></tr>
<tr class="separator:aadbb65c85d15521452fe85788c172b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab262e8194c472063d7c5676d50b43f53"><td class="memItemLeft" align="right" valign="top">abstract T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock_3_01T_01_4.html#ab262e8194c472063d7c5676d50b43f53">FGet</a> (int index, int localCount)</td></tr>
<tr class="memdesc:ab262e8194c472063d7c5676d50b43f53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an item at distance 'index' from the front (beginning of an FVList) <a href="#ab262e8194c472063d7c5676d50b43f53">More...</a><br /></td></tr>
<tr class="separator:ab262e8194c472063d7c5676d50b43f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6baf3395a1bc8dc07b68a24675862eb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af6baf3395a1bc8dc07b68a24675862eb"></a>
abstract bool&#160;</td><td class="memItemRight" valign="bottom"><b>FGet</b> (int index, int localCount, ref T value)</td></tr>
<tr class="separator:af6baf3395a1bc8dc07b68a24675862eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad17c5164b37d0b8ddeacb8433b07ae78"><td class="memItemLeft" align="right" valign="top">abstract T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock_3_01T_01_4.html#ad17c5164b37d0b8ddeacb8433b07ae78">RGet</a> (int index, int localCount)</td></tr>
<tr class="memdesc:ad17c5164b37d0b8ddeacb8433b07ae78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an item at distance 'index' from the back (beginning of an RVList) <a href="#ad17c5164b37d0b8ddeacb8433b07ae78">More...</a><br /></td></tr>
<tr class="separator:ad17c5164b37d0b8ddeacb8433b07ae78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8000708f5618a4d1478ac30a5c75b63c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8000708f5618a4d1478ac30a5c75b63c"></a>
abstract bool&#160;</td><td class="memItemRight" valign="bottom"><b>RGet</b> (int index, int localCount, ref T value)</td></tr>
<tr class="separator:a8000708f5618a4d1478ac30a5c75b63c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0064a76e0a690cb2e44d4592c40115c7"><td class="memItemLeft" align="right" valign="top">abstract VListBlock&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock_3_01T_01_4.html#a0064a76e0a690cb2e44d4592c40115c7">Add</a> (int localCount, T item)</td></tr>
<tr class="memdesc:a0064a76e0a690cb2e44d4592c40115c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new item at the "front" of a FVList where localCount is the number of items currently in the FVList's first block.  <a href="#a0064a76e0a690cb2e44d4592c40115c7">More...</a><br /></td></tr>
<tr class="separator:a0064a76e0a690cb2e44d4592c40115c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a6add3e90d18153d660b51b77da6c6"><td class="memItemLeft" align="right" valign="top">abstract FVList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock_3_01T_01_4.html#ad3a6add3e90d18153d660b51b77da6c6">SubList</a> (int localIndex)</td></tr>
<tr class="memdesc:ad3a6add3e90d18153d660b51b77da6c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list in which this[localIndex-1] is the first item. Nonpositive indexes are allowed and refer to prior lists; SubList returns an empty list if localIndex is so low that it goes past the back of the list.  <a href="#ad3a6add3e90d18153d660b51b77da6c6">More...</a><br /></td></tr>
<tr class="separator:ad3a6add3e90d18153d660b51b77da6c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa341816e5757a142512bccc887c1a80d"><td class="memItemLeft" align="right" valign="top">FVList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock_3_01T_01_4.html#aa341816e5757a142512bccc887c1a80d">ReplaceAt</a> (int localCount, T item, int distanceFromFront)</td></tr>
<tr class="memdesc:aa341816e5757a142512bccc887c1a80d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces an item in a FVList with another, where localCount is the number of items in the FVList's first block and distanceFromFront is the element index to replace (0=front).  <a href="#aa341816e5757a142512bccc887c1a80d">More...</a><br /></td></tr>
<tr class="separator:aa341816e5757a142512bccc887c1a80d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a728ab5ddd32c58fd51272e1f018b3b91"><td class="memItemLeft" align="right" valign="top">FVList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock_3_01T_01_4.html#a728ab5ddd32c58fd51272e1f018b3b91">RemoveAt</a> (int localCount, int distanceFromFront)</td></tr>
<tr class="memdesc:a728ab5ddd32c58fd51272e1f018b3b91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the specified number of items from a FVList where localCount is the number of items in the FVList's first block, distanceFromFront is the first removal position (minimum 0) and count is the number of items to remove. Of course, the terminology used here is to be understood in the context of a FVList (in which items are inserted at the front of the list).  <a href="#a728ab5ddd32c58fd51272e1f018b3b91">More...</a><br /></td></tr>
<tr class="separator:a728ab5ddd32c58fd51272e1f018b3b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae17c0d5f329010962f4b9087a48ecbc6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae17c0d5f329010962f4b9087a48ecbc6"></a>
FVList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>RemoveRange</b> (int localCount, int distanceFromFront, int count)</td></tr>
<tr class="separator:ae17c0d5f329010962f4b9087a48ecbc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a786c68e77ff95b433c00a470612cea29"><td class="memItemLeft" align="right" valign="top">abstract <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock_3_01T_01_4.html#a786c68e77ff95b433c00a470612cea29">MuClear</a> (int localCountWithMutables)</td></tr>
<tr class="memdesc:a786c68e77ff95b433c00a470612cea29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears all mutable items in this chain, and clears the mutable flag. If this block owns mutable items in prior blocks, they are cleared too. <a href="#a786c68e77ff95b433c00a470612cea29">More...</a><br /></td></tr>
<tr class="separator:a786c68e77ff95b433c00a470612cea29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8058c3c6e74a5ddeb0de9a170cf3cc16"><td class="memItemLeft" align="right" valign="top">abstract T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock_3_01T_01_4.html#a8058c3c6e74a5ddeb0de9a170cf3cc16">Front</a> (int localCount)</td></tr>
<tr class="memdesc:a8058c3c6e74a5ddeb0de9a170cf3cc16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the "front" item in a FVList/FWList associated with this block (or back item of a RVList) where localCount is the number of items in the FVList's first block.  <a href="#a8058c3c6e74a5ddeb0de9a170cf3cc16">More...</a><br /></td></tr>
<tr class="separator:a8058c3c6e74a5ddeb0de9a170cf3cc16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a696d94f0349d8b2c39a98cc0283a21fd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a696d94f0349d8b2c39a98cc0283a21fd"></a>
virtual FVList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Where</b> (int _localCount, Predicate&lt; T &gt; keep, WListProtected&lt; T &gt; forWList)</td></tr>
<tr class="separator:a696d94f0349d8b2c39a98cc0283a21fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af14bc17ad3c7666912d996616c12bacd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af14bc17ad3c7666912d996616c12bacd"></a>
virtual FVList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>SmartSelect</b> (int _localCount, Func&lt; T, T &gt; map, WListProtected&lt; T &gt; forWList)</td></tr>
<tr class="separator:af14bc17ad3c7666912d996616c12bacd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a6b98aa7b684188d87eb159a487c99a65"><td class="memItemLeft" align="right" valign="top">static VListBlock&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock_3_01T_01_4.html#a6b98aa7b684188d87eb159a487c99a65">Add</a> (VListBlock&lt; T &gt; self, int localCount, T item)</td></tr>
<tr class="memdesc:a6b98aa7b684188d87eb159a487c99a65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an item to the "front" of an immutable FVList. <a href="#a6b98aa7b684188d87eb159a487c99a65">More...</a><br /></td></tr>
<tr class="separator:a6b98aa7b684188d87eb159a487c99a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c21771a402d6e06fa0c70fd4e5761f9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c21771a402d6e06fa0c70fd4e5761f9"></a>
static FVList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>SubList</b> (VListBlock&lt; T &gt; self, int localCount, int offset)</td></tr>
<tr class="separator:a6c21771a402d6e06fa0c70fd4e5761f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ecf16157cd6b0ac57389200b3d4ddc9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ecf16157cd6b0ac57389200b3d4ddc9"></a>
static FVList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>TailOf</b> (FVList&lt; T &gt; list)</td></tr>
<tr class="separator:a7ecf16157cd6b0ac57389200b3d4ddc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d8bb74c5651e4ccf82fbedafca35f3"><td class="memItemLeft" align="right" valign="top">static VListBlock&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock_3_01T_01_4.html#a25d8bb74c5651e4ccf82fbedafca35f3">Insert</a> (VListBlock&lt; T &gt; self, int localCount, T item, int distanceFromFront)</td></tr>
<tr class="memdesc:a25d8bb74c5651e4ccf82fbedafca35f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new item in a FVList where localCount is the number of items in the FVList's first block and distanceFromFront is the insertion position (0=front).  <a href="#a25d8bb74c5651e4ccf82fbedafca35f3">More...</a><br /></td></tr>
<tr class="separator:a25d8bb74c5651e4ccf82fbedafca35f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd5cc060806dd8ad69f7bd678137de4d"><td class="memItemLeft" align="right" valign="top">static FVList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock_3_01T_01_4.html#abd5cc060806dd8ad69f7bd678137de4d">InsertRange</a> (VListBlock&lt; T &gt; self, int localCount, IList&lt; T &gt; items, int distanceFromFront, bool isRVList)</td></tr>
<tr class="memdesc:abd5cc060806dd8ad69f7bd678137de4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a list of items in the middle of a FVList, where localCount is the number of items in the FVList's first block and distanceFromFront is the insertion position (0=front).  <a href="#abd5cc060806dd8ad69f7bd678137de4d">More...</a><br /></td></tr>
<tr class="separator:abd5cc060806dd8ad69f7bd678137de4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af81c386ce03cedf0543a940a60ee66f3"><td class="memItemLeft" align="right" valign="top">static RVList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock_3_01T_01_4.html#af81c386ce03cedf0543a940a60ee66f3">AddRange</a> (VListBlock&lt; T &gt; self, int localCount, IEnumerator&lt; T &gt; items)</td></tr>
<tr class="memdesc:af81c386ce03cedf0543a940a60ee66f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a list of items to an immutable RVList (not a FVList). <a href="#af81c386ce03cedf0543a940a60ee66f3">More...</a><br /></td></tr>
<tr class="separator:af81c386ce03cedf0543a940a60ee66f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4defe27114f0c15484817b4afac04e72"><td class="memItemLeft" align="right" valign="top">static FVList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock_3_01T_01_4.html#a4defe27114f0c15484817b4afac04e72">AddRange</a> (VListBlock&lt; T &gt; self, int localCount, IList&lt; T &gt; items, bool isRVList)</td></tr>
<tr class="memdesc:a4defe27114f0c15484817b4afac04e72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a list of items to an immutable FVList. <a href="#a4defe27114f0c15484817b4afac04e72">More...</a><br /></td></tr>
<tr class="separator:a4defe27114f0c15484817b4afac04e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef7e8a64c57b78e58573a0e5ec0b3c2e"><td class="memItemLeft" align="right" valign="top">static FVList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock_3_01T_01_4.html#aef7e8a64c57b78e58573a0e5ec0b3c2e">AddRange</a> (VListBlock&lt; T &gt; self, int localCount, FVList&lt; T &gt; front, FVList&lt; T &gt; back)</td></tr>
<tr class="memdesc:aef7e8a64c57b78e58573a0e5ec0b3c2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a range of items to a FVList where localCount is the number of items in the FVList's first block, front points to the beginning of the range to add and back points to the end of the range.  <a href="#aef7e8a64c57b78e58573a0e5ec0b3c2e">More...</a><br /></td></tr>
<tr class="separator:aef7e8a64c57b78e58573a0e5ec0b3c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f289aee67d4b75a35b10e5d8a14ef1a"><td class="memItemLeft" align="right" valign="top">static FVList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock_3_01T_01_4.html#a8f289aee67d4b75a35b10e5d8a14ef1a">FindNextBlock</a> (ref FVList&lt; T &gt; subList, FVList&lt; T &gt; list, out int localCountOfSubList)</td></tr>
<tr class="memdesc:a8f289aee67d4b75a35b10e5d8a14ef1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the block that comes before 'subList' in the direction of the larger list, 'list'.  <a href="#a8f289aee67d4b75a35b10e5d8a14ef1a">More...</a><br /></td></tr>
<tr class="separator:a8f289aee67d4b75a35b10e5d8a14ef1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a840855e3f481f9cf70f6299206ed5c20"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a840855e3f481f9cf70f6299206ed5c20"></a>
static RVList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>FindNextBlock</b> (ref RVList&lt; T &gt; subList, RVList&lt; T &gt; list, out int localCountOfSubList)</td></tr>
<tr class="separator:a840855e3f481f9cf70f6299206ed5c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a7617036d10a5eb9bfcf2aa0bc98add"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a7617036d10a5eb9bfcf2aa0bc98add"></a>
static FVList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>BackUpOnce</b> (FVList&lt; T &gt; subList, FVList&lt; T &gt; list)</td></tr>
<tr class="separator:a6a7617036d10a5eb9bfcf2aa0bc98add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e1bfed3b5b6595df1b83f9c572a87d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af9e1bfed3b5b6595df1b83f9c572a87d"></a>
static RVList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>BackUpOnce</b> (RVList&lt; T &gt; subList, RVList&lt; T &gt; list)</td></tr>
<tr class="separator:af9e1bfed3b5b6595df1b83f9c572a87d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70c51be7a71c9b0ce5afe1d23005ba43"><td class="memItemLeft" align="right" valign="top">static FVList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock_3_01T_01_4.html#a70c51be7a71c9b0ce5afe1d23005ba43">EnsureImmutable</a> (VListBlock&lt; T &gt; self, int localCount)</td></tr>
<tr class="memdesc:a70c51be7a71c9b0ce5afe1d23005ba43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an immutable FVList with the specified parameters, modifying blocks if necessary. <a href="#a70c51be7a71c9b0ce5afe1d23005ba43">More...</a><br /></td></tr>
<tr class="separator:a70c51be7a71c9b0ce5afe1d23005ba43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a332d4f58527a64091468f82d86503152"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock_3_01T_01_4.html#a332d4f58527a64091468f82d86503152">EnsureMutable</a> (WListProtected&lt; T &gt; w, int mutablesNeeded)</td></tr>
<tr class="memdesc:a332d4f58527a64091468f82d86503152"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that at least the specified number of items at the front of a FWList or RWList are mutable and owned by the list. <a href="#a332d4f58527a64091468f82d86503152">More...</a><br /></td></tr>
<tr class="separator:a332d4f58527a64091468f82d86503152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a01a84b7d5f2b0d84969b6314430ff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa4a01a84b7d5f2b0d84969b6314430ff"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>MutableCount</b> (WListProtected&lt; T &gt; w)</td></tr>
<tr class="separator:aa4a01a84b7d5f2b0d84969b6314430ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b1428ea18a01cca173578cd20621db"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09b1428ea18a01cca173578cd20621db"></a>
static <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>MuAdd</b> (WListProtected&lt; T &gt; w, T item)</td></tr>
<tr class="separator:a09b1428ea18a01cca173578cd20621db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae27617d8659a3a8f4242913819cf60d0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae27617d8659a3a8f4242913819cf60d0"></a>
static <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>MuAddEmpty</b> (WListProtected&lt; T &gt; w, int count)</td></tr>
<tr class="separator:ae27617d8659a3a8f4242913819cf60d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af727c41569808c2e6d6d7da56587d923"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock_3_01T_01_4.html#af727c41569808c2e6d6d7da56587d923">MuAddEmpty</a> (WListProtected&lt; T &gt; w, int count, int newBlockSizeLimit)</td></tr>
<tr class="memdesc:af727c41569808c2e6d6d7da56587d923"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds empty item(s) to the front of the list. <a href="#af727c41569808c2e6d6d7da56587d923">More...</a><br /></td></tr>
<tr class="separator:af727c41569808c2e6d6d7da56587d923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb1c7846171aa7fdf4581c5de7b55c00"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock_3_01T_01_4.html#afb1c7846171aa7fdf4581c5de7b55c00">MuMove</a> (WListProtected&lt; T &gt; w, int dffFrom, int dffTo, int count)</td></tr>
<tr class="memdesc:afb1c7846171aa7fdf4581c5de7b55c00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves a series of elements from one location to another in a mutable block. <a href="#afb1c7846171aa7fdf4581c5de7b55c00">More...</a><br /></td></tr>
<tr class="separator:afb1c7846171aa7fdf4581c5de7b55c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba35553b64ed290b3f3a518b4e259378"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba35553b64ed290b3f3a518b4e259378"></a>
static <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>MuRemoveFront</b> (WListProtected&lt; T &gt; w, int count)</td></tr>
<tr class="separator:aba35553b64ed290b3f3a518b4e259378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23667ab1b986e42c8b12829562dd001f"><td class="memItemLeft" align="right" valign="top">static T[]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock_3_01T_01_4.html#a23667ab1b986e42c8b12829562dd001f">ToArray</a> (VListBlock&lt; T &gt; self, int localCount, bool isRList)</td></tr>
<tr class="memdesc:a23667ab1b986e42c8b12829562dd001f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts any kind of FVList to an array, quickly. <a href="#a23667ab1b986e42c8b12829562dd001f">More...</a><br /></td></tr>
<tr class="separator:a23667ab1b986e42c8b12829562dd001f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923aceb523b4819646f88092b173feb9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a923aceb523b4819646f88092b173feb9"></a>
static FVList&lt; Out &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Select&lt; Out &gt;</b> (VListBlock&lt; T &gt; _block, int _localCount, Func&lt; T, Out &gt; map, WListProtected&lt; Out &gt; forWList)</td></tr>
<tr class="separator:a923aceb523b4819646f88092b173feb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af613016ac9ecb1f638d1acbc00d40e83"><td class="memItemLeft" align="right" valign="top">static FVList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock_3_01T_01_4.html#af613016ac9ecb1f638d1acbc00d40e83">Transform</a> (VListBlock&lt; T &gt; _block, int _localCount, VListTransformer&lt; T &gt; x, bool isRList, WListProtected&lt; T &gt; forWList)</td></tr>
<tr class="memdesc:af613016ac9ecb1f638d1acbc00d40e83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a list (combines filtering with selection and more). <a href="#af613016ac9ecb1f638d1acbc00d40e83">More...</a><br /></td></tr>
<tr class="separator:af613016ac9ecb1f638d1acbc00d40e83"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a4f4bb9dbe2d76b70a4e6664f2098884c"><td class="memItemLeft" align="right" valign="top">VListBlock&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock_3_01T_01_4.html#a4f4bb9dbe2d76b70a4e6664f2098884c">AddRange</a> (FVList&lt; T &gt; front, FVList&lt; T &gt; back)</td></tr>
<tr class="memdesc:a4f4bb9dbe2d76b70a4e6664f2098884c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a range of items to the "front" of this block. <a href="#a4f4bb9dbe2d76b70a4e6664f2098884c">More...</a><br /></td></tr>
<tr class="separator:a4f4bb9dbe2d76b70a4e6664f2098884c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad96c677619f18ac86c59e94b7dce64a2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad96c677619f18ac86c59e94b7dce64a2"></a>
<a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>MuAddEmpty2</b> (WListProtected&lt; T &gt; w, int count, int newBlockSizeLimit)</td></tr>
<tr class="separator:ad96c677619f18ac86c59e94b7dce64a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5a3d92a31f38467cd3daa1d1abb17a8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac5a3d92a31f38467cd3daa1d1abb17a8"></a>
abstract <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BlockToArray</b> (T[] array, int arrayOffset, int localCount, bool isRList)</td></tr>
<tr class="separator:ac5a3d92a31f38467cd3daa1d1abb17a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a464cc680d8526766e657ee993c44831c"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock_3_01T_01_4.html#a464cc680d8526766e657ee993c44831c">MuAllocBlock</a> (WListProtected&lt; T &gt; w, int newBlockSizeLimit)</td></tr>
<tr class="memdesc:a464cc680d8526766e657ee993c44831c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used by MuAddEmpty to allocate an empty mutable block. <a href="#a464cc680d8526766e657ee993c44831c">More...</a><br /></td></tr>
<tr class="separator:a464cc680d8526766e657ee993c44831c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b2dbc252ab5c74bea89307859d2ae0c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b2dbc252ab5c74bea89307859d2ae0c"></a>
static FVList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>MakeResult</b> (VListBlock&lt; T &gt; _block, int _localCount, WListProtected&lt; T &gt; forWList)</td></tr>
<tr class="separator:a6b2dbc252ab5c74bea89307859d2ae0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad82be44eec5c846f912770608641aa94"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad82be44eec5c846f912770608641aa94"></a>
static FVList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>MakeResult</b> (T item, WListProtected&lt; T &gt; forWList)</td></tr>
<tr class="separator:ad82be44eec5c846f912770608641aa94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57878eb8afa01780b02f323469a2543"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab57878eb8afa01780b02f323469a2543"></a>
static FVList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>MakeResult</b> (T _1, T _2, WListProtected&lt; T &gt; forWList)</td></tr>
<tr class="separator:ab57878eb8afa01780b02f323469a2543"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected fields</h2></td></tr>
<tr class="memitem:a959e141487361548360e7b6be59957d5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock_3_01T_01_4.html#a959e141487361548360e7b6be59957d5">_immCount</a></td></tr>
<tr class="memdesc:a959e141487361548360e7b6be59957d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of immutable elements in our local array, plus a "mutable" flag in bit 30. <a href="#a959e141487361548360e7b6be59957d5">More...</a><br /></td></tr>
<tr class="separator:a959e141487361548360e7b6be59957d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd1bb9e3735b60d076eaa1e619797a7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2bd1bb9e3735b60d076eaa1e619797a7"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>MutableFlag</b> = 0x40000000</td></tr>
<tr class="separator:a2bd1bb9e3735b60d076eaa1e619797a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af67ffa4ad7db603eb3b7790679e658"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5af67ffa4ad7db603eb3b7790679e658"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>ImmCountMask</b> = MutableFlag - 1</td></tr>
<tr class="separator:a5af67ffa4ad7db603eb3b7790679e658"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a0064a76e0a690cb2e44d4592c40115c7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract VListBlock&lt;T&gt; Loyc.Collections.VListBlock&lt; T &gt;.Add </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>localCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a new item at the "front" of a FVList where localCount is the number of items currently in the FVList's first block. </p>

<p>Implemented in <a class="el" href="classLoyc_1_1Collections_1_1VListBlockArray_3_01T_01_4.html#a59687daadeb64fa757f61f7e67c72fa5">Loyc.Collections.VListBlockArray&lt; T &gt;</a>, and <a class="el" href="classLoyc_1_1Collections_1_1VListBlockOfTwo_3_01T_01_4.html#a70bd823a0e491fc52b8c3b35322b6335">Loyc.Collections.VListBlockOfTwo&lt; T &gt;</a>.</p>

<p>Referenced by <a class="el" href="classLoyc_1_1Collections_1_1VListBlock_3_01T_01_4.html#a4f4bb9dbe2d76b70a4e6664f2098884c">Loyc.Collections.VListBlock&lt; T &gt;.AddRange()</a>.</p>

</div>
</div>
<a class="anchor" id="a6b98aa7b684188d87eb159a487c99a65"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static VListBlock&lt;T&gt; Loyc.Collections.VListBlock&lt; T &gt;.Add </td>
          <td>(</td>
          <td class="paramtype">VListBlock&lt; T &gt;&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>localCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an item to the "front" of an immutable FVList.</p>

</div>
</div>
<a class="anchor" id="af81c386ce03cedf0543a940a60ee66f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static RVList&lt;T&gt; Loyc.Collections.VListBlock&lt; T &gt;.AddRange </td>
          <td>(</td>
          <td class="paramtype">VListBlock&lt; T &gt;&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>localCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IEnumerator&lt; T &gt;&#160;</td>
          <td class="paramname"><em>items</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a list of items to an immutable RVList (not a FVList).</p>
<p>This method is for use by immutable RVLists only.</p>

<p>References <a class="el" href="namespaceLoyc_1_1Collections.html#ab3f241a3b553681db7ce9ce14147e4eeaec211f7c20af43e742bf2570c3cb84f9">Loyc.Collections.Add</a>.</p>

</div>
</div>
<a class="anchor" id="a4defe27114f0c15484817b4afac04e72"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static FVList&lt;T&gt; Loyc.Collections.VListBlock&lt; T &gt;.AddRange </td>
          <td>(</td>
          <td class="paramtype">VListBlock&lt; T &gt;&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>localCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IList&lt; T &gt;&#160;</td>
          <td class="paramname"><em>items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isRVList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a list of items to an immutable FVList.</p>
<p>This method is for use by immutable VLists only.</p>

<p>References <a class="el" href="namespaceLoyc_1_1Collections.html#ab3f241a3b553681db7ce9ce14147e4eeaec211f7c20af43e742bf2570c3cb84f9">Loyc.Collections.Add</a>.</p>

</div>
</div>
<a class="anchor" id="aef7e8a64c57b78e58573a0e5ec0b3c2e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static FVList&lt;T&gt; Loyc.Collections.VListBlock&lt; T &gt;.AddRange </td>
          <td>(</td>
          <td class="paramtype">VListBlock&lt; T &gt;&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>localCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FVList&lt; T &gt;&#160;</td>
          <td class="paramname"><em>front</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FVList&lt; T &gt;&#160;</td>
          <td class="paramname"><em>back</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a range of items to a FVList where localCount is the number of items in the FVList's first block, front points to the beginning of the range to add and back points to the end of the range. </p>
<dl class="section return"><dt>Returns</dt><dd>A new list with the specified range added to it.</dd></dl>
<p>back.Front is NOT included in the range (in fact back can be an empty list) but front.Front is included unless front is also empty.</p>
<p>The elements of the range are inserted in "reverse" (from back to front) so that the order of the elements in the range is preserved (adding them front-first to our front would reverse their order). </p>
<p>This method is for use by immutable VLists only.</p>

<p>References <a class="el" href="namespaceLoyc_1_1Collections.html#ab3f241a3b553681db7ce9ce14147e4eeaec211f7c20af43e742bf2570c3cb84f9">Loyc.Collections.Add</a>, and <a class="el" href="structLoyc_1_1Collections_1_1FVList_3_01T_01_4.html#a6399dc2254a262ef444a9512cfe11e19">Loyc.Collections.FVList&lt; T &gt;.First</a>.</p>

</div>
</div>
<a class="anchor" id="a4f4bb9dbe2d76b70a4e6664f2098884c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VListBlock&lt;T&gt; Loyc.Collections.VListBlock&lt; T &gt;.AddRange </td>
          <td>(</td>
          <td class="paramtype">FVList&lt; T &gt;&#160;</td>
          <td class="paramname"><em>front</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FVList&lt; T &gt;&#160;</td>
          <td class="paramname"><em>back</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a range of items to the "front" of this block.</p>
<dl class="section return"><dt>Returns</dt><dd>This block, or a new block if a new block had to be allocated.</dd></dl>
<p>This method is for use by immutable VLists only.</p>

<p>References <a class="el" href="classLoyc_1_1Collections_1_1VListBlock_3_01T_01_4.html#a0064a76e0a690cb2e44d4592c40115c7">Loyc.Collections.VListBlock&lt; T &gt;.Add()</a>.</p>

</div>
</div>
<a class="anchor" id="a70c51be7a71c9b0ce5afe1d23005ba43"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static FVList&lt;T&gt; Loyc.Collections.VListBlock&lt; T &gt;.EnsureImmutable </td>
          <td>(</td>
          <td class="paramtype">VListBlock&lt; T &gt;&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>localCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an immutable FVList with the specified parameters, modifying blocks if necessary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">localCount</td><td>Number of items in 'self' that belong to the list that you want to make immutable. Nonpositive values of localCount are allowed and refer to blocks prior to 'self'.</td></tr>
  </table>
  </dd>
</dl>
<p>This method may change self and/or other blocks in the chain so that the returned FVList contains no mutable items.</p>

</div>
</div>
<a class="anchor" id="a332d4f58527a64091468f82d86503152"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structLoyc_1_1void.html">void</a> Loyc.Collections.VListBlock&lt; T &gt;.EnsureMutable </td>
          <td>(</td>
          <td class="paramtype">WListProtected&lt; T &gt;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mutablesNeeded</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensures that at least the specified number of items at the front of a FWList or RWList are mutable and owned by the list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutablesNeeded</td><td>Number of mutable items required.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab262e8194c472063d7c5676d50b43f53"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract T Loyc.Collections.VListBlock&lt; T &gt;.FGet </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>localCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an item at distance 'index' from the front (beginning of an FVList)</p>
<p>FGet and RGet were added as an optimization, to reduce the minimum number of virtual calls from 2 to 1 and to decrease the number of calculations involved in looking up an item.</p>

<p>Implemented in <a class="el" href="classLoyc_1_1Collections_1_1VListBlockArray_3_01T_01_4.html#ae3f97e2200b6c1b0cbd88f8b746efe9b">Loyc.Collections.VListBlockArray&lt; T &gt;</a>, and <a class="el" href="classLoyc_1_1Collections_1_1VListBlockOfTwo_3_01T_01_4.html#ab7fce363bba8185746d1878fad018c69">Loyc.Collections.VListBlockOfTwo&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a8f289aee67d4b75a35b10e5d8a14ef1a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static FVList&lt;T&gt; Loyc.Collections.VListBlock&lt; T &gt;.FindNextBlock </td>
          <td>(</td>
          <td class="paramtype">ref FVList&lt; T &gt;&#160;</td>
          <td class="paramname"><em>subList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FVList&lt; T &gt;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out int&#160;</td>
          <td class="paramname"><em>localCountOfSubList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the block that comes before 'subList' in the direction of the larger list, 'list'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subList</td><td>Sublist of list, or an empty list.</td></tr>
    <tr><td class="paramname">list</td><td>The larger, outer list. Can be an empty list if subList is empty.</td></tr>
    <tr><td class="paramname">localCountOfSubList</td><td>The value of r._block.Prior._localCount where r is the return value, or, if r is empty, the value of list._localCount.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The list prior to subList, or an empty block if (1) list and subList are in the same block (2) list._localCount==0 and list._block.Prior is in the same block as subList</dd></dl>
<p>Because of the copy-causing-sharing-failure problem (described in a comment in RVListTests.TestSublistProblem()), FindNextBlock may have to change subList in certain cases so that it really is a sublist of list. Therefore it is a ref argument. </p>

<p>References <a class="el" href="classLoyc_1_1Localize.html#af601a04790ede84ada8e3da04ef02fa4">Loyc.Localize.From()</a>, and <a class="el" href="classLoyc_1_1Collections_1_1VListBlock_3_01T_01_4.html#a2d182adfa580c9bad2a83ff7f283f638">Loyc.Collections.VListBlock&lt; T &gt;.Prior</a>.</p>

</div>
</div>
<a class="anchor" id="a8058c3c6e74a5ddeb0de9a170cf3cc16"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract T Loyc.Collections.VListBlock&lt; T &gt;.Front </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>localCount</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the "front" item in a FVList/FWList associated with this block (or back item of a RVList) where localCount is the number of items in the FVList's first block. </p>

<p>Implemented in <a class="el" href="classLoyc_1_1Collections_1_1VListBlockArray_3_01T_01_4.html#a9a7a7fd40578adf30d019cf4f90c0533">Loyc.Collections.VListBlockArray&lt; T &gt;</a>, and <a class="el" href="classLoyc_1_1Collections_1_1VListBlockOfTwo_3_01T_01_4.html#a52edeceb732a0b3ed8ee776ae6bdc4ab">Loyc.Collections.VListBlockOfTwo&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a25d8bb74c5651e4ccf82fbedafca35f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static VListBlock&lt;T&gt; Loyc.Collections.VListBlock&lt; T &gt;.Insert </td>
          <td>(</td>
          <td class="paramtype">VListBlock&lt; T &gt;&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>localCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>distanceFromFront</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a new item in a FVList where localCount is the number of items in the FVList's first block and distanceFromFront is the insertion position (0=front). </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td>distanceFromFront was out of range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The block resulting from the insert (may or may not be 'this')</dd></dl>
<p>This method is for use by immutable VLists only.</p>

<p>References <a class="el" href="namespaceLoyc_1_1Collections.html#ab3f241a3b553681db7ce9ce14147e4eeaec211f7c20af43e742bf2570c3cb84f9">Loyc.Collections.Add</a>.</p>

</div>
</div>
<a class="anchor" id="abd5cc060806dd8ad69f7bd678137de4d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static FVList&lt;T&gt; Loyc.Collections.VListBlock&lt; T &gt;.InsertRange </td>
          <td>(</td>
          <td class="paramtype">VListBlock&lt; T &gt;&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>localCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IList&lt; T &gt;&#160;</td>
          <td class="paramname"><em>items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>distanceFromFront</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isRVList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a list of items in the middle of a FVList, where localCount is the number of items in the FVList's first block and distanceFromFront is the insertion position (0=front). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">isRVList</td><td>Indicates the insertion order. If isRVList==true, the items[0] is inserted first (which is appropriate for an RVList), otherwise it is inserted last (which is appropriate for a FVList)</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td>distanceFromFront was out of range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The FVList containing the inserted items.</dd></dl>
<p>This method is for use by immutable VLists only.</p>

</div>
</div>
<a class="anchor" id="af727c41569808c2e6d6d7da56587d923"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structLoyc_1_1void.html">void</a> Loyc.Collections.VListBlock&lt; T &gt;.MuAddEmpty </td>
          <td>(</td>
          <td class="paramtype">WListProtected&lt; T &gt;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newBlockSizeLimit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds empty item(s) to the front of the list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>List that needs items</td></tr>
    <tr><td class="paramname">count</td><td>Number of items to add</td></tr>
    <tr><td class="paramname">newBlockSizeLimit</td><td>Limit on size of new block(s); normally VListBlockArray.MAX_BLOCK_LEN (this parameter is used by <a class="el" href="classLoyc_1_1Collections_1_1VListBlock_3_01T_01_4.html#a332d4f58527a64091468f82d86503152" title="Ensures that at least the specified number of items at the front of a FWList or RWList are mutable an...">EnsureMutable()</a>).</td></tr>
  </table>
  </dd>
</dl>
<p>This method doesn't actually clear the items, because all items that are not in use should already have been set to default(T). </p>

</div>
</div>
<a class="anchor" id="a464cc680d8526766e657ee993c44831c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int Loyc.Collections.VListBlock&lt; T &gt;.MuAllocBlock </td>
          <td>(</td>
          <td class="paramtype">WListProtected&lt; T &gt;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newBlockSizeLimit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used by MuAddEmpty to allocate an empty mutable block.</p>
<dl class="section return"><dt>Returns</dt><dd>Capacity of the new block</dd></dl>
<p>w is changed to point to the new block (w._localCount is set to 0)</p>

</div>
</div>
<a class="anchor" id="a786c68e77ff95b433c00a470612cea29"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract <a class="el" href="structLoyc_1_1void.html">void</a> Loyc.Collections.VListBlock&lt; T &gt;.MuClear </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>localCountWithMutables</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears all mutable items in this chain, and clears the mutable flag. If this block owns mutable items in prior blocks, they are cleared too.</p>
<p>Clearing items is unnecessary if ImmCount is zero, as there there are no shared copies and the caller is going to discard the block, so it'll be garbage anyway.</p>

<p>Implemented in <a class="el" href="classLoyc_1_1Collections_1_1VListBlockArray_3_01T_01_4.html#af9b352cf90601ad178a7079e801b0b68">Loyc.Collections.VListBlockArray&lt; T &gt;</a>, and <a class="el" href="classLoyc_1_1Collections_1_1VListBlockOfTwo_3_01T_01_4.html#a96d824cfedf7b153d81f87207ee2be43">Loyc.Collections.VListBlockOfTwo&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="afb1c7846171aa7fdf4581c5de7b55c00"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structLoyc_1_1void.html">void</a> Loyc.Collections.VListBlock&lt; T &gt;.MuMove </td>
          <td>(</td>
          <td class="paramtype">WListProtected&lt; T &gt;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dffFrom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dffTo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves a series of elements from one location to another in a mutable block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>List to modify</td></tr>
    <tr><td class="paramname">dffFrom</td><td>Distance from front of the beginning of the block to move</td></tr>
    <tr><td class="paramname">dffTo</td><td>Distance from front of destination location</td></tr>
    <tr><td class="paramname">count</td><td>Number of elements to copy</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a728ab5ddd32c58fd51272e1f018b3b91"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FVList&lt;T&gt; Loyc.Collections.VListBlock&lt; T &gt;.RemoveAt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>localCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>distanceFromFront</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the specified number of items from a FVList where localCount is the number of items in the FVList's first block, distanceFromFront is the first removal position (minimum 0) and count is the number of items to remove. Of course, the terminology used here is to be understood in the context of a FVList (in which items are inserted at the front of the list). </p>
<dl class="section return"><dt>Returns</dt><dd>The modified list.</dd></dl>
<p>This method is for use by immutable VLists only.</p>

</div>
</div>
<a class="anchor" id="aa341816e5757a142512bccc887c1a80d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FVList&lt;T&gt; Loyc.Collections.VListBlock&lt; T &gt;.ReplaceAt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>localCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>distanceFromFront</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces an item in a FVList with another, where localCount is the number of items in the FVList's first block and distanceFromFront is the element index to replace (0=front). </p>
<dl class="section return"><dt>Returns</dt><dd>The list resulting from the change. Note that this operation is inefficient; it aways allocates a new block.</dd></dl>
<p>This method is for use by immutable VLists only.</p>

</div>
</div>
<a class="anchor" id="ad17c5164b37d0b8ddeacb8433b07ae78"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract T Loyc.Collections.VListBlock&lt; T &gt;.RGet </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>localCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an item at distance 'index' from the back (beginning of an RVList)</p>

<p>Implemented in <a class="el" href="classLoyc_1_1Collections_1_1VListBlockArray_3_01T_01_4.html#a830a93478fffed54fcc9d2675866eb4d">Loyc.Collections.VListBlockArray&lt; T &gt;</a>, and <a class="el" href="classLoyc_1_1Collections_1_1VListBlockOfTwo_3_01T_01_4.html#a06aaca8297b68f39815940aadcef1cc8">Loyc.Collections.VListBlockOfTwo&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ad3a6add3e90d18153d660b51b77da6c6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract FVList&lt;T&gt; Loyc.Collections.VListBlock&lt; T &gt;.SubList </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>localIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a list in which this[localIndex-1] is the first item. Nonpositive indexes are allowed and refer to prior lists; SubList returns an empty list if localIndex is so low that it goes past the back of the list. </p>
<p>Warning: Normally FVList can only contain a reference to an immutable list, but this method can return a reference that includes mutable items.</p>

<p>Implemented in <a class="el" href="classLoyc_1_1Collections_1_1VListBlockArray_3_01T_01_4.html#a8d6c62c2e04ed7cf963f5431c3934220">Loyc.Collections.VListBlockArray&lt; T &gt;</a>, and <a class="el" href="classLoyc_1_1Collections_1_1VListBlockOfTwo_3_01T_01_4.html#a87c0667477f065757d52dbf1535f18a9">Loyc.Collections.VListBlockOfTwo&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a23667ab1b986e42c8b12829562dd001f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T [] Loyc.Collections.VListBlock&lt; T &gt;.ToArray </td>
          <td>(</td>
          <td class="paramtype">VListBlock&lt; T &gt;&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>localCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isRList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts any kind of FVList to an array, quickly.</p>

</div>
</div>
<a class="anchor" id="af613016ac9ecb1f638d1acbc00d40e83"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static FVList&lt;T&gt; Loyc.Collections.VListBlock&lt; T &gt;.Transform </td>
          <td>(</td>
          <td class="paramtype">VListBlock&lt; T &gt;&#160;</td>
          <td class="paramname"><em>_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_localCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VListTransformer&lt; T &gt;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isRList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WListProtected&lt; T &gt;&#160;</td>
          <td class="paramname"><em>forWList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transforms a list (combines filtering with selection and more).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Method to apply to each item in the list</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list formed from transforming all items in the list</dd></dl>
<p>See the documentation of FVList.Transform() for more information.</p>

<p>References <a class="el" href="classLoyc_1_1Collections_1_1VListBlock_3_01T_01_4.html#a959e141487361548360e7b6be59957d5">Loyc.Collections.VListBlock&lt; T &gt;._immCount</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a959e141487361548360e7b6be59957d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Loyc.Collections.VListBlock&lt; T &gt;._immCount</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>number of immutable elements in our local array, plus a "mutable" flag in bit 30.</p>
<p>Aside from the mutable flag, this value only increases, never decreases. </p>
<p>If the some or all of the block is mutable, _immCount bit 30 is set (0x40000000), and the low bits contain the number of immutable items. In that case the total number of items in use, including mutable items, is only known by the FWList or RWList that encapsulates the block. </p>
<p>The mutable flag is part of this field instead of being a separate flag for two reasons: (1) Saving space. A separate boolean would enlarge the object 4 bytes. (2) High-performance thread safety. Instead of using locks, I use interlocked changes to obtain thread safety. </p>
<p>I don't know how fast or slow .NET locking is, but I assume you can't get faster than a single Interlocked.CompareExchange, so I have designed thread safety around _immCount. </p>
<p>I hate trying to guarantee thread safety because I don't know how to prove correctness. I know that thread safety must be considered for at least the following operations: </p><ul>
<li>
Adding an item at the end of an immutable VListBlock: two VLists on different threads may try to add an item to the "front" of the same block at the same time. </li>
<li>
Reserving mutable items in a list: two threads may do this at once, or an immutable VList may add an item at the same instant. </li>
</ul>
<p>Interlocked.CompareExchange() is used in both cases, which ensures that only one thread succeeds and any threads that fail do not alter the value of the field. </p>
<p>A mutable block can be made immutable again by clearing bit 30. No interlocked exchange is required for this, since any thread that notices bit 30 is set will not attempt to modify this field in the first place. </p>
<p>We need not worry about thread safety in order to obtain the immutable tail of a list (or equivalently, to remove items from the "front") because that operation doesn't make use of this field (Remember, each instance of VList has its own private _localCount.) Nor do we need to worry about enumerating or modifying an immutable list (the latter is just an illusion, after all). </p>
<p>I have not concerned myself with thread safety when a single VList instance (whether mutable or immutable) is accessed from multiple threads, because doing so is not supported. It occurs to me, however, that there could be security concerns if untrusted code is given access to any kind of VList; e.g. perhaps malicious code could corrupt a VListBlock somehow by exploiting lack of thread safety. </p>
<p>Theoretically you shouldn't modify an FWList/RWList while it is being enumerated, but the danger is limited to an incorrect sequence of items being returned from the enumerator; a "subList is not within 
list" exception is also possible. </p>
<p>Important things to note: (1) once items are switched from mutable to immutable, they can never be made mutable again, since there is no way to know if any immutable VList references still exist. (2) mutable items always belong to exactly one FWList or one RWList, but a VListBlock doesn't know what FWList it belongs to. A FWList or RWList is detached from its VListBlock when Clear() is called, making the block immutable again. (3) if not all the items in a VListBlock are mutable, then the Prior list is guaranteed to be immutable. In other words, mutable and immutable items are not interleaved; mutable items are always at the "front" and immutable items are always at the "back" (which is the beginning of an RVList or end of an FVList). (4) When the mutable flag is set, _immCount appears to be a very large number. Code that uses _immCount directly instead of calling ImmCount is taking advantage of that fact. </p>

<p>Referenced by <a class="el" href="classLoyc_1_1Collections_1_1VListBlock_3_01T_01_4.html#af613016ac9ecb1f638d1acbc00d40e83">Loyc.Collections.VListBlock&lt; T &gt;.Transform()</a>.</p>

</div>
</div>
<h2 class="groupheader">Property Documentation</h2>
<a class="anchor" id="a1bdf1a2c6f51876cfece605688c7350f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract int Loyc.Collections.VListBlock&lt; T &gt;.Capacity</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum number of elements in this block</p>

</div>
</div>
<a class="anchor" id="ab0bc940741d25d07658612451c536999"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Loyc.Collections.VListBlock&lt; T &gt;.ImmCount</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of immutable elements in-use in our local array.</p>
<p>Mutable items are not included in the count.</p>

</div>
</div>
<a class="anchor" id="a2d0e20dd071804020979bbf9f391f494"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Loyc.Collections.VListBlock&lt; T &gt;.IsMutable</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if part or all of the block is mutable.</p>

</div>
</div>
<a class="anchor" id="a2d182adfa580c9bad2a83ff7f283f638"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract FVList&lt;T&gt; Loyc.Collections.VListBlock&lt; T &gt;.Prior</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a FVList representing the tail of the chain of VListBlocks.</p>
<p>Warning: Normally FVList can only contain a reference to an immutable list, but this property may return a reference to a mutable block if the current block is 100% mutable. Be careful with this value, as FVList is not designed to handle mutable contents!</p>

<p>Referenced by <a class="el" href="classLoyc_1_1Collections_1_1VListBlock_3_01T_01_4.html#a8f289aee67d4b75a35b10e5d8a14ef1a">Loyc.Collections.VListBlock&lt; T &gt;.FindNextBlock()</a>.</p>

</div>
</div>
<a class="anchor" id="a8fb4d8a9e1a8956c2a7e2787c2c9d51b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract int Loyc.Collections.VListBlock&lt; T &gt;.PriorCount</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of immutable items in all previous blocks.</p>

</div>
</div>
<a class="anchor" id="af463776794eda5255e20c7c2fafe1d1b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Loyc.Collections.VListBlock&lt; T &gt;.PriorIsOwned</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this block has exclusive ownership of mutable items in the prior block. Returns false if the prior block is entirely immutable, if we don't have ownership, or if there is no prior block.</p>
<p>This one's hard to explain without a diagram. Note: since there is no independent flag to indicate ownership, the logic in this property relies on the fact that a new mutable block is never created until the prior block is full; if one creates a new mutable block when there is free space but no mutable items allocated in the prior block, this property returns false because it assumes the free space was reserved by some other WList than the list that owns this block.</p>

</div>
</div>
<a class="anchor" id="a5dba15afaf79204759b1d66bc1df1302"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract T Loyc.Collections.VListBlock&lt; T &gt;.this[int localIndex]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span><span class="mlabel">set</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets/sets the specified value at the specified index of this block's array, or, if localIndex is negative, searches recursively in previous blocks for the desired index.</p>
<p>A FVList computes localIndex as FVList._localCount-1-index. </p>
<p>FVList/RVList is responsible for checking that the user's index is valid and throwing IndexOutOfRangeException if not. </p>
<p>The setter can only be called on mutable indices! </p>

</div>
</div>
<a class="anchor" id="a67b1b97c42810868da1509858ba1b6f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Loyc.Collections.VListBlock&lt; T &gt;.TotalCount</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of immutable elements in-use in the entire chain</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jul 6 2014 23:54:33 for Loyc by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
