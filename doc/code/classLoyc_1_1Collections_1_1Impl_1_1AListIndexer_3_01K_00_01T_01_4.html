<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>Loyc: Loyc.Collections.Impl.AListIndexer&lt; K, T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Loyc
   </div>
   <div id="projectbrief">Language of your choice: library documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Events</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceLoyc.html">Loyc</a></li><li class="navelem"><a class="el" href="namespaceLoyc_1_1Collections.html">Collections</a></li><li class="navelem"><a class="el" href="namespaceLoyc_1_1Collections_1_1Impl.html">Impl</a></li><li class="navelem"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer_3_01K_00_01T_01_4.html">AListIndexer< K, T ></a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#properties">Properties</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-attribs">Protected static fields</a> &#124;
<a href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer_3_01K_00_01T_01_4-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Loyc.Collections.Impl.AListIndexer&lt; K, T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Observes changes and builds a table of items in the tree. 
 <a href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer_3_01K_00_01T_01_4.html#details">More...</a></p>
<hr/>Source file:<ul>
<li><a href='https://github.com/qwertie/Loyc/tree/master/Core/Loyc.Collections/ALists/AListIndexer.cs'>/Core/Loyc.Collections/ALists/AListIndexer.cs</a></li>
</ul>
<div class="dynheader">
Inheritance diagram for Loyc.Collections.Impl.AListIndexer&lt; K, T &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer_3_01K_00_01T_01_4.png" usemap="#Loyc.Collections.Impl.AListIndexer&lt; K, T &gt;_map" alt=""/>
  <map id="Loyc.Collections.Impl.AListIndexer&lt; K, T &gt;_map" name="Loyc.Collections.Impl.AListIndexer&lt; K, T &gt;_map">
<area href="interfaceLoyc_1_1Collections_1_1Impl_1_1IAListTreeObserver_3_01K_00_01T_01_4.html" title="An interface that is called to notify observers when items or nodes in the tree of a class derived fr..." alt="Loyc.Collections.Impl.IAListTreeObserver&lt; K, T &gt;" shape="rect" coords="0,0,295,24"/>
</map>
 </div></div>
<a name="details" id="details"></a><h2 class="groupheader">Remarks</h2>
<div class="textblock"><p>Observes changes and builds a table of items in the tree.</p>
<p>The IndexedAList{T} class uses one of these objects to speed up methods that search for items in an AList{T} (IndexOf, Contains, and Remove). The amount of speedup is limited by the size of the nodes in the list being indexed; see <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer_3_01K_00_01T_01_4.html#a7e33aee6db7ab05844c7d15b0322c2b3" title="Returns an index at which the specified item can be found.">IndexOfAny</a>. </p>
<p>It is wasteful to use an AListIndexer if the list is small. AListIndexer is designed to accelerate searches in very large lists, and it offers no performance benefit to small lists; to the contrary, it just wastes time and memory in small lists. </p>
<p>It is recommended to use IndexedAList instead of instantiating this class directly. </p>
<p>In general, AListIndexer requires more memory than the list that is being indexed. Specifically, if pointers use P bytes, then AListIndexer itself consumes moderately MORE than X+P*N bytes of memory, where X is the size of the list being indexed, and N is the number of items in the list. Thus, for example, an indexed list of AList{Object} requires approximately three times as much memory as an AList that is not indexed. </p>
<p>Moreover, changing an indexed list takes at least twice as much time, since the indexer must be notified of each change and updates to the index take O(log N) time per update. Batch operations involving X items that take O(log N) time without an indexer (e.g. RemoveRange(i, X)) will take O(X log N) time instead, because the indexer must be notified about each item changed. </p>
<p>Still, these costs are worthwhile in applications that frequently search for items in the list. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:a21af8e0b0eaf38ee8dbbe22f55348dcb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21af8e0b0eaf38ee8dbbe22f55348dcb"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ItemCount</b><code> [get]</code></td></tr>
<tr class="separator:a21af8e0b0eaf38ee8dbbe22f55348dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a253dbb0a025dba18f3cff443f3f24c11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer_3_01K_00_01T_01_4.html#a253dbb0a025dba18f3cff443f3f24c11">Attach</a> (AListBase&lt; K, T &gt; list, Action&lt; bool &gt; populate)</td></tr>
<tr class="memdesc:a253dbb0a025dba18f3cff443f3f24c11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when the observer is being attached to an AList. <a href="#a253dbb0a025dba18f3cff443f3f24c11">More...</a><br /></td></tr>
<tr class="separator:a253dbb0a025dba18f3cff443f3f24c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c8f6f169cb511632af23deb354611cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer_3_01K_00_01T_01_4.html#a3c8f6f169cb511632af23deb354611cf">Detach</a> ()</td></tr>
<tr class="memdesc:a3c8f6f169cb511632af23deb354611cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when the observer is being detached from an AList. <a href="#a3c8f6f169cb511632af23deb354611cf">More...</a><br /></td></tr>
<tr class="separator:a3c8f6f169cb511632af23deb354611cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac51a0a37a81fb0e1745a23e111fb92f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer_3_01K_00_01T_01_4.html#aac51a0a37a81fb0e1745a23e111fb92f">RootChanged</a> (AListNode&lt; K, T &gt; newRoot, bool clear)</td></tr>
<tr class="memdesc:aac51a0a37a81fb0e1745a23e111fb92f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when the root of the tree changes, or when the list is cleared. <a href="#aac51a0a37a81fb0e1745a23e111fb92f">More...</a><br /></td></tr>
<tr class="separator:aac51a0a37a81fb0e1745a23e111fb92f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c35a45dc0efcea181fc6812b1901228"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer_3_01K_00_01T_01_4.html#a8c35a45dc0efcea181fc6812b1901228">ItemAdded</a> (T item, AListLeaf&lt; K, T &gt; parent)</td></tr>
<tr class="memdesc:a8c35a45dc0efcea181fc6812b1901228"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when an item is added to a leaf node. <a href="#a8c35a45dc0efcea181fc6812b1901228">More...</a><br /></td></tr>
<tr class="separator:a8c35a45dc0efcea181fc6812b1901228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e20911c4161fa578df5b17f69306237"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer_3_01K_00_01T_01_4.html#a7e20911c4161fa578df5b17f69306237">ItemRemoved</a> (T item, AListLeaf&lt; K, T &gt; parent)</td></tr>
<tr class="memdesc:a7e20911c4161fa578df5b17f69306237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when an item is removed from a leaf node. <a href="#a7e20911c4161fa578df5b17f69306237">More...</a><br /></td></tr>
<tr class="separator:a7e20911c4161fa578df5b17f69306237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48fbe8c917f1192577b8822d94ebbab9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer_3_01K_00_01T_01_4.html#a48fbe8c917f1192577b8822d94ebbab9">NodeAdded</a> (AListNode&lt; K, T &gt; child, AListInnerBase&lt; K, T &gt; parent)</td></tr>
<tr class="memdesc:a48fbe8c917f1192577b8822d94ebbab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a child node is added to an inner node. <a href="#a48fbe8c917f1192577b8822d94ebbab9">More...</a><br /></td></tr>
<tr class="separator:a48fbe8c917f1192577b8822d94ebbab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a485240c333c0246e5b2ebea9b672759a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer_3_01K_00_01T_01_4.html#a485240c333c0246e5b2ebea9b672759a">NodeRemoved</a> (AListNode&lt; K, T &gt; child, AListInnerBase&lt; K, T &gt; parent)</td></tr>
<tr class="memdesc:a485240c333c0246e5b2ebea9b672759a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a child node is removed from an inner node. <a href="#a485240c333c0246e5b2ebea9b672759a">More...</a><br /></td></tr>
<tr class="separator:a485240c333c0246e5b2ebea9b672759a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83d088065dd3b9f3c641880278cdb0c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer_3_01K_00_01T_01_4.html#a83d088065dd3b9f3c641880278cdb0c1">RemoveAll</a> (AListNode&lt; K, T &gt; node)</td></tr>
<tr class="memdesc:a83d088065dd3b9f3c641880278cdb0c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when all children are being removed from a node (leaf or inner). Notifications are not sent for individual children. <a href="#a83d088065dd3b9f3c641880278cdb0c1">More...</a><br /></td></tr>
<tr class="separator:a83d088065dd3b9f3c641880278cdb0c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ea987f20a54a971acfff33b38a41965"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer_3_01K_00_01T_01_4.html#a9ea987f20a54a971acfff33b38a41965">AddAll</a> (AListNode&lt; K, T &gt; node)</td></tr>
<tr class="memdesc:a9ea987f20a54a971acfff33b38a41965"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when all children are being added to a node (leaf or inner). Notifications are not sent for individual children. <a href="#a9ea987f20a54a971acfff33b38a41965">More...</a><br /></td></tr>
<tr class="separator:a9ea987f20a54a971acfff33b38a41965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda2c5306cc230494d78426a60ae5463"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer_3_01K_00_01T_01_4.html#abda2c5306cc230494d78426a60ae5463">CheckPoint</a> ()</td></tr>
<tr class="memdesc:abda2c5306cc230494d78426a60ae5463"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a tree modification operation is completed. <a href="#abda2c5306cc230494d78426a60ae5463">More...</a><br /></td></tr>
<tr class="separator:abda2c5306cc230494d78426a60ae5463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e33aee6db7ab05844c7d15b0322c2b3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer_3_01K_00_01T_01_4.html#a7e33aee6db7ab05844c7d15b0322c2b3">IndexOfAny</a> (T item)</td></tr>
<tr class="memdesc:a7e33aee6db7ab05844c7d15b0322c2b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an index at which the specified item can be found. <a href="#a7e33aee6db7ab05844c7d15b0322c2b3">More...</a><br /></td></tr>
<tr class="separator:a7e33aee6db7ab05844c7d15b0322c2b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53a79679a0c1f50d542e8fac0f091c1f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a53a79679a0c1f50d542e8fac0f091c1f"></a>
List&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>IndexesOf</b> (T item)</td></tr>
<tr class="separator:a53a79679a0c1f50d542e8fac0f091c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c9b93b9ec85b02a3df15a2afffdae77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer_3_01K_00_01T_01_4.html#a9c9b93b9ec85b02a3df15a2afffdae77">VerifyCorrectness</a> ()</td></tr>
<tr class="memdesc:a9c9b93b9ec85b02a3df15a2afffdae77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scans the index to verify that it matches the tree that is being indexed. The scan takes O(N log N + N M) time for a list of length N with maximum node size M. <a href="#a9c9b93b9ec85b02a3df15a2afffdae77">More...</a><br /></td></tr>
<tr class="separator:a9c9b93b9ec85b02a3df15a2afffdae77"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:adf23683a27cd10a7afb41cd18bfcc5b1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer_3_01K_00_01T_01_4.html#adf23683a27cd10a7afb41cd18bfcc5b1">ReconstructIndex</a> (T item, AListLeaf&lt; K, T &gt; leaf)</td></tr>
<tr class="memdesc:adf23683a27cd10a7afb41cd18bfcc5b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an item and a leaf that is known to contain a copy of the item, this method returns the index of the item in the tree as a whole. Requires O(M ) <a href="#adf23683a27cd10a7afb41cd18bfcc5b1">More...</a><br /></td></tr>
<tr class="separator:adf23683a27cd10a7afb41cd18bfcc5b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-attribs"></a>
Protected static fields</h2></td></tr>
<tr class="memitem:ac6aefd00aff43eabf032dc33925fec5e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac6aefd00aff43eabf032dc33925fec5e"></a>
static Func&lt; T, T, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>CompareTHashCodes</b> = CompareHashCodes&lt;T&gt;</td></tr>
<tr class="separator:ac6aefd00aff43eabf032dc33925fec5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae24031327cca5463a8f96de66ec8d56e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae24031327cca5463a8f96de66ec8d56e"></a>
static Func&lt; AListNode&lt; K, T &gt;<br class="typebreak" />
, AListNode&lt; K, T &gt;, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>CompareNodeHashCodes</b> = CompareHashCodes&lt;AListNode&lt;K, T&gt;&gt;</td></tr>
<tr class="separator:ae24031327cca5463a8f96de66ec8d56e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bd0a421ea5ae8cf1d5c247ce169df0d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3bd0a421ea5ae8cf1d5c247ce169df0d"></a>
static Func&lt; AListLeaf&lt; K, T &gt;<br class="typebreak" />
, AListLeaf&lt; K, T &gt;, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>CompareLeafHashCodes</b> = CompareHashCodes&lt;AListNode&lt;K, T&gt;&gt;</td></tr>
<tr class="separator:a3bd0a421ea5ae8cf1d5c247ce169df0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cc12e2be996c5b259fa283e96a350dd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0cc12e2be996c5b259fa283e96a350dd"></a>
static Func&lt; AListInnerBase&lt; K, <br class="typebreak" />
T &gt;, AListInnerBase&lt; K, T &gt;<br class="typebreak" />
, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>CompareInnerHashCodes</b> = CompareHashCodes&lt;AListInnerBase&lt;K, T&gt;&gt;</td></tr>
<tr class="separator:a0cc12e2be996c5b259fa283e96a350dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a9ea987f20a54a971acfff33b38a41965"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1void.html">void</a> Loyc.Collections.Impl.AListIndexer&lt; K, T &gt;.AddAll </td>
          <td>(</td>
          <td class="paramtype">AListNode&lt; K, T &gt;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when all children are being added to a node (leaf or inner). Notifications are not sent for individual children.</p>

<p>Implements <a class="el" href="interfaceLoyc_1_1Collections_1_1Impl_1_1IAListTreeObserver_3_01K_00_01T_01_4.html#a767a338b6f7dac6380210491cb125cd9">Loyc.Collections.Impl.IAListTreeObserver&lt; K, T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a253dbb0a025dba18f3cff443f3f24c11"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1void.html">void</a> Loyc.Collections.Impl.AListIndexer&lt; K, T &gt;.Attach </td>
          <td>(</td>
          <td class="paramtype">AListBase&lt; K, T &gt;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action&lt; bool &gt;&#160;</td>
          <td class="paramname"><em>populate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when the observer is being attached to an AList.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The list that the observer is being attached to.</td></tr>
    <tr><td class="paramname">populate</td><td>The observer can invoke this delegate to cause notifications to be sent about all the nodes in the tree through a depth-first search that calls <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer_3_01K_00_01T_01_4.html#a9ea987f20a54a971acfff33b38a41965" title="Called when all children are being added to a node (leaf or inner). Notifications are not sent for in...">AddAll</a> for each node in the tree. When calling this delegate, use a parameter of True if you want AddAll to be called for children before parents (roughly, leaves first). Use False if you want AddAll to be called for inner nodes before their children. populate() also calls <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer_3_01K_00_01T_01_4.html#aac51a0a37a81fb0e1745a23e111fb92f" title="Called when the root of the tree changes, or when the list is cleared.">RootChanged</a>() before scanning the tree. </td></tr>
  </table>
  </dd>
</dl>
<p>If <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer_3_01K_00_01T_01_4.html#a253dbb0a025dba18f3cff443f3f24c11" title="Called when the observer is being attached to an AList.">Attach()</a> throws an exception, AListBase{K,T} will cancel the AddObserver() operation and it will not catch the exception. </p>

<p>Implements <a class="el" href="interfaceLoyc_1_1Collections_1_1Impl_1_1IAListTreeObserver_3_01K_00_01T_01_4.html#afa78aa67a4893b601952cc8b14084fe3">Loyc.Collections.Impl.IAListTreeObserver&lt; K, T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="abda2c5306cc230494d78426a60ae5463"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1void.html">void</a> Loyc.Collections.Impl.AListIndexer&lt; K, T &gt;.CheckPoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when a tree modification operation is completed.</p>
<p>This is called after each modification operation (Add, Insert, Remove, Replace, etc.); the list will normally be in a read-only state ("frozen for concurrency") when this method is called, so do not initiate changes from here. </p>
<p>This method can safely throw an exception, and the list class will not swallow it. Note: if there are multiple observers, throwing an exception from one observers will prevent this notification from reaching other observers that have not been notified yet. </p>

<p>Implements <a class="el" href="interfaceLoyc_1_1Collections_1_1Impl_1_1IAListTreeObserver_3_01K_00_01T_01_4.html#a07dcf4204ea5c803359b54d7fe1d4278">Loyc.Collections.Impl.IAListTreeObserver&lt; K, T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a3c8f6f169cb511632af23deb354611cf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1void.html">void</a> Loyc.Collections.Impl.AListIndexer&lt; K, T &gt;.Detach </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when the observer is being detached from an AList.</p>

<p>Implements <a class="el" href="interfaceLoyc_1_1Collections_1_1Impl_1_1IAListTreeObserver_3_01K_00_01T_01_4.html#a8dae5e8d22892aab48816eefa4e8e6e6">Loyc.Collections.Impl.IAListTreeObserver&lt; K, T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a7e33aee6db7ab05844c7d15b0322c2b3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Loyc.Collections.Impl.AListIndexer&lt; K, T &gt;.IndexOfAny </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an index at which the specified item can be found.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>Item to find.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the item in the list being indexed by this object, or -1 if the item does not exist in the list.</dd></dl>
<p>The search takes O(M log^2 N) time, where N is the size of the list and M is the maximum size of nodes in the list. Due to the "M" factor, A-lists with large nodes are searched more slowly than A-lists with small nodes; however, the "log N" part is a base-M logarithm, so you don't actually gain performance by using very small nodes. This is because very small nodes require deeply nested trees, and deep trees are slow. The AListBase{K,T} documentation discusses the effect of node size further. </p>

</div>
</div>
<a class="anchor" id="a8c35a45dc0efcea181fc6812b1901228"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1void.html">void</a> Loyc.Collections.Impl.AListIndexer&lt; K, T &gt;.ItemAdded </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AListLeaf&lt; K, T &gt;&#160;</td>
          <td class="paramname"><em>parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when an item is added to a leaf node.</p>
<p>Note: this may be called as part of a move operation (remove+add)</p>

<p>Implements <a class="el" href="interfaceLoyc_1_1Collections_1_1Impl_1_1IAListTreeObserver_3_01K_00_01T_01_4.html#a889821df29f744529c69e68a293769a6">Loyc.Collections.Impl.IAListTreeObserver&lt; K, T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a7e20911c4161fa578df5b17f69306237"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1void.html">void</a> Loyc.Collections.Impl.AListIndexer&lt; K, T &gt;.ItemRemoved </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AListLeaf&lt; K, T &gt;&#160;</td>
          <td class="paramname"><em>parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when an item is removed from a leaf node.</p>
<p>Note: this may be called as part of a move operation (remove+add)</p>

<p>Implements <a class="el" href="interfaceLoyc_1_1Collections_1_1Impl_1_1IAListTreeObserver_3_01K_00_01T_01_4.html#a07b43c46bf7d79ae1ccdcba1773a1bf5">Loyc.Collections.Impl.IAListTreeObserver&lt; K, T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a48fbe8c917f1192577b8822d94ebbab9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1void.html">void</a> Loyc.Collections.Impl.AListIndexer&lt; K, T &gt;.NodeAdded </td>
          <td>(</td>
          <td class="paramtype">AListNode&lt; K, T &gt;&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AListInnerBase&lt; K, T &gt;&#160;</td>
          <td class="paramname"><em>parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when a child node is added to an inner node.</p>
<p>Note: this may be called as part of a move operation (remove+add)</p>

<p>Implements <a class="el" href="interfaceLoyc_1_1Collections_1_1Impl_1_1IAListTreeObserver_3_01K_00_01T_01_4.html#a605c03aa32a7878e7453859022f61ebc">Loyc.Collections.Impl.IAListTreeObserver&lt; K, T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a485240c333c0246e5b2ebea9b672759a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1void.html">void</a> Loyc.Collections.Impl.AListIndexer&lt; K, T &gt;.NodeRemoved </td>
          <td>(</td>
          <td class="paramtype">AListNode&lt; K, T &gt;&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AListInnerBase&lt; K, T &gt;&#160;</td>
          <td class="paramname"><em>parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when a child node is removed from an inner node.</p>
<p>Note: this may be called as part of a move operation (remove+add)</p>

<p>Implements <a class="el" href="interfaceLoyc_1_1Collections_1_1Impl_1_1IAListTreeObserver_3_01K_00_01T_01_4.html#a3efb469fbc2ccf1e5fad17b619887798">Loyc.Collections.Impl.IAListTreeObserver&lt; K, T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="adf23683a27cd10a7afb41cd18bfcc5b1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Loyc.Collections.Impl.AListIndexer&lt; K, T &gt;.ReconstructIndex </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AListLeaf&lt; K, T &gt;&#160;</td>
          <td class="paramname"><em>leaf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an item and a leaf that is known to contain a copy of the item, this method returns the index of the item in the tree as a whole. Requires O(M )</p>

</div>
</div>
<a class="anchor" id="a83d088065dd3b9f3c641880278cdb0c1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1void.html">void</a> Loyc.Collections.Impl.AListIndexer&lt; K, T &gt;.RemoveAll </td>
          <td>(</td>
          <td class="paramtype">AListNode&lt; K, T &gt;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when all children are being removed from a node (leaf or inner). Notifications are not sent for individual children.</p>

<p>Implements <a class="el" href="interfaceLoyc_1_1Collections_1_1Impl_1_1IAListTreeObserver_3_01K_00_01T_01_4.html#ad7488b485ec7c71903acf74cc8c028c2">Loyc.Collections.Impl.IAListTreeObserver&lt; K, T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aac51a0a37a81fb0e1745a23e111fb92f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1void.html">void</a> Loyc.Collections.Impl.AListIndexer&lt; K, T &gt;.RootChanged </td>
          <td>(</td>
          <td class="paramtype">AListNode&lt; K, T &gt;&#160;</td>
          <td class="paramname"><em>newRoot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clear</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when the root of the tree changes, or when the list is cleared.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clear</td><td>true if the root is changing due to a Clear() operation. If this parameter is true, the observer should clear its own state. If this parameter is false but newRoot is null, it means that the list was cleared by removing all the items (rather than by calling Clear() on the list). In that case, if the observer still believes that any items exist in leaf nodes, it means that there is a bookkeeping error somewhere.</td></tr>
    <tr><td class="paramname">newRoot</td><td>The new root (null if the tree is cleared).</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interfaceLoyc_1_1Collections_1_1Impl_1_1IAListTreeObserver_3_01K_00_01T_01_4.html#a3abd2107a79db4d3769801f10ca5b267">Loyc.Collections.Impl.IAListTreeObserver&lt; K, T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a9c9b93b9ec85b02a3df15a2afffdae77"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1void.html">void</a> Loyc.Collections.Impl.AListIndexer&lt; K, T &gt;.VerifyCorrectness </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scans the index to verify that it matches the tree that is being indexed. The scan takes O(N log N + N M) time for a list of length N with maximum node size M.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classLoyc_1_1InvalidStateException.html" title="An exception thrown when an object detects that its own state is invalid, or in other words...">InvalidStateException</a></td><td>The index is out of sync with the tree. </td></tr>
  </table>
  </dd>
</dl>
<p>This could indicate a bug somewhere in the A-list code, but it could also be caused by other rogue code, such as items that change their sort order or hashcode after being added to the collection, an observer that has thrown exceptions when it's not allowed to, or buggy multithreading (modifying a list from two threads at once). </p>
<p>Tree observability is a difficult feature to implement correctly, so this method is called a lot in unit tests to help work out the bugs. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Mar 2 2016 14:55:51 for Loyc by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
