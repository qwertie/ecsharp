<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Loyc.Math</name>
    </assembly>
    <members>
        <member name="T:Loyc.Geometry.BoundingBoxMath">
            <summary>Math and extension methods for <see cref="T:Loyc.Geometry.BoundingBox`1"/>.</summary>
            <remarks>This contains many methods that could be considered "core" methods.
            they are implemented as extension methods instead for performance reasons,
            because as a generic class, <see cref="T:Loyc.Geometry.BoundingBox`1"/> cannot do 
            arithmetic quickly.</remarks>
        </member>
        <member name="T:Loyc.Geometry.LineMath">
            <summary>Contains algorithms that operate on lines.</summary>
        </member>
        <member name="M:Loyc.Geometry.LineMath.SimplifyPolyline``1(``0,System.Collections.Generic.ICollection{Loyc.Geometry.Point{System.Single}},System.Single)">
            <summary>Simplifies a polyline using the Douglas-Peucker line 
            simplification algorithm. This algorithm removes points that are 
            deemed unimportant; the output is a subset of the input.</summary>
            <typeparam name="List">Original unsimplified polyline</typeparam>
            <param name="output">The output polyline is added in order to this collection</param>
            <param name="tolerance">The distance between the input polyline and the 
            output polyline will never exceed this distance. Increase this value to 
            simplify more aggressively.</param>
            <returns>The number of output points.</returns>
            <remarks>
            The average time complexity of this algorithm is O(N log N). 
            The worst-case time complexity is O(N^2).
            </remarks>
        </member>
        <member name="M:Loyc.Geometry.LineMath.SimplifyPolyline``1(``0,System.Collections.Generic.ICollection{Loyc.Geometry.Point{System.Double}},System.Double)">
            <inheritdoc cref="M:Loyc.Geometry.LineMath.SimplifyPolyline``1(``0,System.Collections.Generic.ICollection{Loyc.Geometry.Point{System.Single}},System.Single)"/>
        </member>
        <member name="M:Loyc.Geometry.LineMath.ProjectOnto(Loyc.Geometry.Point{System.Single},Loyc.Geometry.LineSegment{System.Single},Loyc.Geometry.LineType)">
            <summary>Performs projection, which finds the point on a line segment 
            or infinite line that is nearest to a specified point.</summary>
            <param name="seg">The line segment</param>
            <param name="p">The test point to be projected</param>
            <param name="infiniteLine">Whether to extend the line infinitely.</param>
            <param name="end">Set to 0 if the point is on the line segment (including
            one of the endpoints), -1 if the point is before seg.A, 1 if the point is 
            after seg.B, and null if the line segment is degenerate (seg.A==seg.B)</param>
            <returns>The projected point.</returns>
            <remarks>
            This algorithm is fast and accurate, and can be easily adapted to 3D.
            A special advantage of this approach is that it runs fastest when the 
            point is projected onto one of the endpoints (when infiniteLine is 
            false).
            <para/>
            Algorithm comes from: http://geomalgorithms.com/a02-_lines.html
            See section "Distance of a Point to a Ray or Segment"
            </remarks>
        </member>
        <member name="M:Loyc.Geometry.LineMath.GetFractionAlong(Loyc.Geometry.Point{System.Single},Loyc.Geometry.LineSegment{System.Single},Loyc.Geometry.LineType)">
            <summary>Gets the projection of a point onto a line, expressed as a 
            fraction where 0 represents the start of the line and 1 represents the 
            end of the line.</summary>
            <param name="infiniteLine">Whether to return numbers outside the range
            (0, 1) if the projection is outside the line segment. If this is false,
            the result is clamped to (0, 1)</param>
            <param name="end">Same as for <see cref="M:Loyc.Geometry.LineMath.ProjectOnto(Loyc.Geometry.Point{System.Single},Loyc.Geometry.LineSegment{System.Single},Loyc.Geometry.LineType)"/>.</param>
            <returns>The fraction of p along seg, as explained already. If seg is
            zero-length, the result is always 0.</returns>
            <remarks>This method uses the same technique as <see cref="M:Loyc.Geometry.LineMath.ProjectOnto(Loyc.Geometry.Point{System.Single},Loyc.Geometry.LineSegment{System.Single},Loyc.Geometry.LineType)"/>.</remarks>
        </member>
        <member name="M:Loyc.Geometry.LineMath.PointAlong(Loyc.Geometry.LineSegment{System.Single},System.Single)">
            <summary>Given a fraction between zero and one, calculates a point 
            between two points (0=point A, 1=point B, 0.5=midpoint).</summary>
            <remarks>If you just want the midpoint, call Midpoint() which 
            is faster. If the fraction is outside the range [0,1], the result
            will be along the infinite extension of the line. If the two points
            are the same, this method always returns the same point as long as
            the math doesn't overflow, possibly with slight deviations caused 
            by floating-point rounding.</remarks>
        </member>
        <member name="M:Loyc.Geometry.LineMath.Midpoint(Loyc.Geometry.LineSegment{System.Single})">
            <summary>Returns the midpoint, (A + B) >> 1.</summary>
        </member>
        <member name="M:Loyc.Geometry.LineMath.ComputeIntersection(Loyc.Geometry.LineSegment{System.Single},Loyc.Geometry.LineType,System.Single@,Loyc.Geometry.LineSegment{System.Single},Loyc.Geometry.LineType,System.Single@)">
            <summary>Computes the location that lines, rays or line segments 
            intersect, expressed as a fraction of the distance along each 
            LineSegment.</summary>
            <param name="P">First line segment</param>
            <param name="pType">Type of line P (Segment, Ray, Infinite)</param>
            <param name="pFrac">Fraction along P of the intersection point. If this
            method returns false, pFrac is still computed. If the hypothetical
            intersection point of the infinite extension of P and Q is beyond the 
            P.A side of the line, pFrac is set to an appropriate negative value if 
            pType is Infinite and 0 otherwise. If the hypothetical intersection
            is on the P.B side of the line, pFrac is set to 1 if pType is Segment
            and a value above 1 otherwise.</param>
            <param name="Q">Second line segment</param>
            <param name="qType">Type of line Q (Segment, Ray, Infinite)</param>
            <param name="qFrac">Fraction along Q of the intersection point. If this
            method returns false, qFrac may be <c>NaN</c> if the analysis of line
            P already determined that pFrac is beyond the range of line P. In other 
            words, if Q is assumed to be an infinite line and P still does not 
            intersect with Q, qFrac is set to NaN because the method aborts 
            analysis to avoid wasting CPU time. On the other hand, if this method 
            determines that P might intersect with Q, but a full analysis shows 
            that it does not, the method returns false and sets qFrac to a real 
            number. qFrac is set to 0 if the intersection point of the infinite 
            extension of Q is on the Q.A side of the line, and 1 if the 
            intersection point is on the Q.B side of the line.</param>
            <returns>True if the lines intersect, false otherwise.</returns>
            <remarks>
            This method does not do a bounding-box check. If you are doing 
            calculations with line segments and you expect the majority of your
            intersection calculations to return false, you may save time by 
            testing whether the bounding boxes of the lines overlap before calling 
            this method.
            <para/>
            If the input segments contain NaNs, the result is false and pFrac/qFrac
            will be NaN.
            <para/>
            If the either of the line segments are degenerate (single points), 
            overlap can still be detected and the LineType of the degenerate line
            has no effect; the degenerate line is always treated as a point.
            If both lines are points, the method will return true iff they are the
            same point, and if true is returned, pFrac will be 0.5f
            <para/>
            The output fractions pFrac and qFrac will be infinite if the magnitude 
            of the result overflows.
            <para/>
            If the two line segments are parallel but do not overlap, this method
            returns false; pFrac and qFrac are both set to NaN. If the two lines 
            are parallel and overlap, a region of overlap is detected and pFrac
            and qFrac refer to the center of this region of overlap. If, in this
            case, P and/or Q are rays or infinite lines, this method behaves as
            though P and/or Q are extended to cover each other. For instance, 
            suppose that P and Q are lines on the X axis, P.A.X=0, P.B.X=6, 
            Q.A.X=10, Q.B.X=16:
            <pre>
                   P.A---------------P.B         Q.B---------------------Q.A
            -2  -1  0  1  2  3  4  5  6  7  8  9  10  11  12  13  14  15  16  17
            </pre>
            If P and Q are both line segments, there is no overlap and this method 
            will return false. However, if Q is a Ray or an infinite line, it 
            extends toward negative infinity and the minimum overlap between the 
            lines is 0..6. In this case, the region of overlap is considered to be 
            0..6 if P is a line segment, and 0..16 if P is a ray or an infinite 
            line. If P is a line segment, the midpoint is 3, and pFrac will be set
            to 0.5, halfway along the line, while qFrac will be 2.333. If P is a 
            ray or an infinite line, the midpoint is 8, pFrac will be 1.333, and
            qFrac will be 1.333.
            </remarks>
        </member>
        <member name="M:Loyc.Geometry.LineMath.ComputeIntersection(Loyc.Geometry.LineSegment{System.Single},Loyc.Geometry.LineType,Loyc.Geometry.LineSegment{System.Single},Loyc.Geometry.LineType)">
            <summary>Computes the intersection point between two lines, rays or 
            line segments.</summary>
            <remarks>This method is implemented based on the other overload,
            <see cref="M:Loyc.Geometry.LineMath.ComputeIntersection(Loyc.Geometry.LineSegment{System.Single},Loyc.Geometry.LineType,System.Single@,Loyc.Geometry.LineSegment{System.Single},Loyc.Geometry.LineType,System.Single@)"/>.
            </remarks>
        </member>
        <member name="M:Loyc.Geometry.LineMath.ClipTo(Loyc.Geometry.LineSegment{System.Single},Loyc.Geometry.BoundingBox{System.Single})">
            <summary>Quickly clips a line to a bounding box.</summary>
            <returns>A clipped line, or null if the line was outside the bounding box.</returns>
            <remarks>If the bounding box is not normalized (min > max), the result is undefined.</remarks>
        </member>
        <member name="M:Loyc.Geometry.LineMath.ProjectOnto(Loyc.Geometry.Point{System.Double},Loyc.Geometry.LineSegment{System.Double},Loyc.Geometry.LineType)">
            <summary>Performs projection, which finds the point on a line segment 
            or infinite line that is nearest to a specified point.</summary>
            <param name="seg">The line segment</param>
            <param name="p">The test point to be projected</param>
            <param name="infiniteLine">Whether to extend the line infinitely.</param>
            <param name="end">Set to 0 if the point is on the line segment (including
            one of the endpoints), -1 if the point is before seg.A, 1 if the point is 
            after seg.B, and null if the line segment is degenerate (seg.A==seg.B)</param>
            <returns>The projected point.</returns>
            <remarks>
            This algorithm is fast and accurate, and can be easily adapted to 3D.
            A special advantage of this approach is that it runs fastest when the 
            point is projected onto one of the endpoints (when infiniteLine is 
            false).
            <para/>
            Algorithm comes from: http://geomalgorithms.com/a02-_lines.html
            See section "Distance of a Point to a Ray or Segment"
            </remarks>
        </member>
        <member name="M:Loyc.Geometry.LineMath.GetFractionAlong(Loyc.Geometry.Point{System.Double},Loyc.Geometry.LineSegment{System.Double},Loyc.Geometry.LineType)">
            <summary>Gets the projection of a point onto a line, expressed as a 
            fraction where 0 represents the start of the line and 1 represents the 
            end of the line.</summary>
            <param name="infiniteLine">Whether to return numbers outside the range
            (0, 1) if the projection is outside the line segment. If this is false,
            the result is clamped to (0, 1)</param>
            <param name="end">Same as for <see cref="M:Loyc.Geometry.LineMath.ProjectOnto(Loyc.Geometry.Point{System.Single},Loyc.Geometry.LineSegment{System.Single},Loyc.Geometry.LineType)"/>.</param>
            <returns>The fraction of p along seg, as explained already. If seg is
            zero-length, the result is always 0.</returns>
            <remarks>This method uses the same technique as <see cref="M:Loyc.Geometry.LineMath.ProjectOnto(Loyc.Geometry.Point{System.Single},Loyc.Geometry.LineSegment{System.Single},Loyc.Geometry.LineType)"/>.</remarks>
        </member>
        <member name="M:Loyc.Geometry.LineMath.PointAlong(Loyc.Geometry.LineSegment{System.Double},System.Double)">
            <summary>Given a fraction between zero and one, calculates a point 
            between two points (0=point A, 1=point B, 0.5=midpoint).</summary>
            <remarks>If you just want the midpoint, call Midpoint() which 
            is faster. If the fraction is outside the range [0,1], the result
            will be along the infinite extension of the line. If the two points
            are the same, this method always returns the same point as long as
            the math doesn't overflow, possibly with slight deviations caused 
            by floating-point rounding.</remarks>
        </member>
        <member name="M:Loyc.Geometry.LineMath.Midpoint(Loyc.Geometry.LineSegment{System.Double})">
            <summary>Returns the midpoint, (A + B) >> 1.</summary>
        </member>
        <member name="M:Loyc.Geometry.LineMath.ComputeIntersection(Loyc.Geometry.LineSegment{System.Double},Loyc.Geometry.LineType,System.Double@,Loyc.Geometry.LineSegment{System.Double},Loyc.Geometry.LineType,System.Double@)">
            <summary>Computes the location that lines, rays or line segments 
            intersect, expressed as a fraction of the distance along each 
            LineSegment.</summary>
            <param name="P">First line segment</param>
            <param name="pType">Type of line P (Segment, Ray, Infinite)</param>
            <param name="pFrac">Fraction along P of the intersection point. If this
            method returns false, pFrac is still computed. If the hypothetical
            intersection point of the infinite extension of P and Q is beyond the 
            P.A side of the line, pFrac is set to an appropriate negative value if 
            pType is Infinite and 0 otherwise. If the hypothetical intersection
            is on the P.B side of the line, pFrac is set to 1 if pType is Segment
            and a value above 1 otherwise.</param>
            <param name="Q">Second line segment</param>
            <param name="qType">Type of line Q (Segment, Ray, Infinite)</param>
            <param name="qFrac">Fraction along Q of the intersection point. If this
            method returns false, qFrac may be <c>NaN</c> if the analysis of line
            P already determined that pFrac is beyond the range of line P. In other 
            words, if Q is assumed to be an infinite line and P still does not 
            intersect with Q, qFrac is set to NaN because the method aborts 
            analysis to avoid wasting CPU time. On the other hand, if this method 
            determines that P might intersect with Q, but a full analysis shows 
            that it does not, the method returns false and sets qFrac to a real 
            number. qFrac is set to 0 if the intersection point of the infinite 
            extension of Q is on the Q.A side of the line, and 1 if the 
            intersection point is on the Q.B side of the line.</param>
            <returns>True if the lines intersect, false otherwise.</returns>
            <remarks>
            This method does not do a bounding-box check. If you are doing 
            calculations with line segments and you expect the majority of your
            intersection calculations to return false, you may save time by 
            testing whether the bounding boxes of the lines overlap before calling 
            this method.
            <para/>
            If the input segments contain NaNs, the result is false and pFrac/qFrac
            will be NaN.
            <para/>
            If the either of the line segments are degenerate (single points), 
            overlap can still be detected and the LineType of the degenerate line
            has no effect; the degenerate line is always treated as a point.
            If both lines are points, the method will return true iff they are the
            same point, and if true is returned, pFrac will be 0.5f
            <para/>
            The output fractions pFrac and qFrac will be infinite if the magnitude 
            of the result overflows.
            <para/>
            If the two line segments are parallel but do not overlap, this method
            returns false; pFrac and qFrac are both set to NaN. If the two lines 
            are parallel and overlap, a region of overlap is detected and pFrac
            and qFrac refer to the center of this region of overlap. If, in this
            case, P and/or Q are rays or infinite lines, this method behaves as
            though P and/or Q are extended to cover each other. For instance, 
            suppose that P and Q are lines on the X axis, P.A.X=0, P.B.X=6, 
            Q.A.X=10, Q.B.X=16:
            <pre>
                   P.A---------------P.B         Q.B---------------------Q.A
            -2  -1  0  1  2  3  4  5  6  7  8  9  10  11  12  13  14  15  16  17
            </pre>
            If P and Q are both line segments, there is no overlap and this method 
            will return false. However, if Q is a Ray or an infinite line, it 
            extends toward negative infinity and the minimum overlap between the 
            lines is 0..6. In this case, the region of overlap is considered to be 
            0..6 if P is a line segment, and 0..16 if P is a ray or an infinite 
            line. If P is a line segment, the midpoint is 3, and pFrac will be set
            to 0.5, halfway along the line, while qFrac will be 2.333. If P is a 
            ray or an infinite line, the midpoint is 8, pFrac will be 1.333, and
            qFrac will be 1.333.
            </remarks>
        </member>
        <member name="M:Loyc.Geometry.LineMath.ComputeIntersection(Loyc.Geometry.LineSegment{System.Double},Loyc.Geometry.LineType,Loyc.Geometry.LineSegment{System.Double},Loyc.Geometry.LineType)">
            <summary>Computes the intersection point between two lines, rays or 
            line segments.</summary>
            <remarks>This method is implemented based on the other overload,
            <see cref="M:Loyc.Geometry.LineMath.ComputeIntersection(Loyc.Geometry.LineSegment{System.Double},Loyc.Geometry.LineType,System.Double@,Loyc.Geometry.LineSegment{System.Double},Loyc.Geometry.LineType,System.Double@)"/>.
            </remarks>
        </member>
        <member name="M:Loyc.Geometry.LineMath.ClipTo(Loyc.Geometry.LineSegment{System.Double},Loyc.Geometry.BoundingBox{System.Double})">
            <summary>Quickly clips a line to a bounding box.</summary>
            <returns>A clipped line, or null if the line was outside the bounding box.</returns>
            <remarks>If the bounding box is not normalized (min > max), the result is undefined.</remarks>
        </member>
        <member name="T:Loyc.Geometry.LineType">
            <summary>Indicates how a <see cref="T:Loyc.Geometry.LineSegment`1"/> should be treated in
            a math algorithm: as a segment (the default), as a ray originating at A 
            (extending B infinitely), or as an line that is infinite in both directions.</summary>
        </member>
        <member name="T:Loyc.Geometry.PointExt">
            <summary>Contains methods for manipulating points in generic code.</summary>
            <remarks>Using <see cref="T:Loyc.Geometry.PointMath"/> extension methods is easier. These
            methods may be faster but they require a "math" structure (see <see cref="T:Loyc.Math.Maths`1"/>).</remarks>
        </member>
        <member name="M:Loyc.Geometry.PointExt.Add``3(``2,``0,``0)">
            <summary>Returns the sum of two vectors.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointExt.Subtract``2(``1,Loyc.Geometry.IPoint{``0},Loyc.Geometry.IPoint{``0})">
            <summary>Returns the difference between two points or vectors.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointExt.Multiply``2(``1,Loyc.Geometry.IPoint{``0},``0)">
            <summary>Returns a point or vector multiplied by a scaling factor.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointExt.Divide``2(``1,Loyc.Geometry.IPoint{``0},``0)">
            <summary>Returns a point or vector divided by a scaling factor.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointExt.ShiftLeft``2(``1,Loyc.Geometry.IPoint{``0},System.Int32)">
            <summary>Returns a point or vector scaled up by a power of two.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointExt.ShiftRight``2(``1,Loyc.Geometry.IPoint{``0},System.Int32)">
            <summary>Returns a point or vector scaled down by a power of two.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointExt.MulDiv``2(``1,Loyc.Geometry.IPoint{``0},``0,``0)">
            <summary>Returns a point or vector by a factor, then divides by another factor.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointExt.Dot``2(``1,Loyc.Geometry.IPoint{``0},Loyc.Geometry.IPoint{``0})">
            <summary>Gets the dot product of two vectors.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointExt.Cross``2(``1,Loyc.Geometry.IPoint{``0},Loyc.Geometry.IPoint{``0})">
            <summary>Gets the cross product of two vectors.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointExt.Rot90``2(``1,Loyc.Geometry.IPoint{``0})">
            <summary>Returns a vector rotated 90 degrees.</summary>
            <remarks>
            Rotatation is clockwise if increasing Y goes downward, counter-
            clockwise if increasing Y goes upward.
            </remarks>
        </member>
        <member name="M:Loyc.Geometry.PointExt.Negate``2(``1,Loyc.Geometry.IPoint{``0})">
            <summary>Returns a vector with its direction reversed.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointExt.Quadrance``2(``1,Loyc.Geometry.IPoint{``0})">
            <summary>Gets the square of the length of a vector.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointExt.Length``2(``1,Loyc.Geometry.IPoint{``0})">
            <summary>Gets the length of a vector.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointExt.Angle``2(``1,Loyc.Geometry.IPoint{``0})">
            <summary>Gets the angle from 0 to 2*PI of the vector, where (1,0) has 
            angle 0 and (0,1) has angle PI/2.</summary>
        </member>
        <member name="T:Loyc.Geometry.PointMath">
            <summary>Math and extension methods for <see cref="T:Loyc.Geometry.Point`1"/>.</summary>
            <remarks>This contains many methods that should be considered "core" 
            functionality, including many methods such as Add(), Sub() and Mul() that 
            would ordinarily be implemented as operators (+ - *) if it weren't for 
            limitations of C#. These operations are implemented as extension methods for 
            performance reasons, because as a generic class, <see cref="T:Loyc.Geometry.Point`1"/> 
            cannot do arithmetic quickly. The extension methods provide operations that 
            are optimized for specific data types (currently int, float and double).</remarks>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Cross``1(Loyc.Geometry.Vector{``0},Loyc.Geometry.Vector{``0})">
            <summary>Computes the "cross product" of a pair of vectors.</summary>
            <remarks>
            This is not a general cross product, as cross product is only a 3D concept,
            but this operator acts as though the two points were in the Z=0 plane and
            returns the Z coordinate of the cross product: b.X * a.Y - b.Y * a.X.
            This value is zero if the vectors are parallel; it is a.Length * b.Length 
            or -a.Length * b.Length if the vectors are perpendicular. One use of 
            cross product is to determine whether the angle between two lines is greater 
            or less than 180 degrees, corresponding to return values less or greater than 
            zero.
            </remarks>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Rot90``1(Loyc.Geometry.Vector{``0})">
            <summary>Rotates a vector 90 degrees.</summary>
            <remarks>
            Rotatation is clockwise if increasing Y goes downward, counter-
            clockwise if increasing Y goes upward. If the vector represents the 
            direction of a line, the result also represents the coefficients 
            (a,b) of the implicit line equation aX + bY + c = 0.
            </remarks>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Quadrance``1(Loyc.Geometry.Vector{``0})">
            <summary>Gets the square of the length of the vector.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Length``1(Loyc.Geometry.Vector{``0})">
            <summary>Gets the length of the vector.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Angle``1(Loyc.Geometry.Vector{``0})">
            <summary>Gets the angle from 0 to 2*PI of the vector, where (1,0) has 
            angle 0 and (0,1) has angle PI/2.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Vector``1(Loyc.Geometry.LineSegment{``0})">
            <summary>Returns the vector from A to B (seg.B - seg.A)</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.HalfwayTo``1(Loyc.Geometry.Point{``0},Loyc.Geometry.Point{``0})">
            <summary>Returns the midpoint between A and B ((a + b) / 2)</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.AsBCL(Loyc.Geometry.Point{System.Int32})">
            <summary>Converts a Loyc point to BCL type.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.AsBCL(Loyc.Geometry.Vector{System.Int32})">
            <summary>Converts a Loyc vector to BCL type.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.AsBCL(Loyc.Geometry.Point{System.Single})">
            <summary>Converts a Loyc point to BCL type.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.AsBCL(Loyc.Geometry.Vector{System.Single})">
            <summary>Converts a Loyc vector to BCL type.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.AsBCL(Loyc.Geometry.Point{System.Double})">
            <summary>Converts a Loyc point to BCL type.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.AsBCL(Loyc.Geometry.Vector{System.Double})">
            <summary>Converts a Loyc vector to BCL type.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.AsLoyc(System.Drawing.Point)">
            <summary>Converts a BCL point to a Loyc point.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.AsLoyc(System.Drawing.PointF)">
            <summary>Converts a BCL point to a Loyc point.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.AsLoyc(System.Windows.Point)">
            <summary>Converts a BCL point to a Loyc point.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.AsLoyc(System.Windows.Vector)">
            <summary>Converts a BCL Vector to a Loyc point.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.AsLoycVector(System.Drawing.Point)">
            <summary>Converts a BCL point to a Loyc vector.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.AsLoycVector(System.Drawing.PointF)">
            <summary>Converts a BCL point to a Loyc vector.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.AsLoycVector(System.Windows.Point)">
            <summary>Converts a BCL point to a Loyc vector.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.To``1(Loyc.Geometry.Point{``0},Loyc.Geometry.Point{``0})">
            <summary>Constructs a <see cref="T:Loyc.Geometry.LineSegment`1"/> from two points.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Abs``1(Loyc.Geometry.Vector{``0})">
            <summary>Gets the absolute value of vector's individual components.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Abs``1(Loyc.Geometry.Vector3{``0})">
            <summary>Gets the absolute value of vector's individual components.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Dot(Loyc.Geometry.Vector{System.Int32},Loyc.Geometry.Vector{System.Int32})">
            <summary>Dot product. a*b equals lhs.Length*rhs.Length*Cos(theta) if theta 
            is the angle between two vectors.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Cross(Loyc.Geometry.Vector{System.Int32},Loyc.Geometry.Vector{System.Int32})">
            <summary>Computes the "cross product" of a pair of 2D vectors.</summary>
            <remarks>
            This is not a general cross product, as cross product is only a 3D concept,
            but this operator acts as though the two points were in the Z=0 plane and
            returns the Z coordinate of the cross product: b.X * a.Y - b.Y * a.X.
            This value is zero if the vectors are parallel; it is a.Length * b.Length 
            or -a.Length * b.Length if the vectors are perpendicular. One use of 
            cross product is to determine whether the angle between two lines is greater 
            or less than 180 degrees, corresponding to return values less or greater than 
            zero.
            </remarks>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Cross(Loyc.Geometry.Vector3{System.Int32},Loyc.Geometry.Vector3{System.Int32})">
            <summary>Computes the cross product of a pair of 3D vectors.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Rot90(Loyc.Geometry.Vector{System.Int32})">
            <summary>Rotates a vector 90 degrees.</summary>
            <remarks>
            Rotatation is clockwise if increasing Y goes downward, counter-
            clockwise if increasing Y goes upward. If the vector represents the 
            direction of a line, the result also represents the coefficients 
            (a,b) of the implicit line equation aX + bY + c = 0.
            </remarks>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Neg(Loyc.Geometry.Vector{System.Int32})">
            <summary>Reverses a vector.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Neg(Loyc.Geometry.Vector3{System.Int32})">
            <summary>Reverses a vector.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Quadrance(Loyc.Geometry.Vector{System.Int32})">
            <summary>Gets the square of the length of the vector.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Length(Loyc.Geometry.Vector{System.Int32})">
            <summary>Gets the length of the vector.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Angle(Loyc.Geometry.Vector{System.Int32})">
            <summary>Gets the angle from 0 to 2*PI of the vector, where (1,0) has 
            angle 0 and (0,1) has angle PI/2.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.AngleDeg(Loyc.Geometry.Vector{System.Int32})">
            <summary>Gets the angle from 0 to 360 of the vector, where (1,0) has 
            angle 0 and (0,1) has angle 90.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Vector(Loyc.Geometry.LineSegment{System.Int32})">
            <summary>Returns seg.B - seg.A.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Abs(Loyc.Geometry.Vector{System.Int32})">
            <summary>Gets the absolute value of the vector's individual components.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Abs(Loyc.Geometry.Vector3{System.Int32})">
            <summary>Gets the absolute value of the vector's individual components.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.ComputeConvexHull(System.Collections.Generic.IEnumerable{Loyc.Geometry.Point{System.Int32}})">
            <summary>Computes the convex hull of a polygon, in clockwise order in a Y-up 
            coordinate system (counterclockwise in a Y-down coordinate system).</summary>
            <remarks>Uses the Monotone Chain algorithm, a.k.a. Andrew's Algorithm.</remarks>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Dot(Loyc.Geometry.Vector{System.Single},Loyc.Geometry.Vector{System.Single})">
            <summary>Dot product. a*b equals lhs.Length*rhs.Length*Cos(theta) if theta 
            is the angle between two vectors.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Cross(Loyc.Geometry.Vector{System.Single},Loyc.Geometry.Vector{System.Single})">
            <summary>Computes the "cross product" of a pair of 2D vectors.</summary>
            <remarks>
            This is not a general cross product, as cross product is only a 3D concept,
            but this operator acts as though the two points were in the Z=0 plane and
            returns the Z coordinate of the cross product: b.X * a.Y - b.Y * a.X.
            This value is zero if the vectors are parallel; it is a.Length * b.Length 
            or -a.Length * b.Length if the vectors are perpendicular. One use of 
            cross product is to determine whether the angle between two lines is greater 
            or less than 180 degrees, corresponding to return values less or greater than 
            zero.
            </remarks>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Cross(Loyc.Geometry.Vector3{System.Single},Loyc.Geometry.Vector3{System.Single})">
            <summary>Computes the cross product of a pair of 3D vectors.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Rot90(Loyc.Geometry.Vector{System.Single})">
            <summary>Rotates a vector 90 degrees.</summary>
            <remarks>
            Rotatation is clockwise if increasing Y goes downward, counter-
            clockwise if increasing Y goes upward. If the vector represents the 
            direction of a line, the result also represents the coefficients 
            (a,b) of the implicit line equation aX + bY + c = 0.
            </remarks>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Neg(Loyc.Geometry.Vector{System.Single})">
            <summary>Reverses a vector.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Neg(Loyc.Geometry.Vector3{System.Single})">
            <summary>Reverses a vector.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Quadrance(Loyc.Geometry.Vector{System.Single})">
            <summary>Gets the square of the length of the vector.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Length(Loyc.Geometry.Vector{System.Single})">
            <summary>Gets the length of the vector.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Angle(Loyc.Geometry.Vector{System.Single})">
            <summary>Gets the angle from 0 to 2*PI of the vector, where (1,0) has 
            angle 0 and (0,1) has angle PI/2.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.AngleDeg(Loyc.Geometry.Vector{System.Single})">
            <summary>Gets the angle from 0 to 360 of the vector, where (1,0) has 
            angle 0 and (0,1) has angle 90.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Vector(Loyc.Geometry.LineSegment{System.Single})">
            <summary>Returns seg.B - seg.A.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Abs(Loyc.Geometry.Vector{System.Single})">
            <summary>Gets the absolute value of the vector's individual components.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Abs(Loyc.Geometry.Vector3{System.Single})">
            <summary>Gets the absolute value of the vector's individual components.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.ComputeConvexHull(System.Collections.Generic.IEnumerable{Loyc.Geometry.Point{System.Single}})">
            <summary>Computes the convex hull of a polygon, in clockwise order in a Y-up 
            coordinate system (counterclockwise in a Y-down coordinate system).</summary>
            <remarks>Uses the Monotone Chain algorithm, a.k.a. Andrew's Algorithm.</remarks>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Dot(Loyc.Geometry.Vector{System.Double},Loyc.Geometry.Vector{System.Double})">
            <summary>Dot product. a*b equals lhs.Length*rhs.Length*Cos(theta) if theta 
            is the angle between two vectors.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Cross(Loyc.Geometry.Vector{System.Double},Loyc.Geometry.Vector{System.Double})">
            <summary>Computes the "cross product" of a pair of 2D vectors.</summary>
            <remarks>
            This is not a general cross product, as cross product is only a 3D concept,
            but this operator acts as though the two points were in the Z=0 plane and
            returns the Z coordinate of the cross product: b.X * a.Y - b.Y * a.X.
            This value is zero if the vectors are parallel; it is a.Length * b.Length 
            or -a.Length * b.Length if the vectors are perpendicular. One use of 
            cross product is to determine whether the angle between two lines is greater 
            or less than 180 degrees, corresponding to return values less or greater than 
            zero.
            </remarks>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Cross(Loyc.Geometry.Vector3{System.Double},Loyc.Geometry.Vector3{System.Double})">
            <summary>Computes the cross product of a pair of 3D vectors.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Rot90(Loyc.Geometry.Vector{System.Double})">
            <summary>Rotates a vector 90 degrees.</summary>
            <remarks>
            Rotatation is clockwise if increasing Y goes downward, counter-
            clockwise if increasing Y goes upward. If the vector represents the 
            direction of a line, the result also represents the coefficients 
            (a,b) of the implicit line equation aX + bY + c = 0.
            </remarks>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Neg(Loyc.Geometry.Vector{System.Double})">
            <summary>Reverses a vector.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Neg(Loyc.Geometry.Vector3{System.Double})">
            <summary>Reverses a vector.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Quadrance(Loyc.Geometry.Vector{System.Double})">
            <summary>Gets the square of the length of the vector.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Length(Loyc.Geometry.Vector{System.Double})">
            <summary>Gets the length of the vector.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Angle(Loyc.Geometry.Vector{System.Double})">
            <summary>Gets the angle from 0 to 2*PI of the vector, where (1,0) has 
            angle 0 and (0,1) has angle PI/2.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.AngleDeg(Loyc.Geometry.Vector{System.Double})">
            <summary>Gets the angle from 0 to 360 of the vector, where (1,0) has 
            angle 0 and (0,1) has angle 90.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Vector(Loyc.Geometry.LineSegment{System.Double})">
            <summary>Returns seg.B - seg.A.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Abs(Loyc.Geometry.Vector{System.Double})">
            <summary>Gets the absolute value of the vector's individual components.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Abs(Loyc.Geometry.Vector3{System.Double})">
            <summary>Gets the absolute value of the vector's individual components.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.ComputeConvexHull(System.Collections.Generic.IEnumerable{Loyc.Geometry.Point{System.Double}})">
            <summary>Computes the convex hull of a polygon, in clockwise order in a Y-up 
            coordinate system (counterclockwise in a Y-down coordinate system).</summary>
            <remarks>Uses the Monotone Chain algorithm, a.k.a. Andrew's Algorithm.</remarks>
        </member>
        <member name="T:Loyc.Geometry.PolygonMath">
            <summary>
            Contains useful basic polygon algorithms: hit testing, area calculation,
            orientation detection.
            </summary>
            <summary>
            Contains useful basic polygon algorithms: hit testing, area calculation,
            orientation detection.
            </summary>
            <summary>
            Contains useful basic polygon algorithms: hit testing, area calculation,
            orientation detection.
            </summary>
            <summary>
            Contains useful basic polygon algorithms: hit testing, area calculation,
            orientation detection.
            </summary>
            <summary>
            Contains useful basic polygon algorithms: hit testing, area calculation,
            orientation detection.
            </summary>
        </member>
        <member name="M:Loyc.Geometry.PolygonMath.PolygonArea(System.Collections.Generic.IEnumerable{Loyc.Geometry.Point{System.Int32}})">
            <summary>Computes the area of a polygon.</summary>
            <returns>The area. The result is positive if the polygon is clockwise 
            (assuming a coordinate system in which increasing Y goes upward), or 
            negative if the polygon is counterclockwise.</returns>
            <remarks>http://www.codeproject.com/Tips/601272/Calculating-the-area-of-a-polygon</remarks>
        </member>
        <member name="M:Loyc.Geometry.PolygonMath.Orientation(System.Collections.Generic.IEnumerable{Loyc.Geometry.Point{System.Int32}})">
            <summary>Returns Math.Sign(PolygonArea(poly)): positive when clockwise 
            and increasing Y goes upward.</summary>
            <remarks>A common approach to this problem is to look at the topmost
            point and the two points on either side. However, if one is not careful,
            this technique may be unable to detect the orientation in case the 
            polygon has duplicate points, horizontal lines on top, or a degenerate
            top in which the top part of the polygon is zero-width (these problems
            can occur even if the polygon's lines do not cross one another.) That's
            why I chose to compute orientation based on area instead.</remarks>
        </member>
        <member name="M:Loyc.Geometry.PolygonMath.IsPointInPolygon(System.Collections.Generic.IEnumerable{Loyc.Geometry.Point{System.Int32}},Loyc.Geometry.Point{System.Int32})">
            <summary>Finds out if a point is inside the polygon using a winding 
            test.</summary>
        </member>
        <member name="M:Loyc.Geometry.PolygonMath.GetWindingNumber(System.Collections.Generic.IEnumerable{Loyc.Geometry.Point{System.Int32}},Loyc.Geometry.Point{System.Int32})">
            <summary>Counts the number of times the polygon winds around a test 
            point, using a rightward raycasting test.</summary>
            <returns>Returns the winding number: the number of times that the
            polygon winds around the point. Positive means clockwise (assuming a 
            coordinate system in which increasing Y goes upward), negative means
            counterclockwise. Always returns -1, 0 or +1 when the polygon does
            not self-intersect. Returns 0 for a degenerate polygon.</returns>
            <remarks>
            The test point is considered to be within the polygon if it lies
            on a top or left edge, but not on a bottom or right edge (within
            the precision limits of 'double' arithmetic). The test point will 
            never be considered inside a degenerate (zero-width) area.
            </remarks>
        </member>
        <member name="M:Loyc.Geometry.PolygonMath.PolygonArea(System.Collections.Generic.IEnumerable{Loyc.Geometry.Point{System.Single}})">
            <summary>Computes the area of a polygon.</summary>
            <returns>The area. The result is positive if the polygon is clockwise 
            (assuming a coordinate system in which increasing Y goes upward), or 
            negative if the polygon is counterclockwise.</returns>
            <remarks>http://www.codeproject.com/Tips/601272/Calculating-the-area-of-a-polygon</remarks>
        </member>
        <member name="M:Loyc.Geometry.PolygonMath.Orientation(System.Collections.Generic.IEnumerable{Loyc.Geometry.Point{System.Single}})">
            <summary>Returns Math.Sign(PolygonArea(poly)): positive when clockwise 
            and increasing Y goes upward.</summary>
            <remarks>A common approach to this problem is to look at the topmost
            point and the two points on either side. However, if one is not careful,
            this technique may be unable to detect the orientation in case the 
            polygon has duplicate points, horizontal lines on top, or a degenerate
            top in which the top part of the polygon is zero-width (these problems
            can occur even if the polygon's lines do not cross one another.) That's
            why I chose to compute orientation based on area instead.</remarks>
        </member>
        <member name="M:Loyc.Geometry.PolygonMath.IsPointInPolygon(System.Collections.Generic.IEnumerable{Loyc.Geometry.Point{System.Single}},Loyc.Geometry.Point{System.Single})">
            <summary>Finds out if a point is inside the polygon using a winding 
            test.</summary>
        </member>
        <member name="M:Loyc.Geometry.PolygonMath.GetWindingNumber(System.Collections.Generic.IEnumerable{Loyc.Geometry.Point{System.Single}},Loyc.Geometry.Point{System.Single})">
            <summary>Counts the number of times the polygon winds around a test 
            point, using a rightward raycasting test.</summary>
            <returns>Returns the winding number: the number of times that the
            polygon winds around the point. Positive means clockwise (assuming a 
            coordinate system in which increasing Y goes upward), negative means
            counterclockwise. Always returns -1, 0 or +1 when the polygon does
            not self-intersect. Returns 0 for a degenerate polygon.</returns>
            <remarks>
            The test point is considered to be within the polygon if it lies
            on a top or left edge, but not on a bottom or right edge (within
            the precision limits of 'double' arithmetic). The test point will 
            never be considered inside a degenerate (zero-width) area.
            </remarks>
        </member>
        <member name="M:Loyc.Geometry.PolygonMath.PolygonArea(System.Collections.Generic.IEnumerable{Loyc.Geometry.Point{System.Double}})">
            <summary>Computes the area of a polygon.</summary>
            <returns>The area. The result is positive if the polygon is clockwise 
            (assuming a coordinate system in which increasing Y goes upward), or 
            negative if the polygon is counterclockwise.</returns>
            <remarks>http://www.codeproject.com/Tips/601272/Calculating-the-area-of-a-polygon</remarks>
        </member>
        <member name="M:Loyc.Geometry.PolygonMath.Orientation(System.Collections.Generic.IEnumerable{Loyc.Geometry.Point{System.Double}})">
            <summary>Returns Math.Sign(PolygonArea(poly)): positive when clockwise 
            and increasing Y goes upward.</summary>
            <remarks>A common approach to this problem is to look at the topmost
            point and the two points on either side. However, if one is not careful,
            this technique may be unable to detect the orientation in case the 
            polygon has duplicate points, horizontal lines on top, or a degenerate
            top in which the top part of the polygon is zero-width (these problems
            can occur even if the polygon's lines do not cross one another.) That's
            why I chose to compute orientation based on area instead.</remarks>
        </member>
        <member name="M:Loyc.Geometry.PolygonMath.IsPointInPolygon(System.Collections.Generic.IEnumerable{Loyc.Geometry.Point{System.Double}},Loyc.Geometry.Point{System.Double})">
            <summary>Finds out if a point is inside the polygon using a winding 
            test.</summary>
        </member>
        <member name="M:Loyc.Geometry.PolygonMath.GetWindingNumber(System.Collections.Generic.IEnumerable{Loyc.Geometry.Point{System.Double}},Loyc.Geometry.Point{System.Double})">
            <summary>Counts the number of times the polygon winds around a test 
            point, using a rightward raycasting test.</summary>
            <returns>Returns the winding number: the number of times that the
            polygon winds around the point. Positive means clockwise (assuming a 
            coordinate system in which increasing Y goes upward), negative means
            counterclockwise. Always returns -1, 0 or +1 when the polygon does
            not self-intersect. Returns 0 for a degenerate polygon.</returns>
            <remarks>
            The test point is considered to be within the polygon if it lies
            on a top or left edge, but not on a bottom or right edge (within
            the precision limits of 'double' arithmetic). The test point will 
            never be considered inside a degenerate (zero-width) area.
            </remarks>
        </member>
        <member name="M:Loyc.Geometry.PolygonMath.PolygonArea(System.Collections.Generic.IEnumerable{Loyc.Geometry.Point{Loyc.Math.FPI8}})">
            <summary>Computes the area of a polygon.</summary>
            <returns>The area. The result is positive if the polygon is clockwise 
            (assuming a coordinate system in which increasing Y goes upward), or 
            negative if the polygon is counterclockwise.</returns>
            <remarks>http://www.codeproject.com/Tips/601272/Calculating-the-area-of-a-polygon</remarks>
        </member>
        <member name="M:Loyc.Geometry.PolygonMath.Orientation(System.Collections.Generic.IEnumerable{Loyc.Geometry.Point{Loyc.Math.FPI8}})">
            <summary>Returns Math.Sign(PolygonArea(poly)): positive when clockwise 
            and increasing Y goes upward.</summary>
            <remarks>A common approach to this problem is to look at the topmost
            point and the two points on either side. However, if one is not careful,
            this technique may be unable to detect the orientation in case the 
            polygon has duplicate points, horizontal lines on top, or a degenerate
            top in which the top part of the polygon is zero-width (these problems
            can occur even if the polygon's lines do not cross one another.) That's
            why I chose to compute orientation based on area instead.</remarks>
        </member>
        <member name="M:Loyc.Geometry.PolygonMath.IsPointInPolygon(System.Collections.Generic.IEnumerable{Loyc.Geometry.Point{Loyc.Math.FPI8}},Loyc.Geometry.Point{Loyc.Math.FPI8})">
            <summary>Finds out if a point is inside the polygon using a winding 
            test.</summary>
        </member>
        <member name="M:Loyc.Geometry.PolygonMath.GetWindingNumber(System.Collections.Generic.IEnumerable{Loyc.Geometry.Point{Loyc.Math.FPI8}},Loyc.Geometry.Point{Loyc.Math.FPI8})">
            <summary>Counts the number of times the polygon winds around a test 
            point, using a rightward raycasting test.</summary>
            <returns>Returns the winding number: the number of times that the
            polygon winds around the point. Positive means clockwise (assuming a 
            coordinate system in which increasing Y goes upward), negative means
            counterclockwise. Always returns -1, 0 or +1 when the polygon does
            not self-intersect. Returns 0 for a degenerate polygon.</returns>
            <remarks>
            The test point is considered to be within the polygon if it lies
            on a top or left edge, but not on a bottom or right edge (within
            the precision limits of 'double' arithmetic). The test point will 
            never be considered inside a degenerate (zero-width) area.
            </remarks>
        </member>
        <member name="M:Loyc.Geometry.PolygonMath.PolygonArea(System.Collections.Generic.IEnumerable{Loyc.Geometry.Point{Loyc.Math.FPI16}})">
            <summary>Computes the area of a polygon.</summary>
            <returns>The area. The result is positive if the polygon is clockwise 
            (assuming a coordinate system in which increasing Y goes upward), or 
            negative if the polygon is counterclockwise.</returns>
            <remarks>http://www.codeproject.com/Tips/601272/Calculating-the-area-of-a-polygon</remarks>
        </member>
        <member name="M:Loyc.Geometry.PolygonMath.Orientation(System.Collections.Generic.IEnumerable{Loyc.Geometry.Point{Loyc.Math.FPI16}})">
            <summary>Returns Math.Sign(PolygonArea(poly)): positive when clockwise 
            and increasing Y goes upward.</summary>
            <remarks>A common approach to this problem is to look at the topmost
            point and the two points on either side. However, if one is not careful,
            this technique may be unable to detect the orientation in case the 
            polygon has duplicate points, horizontal lines on top, or a degenerate
            top in which the top part of the polygon is zero-width (these problems
            can occur even if the polygon's lines do not cross one another.) That's
            why I chose to compute orientation based on area instead.</remarks>
        </member>
        <member name="M:Loyc.Geometry.PolygonMath.IsPointInPolygon(System.Collections.Generic.IEnumerable{Loyc.Geometry.Point{Loyc.Math.FPI16}},Loyc.Geometry.Point{Loyc.Math.FPI16})">
            <summary>Finds out if a point is inside the polygon using a winding 
            test.</summary>
        </member>
        <member name="M:Loyc.Geometry.PolygonMath.GetWindingNumber(System.Collections.Generic.IEnumerable{Loyc.Geometry.Point{Loyc.Math.FPI16}},Loyc.Geometry.Point{Loyc.Math.FPI16})">
            <summary>Counts the number of times the polygon winds around a test 
            point, using a rightward raycasting test.</summary>
            <returns>Returns the winding number: the number of times that the
            polygon winds around the point. Positive means clockwise (assuming a 
            coordinate system in which increasing Y goes upward), negative means
            counterclockwise. Always returns -1, 0 or +1 when the polygon does
            not self-intersect. Returns 0 for a degenerate polygon.</returns>
            <remarks>
            The test point is considered to be within the polygon if it lies
            on a top or left edge, but not on a bottom or right edge (within
            the precision limits of 'double' arithmetic). The test point will 
            never be considered inside a degenerate (zero-width) area.
            </remarks>
        </member>
        <member name="T:Loyc.Geometry.Rectangle3Ext">
            <summary>Contains methods to manipulate rectangles.</summary>
            <remarks>Unfortunately, C# often can't infer the type parameters. Many of 
            these methods must be called with explicit type parameters.</remarks>
        </member>
        <member name="T:Loyc.Geometry.RectangleExt">
            <summary>Contains methods to manipulate rectangles.</summary>
            <remarks>Unfortunately, C# often can't infer the type parameters. Many of 
            these methods must be called with explicit type parameters.</remarks>
        </member>
        <member name="M:Loyc.Geometry.RectangleExt.Union``2(``0,``0)">
            <summary>Computes the union of two <i>normalized</i> rectangles,
            i.e. a rectangle large enough to cover both original rectangles.</summary>
            <remarks>The results may be incorrect if one or both rectangles 
            are not normalized.</remarks>
        </member>
        <member name="M:Loyc.Geometry.RectangleExt.Intersect``2(``0,``0)">
            <summary>Computes the intersection of two <i>normalized</i> rectangles,
            i.e. the region covered by both original rectangles.</summary>
            <remarks>The results may be incorrect if one or both rectangles are
            not normalized. If the rectangles do not overlap, a non-normalized 
            rectangle is returned.</remarks>
        </member>
        <member name="M:Loyc.Geometry.RectangleExt.ExpandToInclude``3(``0,``1)">
            <summary>Expands a rectangle's boundaries to include a given point.</summary>
            <returns>Returns true if the rectangle changed.</returns>
        </member>
        <member name="M:Loyc.Geometry.RectangleExt.ExpandToInclude``3(``0,System.Collections.Generic.IEnumerable{``1})">
            <summary>Expands a rectangle's boundaries to include a series of points.</summary>
            <returns>Returns true if the rectangle changed.</returns>
        </member>
        <member name="M:Loyc.Geometry.RectangleExt.Contains``3(``0,``1)">
            <summary>Determines whether a rectangle contains a given point.</summary>
            <remarks>Returns false if the rectangle is not normalized.</remarks>
        </member>
        <member name="M:Loyc.Geometry.RectangleExt.Contains``2(``0,``0)">
            <summary>Determines whether a rectangle fully contains another rectangle.</summary>
            <remarks>May not work correctly if either of the rectangles is not normalized.</remarks>
        </member>
        <member name="M:Loyc.Geometry.RectangleExt.Overlaps``2(``0,``0)">
            <summary>Determines whether a rectangle overlaps another rectangle.</summary>
            <remarks>May not work correctly if either of the rectangles is not normalized.</remarks>
        </member>
        <member name="T:Loyc.Geometry.BoundingBox`1">
            <summary>Holds a mutable 2D bounding rectangle.</summary>
            <typeparam name="T">Data type of each coordinate.</typeparam>
            <remarks>
            Many extension methods are provided in <see cref="T:Loyc.Geometry.BoundingBoxExt"/>.
            They are separate from the class itself so that specialized versions are
            available for particular types (notably int, double and float).
            <para/>
            X1 and Y1 should contains the minimum coordinates, while X2 and Y2 
            should contain the maximum coordinates. BoundingBox generally does not 
            guarantee that this is true unless you call <see cref="M:Loyc.Geometry.BoundingBoxExt.Normalize``1(Loyc.Geometry.BoundingBox{``0})"/>,
            or if you use a constructor that accepts two points (rather than 
            explicit minimum and maximum coordinates.) Some methods will not work
            correctly if the "maximum" coordinate is less than the "minimum" 
            coordinate; they may simply assume that the maximum exceeds the 
            minumum.
            <para/>
            A BoundingBox is considered to include both the minimum and maximum 
            coordinates. A point on the border is considered to be within the 
            bounding box, and the Width and Height are incremented to account
            for this. For example, if T is int and (X1,X2)=(0,10), the Width is
            11; if T is float and (X1,X2)=(0,10), the Width is infitessimally
            more than 10 (the result is incremented with MathEx.NextHigher()).
            </remarks>
        </member>
        <member name="T:Loyc.Geometry.BoundingBoxExt">
            <summary>Extension methods for <see cref="T:Loyc.Geometry.BoundingBox`1"/>.</summary>
        </member>
        <member name="T:Loyc.Geometry.LineSegment`1">
            <summary>Holds a 2D line segment.</summary>
            <typeparam name="T">Coordinate type</typeparam>
        </member>
        <member name="T:Loyc.Geometry.LineSegment3`1">
            <summary>Holds a 3D line segment.</summary>
            <typeparam name="T">Coordinate type</typeparam>
        </member>
        <member name="T:Loyc.Geometry.Point`1">
            <summary>A 2D point (X-Y pair) structure.</summary>
            <remarks>Although this structure contains operators such as + and -, their 
            performance is suboptimal due to limitations of C#. The <see cref="T:Loyc.Geometry.PointMath"/>
            class of Loyc.Utilities.dll contains extension methods such as Add() and Sub()
            that perform faster on common coordindate types such as int and double.</remarks>
            <typeparam name="T">Coordinate type.</typeparam>
            <seealso cref="T:Loyc.Geometry.PointMath"/>
            <seealso cref="T:Loyc.Geometry.Vector`1"/>
        </member>
        <member name="T:Loyc.Geometry.Point3`1">
            <summary>A 3D point (X-Y-Z triplet) structure.</summary>
            <typeparam name="T">Coordinate type.</typeparam>
            <seealso cref="T:Loyc.Geometry.PointMath"/>
            <seealso cref="T:Loyc.Geometry.Vector3`1"/>
        </member>
        <member name="T:Loyc.Geometry.Vector3`1">
            <summary>Represents a three-dimensional vector, i.e. a magnitude and 
            direction or the difference between two points, stored as X, Y and Z
            components.</summary>
            <remarks>A vector is the same as a point except for the operations it
            supports. For example, it usually does not make sense to add two points,
            but you can add two vectors (to get another vector) or you can add a 
            vector to a point (to get a point).
            <para/>
            If you really do need to add two points together or something like 
            that, you can typecast from <see cref="T:Loyc.Geometry.Point3`1"/> to 
            <see cref="T:Loyc.Geometry.Vector3`1"/>.
            </remarks>
            <seealso cref="T:Loyc.Geometry.PointMath"/>
            <seealso cref="T:Loyc.Geometry.VectorMath`1"/>
            <seealso cref="T:Loyc.Geometry.Point3`1"/>
        </member>
        <member name="M:Loyc.Geometry.Vector3`1.op_Multiply(Loyc.Geometry.Vector3{`0},Loyc.Geometry.Vector3{`0})">
            <summary>Dot product. a*b equals lhs.Length*rhs.Length*Cos(theta) if theta 
            is the angle between two vectors.</summary>
        </member>
        <member name="M:Loyc.Geometry.Vector3`1.op_UnaryNegation(Loyc.Geometry.Vector3{`0})">
            <summary>Reverses a vector.</summary>
        </member>
        <member name="T:Loyc.Geometry.Vector3Math`1">
            <summary>Implementation of <see cref="T:Loyc.Math.IAdditionGroup`1"/> for <see cref="T:Loyc.Geometry.Vector`1"/>.</summary>
            <typeparam name="T">Coordinate type.</typeparam>
        </member>
        <member name="T:Loyc.Geometry.VectorExt">
            <summary>Extension methods for vectors. TODO: reconsider distribution of
            methods between this class and <see cref="T:Loyc.Geometry.PointMath"/> in Loyc.Utilities.</summary>
        </member>
        <member name="M:Loyc.Geometry.VectorExt.Cross``1(Loyc.Geometry.Vector3{``0},Loyc.Geometry.Vector3{``0})">
            <summary>Computes the "cross product" of a pair of vectors.</summary>
            <remarks>
            This is not a general cross product, as cross product is only a 3D concept,
            but this operator acts as though the two points were in the Z=0 plane and
            returns the Z coordinate of the cross product: b.X * a.Y - b.Y * a.X.
            This value is zero if the vectors are parallel; it is a.Length * b.Length 
            or -a.Length * b.Length if the vectors are perpendicular. One use of 
            cross product is to determine whether the angle between two lines is greater 
            or less than 180 degrees, corresponding to return values less or greater than 
            zero.
            </remarks>
        </member>
        <member name="M:Loyc.Geometry.VectorExt.Quadrance``1(Loyc.Geometry.Vector3{``0})">
            <summary>Gets the square of the length of the vector.</summary>
        </member>
        <member name="M:Loyc.Geometry.VectorExt.Length``1(Loyc.Geometry.Vector3{``0})">
            <summary>Gets the length of the vector.</summary>
        </member>
        <member name="T:Loyc.Geometry.Vector`1">
            <summary>Represents a two-dimensional vector, i.e. a magnitude and 
            direction or the difference between two points, stored as X and Y
            components.</summary>
            <remarks>A vector is the same as a point except for the operations it
            supports. For example, it usually does not make sense to add two points,
            but you can add two vectors (to get another vector) or you can add a 
            vector to a point (to get a point).
            <para/>
            If you really do need to add two points together or something like 
            that, you can typecast from <see cref="T:Loyc.Geometry.Point`1"/> to 
            <see cref="T:Loyc.Geometry.Vector`1"/>.
            <para/>
            Although this structure contains operators such as + and -, their 
            performance is suboptimal due to limitations of C#. The <see cref="T:Loyc.Geometry.PointMath"/>
            class of Loyc.Utilities.dll contains extension methods such as Add() and Sub()
            that perform faster on common coorindate types such as int and double.</remarks>
            <seealso cref="T:Loyc.Geometry.PointMath"/>
            <seealso cref="T:Loyc.Geometry.VectorMath`1"/>
            <seealso cref="T:Loyc.Geometry.Point`1"/>
        </member>
        <member name="M:Loyc.Geometry.Vector`1.op_Multiply(Loyc.Geometry.Vector{`0},Loyc.Geometry.Vector{`0})">
            <summary>Dot product. a*b equals lhs.Length*rhs.Length*Cos(theta) if theta 
            is the angle between two vectors.</summary>
        </member>
        <member name="M:Loyc.Geometry.Vector`1.op_UnaryNegation(Loyc.Geometry.Vector{`0})">
            <summary>Reverses a vector.</summary>
        </member>
        <member name="T:Loyc.Geometry.VectorMath`1">
            <summary>An implementation of <see cref="T:Loyc.Math.IAdditionGroup`1"/> for <see cref="T:Loyc.Geometry.Vector`1"/>.</summary>
            <typeparam name="T">Coordinate type.</typeparam>
        </member>
        <member name="T:Loyc.Math.MathEx">
            <summary>
            Provides additional math functions that are not available in System.Math.
            </summary>
        </member>
        <member name="M:Loyc.Math.MathEx.Sign``1(``0)">
            <summary>Returns the sign of a number (-1 for negative, 1 for positive, 0 for zero).</summary>
        </member>
        <member name="M:Loyc.Math.MathEx.Sign(System.Int32)">
            <summary>Returns the sign of a number (-1 for negative, 1 for positive, 0 for zero).</summary>
        </member>
        <member name="M:Loyc.Math.MathEx.Sign(System.Int64)">
            <summary>Returns the sign of a number (-1 for negative, 1 for positive, 0 for zero).</summary>
        </member>
        <member name="M:Loyc.Math.MathEx.Sign(System.Single)">
            <summary>Returns the sign of a number (-1 for negative, 1 for positive, 0 for zero).</summary>
        </member>
        <member name="M:Loyc.Math.MathEx.Sign(System.Double)">
            <summary>Returns the sign of a number (-1 for negative, 1 for positive, 0 for zero).</summary>
        </member>
        <member name="M:Loyc.Math.MathEx.MulShift(System.Int32,System.Int32,System.Int32)">
            <summary>Multiplies two integers, internally producing a double-size 
            result so that overflow is not possible, then divides the result by the 
            specified power of two using a right shift.</summary>
            <returns>a * mulBy >> shiftBy, without overflow during multiplication.</returns>
            <remarks>This method does not handle the case that the result is too
            large to fit in the original data type.</remarks>
        </member>
        <member name="M:Loyc.Math.MathEx.MulShift(System.UInt32,System.UInt32,System.Int32)">
            <inheritdoc cref="M:Loyc.Math.MathEx.MulShift(System.Int32,System.Int32,System.Int32)"/>
        </member>
        <member name="M:Loyc.Math.MathEx.MulShift(System.Int64,System.Int64,System.Int32)">
            <inheritdoc cref="M:Loyc.Math.MathEx.MulShift(System.Int32,System.Int32,System.Int32)"/>
        </member>
        <member name="M:Loyc.Math.MathEx.MulShift(System.UInt64,System.UInt64,System.Int32)">
            <inheritdoc cref="M:Loyc.Math.MathEx.MulShift(System.Int32,System.Int32,System.Int32)"/>
        </member>
        <member name="M:Loyc.Math.MathEx.MulDiv(System.Int32,System.Int32,System.Int32,System.Int32@)">
            <summary>Multiplies two integers, internally producing a double-size 
            result so that overflow is not possible, then divides the result by the 
            specified number.</summary>
            <param name="remainder">The remainder of the division is placed here. 
            The remainder is computed properly even if the main result overflows.</param>
            <returns>a * mulBy / divBy, without overflow during multiplication.</returns>
            <remarks>If the final result does not fit in the original data type, 
            this method returns largest possible value of the result type 
            (int.MaxValue, or int.MinValue if the overflowing result is negative).
            </remarks>
        </member>
        <member name="M:Loyc.Math.MathEx.MulDiv(System.UInt32,System.UInt32,System.UInt32,System.UInt32@)">
            <inheritdoc cref="M:Loyc.Math.MathEx.MulDiv(System.Int32,System.Int32,System.Int32,System.Int32@)"/>
            <remarks>If the final result does not fit in the original data type, 
            this method returns largest possible value of the result type 
            (uint.MaxValue).</remarks>
        </member>
        <member name="M:Loyc.Math.MathEx.MulDiv(System.Int64,System.Int64,System.Int64,System.Int64@)">
            <inheritdoc cref="M:Loyc.Math.MathEx.MulDiv(System.Int32,System.Int32,System.Int32,System.Int32@)"/>
            <remarks>If the final result does not fit in the original data type, 
            this method returns largest possible value of the result type 
            (long.MaxValue, or long.MinValue if the overflowing result is negative).
            </remarks>
        </member>
        <member name="M:Loyc.Math.MathEx.MulDiv(System.UInt64,System.UInt64,System.UInt64,System.UInt64@)">
            <inheritdoc cref="M:Loyc.Math.MathEx.MulDiv(System.Int32,System.Int32,System.Int32,System.Int32@)"/>
            <remarks>If the final result does not fit in the original data type, 
            this method returns largest possible value of the result type 
            (ulong.MaxValue).</remarks>
        </member>
        <member name="M:Loyc.Math.MathEx.MulDiv(System.Int32,System.Int32,System.Int32)">
            <inheritdoc cref="M:Loyc.Math.MathEx.MulDiv(System.Int32,System.Int32,System.Int32,System.Int32@)"/>
        </member>
        <member name="M:Loyc.Math.MathEx.MulDiv(System.UInt32,System.UInt32,System.UInt32)">
            <inheritdoc cref="M:Loyc.Math.MathEx.MulDiv(System.UInt32,System.UInt32,System.UInt32,System.UInt32@)"/>
        </member>
        <member name="M:Loyc.Math.MathEx.MulDiv(System.Int64,System.Int64,System.Int64)">
            <inheritdoc cref="M:Loyc.Math.MathEx.MulDiv(System.Int64,System.Int64,System.Int64,System.Int64@)"/>
        </member>
        <member name="M:Loyc.Math.MathEx.MulDiv(System.UInt64,System.UInt64,System.UInt64)">
            <inheritdoc cref="M:Loyc.Math.MathEx.MulDiv(System.UInt64,System.UInt64,System.UInt64,System.UInt64@)"/>
        </member>
        <member name="M:Loyc.Math.MathEx.RoL(System.UInt32,System.Int32)">
            <summary>Rotates a bit pattern left by the specified number of bits.</summary>
        </member>
        <member name="M:Loyc.Math.MathEx.RoL(System.Int32,System.Int32)">
            <summary>Rotates a bit pattern left by the specified number of bits.</summary>
        </member>
        <member name="M:Loyc.Math.MathEx.RoL(System.UInt64,System.Int32)">
            <summary>Rotates a bit pattern left by the specified number of bits.</summary>
        </member>
        <member name="M:Loyc.Math.MathEx.RoL(System.Int64,System.Int32)">
            <summary>Rotates a bit pattern left by the specified number of bits.</summary>
        </member>
        <member name="M:Loyc.Math.MathEx.RoL(System.UInt16,System.Int32)">
            <summary>Rotates a bit pattern left by the specified number of bits.</summary>
        </member>
        <member name="M:Loyc.Math.MathEx.RoL(System.Byte,System.Int32)">
            <summary>Rotates a bit pattern left by the specified number of bits.</summary>
        </member>
        <member name="M:Loyc.Math.MathEx.RoR(System.UInt32,System.Int32)">
            <summary>Rotates a bit pattern right by the specified number of bits.</summary>
        </member>
        <member name="M:Loyc.Math.MathEx.RoR(System.Int32,System.Int32)">
            <summary>Rotates a bit pattern right by the specified number of bits.</summary>
        </member>
        <member name="M:Loyc.Math.MathEx.RoR(System.UInt64,System.Int32)">
            <summary>Rotates a bit pattern right by the specified number of bits.</summary>
        </member>
        <member name="M:Loyc.Math.MathEx.RoR(System.Int64,System.Int32)">
            <summary>Rotates a bit pattern right by the specified number of bits.</summary>
        </member>
        <member name="M:Loyc.Math.MathEx.RoR(System.UInt16,System.Int32)">
            <summary>Rotates a bit pattern right by the specified number of bits.</summary>
        </member>
        <member name="M:Loyc.Math.MathEx.RoR(System.Byte,System.Int32)">
            <summary>Rotates a bit pattern right by the specified number of bits.</summary>
        </member>
        <member name="M:Loyc.Math.MathEx.Sqrt(System.Int64)">
            Algorithms from http://aggregate.org/MAGIC and possibly
            http://www.devmaster.net/articles/fixed-point-optimizations/ or
            http://graphics.stanford.edu/~seander/bithacks.html
        </member>
        <member name="M:Loyc.Math.MathEx.CountOnes(System.UInt32)">
            <summary>Returns the number of '1' bits in x</summary>
            <remarks>
            For example, CountOnes(0xF0) == 4.
            <para/>
            Some processors have a dedicated instruction for this operation, but
            the .NET framework provides no access to it.
            </remarks>
        </member>
        <member name="M:Loyc.Math.MathEx.CountOnes(System.Byte)">
            <inheritdoc cref="M:Loyc.Math.MathEx.CountOnes(System.Int32)"/>
        </member>
        <member name="M:Loyc.Math.MathEx.CountOnes(System.UInt16)">
            <inheritdoc cref="M:Loyc.Math.MathEx.CountOnes(System.Int32)"/>
        </member>
        <member name="M:Loyc.Math.MathEx.CountOnes(System.Int64)">
            <inheritdoc cref="M:Loyc.Math.MathEx.CountOnes(System.Int32)"/>
        </member>
        <member name="M:Loyc.Math.MathEx.CountOnes(System.UInt64)">
            <inheritdoc cref="M:Loyc.Math.MathEx.CountOnes(System.Int32)"/>
        </member>
        <member name="M:Loyc.Math.MathEx.Log2Floor(System.UInt32)">
            <inheritdoc cref="M:Loyc.Math.MathEx.Log2Floor(System.Int32)"/>
        </member>
        <member name="M:Loyc.Math.MathEx.Log2Floor(System.Int32)">
            <summary>
            Returns the floor of the base-2 logarithm of x. e.g. 1024 -> 10, 1000 -> 9
            </summary><remarks>
            The return value is -1 for an input that is zero or negative.
            <para/>
            Some processors have a dedicated instruction for this operation, but
            the .NET framework provides no access to it.
            </remarks>
        </member>
        <member name="M:Loyc.Math.MathEx.Log2Floor(System.UInt64)">
            <inheritdoc cref="M:Loyc.Math.MathEx.Log2Floor(System.Int32)"/>
        </member>
        <member name="M:Loyc.Math.MathEx.Log2Floor(System.Int64)">
            <inheritdoc cref="M:Loyc.Math.MathEx.Log2Floor(System.Int32)"/>
        </member>
        <member name="M:Loyc.Math.MathEx.NextPowerOf2(System.UInt32)">
            <summary>Gets the next higher power of 2, e.g. 4=>8, 13=>16.</summary>
            <remarks>For negative values of x, NextPowerOf2((uint)x) is 0.</remarks>
        </member>
        <member name="M:Loyc.Math.MathEx.NextPowerOf2(System.UInt64)">
            <summary>Gets the next higher power of 2, e.g. 4=>8, 13=>16.</summary>
            <remarks>For negative values of (long)x, NextPowerOf2((ulong)x) is 0.</remarks>
        </member>
        <member name="M:Loyc.Math.MathEx.NextPowerOf2(System.Int32)">
            <summary>Calls <see cref="M:Loyc.Math.MathEx.NextPowerOf2(System.UInt32)"/>.</summary>
        </member>
        <member name="M:Loyc.Math.MathEx.NextPowerOf2(System.Int64)">
            <summary>Calls <see cref="M:Loyc.Math.MathEx.NextPowerOf2(System.UInt64)"/>.</summary>
        </member>
        <member name="M:Loyc.Math.MathEx.FindFirstOne(System.UInt32)">
            <summary>Returns the bit position of the first '1' bit in a uint, or -1 
            the input is zero.</summary>
        </member>
        <member name="M:Loyc.Math.MathEx.FindFirstZero(System.UInt32)">
            <summary>Returns the bit position of the first '0' bit in a uint, or -1
            if there are no zeros.</summary>
        </member>
        <member name="M:Loyc.Math.MathEx.FindLastOne(System.UInt32)">
            <summary>Returns the bit position of the first '1' bit in a uint, or -1 
            the input is zero.</summary>
        </member>
        <member name="M:Loyc.Math.MathEx.Average(System.Int32,System.Int32)">
            <summary>Computes the average of two integers. Will not overflow.</summary>
        </member>
        <member name="M:Loyc.Math.MathEx.Average(System.Int64,System.Int64)">
            <summary>Computes the average of two integers. Will not overflow.</summary>
        </member>
        <member name="M:Loyc.Math.MathEx.Average(System.Single,System.Single)">
            <summary>Computes the average of two numbers. Will not overflow.</summary>
        </member>
        <member name="M:Loyc.Math.MathEx.Average(System.Double,System.Double)">
            <summary>Computes the average of two numbers. Will not overflow.</summary>
        </member>
        <member name="M:Loyc.Math.MathEx.Average``1(``0,``0)">
            <summary>Computes the average of two numbers. Slow. No overflow protection.</summary>
        </member>
        <member name="M:Loyc.Math.MathEx.IsPrime(System.Int32)">
            <summary>Returns true if <c>num</c> is a prime number, meaning 
            that it is greater than 1 and is divisible only by 1 and itself.
            </summary>
            <param name="num">A number to test.</param>
            <remarks>
            This test takes O(sqrt(num)) time and it is moderately optimized, 
            although faster algorithms exist (e.g. the Sieve of Eratosthenes 
            can be faster <i>per number</i>, but is designed to find a list of 
            <i>all</i> the prime numbers rather than to test a single number.
            </remarks>
        </member>
        <member name="T:Loyc.Math.FPI8">
            <summary>Fixed-point type based on Int32 with 8 fractional bits</summary>
        </member>
        <member name="T:Loyc.Math.FPI16">
            <summary>Fixed-point type based on Int32 with 16 fractional bits</summary>
        </member>
        <member name="T:Loyc.Math.FPI23">
            <summary>Fixed-point type based on Int32 with 23 fractional bits</summary>
        </member>
        <member name="T:Loyc.Math.FPL16">
            <summary>Fixed-point type based on Int64 with 16 fractional bits</summary>
        </member>
        <member name="T:Loyc.Math.FPL32">
            <summary>Fixed-point type based on Int64 with 32 fractional bits</summary>
        </member>
        <member name="T:Loyc.Math.Math128">
            <summary>Contains methods for manipulating 128-bit numbers, multiplying 
            64-bit numbers to produce 128-bit results, and dividing 128-bit numbers 
            by 64-bit numbers.</summary>
            <remarks>
            MathEx.MulDiv and MathEx.MulShift rely on this class for 64x64 MulDiv() 
            and MulShift().
            <para/>
            Some functionality is incomplete at this time, e.g. there are no 
            comparison methods or 128+128 addition/subtraction.
            <para/>
            This class works on raw Int64 values, so a 128-bit number is represented 
            by a pair of Int64s, one with high bits and one with low bits. By 
            convention, the low 64 bits are always unsigned (because they contain no
            sign bit), and the high 64 bits may be signed or unsigned, which 
            represents the sign of the 128-bit number as a whole.
            <para/>
            Many methods pass the low 64 bits by reference and the high 64 bits by 
            value, returning the "new" high 64 bits as the return value. This is done 
            to help implement signed math in terms of unsigned math. If the parameter
            type is "ref ulong", C# does not allow you to pass "ref long", even with
            a cast. Passing the high bits by value is therefore less cumbersome.
            </remarks>
        </member>
        <member name="M:Loyc.Math.Math128.Divide(System.Int64,System.UInt64,System.Int64,System.Int64@,System.Boolean)">
            <summary>Divides an signed 128-bit number by a signed 64-bit 
            number to produce a 64-bit result.</summary>
            <returns>Returns the division result (known as the "quotient"). If the 
            result is too large to represent, long.MinValue or long.MaxValue is 
            returned instead.</returns>
            <inheritdoc cref="M:Loyc.Math.Math128.Divide(System.Int64,System.UInt64,System.Int64,System.Int64@,System.Int64@,System.Boolean)"/>
        </member>
        <member name="M:Loyc.Math.Math128.Divide(System.Int64,System.UInt64,System.Int64,System.Int64@,System.Int64@,System.Boolean)">
            <summary>Divides an signed 128-bit number by a signed 64-bit 
            number to produce a 128-bit result.</summary>
            <param name="roundDown">If true, the result is rounded down, instead
            of being rounded toward zero, which changes the remainder and 
            quotient if a is negative but b is positive.</param>
            <remarks>
            When dividing a negative number by a positive number, it is 
            conventionally rounded toward zero. Consequently, the remainder is zero 
            or negative to satisfy the standard integer division equation 
            <c>a = b*q + r</c>, where q is the quotient (result) and r is the 
            remainder.
            <para/>
            This is not always what you want. So, if roundDown is true, the result 
            is rounded down instead of toward zero. This ensures that if 'a' is 
            negative and 'b' is positive, the remainder is positive too, a fact 
            which is useful for modulus arithmetic. The table below illustrates 
            the difference:
            <pre>
            inputs   | standard  | roundDown
                     |  output   |  output  
             a   b   |   q   r   |   q   r
            --- ---  |  --- ---  |  --- ---
             7   3   |   2   1   |   2   1
            -7   3   |  -2  -1   |  -3   2
             7  -3   |  -2   1   |  -3  -2
            -7  -3   |   2  -1   |   2  -1
            </pre>
            </remarks>
            <inheritdoc cref="M:Loyc.Math.Math128.Divide(System.UInt64,System.UInt64,System.UInt64,System.UInt64@,System.UInt64@)"/>
        </member>
        <member name="M:Loyc.Math.Math128.Divide(System.UInt64,System.UInt64,System.UInt64,System.UInt64@)">
            <summary>Divides an signed 128-bit number by a signed 64-bit 
            number to produce a 64-bit result.</summary>
            <remarks>If the result did not fit in 64 bits, this method returns 
            ulong.MaxValue.</remarks>
            <inheritdoc cref="M:Loyc.Math.Math128.Divide(System.UInt64,System.UInt64,System.UInt64,System.UInt64@,System.UInt64@)"/>
        </member>
        <member name="M:Loyc.Math.Math128.Divide(System.UInt64,System.UInt64,System.UInt64,System.UInt64@,System.UInt64@)">
            <summary>Divides an unsigned 128-bit number by an unsigned 64-bit 
            number to produce a 128-bit result.</summary>
            <param name="aH">High 64 bits of the dividend.</param>
            <param name="aL">Low 64 bits of the dividend.</param>
            <param name="b">The divisor.</param>
            <param name="resultHi">High 64 bits of result.</param>
            <param name="remainder">Remainder of the division.</param>
            <returns>The low 64 bits of the result (known as the "quotient").</returns>
            <exception cref="T:System.DivideByZeroException">b was zero.</exception>
        </member>
        <member name="M:Loyc.Math.Math128.ShiftLeft(System.UInt64,System.UInt64@,System.Int32)">
            <summary>Shifts a 128-bit value left.</summary>
            <param name="aH">High 64 bits</param>
            <param name="aL">Low 64 bits</param>
            <param name="amount">Number of bits to shift.</param>
            <returns>The new value of aH</returns>
            <remarks>The convention is that signed numbers use Int64 for aH and 
            unsigned numbers used UInt64 for aH. The fact that aH is not passed 
            by reference makes it easier to shift a signed number left by casting 
            aH to UInt64. The cast would not be allowed if passing by reference.
            Of course, right shift, on the other hand, requires two separate 
            methods since it behaves differently for signed and unsigned inputs.
            <para/>
            This method does not allow shifting by a negative amount. The reason 
            is that there is only one ShiftLeft, so if the amount is negative, 
            it's not known whether a signed or unsigned ShiftRight is intended.
            </remarks>
        </member>
        <member name="M:Loyc.Math.Math128.ShiftLeftFast(System.UInt64,System.UInt64@,System.Int32)">
            <summary>Variation of ShiftLeft() for cases when you know 64 > amount >= 0.</summary>
        </member>
        <member name="M:Loyc.Math.Math128.ShiftLeftEx(System.UInt64@,System.UInt64@,System.Int32)">
            <summary>Shifts a 128-bit value left and saves the overflowed bits.</summary>
            <param name="aH">High 64 bits</param>
            <param name="aL">Low 64 bits</param>
            <param name="amount">Number of bits to shift. Negative amounts are not permitted.</param>
            <returns>The bits that were shifted off the left side.</returns>
            <remarks>Asserts that amount > 0 (no exception)</remarks>
        </member>
        <member name="M:Loyc.Math.Math128.ShiftRight(System.UInt64,System.UInt64@,System.Int32)">
            <summary>Shifts a 128-bit value right.</summary>
            <param name="aH">High 64 bits</param>
            <param name="aL">Low 64 bits</param>
            <param name="amount">Number of bits to shift.</param>
            <returns>The new value of aH</returns>
            <remarks>This method, unlike ShiftLeft(), allows shifting by a negative 
            amount, which is translated to a left shift.
            <para/>
            TODO: ShiftRightEx</remarks>
        </member>
        <member name="M:Loyc.Math.Math128.ShiftRightFast(System.UInt64,System.UInt64@,System.Int32)">
            <summary>Variation of ShiftRight() for cases when you know 64 > amount >= 0.</summary>
        </member>
        <member name="M:Loyc.Math.Math128.ShiftRight(System.Int64,System.UInt64@,System.Int32)">
            <inheritdoc cref="M:Loyc.Math.Math128.ShiftRight(System.UInt64,System.UInt64@,System.Int32)"/>
        </member>
        <member name="M:Loyc.Math.Math128.ShiftRightFast(System.Int64,System.UInt64@,System.Int32)">
            <summary>Variation of ShiftRight() for cases when you know 64 > amount >= 0.</summary>
        </member>
        <member name="M:Loyc.Math.Math128.Add(System.UInt64,System.UInt64@,System.UInt64)">
            <summary>Adds a 64-bit number to a 128-bit number.</summary>
            <param name="aH">High 64 bits of 128-bit number</param>
            <param name="aL">Low 64 bits of 128-bit number</param>
            <param name="amount">Amount to add</param>
            <returns>The high 64 bits of the result.</returns>
        </member>
        <member name="M:Loyc.Math.Math128.Subtract(System.UInt64,System.UInt64@,System.UInt64)">
            <summary>Subtracts a 64-bit number from a 128-bit number.</summary>
            <param name="aH">High 64 bits of 128-bit number</param>
            <param name="aL">Low 64 bits of 128-bit number</param>
            <param name="amount">Amount to subtract</param>
            <returns>The high 64 bits of the result.</returns>
        </member>
        <member name="M:Loyc.Math.Math128.Add(System.Int64,System.UInt64@,System.Int64)">
            <inheritdoc cref="M:Loyc.Math.Math128.Add(System.UInt64,System.UInt64@,System.UInt64)"/>
        </member>
        <member name="M:Loyc.Math.Math128.Subtract(System.Int64,System.UInt64@,System.Int64)">
            <inheritdoc cref="M:Loyc.Math.Math128.Subtract(System.UInt64,System.UInt64@,System.UInt64)"/>
        </member>
        <member name="T:Loyc.Math.Maths`1">
            <summary>
            This class helps generic code to perform calculations on numbers of 
            unknown type, by providing access to various math interfaces.
            </summary>
            <typeparam name="T">A numeric type.</typeparam>
            <remarks>
            If a certain math interface is not available for a certain type, 
            then the corresponding field will be null. For example, 
            Maths&lt;int>.FloatMath is null because int is not floating-point.
            The <see cref="F:Loyc.Math.Maths`1.Traits"/>, <see cref="F:Loyc.Math.Maths`1.Math"/>, and related properties 
            will be null for non-numeric types.
            <para/>
            TODO: support non-builtin types!
            <para/>
            Generic code that uses Maths&lt;T> is slower than code that uses a
            generic parameter with a math constraint. That's because generic 
            struct parameters are early-bound and can be inlined, while calls 
            through an interface such as IMath&lt;T> are normal late-bound 
            interface calls and cannot be inlined. Compare the two examples 
            below.
            </remarks>
            <example>
            // Calculates the length of a vector with magnitude (x, y):
            // Slower version based on Maths&lt;T>. Example: Length(3.0,4.0)
            public T Length&lt;T>(T x, T y)
            {
                var m = Maths&lt;T>.Math;
                return m.Sqrt(m.Add(m.Square(x), m.Square(y)));
            }
            
            // Calculates the length of a vector with magnitude (x, y):
            // Faster version based on Maths&lt;T>. Unfortunately, this version is 
            // inconvenient to call because the caller must specify which math 
            // provider to use. Example: Length&lt;double,MathD>(3.0,4.0)
            public T Length&lt;T,M>(T x, T y) where M:struct,IMath&lt;T>
            {
                var m = default(M);
                return m.Sqrt(m.Add(m.Square(x), m.Square(y)));
            }
            </example>
        </member>
        <member name="T:Loyc.Math.MathI8">
            <summary>Implements <see cref="T:Loyc.Math.IIntMath`1"/> for numbers of type System.SByte.</summary>
        </member>
        <member name="T:Loyc.Math.MathU8">
            <summary>Implements <see cref="T:Loyc.Math.IUIntMath`1"/> for numbers of type System.Byte.</summary>
        </member>
        <member name="T:Loyc.Math.MathI16">
            <summary>Implements <see cref="T:Loyc.Math.IIntMath`1"/> for numbers of type System.Int16.</summary>
        </member>
        <member name="T:Loyc.Math.MathU16">
            <summary>Implements <see cref="T:Loyc.Math.IUIntMath`1"/> for numbers of type System.UInt16.</summary>
        </member>
        <member name="T:Loyc.Math.MathI">
            <summary>Implements <see cref="T:Loyc.Math.IIntMath`1"/> for numbers of type System.Int32.</summary>
        </member>
        <member name="T:Loyc.Math.MathU">
            <summary>Implements <see cref="T:Loyc.Math.IUIntMath`1"/> for numbers of type System.UInt32.</summary>
        </member>
        <member name="T:Loyc.Math.MathL">
            <summary>Implements <see cref="T:Loyc.Math.IIntMath`1"/> for numbers of type System.Int64.</summary>
        </member>
        <member name="T:Loyc.Math.MathUL">
            <summary>Implements <see cref="T:Loyc.Math.IUIntMath`1"/> for numbers of type System.UInt64.</summary>
        </member>
        <member name="T:Loyc.Math.MathF">
            <summary>Implements <see cref="T:Loyc.Math.IFloatMath`1"/> for numbers of type System.Single.</summary>
        </member>
        <member name="T:Loyc.Math.MathD">
            <summary>Implements <see cref="T:Loyc.Math.IFloatMath`1"/> for numbers of type System.Double.</summary>
        </member>
        <member name="T:Loyc.Math.MathF8">
            <summary>Implements <see cref="T:Loyc.Math.IRationalMath`1"/> for numbers of type FPI8.</summary>
        </member>
        <member name="T:Loyc.Math.MathF16">
            <summary>Implements <see cref="T:Loyc.Math.IRationalMath`1"/> for numbers of type FPI16.</summary>
        </member>
        <member name="T:Loyc.Math.MathF23">
            <summary>Implements <see cref="T:Loyc.Math.IRationalMath`1"/> for numbers of type FPI23.</summary>
        </member>
        <member name="T:Loyc.Math.MathFL16">
            <summary>Implements <see cref="T:Loyc.Math.IRationalMath`1"/> for numbers of type FPL16.</summary>
        </member>
        <member name="T:Loyc.Math.MathFL32">
            <summary>Implements <see cref="T:Loyc.Math.IRationalMath`1"/> for numbers of type FPL32.</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Loyc.Range" -->
        <member name="M:Loyc.Range.Inclusive(System.Int32,System.Int32)">
            <summary>Returns a range from lo to hi that includes both lo and hi.</summary>
        </member>
        <member name="M:Loyc.Range.ExcludeHi(System.Int32,System.Int32)">
            <summary>Returns a range from lo to hi that excludes hi by decreasing it by 1.</summary>
        </member>
        <member name="M:Loyc.Range.StartingAt(System.Int32)">
            <summary>Returns a range from lo to the MaxValue of the number type.</summary>
        </member>
        <member name="M:Loyc.Range.Only(System.Int32)">
            <summary>Returns the same range as Incl(num, num).</summary>
        </member>
        <member name="M:Loyc.Range.Inclusive(System.UInt32,System.UInt32)">
            <summary>Returns a range from lo to hi that includes both lo and hi.</summary>
        </member>
        <member name="M:Loyc.Range.ExcludeHi(System.UInt32,System.UInt32)">
            <summary>Returns a range from lo to hi that excludes hi by decreasing it by 1.</summary>
        </member>
        <member name="M:Loyc.Range.StartingAt(System.UInt32)">
            <summary>Returns a range from lo to the MaxValue of the number type.</summary>
        </member>
        <member name="M:Loyc.Range.Only(System.UInt32)">
            <summary>Returns the same range as Incl(num, num).</summary>
        </member>
        <member name="M:Loyc.Range.Inclusive(System.Int64,System.Int64)">
            <summary>Returns a range from lo to hi that includes both lo and hi.</summary>
        </member>
        <member name="M:Loyc.Range.ExcludeHi(System.Int64,System.Int64)">
            <summary>Returns a range from lo to hi that excludes hi by decreasing it by 1.</summary>
        </member>
        <member name="M:Loyc.Range.StartingAt(System.Int64)">
            <summary>Returns a range from lo to the MaxValue of the number type.</summary>
        </member>
        <member name="M:Loyc.Range.Only(System.Int64)">
            <summary>Returns the same range as Incl(num, num).</summary>
        </member>
        <member name="M:Loyc.Range.Inclusive(System.UInt64,System.UInt64)">
            <summary>Returns a range from lo to hi that includes both lo and hi.</summary>
        </member>
        <member name="M:Loyc.Range.ExcludeHi(System.UInt64,System.UInt64)">
            <summary>Returns a range from lo to hi that excludes hi by decreasing it by 1.</summary>
        </member>
        <member name="M:Loyc.Range.StartingAt(System.UInt64)">
            <summary>Returns a range from lo to the MaxValue of the number type.</summary>
        </member>
        <member name="M:Loyc.Range.Only(System.UInt64)">
            <summary>Returns the same range as Incl(num, num).</summary>
        </member>
        <member name="M:Loyc.Range.Inclusive(System.Single,System.Single)">
            <summary>Returns a range from lo to hi that includes both lo and hi.</summary>
        </member>
        <member name="M:Loyc.Range.ExcludeHi(System.Single,System.Single)">
            <summary>Returns a range from lo to hi that excludes hi by decreasing it by 1.</summary>
        </member>
        <member name="M:Loyc.Range.StartingAt(System.Single)">
            <summary>Returns a range from lo to the MaxValue of the number type.</summary>
        </member>
        <member name="M:Loyc.Range.Only(System.Single)">
            <summary>Returns the same range as Incl(num, num).</summary>
        </member>
        <member name="M:Loyc.Range.Inclusive(System.Double,System.Double)">
            <summary>Returns a range from lo to hi that includes both lo and hi.</summary>
        </member>
        <member name="M:Loyc.Range.ExcludeHi(System.Double,System.Double)">
            <summary>Returns a range from lo to hi that excludes hi by decreasing it by 1.</summary>
        </member>
        <member name="M:Loyc.Range.StartingAt(System.Double)">
            <summary>Returns a range from lo to the MaxValue of the number type.</summary>
        </member>
        <member name="M:Loyc.Range.Only(System.Double)">
            <summary>Returns the same range as Incl(num, num).</summary>
        </member>
        <member name="M:Loyc.Range.Inclusive(Loyc.Math.FPI8,Loyc.Math.FPI8)">
            <summary>Returns a range from lo to hi that includes both lo and hi.</summary>
        </member>
        <member name="M:Loyc.Range.ExcludeHi(Loyc.Math.FPI8,Loyc.Math.FPI8)">
            <summary>Returns a range from lo to hi that excludes hi by decreasing it by 1.</summary>
        </member>
        <member name="M:Loyc.Range.StartingAt(Loyc.Math.FPI8)">
            <summary>Returns a range from lo to the MaxValue of the number type.</summary>
        </member>
        <member name="M:Loyc.Range.Only(Loyc.Math.FPI8)">
            <summary>Returns the same range as Incl(num, num).</summary>
        </member>
        <member name="M:Loyc.Range.Inclusive(Loyc.Math.FPI16,Loyc.Math.FPI16)">
            <summary>Returns a range from lo to hi that includes both lo and hi.</summary>
        </member>
        <member name="M:Loyc.Range.ExcludeHi(Loyc.Math.FPI16,Loyc.Math.FPI16)">
            <summary>Returns a range from lo to hi that excludes hi by decreasing it by 1.</summary>
        </member>
        <member name="M:Loyc.Range.StartingAt(Loyc.Math.FPI16)">
            <summary>Returns a range from lo to the MaxValue of the number type.</summary>
        </member>
        <member name="M:Loyc.Range.Only(Loyc.Math.FPI16)">
            <summary>Returns the same range as Incl(num, num).</summary>
        </member>
    </members>
</doc>
