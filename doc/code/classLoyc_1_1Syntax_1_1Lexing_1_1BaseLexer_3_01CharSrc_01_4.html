<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>Enhanced C#: Loyc.Syntax.Lexing.BaseLexer&lt; CharSrc &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Enhanced C#
   </div>
   <div id="projectbrief">Language of your choice: library documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Events</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceLoyc.html">Loyc</a></li><li class="navelem"><a class="el" href="namespaceLoyc_1_1Syntax.html">Syntax</a></li><li class="navelem"><a class="el" href="namespaceLoyc_1_1Syntax_1_1Lexing.html">Lexing</a></li><li class="navelem"><a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer_3_01CharSrc_01_4.html">BaseLexer< CharSrc ></a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Nested classes</a> &#124;
<a href="#pub-static-attribs">Public static fields</a> &#124;
<a href="#properties">Properties</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected fields</a> &#124;
<a href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer_3_01CharSrc_01_4-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Loyc.Syntax.Lexing.BaseLexer&lt; CharSrc &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The recommended base class for lexers generated by LLLPG, when not using the <code>inputSource</code> option. 
 <a href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer_3_01CharSrc_01_4.html#details">More...</a></p>
<hr/><b>Source file</b>:<ul>
<li><a href='https://github.com/qwertie/ecsharp/tree/master/Core/Loyc.Syntax/Lexing/BaseLexer.cs'>/Core/Loyc.Syntax/Lexing/BaseLexer.cs</a></li>
</ul>
<div class="dynheader">
Inheritance diagram for Loyc.Syntax.Lexing.BaseLexer&lt; CharSrc &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer_3_01CharSrc_01_4.png" usemap="#Loyc.Syntax.Lexing.BaseLexer&lt; CharSrc &gt;_map" alt=""/>
  <map id="Loyc.Syntax.Lexing.BaseLexer&lt; CharSrc &gt;_map" name="Loyc.Syntax.Lexing.BaseLexer&lt; CharSrc &gt;_map">
<area href="interfaceLoyc_1_1Syntax_1_1IIndexToLine.html" title="Contains IndexToLine method." alt="Loyc.Syntax.IIndexToLine" shape="rect" coords="351,0,692,24"/>
<area href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseILexer_3_01CharSrc_00_01Token_01_4.html" title="A version of BaseLexer{CharSrc} that implements ILexer{Token}. You should use this base class if you ..." alt="Loyc.Syntax.Lexing.BaseILexer&lt; CharSrc, Token &gt;" shape="rect" coords="0,112,341,136"/>
<area href="structLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer_3_01CharSrc_01_4_1_1SavePosition.html" title="A helper class used by LLLPG for backtracking." alt="Loyc.Syntax.Lexing.BaseLexer&lt; CharSrc &gt;.SavePosition" shape="rect" coords="351,112,692,136"/>
<area href="classLoyc_1_1Syntax_1_1Lexing_1_1LexerSourceWorkaround_3_01CharSrc_01_4.html" title="This class only exists to work around a limitation of the C# language: "cannot change access modifier..." alt="Loyc.Syntax.Lexing.LexerSourceWorkaround&lt; CharSrc &gt;" shape="rect" coords="702,112,1043,136"/>
<area href="classLoyc_1_1Syntax_1_1Lexing_1_1LexerSource_3_01CharSrc_01_4.html" title="An implementation of the LLLPG Lexer API, used with the LLLPG options inputSource and inputClass..." alt="Loyc.Syntax.Lexing.LexerSource&lt; CharSrc &gt;" shape="rect" coords="702,168,1043,192"/>
</map>
 </div></div>
<a name="details" id="details"></a><h2 class="groupheader">Remarks</h2>
<div class="textblock"><p>The recommended base class for lexers generated by LLLPG, when not using the <code>inputSource</code> option.</p>
<p>If you are using the <code>inputSource</code> and <code>inputClass</code> options of, LLLPG, use LexerSource{CharSource} instead. If you want to write a lexer that implements ILexer{Tok} (so it is compatible with postprocessors like <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1IndentTokenGenerator.html" title="A preprocessor usually inserted between the lexer and parser that inserts &quot;indent&quot;, &quot;dedent&quot;, and &quot;end-of-line&quot; tokens at appropriate places in a token stream. ">IndentTokenGenerator</a> and <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1TokensToTree.html" title="A preprocessor usually inserted between the lexer and parser that converts a token list into a token ...">TokensToTree</a>), use BaseILexer{CharSrc,Tok} as your base class instead. </p>
<p>This class contains many methods required by LLLPG, such as NewSet, LA(int), LA0, <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer_3_01CharSrc_01_4.html#ae2ed46c1667602dbdfdab1f5fe49785a" title="Increments InputPosition. Called by LLLPG when prediction already verified the input (and caller does...">Skip</a>, Match(...), and TryMatch(...), along with a few properties that are not used by LLLPG that you still might want to have around, such as FileName, CharSource and <a class="el" href="classLoyc_1_1Syntax_1_1SourceFile.html">SourceFile</a>. </p>
<p>It also implements the caching behavior for which ICharSource was created. See the documentation of ICharSource for more information. </p>
<p>All lexers derived from <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html" title="Alias for BaseLexer{C} where C is ICharSource.">BaseLexer</a> should call <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer_3_01CharSrc_01_4.html#aaf01d80adc87cbc7457dac46df1f41b1" title="The lexer must call this method exactly once after it advances past each newline, even inside comment...">AfterNewline()</a> at the end of their newline rule, in order to increment the current line number. Alternately, your lexer can borrow the newline parser built into <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html" title="Alias for BaseLexer{C} where C is ICharSource.">BaseLexer</a>, which is called <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer_3_01CharSrc_01_4.html#abae963fe4011bda74065554b7f606f0e" title="Default newline parser that matches &#39; &#39; or &#39;&#39; unconditionally.">Newline()</a> and calls <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer_3_01CharSrc_01_4.html#aaf01d80adc87cbc7457dac46df1f41b1" title="The lexer must call this method exactly once after it advances past each newline, even inside comment...">AfterNewline()</a> for you. It is possible to have LLLPG treat this method as a rule, and tell LLLPG the meaning of the rule like this: </p><div class="fragment"><div class="line"><span class="keyword">extern</span> token <a class="code" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer_3_01CharSrc_01_4.html#abae963fe4011bda74065554b7f606f0e">Newline</a> <span class="charliteral">&#39;\r&#39;</span> <span class="charliteral">&#39;\n&#39;</span>? | <span class="charliteral">&#39;\n&#39;</span> };</div>
<div class="line"><span class="comment">// BaseLexer also defines a Spaces() method, which behaves like this:</span></div>
<div class="line"><span class="keyword">extern</span> token <a class="code" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer_3_01CharSrc_01_4.html#a79c4e1d9e02ed6f1bd69870ff2f44a99">Spaces</a> (<span class="charliteral">&#39; &#39;</span>|<span class="charliteral">&#39;\t&#39;</span>)* }; </div>
</div><!-- fragment --><p> The <code>extern</code> modifier tells LLLPG not to generate code for the rule, but the rule must still have a body so that LLLPG can perform prediction. </p>
<p>By default, errors are handled by throwing FormatException. The recommended way to alter this behavior is to change the <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer_3_01CharSrc_01_4.html#a2e052d761c53ba883b58b03cb7f8e4ff" title="Gets or sets the object to which error messages are sent. The default object is LogExceptionErrorSink...">ErrorSink</a> property. For example, set it to <a class="el" href="classLoyc_1_1MessageSink.html#a81ac62c2a94fe066156cce21f878f2a1" title="Sends all messages to the System.Console.WriteLine(string).">MessageSink.Console</a> to send errors to the console, or use <a class="el" href="classLoyc_1_1MessageSink.html#a56c0dedc4cca2f845665f0cdd1ed0fbd" title="Sends all messages to a user-defined method.">MessageSink.FromDelegate</a> to provide a custom handler. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CharSrc</td><td>A class that implements ICharSource. In order to write lexers that can accept any source of characters, set CharSrc=ICharSource. For maximum performance when parsing strings (or to avoid memory allocation), set CharSrc=<a class="el" href="structLoyc_1_1UString.html" title="UString is a slice of a string. It is a wrapper around string that provides a IBRange{T} of 21-bit UC...">UString</a> (<a class="el" href="structLoyc_1_1UString.html" title="UString is a slice of a string. It is a wrapper around string that provides a IBRange{T} of 21-bit UC...">UString</a> is a wrapper around <code>System.String</code> that, among other things, implements <code>ICharSource</code>; please note that C# will implicitly convert normal strings to <a class="el" href="structLoyc_1_1UString.html" title="UString is a slice of a string. It is a wrapper around string that provides a IBRange{T} of 21-bit UC...">UString</a> for you).</td></tr>
  </table>
  </dd>
</dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>CharSrc</em></td><td>&#160;:</td><td valign="top"><em><a class="el" href="interfaceLoyc_1_1Collections_1_1ICharSource.html">ICharSource</a></em></td><td>&#160;</td></tr>
</table>
</dl>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Nested classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer_3_01CharSrc_01_4_1_1SavePosition.html">SavePosition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class used by LLLPG for backtracking. <a href="structLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer_3_01CharSrc_01_4_1_1SavePosition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Public static fields</h2></td></tr>
<tr class="memitem:a1fbcd1f42ea2ebe33b7ee53481fd73e6"><td class="memItemLeft" align="right" valign="top">static readonly <a class="el" href="interfaceLoyc_1_1IMessageSink.html">IMessageSink</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer_3_01CharSrc_01_4.html#a1fbcd1f42ea2ebe33b7ee53481fd73e6">LogExceptionErrorSink</a></td></tr>
<tr class="memdesc:a1fbcd1f42ea2ebe33b7ee53481fd73e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throws <a class="el" href="classLoyc_1_1LogException.html" title="An exception that includes a &quot;context&quot; object as part of a LogMessage structure, typically used to in...">LogException</a> when it receives an error. Non-errors are sent to MessageSink.Current. <a href="#a1fbcd1f42ea2ebe33b7ee53481fd73e6">More...</a><br /></td></tr>
<tr class="separator:a1fbcd1f42ea2ebe33b7ee53481fd73e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2519061cb92a4df83891264cec3796f0"><td class="memItemLeft" align="right" valign="top">static readonly <a class="el" href="interfaceLoyc_1_1IMessageSink.html">IMessageSink</a>&#160;</td><td class="memItemRight" valign="bottom"><b>FormatExceptionErrorSink</b></td></tr>
<tr class="separator:a2519061cb92a4df83891264cec3796f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:a2e052d761c53ba883b58b03cb7f8e4ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceLoyc_1_1IMessageSink.html">IMessageSink</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer_3_01CharSrc_01_4.html#a2e052d761c53ba883b58b03cb7f8e4ff">ErrorSink</a><code> [get, set]</code></td></tr>
<tr class="memdesc:a2e052d761c53ba883b58b03cb7f8e4ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets or sets the object to which error messages are sent. The default object is <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer_3_01CharSrc_01_4.html#a1fbcd1f42ea2ebe33b7ee53481fd73e6" title="Throws LogException when it receives an error. Non-errors are sent to MessageSink.Current.">LogExceptionErrorSink</a>, which throws an exception if an error occurs. <a href="#a2e052d761c53ba883b58b03cb7f8e4ff">More...</a><br /></td></tr>
<tr class="separator:a2e052d761c53ba883b58b03cb7f8e4ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94e48d9dc50a8819b2eef0d066271ca9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94e48d9dc50a8819b2eef0d066271ca9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>LA0</b><code> [get, set]</code></td></tr>
<tr class="separator:a94e48d9dc50a8819b2eef0d066271ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab763519cf99be73dc4df98dacc54288f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab763519cf99be73dc4df98dacc54288f"></a>
CharSrc&#160;</td><td class="memItemRight" valign="bottom"><b>CharSource</b><code> [get]</code></td></tr>
<tr class="separator:ab763519cf99be73dc4df98dacc54288f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ac6dbc04a18d1553cb0b181162f4e0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa7ac6dbc04a18d1553cb0b181162f4e0"></a>
string&#160;</td><td class="memItemRight" valign="bottom"><b>FileName</b><code> [get]</code></td></tr>
<tr class="separator:aa7ac6dbc04a18d1553cb0b181162f4e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72525ee341d3f3381289c0684fb415fd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a72525ee341d3f3381289c0684fb415fd"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>InputPosition</b><code> [get, set]</code></td></tr>
<tr class="separator:a72525ee341d3f3381289c0684fb415fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a740398ec867b589603e66118e072ac9a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a740398ec867b589603e66118e072ac9a"></a>
LexerSourceFile&lt; CharSrc &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>SourceFile</b><code> [get]</code></td></tr>
<tr class="separator:a740398ec867b589603e66118e072ac9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10aa65ed2e21ad7fa8e4ef86bc4b35af"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer_3_01CharSrc_01_4.html#a10aa65ed2e21ad7fa8e4ef86bc4b35af">LineNumber</a><code> [get]</code></td></tr>
<tr class="memdesc:a10aa65ed2e21ad7fa8e4ef86bc4b35af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current line number. Starts at 1 for the first line, unless derived class changes it. <a href="#a10aa65ed2e21ad7fa8e4ef86bc4b35af">More...</a><br /></td></tr>
<tr class="separator:a10aa65ed2e21ad7fa8e4ef86bc4b35af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a195bafdad5c6bc2d0dce2354f2debce2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer_3_01CharSrc_01_4.html#a195bafdad5c6bc2d0dce2354f2debce2">LineStartAt</a><code> [get]</code></td></tr>
<tr class="memdesc:a195bafdad5c6bc2d0dce2354f2debce2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index at which the current line started. <a href="#a195bafdad5c6bc2d0dce2354f2debce2">More...</a><br /></td></tr>
<tr class="separator:a195bafdad5c6bc2d0dce2354f2debce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header properties_interfaceLoyc_1_1Syntax_1_1IIndexToLine"><td colspan="2" onclick="javascript:toggleInherit('properties_interfaceLoyc_1_1Syntax_1_1IIndexToLine')"><img src="closed.png" alt="-"/>&#160;Properties inherited from <a class="el" href="interfaceLoyc_1_1Syntax_1_1IIndexToLine.html">Loyc.Syntax.IIndexToLine</a></td></tr>
<tr class="memitem:a6d3da28c156caea83183fa8b10c1d56f inherit properties_interfaceLoyc_1_1Syntax_1_1IIndexToLine"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1Syntax_1_1IIndexToLine.html#a6d3da28c156caea83183fa8b10c1d56f">FileName</a><code> [get]</code></td></tr>
<tr class="memdesc:a6d3da28c156caea83183fa8b10c1d56f inherit properties_interfaceLoyc_1_1Syntax_1_1IIndexToLine"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the file name used in results returned by <a class="el" href="interfaceLoyc_1_1Syntax_1_1IIndexToLine.html#ae22d4575baf857ef0c7cf5a5b15047b3" title="Returns the position in a source file of the specified index.">IndexToLine(int)</a>. <a href="#a6d3da28c156caea83183fa8b10c1d56f">More...</a><br /></td></tr>
<tr class="separator:a6d3da28c156caea83183fa8b10c1d56f inherit properties_interfaceLoyc_1_1Syntax_1_1IIndexToLine"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aee0fca65b95753d88fdccc1b9e5a7214"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer_3_01CharSrc_01_4.html#aee0fca65b95753d88fdccc1b9e5a7214">BaseLexer</a> (CharSrc chars, string fileName=&quot;&quot;, int inputPosition=0, bool newSourceFile=true)</td></tr>
<tr class="memdesc:aee0fca65b95753d88fdccc1b9e5a7214"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html" title="Alias for BaseLexer{C} where C is ICharSource.">BaseLexer</a>. <a href="#aee0fca65b95753d88fdccc1b9e5a7214">More...</a><br /></td></tr>
<tr class="separator:aee0fca65b95753d88fdccc1b9e5a7214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429c45b8daf9f0adafa187bf4e27f211"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer_3_01CharSrc_01_4.html#a429c45b8daf9f0adafa187bf4e27f211">Reset</a> (CharSrc chars, string fileName=&quot;&quot;, int inputPosition=0, bool newSourceFile=true)</td></tr>
<tr class="memdesc:a429c45b8daf9f0adafa187bf4e27f211"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reinitializes the object. This method is called by the constructor. <a href="#a429c45b8daf9f0adafa187bf4e27f211">More...</a><br /></td></tr>
<tr class="separator:a429c45b8daf9f0adafa187bf4e27f211"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a905fa03603e9bbe2cdcee89c2e4dc48c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a905fa03603e9bbe2cdcee89c2e4dc48c"></a>
<a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Reset</b> ()</td></tr>
<tr class="separator:a905fa03603e9bbe2cdcee89c2e4dc48c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc17a4768d11713a95f4c084f201d7ef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc17a4768d11713a95f4c084f201d7ef"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>LA</b> (int i)</td></tr>
<tr class="separator:abc17a4768d11713a95f4c084f201d7ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ed46c1667602dbdfdab1f5fe49785a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer_3_01CharSrc_01_4.html#ae2ed46c1667602dbdfdab1f5fe49785a">Skip</a> ()</td></tr>
<tr class="memdesc:ae2ed46c1667602dbdfdab1f5fe49785a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments InputPosition. Called by LLLPG when prediction already verified the input (and caller doesn't save LA(0)) <a href="#ae2ed46c1667602dbdfdab1f5fe49785a">More...</a><br /></td></tr>
<tr class="separator:ae2ed46c1667602dbdfdab1f5fe49785a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf01d80adc87cbc7457dac46df1f41b1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer_3_01CharSrc_01_4.html#aaf01d80adc87cbc7457dac46df1f41b1">AfterNewline</a> ()</td></tr>
<tr class="memdesc:aaf01d80adc87cbc7457dac46df1f41b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The lexer must call this method exactly once after it advances past each newline, even inside comments and strings. This method keeps the <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer_3_01CharSrc_01_4.html#a10aa65ed2e21ad7fa8e4ef86bc4b35af" title="Current line number. Starts at 1 for the first line, unless derived class changes it...">LineNumber</a> and <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer_3_01CharSrc_01_4.html#a195bafdad5c6bc2d0dce2354f2debce2" title="Index at which the current line started.">LineStartAt</a> properties updated. <a href="#aaf01d80adc87cbc7457dac46df1f41b1">More...</a><br /></td></tr>
<tr class="separator:aaf01d80adc87cbc7457dac46df1f41b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a53c05e773d4c3fda024f067af57ae6bf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a53c05e773d4c3fda024f067af57ae6bf"></a>
static HashSet&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>NewSet</b> (params int[] items)</td></tr>
<tr class="separator:a53c05e773d4c3fda024f067af57ae6bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc64d3d34e11b837e3bc791067c2085a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc64d3d34e11b837e3bc791067c2085a"></a>
static HashSet&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>NewSetOfRanges</b> (params int[] ranges)</td></tr>
<tr class="separator:abc64d3d34e11b837e3bc791067c2085a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected fields</h2></td></tr>
<tr class="memitem:ac427e0418ad3558756a6365be0b7461e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac427e0418ad3558756a6365be0b7461e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>CachedBlockSize</b> = 128</td></tr>
<tr class="separator:ac427e0418ad3558756a6365be0b7461e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb254f4f5e4f2b6c76067ea306fb8db4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb254f4f5e4f2b6c76067ea306fb8db4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>_lineStartAt</b></td></tr>
<tr class="separator:aeb254f4f5e4f2b6c76067ea306fb8db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8eeb903f5eef427b220c816436496da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae8eeb903f5eef427b220c816436496da"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>_lineNumber</b> = 1</td></tr>
<tr class="separator:ae8eeb903f5eef427b220c816436496da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeff8a11670655e4fb27d4d0613bf868"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLoyc_1_1Syntax_1_1SourcePos.html">SourcePos</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer_3_01CharSrc_01_4.html#afeff8a11670655e4fb27d4d0613bf868">IndexToLine</a> (int index)</td></tr>
<tr class="memdesc:afeff8a11670655e4fb27d4d0613bf868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position in a source file of the specified index. <a href="#afeff8a11670655e4fb27d4d0613bf868">More...</a><br /></td></tr>
<tr class="separator:afeff8a11670655e4fb27d4d0613bf868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae963fe4011bda74065554b7f606f0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer_3_01CharSrc_01_4.html#abae963fe4011bda74065554b7f606f0e">Newline</a> ()</td></tr>
<tr class="memdesc:abae963fe4011bda74065554b7f606f0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default newline parser that matches '<br />
' or '' unconditionally. <a href="#abae963fe4011bda74065554b7f606f0e">More...</a><br /></td></tr>
<tr class="separator:abae963fe4011bda74065554b7f606f0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79c4e1d9e02ed6f1bd69870ff2f44a99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer_3_01CharSrc_01_4.html#a79c4e1d9e02ed6f1bd69870ff2f44a99">Spaces</a> ()</td></tr>
<tr class="memdesc:a79c4e1d9e02ed6f1bd69870ff2f44a99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skips past any spaces at the current position. Equivalent to <code>rule Spaces @[ (' '|'')* ]</code> in LLLPG. <a href="#a79c4e1d9e02ed6f1bd69870ff2f44a99">More...</a><br /></td></tr>
<tr class="separator:a79c4e1d9e02ed6f1bd69870ff2f44a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24a912e497d5edaeefc406f702c42cd0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a24a912e497d5edaeefc406f702c42cd0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>MatchAny</b> ()</td></tr>
<tr class="separator:a24a912e497d5edaeefc406f702c42cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a989354ec16b9fbb098beaca1f4954234"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a989354ec16b9fbb098beaca1f4954234"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>Match</b> (HashSet&lt; int &gt; set)</td></tr>
<tr class="separator:a989354ec16b9fbb098beaca1f4954234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf8f9413e205be2d30ccbd974f2098be"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf8f9413e205be2d30ccbd974f2098be"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>Match</b> (int a)</td></tr>
<tr class="separator:abf8f9413e205be2d30ccbd974f2098be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae696dfbc3405c2c92c9d2ab5c71898da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae696dfbc3405c2c92c9d2ab5c71898da"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>Match</b> (int a, int b)</td></tr>
<tr class="separator:ae696dfbc3405c2c92c9d2ab5c71898da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad88e5e0ef54f8f30394d78200866c8bc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad88e5e0ef54f8f30394d78200866c8bc"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>Match</b> (int a, int b, int c)</td></tr>
<tr class="separator:ad88e5e0ef54f8f30394d78200866c8bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16124cdfbbc03f33a1cc70774070a58f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16124cdfbbc03f33a1cc70774070a58f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>Match</b> (int a, int b, int c, int d)</td></tr>
<tr class="separator:a16124cdfbbc03f33a1cc70774070a58f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79b27c275f5c7611471ec953d93b10c5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a79b27c275f5c7611471ec953d93b10c5"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>MatchRange</b> (int aLo, int aHi)</td></tr>
<tr class="separator:a79b27c275f5c7611471ec953d93b10c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00e219b0596bba3e3298ae41a13b8b1e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a00e219b0596bba3e3298ae41a13b8b1e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>MatchRange</b> (int aLo, int aHi, int bLo, int bHi)</td></tr>
<tr class="separator:a00e219b0596bba3e3298ae41a13b8b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fb5b2865347675eeafaf54e942d74af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0fb5b2865347675eeafaf54e942d74af"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>MatchExcept</b> ()</td></tr>
<tr class="separator:a0fb5b2865347675eeafaf54e942d74af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8666dcd3ffb3512ba4d5537f6dc67480"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8666dcd3ffb3512ba4d5537f6dc67480"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>MatchExcept</b> (HashSet&lt; int &gt; set)</td></tr>
<tr class="separator:a8666dcd3ffb3512ba4d5537f6dc67480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64968bdd1a41ee4013021bea728738ee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a64968bdd1a41ee4013021bea728738ee"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>MatchExcept</b> (int a)</td></tr>
<tr class="separator:a64968bdd1a41ee4013021bea728738ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4262bd3b29b8b8708ae86df549dc4e27"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4262bd3b29b8b8708ae86df549dc4e27"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>MatchExcept</b> (int a, int b)</td></tr>
<tr class="separator:a4262bd3b29b8b8708ae86df549dc4e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5ce2931370ef2653fd598eefbdef4db"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab5ce2931370ef2653fd598eefbdef4db"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>MatchExcept</b> (int a, int b, int c)</td></tr>
<tr class="separator:ab5ce2931370ef2653fd598eefbdef4db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d3b3f3f052f98bee8c25cbaf5af04f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a97d3b3f3f052f98bee8c25cbaf5af04f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>MatchExcept</b> (int a, int b, int c, int d)</td></tr>
<tr class="separator:a97d3b3f3f052f98bee8c25cbaf5af04f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab79345325987375813bf153380ee0f75"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab79345325987375813bf153380ee0f75"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>MatchExceptRange</b> (int aLo, int aHi)</td></tr>
<tr class="separator:ab79345325987375813bf153380ee0f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b2b55568a4f7430dc2944857366369e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b2b55568a4f7430dc2944857366369e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>MatchExceptRange</b> (int aLo, int aHi, int bLo, int bHi)</td></tr>
<tr class="separator:a8b2b55568a4f7430dc2944857366369e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83f44082eff9d65428ec01d752b5bff6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a83f44082eff9d65428ec01d752b5bff6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>TryMatch</b> (HashSet&lt; int &gt; set)</td></tr>
<tr class="separator:a83f44082eff9d65428ec01d752b5bff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8caf15f395c4cdda9f9cd69a03583f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c8caf15f395c4cdda9f9cd69a03583f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>TryMatch</b> (int a)</td></tr>
<tr class="separator:a2c8caf15f395c4cdda9f9cd69a03583f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad25af34eed7a5ce39509e937661b0fc0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad25af34eed7a5ce39509e937661b0fc0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>TryMatch</b> (int a, int b)</td></tr>
<tr class="separator:ad25af34eed7a5ce39509e937661b0fc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5df24a7d60d5c4da814e2b30b39e024e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5df24a7d60d5c4da814e2b30b39e024e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>TryMatch</b> (int a, int b, int c)</td></tr>
<tr class="separator:a5df24a7d60d5c4da814e2b30b39e024e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad74f4f7b1114fe43a9abbe2d4bd0b6a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad74f4f7b1114fe43a9abbe2d4bd0b6a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>TryMatch</b> (int a, int b, int c, int d)</td></tr>
<tr class="separator:aad74f4f7b1114fe43a9abbe2d4bd0b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d455af37f23ad5c1926cff8ee331b49"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7d455af37f23ad5c1926cff8ee331b49"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>TryMatchRange</b> (int aLo, int aHi)</td></tr>
<tr class="separator:a7d455af37f23ad5c1926cff8ee331b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d41a5b72b6bebfcf045bb3ded8fc3b4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d41a5b72b6bebfcf045bb3ded8fc3b4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>TryMatchRange</b> (int aLo, int aHi, int bLo, int bHi)</td></tr>
<tr class="separator:a3d41a5b72b6bebfcf045bb3ded8fc3b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa88a13bdc50b6804715ffc1bef787c4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa88a13bdc50b6804715ffc1bef787c4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>TryMatchExcept</b> ()</td></tr>
<tr class="separator:afa88a13bdc50b6804715ffc1bef787c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4024ceef85e3cf565d661fdb3fef66b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa4024ceef85e3cf565d661fdb3fef66b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>TryMatchExcept</b> (HashSet&lt; int &gt; set)</td></tr>
<tr class="separator:aa4024ceef85e3cf565d661fdb3fef66b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42f0db593c731313c884650cb910006e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a42f0db593c731313c884650cb910006e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>TryMatchExcept</b> (int a)</td></tr>
<tr class="separator:a42f0db593c731313c884650cb910006e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a115eb42b4fd0042e916ee09dd6ce45a4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a115eb42b4fd0042e916ee09dd6ce45a4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>TryMatchExcept</b> (int a, int b)</td></tr>
<tr class="separator:a115eb42b4fd0042e916ee09dd6ce45a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01978861942c755d0d57a0185671dfed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01978861942c755d0d57a0185671dfed"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>TryMatchExcept</b> (int a, int b, int c)</td></tr>
<tr class="separator:a01978861942c755d0d57a0185671dfed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad460e405359d3f91dee0b236c59c7434"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad460e405359d3f91dee0b236c59c7434"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>TryMatchExcept</b> (int a, int b, int c, int d)</td></tr>
<tr class="separator:ad460e405359d3f91dee0b236c59c7434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93ecd2b9737ac3e9cdb43f735ab3e00e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a93ecd2b9737ac3e9cdb43f735ab3e00e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>TryMatchExceptRange</b> (int aLo, int aHi)</td></tr>
<tr class="separator:a93ecd2b9737ac3e9cdb43f735ab3e00e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa051af0df9e4ea469d41503f0c0dae4e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa051af0df9e4ea469d41503f0c0dae4e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>TryMatchExceptRange</b> (int aLo, int aHi, int bLo, int bHi)</td></tr>
<tr class="separator:aa051af0df9e4ea469d41503f0c0dae4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39e00a004728efa30701f4d3cda228cf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a39e00a004728efa30701f4d3cda228cf"></a>
virtual <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Check</b> (bool expectation, string expectedDescr=&quot;&quot;)</td></tr>
<tr class="separator:a39e00a004728efa30701f4d3cda228cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa705871192b412f511003f01639b97fb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer_3_01CharSrc_01_4.html#aa705871192b412f511003f01639b97fb">Error</a> (int lookaheadIndex, string message)</td></tr>
<tr class="memdesc:aa705871192b412f511003f01639b97fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is called to handle errors that occur during lexing. <a href="#aa705871192b412f511003f01639b97fb">More...</a><br /></td></tr>
<tr class="separator:aa705871192b412f511003f01639b97fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67212f3809c7a95082c92b7c5c04c388"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer_3_01CharSrc_01_4.html#a67212f3809c7a95082c92b7c5c04c388">Error</a> (int lookaheadIndex, string format, params object[] args)</td></tr>
<tr class="memdesc:a67212f3809c7a95082c92b7c5c04c388"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is called to format and handle errors that occur during lexing. The default implementation sends errors to <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer_3_01CharSrc_01_4.html#a2e052d761c53ba883b58b03cb7f8e4ff" title="Gets or sets the object to which error messages are sent. The default object is LogExceptionErrorSink...">ErrorSink</a>, which, by default, throws a FormatException. <a href="#a67212f3809c7a95082c92b7c5c04c388">More...</a><br /></td></tr>
<tr class="separator:a67212f3809c7a95082c92b7c5c04c388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f5a8dac7528f7c40c7758241042f50f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2f5a8dac7528f7c40c7758241042f50f"></a>
virtual <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Error</b> (bool inverted, int range0lo, int range0hi)</td></tr>
<tr class="separator:a2f5a8dac7528f7c40c7758241042f50f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ab861c69cc4eb30535481b27b2e278f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ab861c69cc4eb30535481b27b2e278f"></a>
virtual <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Error</b> (bool inverted, params int[] ranges)</td></tr>
<tr class="separator:a0ab861c69cc4eb30535481b27b2e278f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7097245fc3157c28d5b7c68699bedfd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa7097245fc3157c28d5b7c68699bedfd"></a>
virtual <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Error</b> (bool inverted, IList&lt; int &gt; ranges)</td></tr>
<tr class="separator:aa7097245fc3157c28d5b7c68699bedfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a570afeccb0831511129a01a928789746"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a570afeccb0831511129a01a928789746"></a>
virtual <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Error</b> (bool inverted, HashSet&lt; int &gt; set)</td></tr>
<tr class="separator:a570afeccb0831511129a01a928789746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ab17e0960bcab0b15dd3c2c0c9f012d"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer_3_01CharSrc_01_4.html#a9ab17e0960bcab0b15dd3c2c0c9f012d">RangesToString</a> (IList&lt; int &gt; ranges)</td></tr>
<tr class="memdesc:a9ab17e0960bcab0b15dd3c2c0c9f012d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a list of character ranges to a string, e.g. for input list {'*','*','a','z'}, the output is "'*' 'a'..'z'". <a href="#a9ab17e0960bcab0b15dd3c2c0c9f012d">More...</a><br /></td></tr>
<tr class="separator:a9ab17e0960bcab0b15dd3c2c0c9f012d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a6036bb9deaf51fff90e741a79e206"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer_3_01CharSrc_01_4.html#ab0a6036bb9deaf51fff90e741a79e206">PrintChar</a> (int c, StringBuilder sb)</td></tr>
<tr class="memdesc:ab0a6036bb9deaf51fff90e741a79e206"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a character as a string, e.g. <code>'a' -&gt; "'a'"</code>, with the special value -1 representing EOF, so PrintChar(-1, ...) == "EOF". <a href="#ab0a6036bb9deaf51fff90e741a79e206">More...</a><br /></td></tr>
<tr class="separator:ab0a6036bb9deaf51fff90e741a79e206"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aee0fca65b95753d88fdccc1b9e5a7214"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html">Loyc.Syntax.Lexing.BaseLexer</a>&lt; CharSrc &gt;.<a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html">BaseLexer</a> </td>
          <td>(</td>
          <td class="paramtype">CharSrc&#160;</td>
          <td class="paramname"><em>chars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>fileName</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>inputPosition</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>newSourceFile</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html" title="Alias for BaseLexer{C} where C is ICharSource.">BaseLexer</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chars</td><td>A source of characters, e.g. <a class="el" href="structLoyc_1_1UString.html" title="UString is a slice of a string. It is a wrapper around string that provides a IBRange{T} of 21-bit UC...">UString</a>.</td></tr>
    <tr><td class="paramname">fileName</td><td>A file name associated with the characters, which will be used for error reporting.</td></tr>
    <tr><td class="paramname">inputPosition</td><td>A location to start lexing (normally 0). Careful: If you're starting to lex in the middle of the file, the <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer_3_01CharSrc_01_4.html#a10aa65ed2e21ad7fa8e4ef86bc4b35af" title="Current line number. Starts at 1 for the first line, unless derived class changes it...">LineNumber</a> still starts at 1, and (if <code>newSourceFile</code> is true) the <a class="el" href="classLoyc_1_1Syntax_1_1SourceFile.html">SourceFile</a> object may or may not discover line breaks prior to the starting point, depending on how it is used.</td></tr>
    <tr><td class="paramname">newSourceFile</td><td>Whether to create a LexerSourceFile{C} object (an implementation of <a class="el" href="interfaceLoyc_1_1Syntax_1_1ISourceFile.html" title="Represents a text file with a file name and its textual content, plus the data necessary to convert b...">ISourceFile</a>) to keep track of line boundaries. The <a class="el" href="classLoyc_1_1Syntax_1_1SourceFile.html">SourceFile</a> property will point to this object, and it will be null if this parameter is false. Using 'false' will avoid memory allocation, but prevent you from mapping character positions to line numbers and vice versa. However, this object will still keep track of the current <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer_3_01CharSrc_01_4.html#a10aa65ed2e21ad7fa8e4ef86bc4b35af" title="Current line number. Starts at 1 for the first line, unless derived class changes it...">LineNumber</a> and <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer_3_01CharSrc_01_4.html#a195bafdad5c6bc2d0dce2354f2debce2" title="Index at which the current line started.">LineStartAt</a> (the index where the current line started) when this parameter is false.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aaf01d80adc87cbc7457dac46df1f41b1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structLoyc_1_1void.html">void</a> <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html">Loyc.Syntax.Lexing.BaseLexer</a>&lt; CharSrc &gt;.AfterNewline </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The lexer must call this method exactly once after it advances past each newline, even inside comments and strings. This method keeps the <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer_3_01CharSrc_01_4.html#a10aa65ed2e21ad7fa8e4ef86bc4b35af" title="Current line number. Starts at 1 for the first line, unless derived class changes it...">LineNumber</a> and <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer_3_01CharSrc_01_4.html#a195bafdad5c6bc2d0dce2354f2debce2" title="Index at which the current line started.">LineStartAt</a> properties updated.</p>

<p>Reimplemented in <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseILexer_3_01CharSrc_00_01Token_01_4.html#acdb9de5430c8ac55299c19736deeef7c">Loyc.Syntax.Lexing.BaseILexer&lt; CharSrc, Token &gt;</a>, and <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1LexerSource_3_01CharSrc_01_4.html#ade103d22afad41ba21889c2396006aed">Loyc.Syntax.Lexing.LexerSource&lt; CharSrc &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aa705871192b412f511003f01639b97fb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structLoyc_1_1void.html">void</a> <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html">Loyc.Syntax.Lexing.BaseLexer</a>&lt; CharSrc &gt;.Error </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lookaheadIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is called to handle errors that occur during lexing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lookaheadIndex</td><td>Index where the error occurred, relative to the current InputPosition (i.e. InputPosition + lookaheadIndex is the position of the error).</td></tr>
    <tr><td class="paramname">message</td><td>An error message, not including the error location.</td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1LexerSourceWorkaround_3_01CharSrc_01_4.html#af124a47fd8c62eef95e0a8990e251b78">Loyc.Syntax.Lexing.LexerSourceWorkaround&lt; CharSrc &gt;</a>, and <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1LexerSource_3_01CharSrc_01_4.html#a25b0fabb3d20ba608c2c4bd3e48e022d">Loyc.Syntax.Lexing.LexerSource&lt; CharSrc &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a67212f3809c7a95082c92b7c5c04c388"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structLoyc_1_1void.html">void</a> <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html">Loyc.Syntax.Lexing.BaseLexer</a>&lt; CharSrc &gt;.Error </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lookaheadIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">params object[]&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is called to format and handle errors that occur during lexing. The default implementation sends errors to <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer_3_01CharSrc_01_4.html#a2e052d761c53ba883b58b03cb7f8e4ff" title="Gets or sets the object to which error messages are sent. The default object is LogExceptionErrorSink...">ErrorSink</a>, which, by default, throws a FormatException.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lookaheadIndex</td><td>Index where the error occurred, relative to the current InputPosition (i.e. InputPosition + lookaheadIndex is the position of the error).</td></tr>
    <tr><td class="paramname">format</td><td>An error description with argument placeholders.</td></tr>
    <tr><td class="paramname">args</td><td>Arguments to insert into the error message.</td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1LexerSourceWorkaround_3_01CharSrc_01_4.html#a5d226cb13e6f4ce57bb988c39e3dca5e">Loyc.Syntax.Lexing.LexerSourceWorkaround&lt; CharSrc &gt;</a>, and <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1LexerSource_3_01CharSrc_01_4.html#a1469281ae2a685657210cd51c705842a">Loyc.Syntax.Lexing.LexerSource&lt; CharSrc &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="afeff8a11670655e4fb27d4d0613bf868"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLoyc_1_1Syntax_1_1SourcePos.html">SourcePos</a> <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html">Loyc.Syntax.Lexing.BaseLexer</a>&lt; CharSrc &gt;.IndexToLine </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the position in a source file of the specified index.</p>
<p>If index is negative, this should return a <a class="el" href="classLoyc_1_1Syntax_1_1SourcePos.html" title="Holds a filename (FileName), a line number (Line) and a position in the line (PosInLine), representing a position in a source code file.">SourcePos</a> where Line and PosInLine are zero (signifying an unknown location). If index is beyond the end of the file, this should retun the final position in the file.</p>

<p>Implements <a class="el" href="interfaceLoyc_1_1Syntax_1_1IIndexToLine.html#ae22d4575baf857ef0c7cf5a5b15047b3">Loyc.Syntax.IIndexToLine</a>.</p>

</div>
</div>
<a class="anchor" id="abae963fe4011bda74065554b7f606f0e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1void.html">void</a> <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html">Loyc.Syntax.Lexing.BaseLexer</a>&lt; CharSrc &gt;.Newline </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default newline parser that matches '<br />
' or '' unconditionally.</p>
<p>You can use this implementation in an LLLPG lexer with "extern", like so: <code>extern rule Newline '' + '<br />
'? | '<br />
' };</code> By using this implementation everywhere in the grammar in which a newline is allowed (even inside comments and strings), you can ensure that <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer_3_01CharSrc_01_4.html#aaf01d80adc87cbc7457dac46df1f41b1" title="The lexer must call this method exactly once after it advances past each newline, even inside comment...">AfterNewline()</a> is called, so that the line number is updated properly. </p>

</div>
</div>
<a class="anchor" id="ab0a6036bb9deaf51fff90e741a79e206"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1void.html">void</a> <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html">Loyc.Syntax.Lexing.BaseLexer</a>&lt; CharSrc &gt;.PrintChar </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringBuilder&#160;</td>
          <td class="paramname"><em>sb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints a character as a string, e.g. <code>'a' -&gt; "'a'"</code>, with the special value -1 representing EOF, so PrintChar(-1, ...) == "EOF".</p>

</div>
</div>
<a class="anchor" id="a9ab17e0960bcab0b15dd3c2c0c9f012d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html">Loyc.Syntax.Lexing.BaseLexer</a>&lt; CharSrc &gt;.RangesToString </td>
          <td>(</td>
          <td class="paramtype">IList&lt; int &gt;&#160;</td>
          <td class="paramname"><em>ranges</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a list of character ranges to a string, e.g. for input list {'*','*','a','z'}, the output is "'*' 'a'..'z'".</p>

</div>
</div>
<a class="anchor" id="a429c45b8daf9f0adafa187bf4e27f211"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structLoyc_1_1void.html">void</a> <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html">Loyc.Syntax.Lexing.BaseLexer</a>&lt; CharSrc &gt;.Reset </td>
          <td>(</td>
          <td class="paramtype">CharSrc&#160;</td>
          <td class="paramname"><em>chars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>fileName</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>inputPosition</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>newSourceFile</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reinitializes the object. This method is called by the constructor.</p>
<p>See the constructor for documentation of the parameters. </p>
<p>This method can be used to avoid memory allocations when you need to parse many small strings in a row. If that's your goal, you should set the <code>newSourceFile</code> parameter to false if possible.</p>

<p>Reimplemented in <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseILexer_3_01CharSrc_00_01Token_01_4.html#aed0208c6e7680f95359a2f6688534080">Loyc.Syntax.Lexing.BaseILexer&lt; CharSrc, Token &gt;</a>, and <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1LexerSource_3_01CharSrc_01_4.html#a9bc7605801736eee683422aee1a79588">Loyc.Syntax.Lexing.LexerSource&lt; CharSrc &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ae2ed46c1667602dbdfdab1f5fe49785a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1void.html">void</a> <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html">Loyc.Syntax.Lexing.BaseLexer</a>&lt; CharSrc &gt;.Skip </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increments InputPosition. Called by LLLPG when prediction already verified the input (and caller doesn't save LA(0))</p>

</div>
</div>
<a class="anchor" id="a79c4e1d9e02ed6f1bd69870ff2f44a99"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1void.html">void</a> <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html">Loyc.Syntax.Lexing.BaseLexer</a>&lt; CharSrc &gt;.Spaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Skips past any spaces at the current position. Equivalent to <code>rule Spaces @[ (' '|'')* ]</code> in LLLPG.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a2519061cb92a4df83891264cec3796f0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">readonly <a class="el" href="interfaceLoyc_1_1IMessageSink.html">IMessageSink</a> <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html">Loyc.Syntax.Lexing.BaseLexer</a>&lt; CharSrc &gt;.FormatExceptionErrorSink</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= MessageSink.FromDelegate(</div>
<div class="line">            (sev, location, fmt, args) =&gt; { </div>
<div class="line">                <span class="keywordflow">if</span> (sev &gt;= <a class="code" href="namespaceLoyc.html#aeb4d5c77591b654c8d37485b1dd00f5e">Severity</a>.Error)</div>
<div class="line">                    <span class="keywordflow">throw</span> <span class="keyword">new</span> FormatException(MessageSink.LocationString(location) + <span class="stringliteral">&quot;: &quot;</span> + Localize.Localized(fmt, args));</div>
<div class="line">                <span class="keywordflow">else</span></div>
<div class="line">                    MessageSink.Current.Write(sev, location, fmt, args);</div>
<div class="line">            })</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a1fbcd1f42ea2ebe33b7ee53481fd73e6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">readonly <a class="el" href="interfaceLoyc_1_1IMessageSink.html">IMessageSink</a> <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html">Loyc.Syntax.Lexing.BaseLexer</a>&lt; CharSrc &gt;.LogExceptionErrorSink</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= MessageSink.FromDelegate(</div>
<div class="line">            (sev, location, fmt, args) =&gt; {</div>
<div class="line">                LogMessage msg = <span class="keyword">new</span> LogMessage(sev, location, fmt, args);</div>
<div class="line">                <span class="keywordflow">if</span> (sev &gt;= <a class="code" href="namespaceLoyc.html#aeb4d5c77591b654c8d37485b1dd00f5e">Severity</a>.Error)</div>
<div class="line">                    <span class="keywordflow">throw</span> <span class="keyword">new</span> LogException(msg);</div>
<div class="line">                <span class="keywordflow">else</span></div>
<div class="line">                    msg.WriteTo(MessageSink.Current);</div>
<div class="line">            })</div>
</div><!-- fragment -->
<p>Throws <a class="el" href="classLoyc_1_1LogException.html" title="An exception that includes a &quot;context&quot; object as part of a LogMessage structure, typically used to in...">LogException</a> when it receives an error. Non-errors are sent to MessageSink.Current.</p>

</div>
</div>
<h2 class="groupheader">Property Documentation</h2>
<a class="anchor" id="a2e052d761c53ba883b58b03cb7f8e4ff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceLoyc_1_1IMessageSink.html">IMessageSink</a> <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html">Loyc.Syntax.Lexing.BaseLexer</a>&lt; CharSrc &gt;.ErrorSink</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span><span class="mlabel">set</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets or sets the object to which error messages are sent. The default object is <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer_3_01CharSrc_01_4.html#a1fbcd1f42ea2ebe33b7ee53481fd73e6" title="Throws LogException when it receives an error. Non-errors are sent to MessageSink.Current.">LogExceptionErrorSink</a>, which throws an exception if an error occurs.</p>

</div>
</div>
<a class="anchor" id="a10aa65ed2e21ad7fa8e4ef86bc4b35af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html">Loyc.Syntax.Lexing.BaseLexer</a>&lt; CharSrc &gt;.LineNumber</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Current line number. Starts at 1 for the first line, unless derived class changes it.</p>

</div>
</div>
<a class="anchor" id="a195bafdad5c6bc2d0dce2354f2debce2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html">Loyc.Syntax.Lexing.BaseLexer</a>&lt; CharSrc &gt;.LineStartAt</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index at which the current line started.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue May 17 2016 01:22:57 for Enhanced C# by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
