<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>Loyc: Loyc.Collections.Impl.InternalSet&lt; T &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Loyc
   </div>
   <div id="projectbrief">Language of your choice: library documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Events</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceLoyc.html">Loyc</a></li><li class="navelem"><a class="el" href="namespaceLoyc_1_1Collections.html">Collections</a></li><li class="navelem"><a class="el" href="namespaceLoyc_1_1Collections_1_1Impl.html">Impl</a></li><li class="navelem"><a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalSet_3_01T_01_4.html">InternalSet< T ></a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Nested classes</a> &#124;
<a href="#pub-attribs">Public fields</a> &#124;
<a href="#pub-static-attribs">Public static fields</a> &#124;
<a href="#properties">Properties</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="structLoyc_1_1Collections_1_1Impl_1_1InternalSet_3_01T_01_4-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Loyc.Collections.Impl.InternalSet&lt; T &gt; Struct Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A hash-trie data structure for use inside other data structures. 
 <a href="structLoyc_1_1Collections_1_1Impl_1_1InternalSet_3_01T_01_4.html#details">More...</a></p>
<hr/>Source file:<ul>
<li><a href='https://github.com/qwertie/Loyc/tree/master/Core/Loyc.Collections/Sets/InternalSet.cs'>/Core/Loyc.Collections/Sets/InternalSet.cs</a></li>
</ul>
<div class="dynheader">
Inheritance diagram for Loyc.Collections.Impl.InternalSet&lt; T &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="structLoyc_1_1Collections_1_1Impl_1_1InternalSet_3_01T_01_4.png" usemap="#Loyc.Collections.Impl.InternalSet&lt; T &gt;_map" alt=""/>
  <map id="Loyc.Collections.Impl.InternalSet&lt; T &gt;_map" name="Loyc.Collections.Impl.InternalSet&lt; T &gt;_map">
<area href="structLoyc_1_1Collections_1_1Impl_1_1InternalSet_3_01T_01_4_1_1Enumerator.html" alt="Loyc.Collections.Impl.InternalSet&lt; T &gt;.Enumerator" shape="rect" coords="0,112,296,136"/>
</map>
 </div></div>
<a name="details" id="details"></a><h2 class="groupheader">Remarks</h2>
<div class="textblock"><p>A hash-trie data structure for use inside other data structures.</p>
<p>InternalSet{T} is a dual-mode mutable/immutable "hash trie", which is a kind of tree that is built from the hashcode of the items it contains. It supports fast cloning, and is suitable as a persistent data structure. </p>
<p>InternalSet&lt;T&gt; is not designed to be used by itself, but as a building block for other data structures. It has no Count property because it does not know its own size; the outer data structure must track the size if the size is needed. The lack of a Count property allows an empty InternalSet to use a mere single word of memory! </p>
<p>This is my second implementation of InternalSet. The original version used memory very efficiently for reference types, but required boxing for value types; this version needs more memory, but is moderately faster in most cases and supports value types without boxing. I estimate that InternalSet (the second version) uses roughly the same amount of memory as HashSet{T} (actually more or less depending on the number of items in the set, and on the hashcode distribution.) </p>
<p>Collection classes based on InternalSet are most efficient for small sets, but if you always need small sets then a simple wrapper around HashSet would suffice. In fact, despite my best efforts, this data type rarely outperforms HashSet, but this is because HashSet{T} is quite fast, not because InternalSet{T} is slow. Still, there are several reasons to consider using a collection class based on InternalSet instead of HashSet{T}: </p><ul>
<li>
All of my set collections offer read-only variants. You can instantly convert any mutable set or dictionary into an immutable one, and convert any immutable set or dictionary back into a mutable one in O(1) time; this relies on the same fast-cloning technique I developed for AList{T}*. </li>
<li>
All of my set collections offer set operators that combine or intersect two sets without modifying the source sets ("|" for union, "&amp;amp;" for intersection, "-" for subtraction); these operators are available on both the mutable and immutable versions of the sets. </li>
<li>
InternalSet{T} supports combined "get-and-replace" and "get-and-remove" operations, which is mainly useful when it is being used as a dictionary (i.e. when T is a key-value pair). There are two "Add" modes, "add if not present" and "add or replace"; both modes retrieve the existing value if the key was already present, and the "add or replace" mode furthermore changes the value. Also, when removing an item, you can get the value that was removed. </li>
<li>
InternalSet{T}'s enumerator allows you to change or delete the current value (this feature is used internally by set operations such as <a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalSet_3_01T_01_4.html#a67aff8e7df81b991c98919b9074b8f26" title="Adds the contents of &#39;other&#39; to this set.">UnionWith</a> and <a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalSet_3_01T_01_4.html#afce719fab16ac0fc14977360e6d05e23" title="Removes all items from this set that are not present in &#39;other&#39;.">IntersectWith</a>). </li>
<li>
InternalSet{T} was inspired by Clojure's PersistentHashMap, or rather by Karl Krukow's blog posts about PersistentHashMap**, and so it is designed so that you can use it as a fully persistent set, which means that you can keep a copy of every old version of the set that has ever existed, if you want. The "+" and "-" operators (provided on the wrapper classes, not on InternalSet{T} itself) allow you to add or remove a single item without modifying the original set. There is a substantial performance penalty for overusing these operators, but these operators are cheaper than duplicating a HashSet{T} every time you modify it. </li>
</ul>
<ul>
<li>After developing AList{T} and <a class="el" href="namespaceLoyc.html" title="Main Loyc namespace. This namespace includes all general-purpose code in the Loyc megaproject...">Loyc</a> trees, I realized that freezable classes are error-prone, because it is sometimes difficult for a developer to figure out (before run-time) whether a given object could be frozen. If an object is frozen and you modify it, the compiler will never detect your mistake in advance and warn you. The collections based on InternalSet{T} fix this problem by having separate data types for frozen and unfrozen (a.k.a. immutable and mutable) collections.<br />
 ** <a href="http://blog.higher-order.net/2010/08/16/assoc-and-clojures-persistenthashmap-part-ii/">http://blog.higher-order.net/2010/08/16/assoc-and-clojures-persistenthashmap-part-ii/</a> </li>
</ul>
<p>InternalSet is not efficient for Ts that are expensive to compare; unlike standard .NET collections, this data structure does not store the hashcode of each item inside the collection. The memory saved by not storing the hashcode compensates for the extra memory that <code>InternalSet</code> tends to require due to its structure. </p>
<p>As I was saying, this data structure is inspired by Clojure's PersistentHashMap. Whereas PersistentHashMap uses nodes of size 32, I chose to use nodes of size 16 in order to increase space efficiency for small sets; for some reason I tend to design programs that use many small collections and a few big ones, so I tend to prefer designs that stay efficient at small sizes. </p>
<p>So InternalSet is a tree of nodes, with each level of the tree representing 4 bits of the hashcode. Slots in the root node are selected based on bits 0 to 3 of the hashcode, slots in children of the root are selected based on bits 4 to 7 of the hashcode, and so forth. Here's a diagram: </p><pre>
                             _root*
* IsFrozen=true                |
                               |
      +---------+---------+----+----+---------+---------+
      |         |         |         |         |         |
     0x2       0x3       0x6       0x7       0x9       0xF
                |                   |         |
             +--+--+                |      +--+--+
             |     |                |      |     |
           0x13   0x73             0x57  0x09   0x59
</pre><p> Each of the 12 nodes on this diagram has 16 slots for items of type T, and the 4 nodes that have children have 16 additional slots for references to children. The numbers on the nodes represent their role in the tree; for example: </p><ul>
<li>
0x59 is at depth 2 and only holds items whose hashcodes end with 0x59. </li>
<li>
0x9 is at depth 1 and only holds items whose hashcodes end with 0x9.  </li>
<li>
the root node is always at depth 0 and can hold any item regardless of hashcode. </li>
</ul>
<p>Technically, this data structure has O(log N) time complexity for search, insertion and removal. However, it's a base-16 logarithm and maxes out at 8 levels, so it is faster than typical O(log N) algorithms that are base-2. At smaller sizes, its speed is similar to a conventional hashtable, and some operations are still efficient at large sizes, too. </p>
<p>Unlike InternalList{T}, <code>new InternalSet&lt;T&gt;()</code> is a valid empty set. Moreover, because the root node is never changed after it is created (unless you modify it while it is frozen), all copies of an InternalSet{T} represent the same set unless the set is frozen with <a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalSet_3_01T_01_4.html#a432ccca55f47e17bf37202d7206d366e" title="Freezes the hashtrie so that any further changes require paths in the tree to be copied.">CloneFreeze</a>; see <a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalSet_3_01T_01_4.html#a5de45aaff18329740d9f532a772f8056" title="Thaws a frozen root node by duplicating it, or creates the root node if the set doesn&#39;t have one...">Thaw()</a> for more information. </p>
<p>The neatest feature of this data structure is fast cloning and subtree sharing. You can call <a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalSet_3_01T_01_4.html#a432ccca55f47e17bf37202d7206d366e" title="Freezes the hashtrie so that any further changes require paths in the tree to be copied.">CloneFreeze</a> to freeze/clone the trie in O(1) time; this freezes the root node (a transitive property that implicitly affects all children), but still permits the hashtrie to be modified by copying nodes on-demand. Thus the trie is actually frozen, but copy-on-write behavior provides the illusion that it is still editable. </p>
<p>This data structure is designed to support classes that contain mutable data, so that it can be used to construct dictionaries; that is, it allows T values that have an immutable "key" part and a mutable "value" part. Call Find to retrieve the value associated with a key, and call <a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalSet_3_01T_01_4.html#a769b8ece9af71dd9b97acce26c6d60ac" title="Tries to add an item to the set, and retrieves the existing item if present.">Add</a> with replaceIfPresent=true to change the "value" associated with a key. The Map{K,V} and MMap{K,V} classes rely on this feature to implement a dictionary. </p>
<p><b>How it works</b>: I call this data structure a "hash-trie" because it blends properties of hashtables and tries. It places items into a tree by taking their hashcode and dividing it into 8 groups of 4 bits, starting at the least significant bits. Each group of 4 bits is used to select a location in the tree/trie, and each node of the tree always has 16 items (and 16 children, if it has any children at all.) For example, consider a tree with 7 items that have the following hash codes: </p>
<ul>
<li>J: 0x89BC98B1 <br />
</li>
<li>K: 0xB173A12C <br />
</li>
<li>L: 0x20913491 <br />
</li>
<li>M: 0x1977FEB3 <br />
</li>
<li>N: 0x01299451 <br />
</li>
<li>O: 0x0732AF01 <br />
</li>
<li>P: 0x0732AF01 (Note: O.Equals(P)==false, but the hashcodes are equal) </li>
</ul>
<p>The top level of the trie represents the lowest 4 bits of the hashcode. Since each node has 16 items, 7 items can usually fit in a single node, but in this case there are too many hashcodes that end with "1", causing a node split: </p><pre>
                           |0|1|2|3|4|5|6|7|8|9|A|B|C|D|E|F|
       _root ==&gt; _items    | |!|!|M|!| | | | | | | |K| | | |
                 _children | |*| | | | | | | | | | | | | | |</pre><pre>                           |0|1|2|3|4|5|6|7|8|9|A|B|C|D|E|F|
* child node ==&gt; _items    |O|P| | | |N| | | |L| |J| | | | |
                 _children (null)</pre><pre>("!" represents the deleted flag, which indicates that an item was 
 once present at this location.)
</pre><p> The second level of the trie represents bits 4-7, which is the second- last hex digit. You can see, for example, that the second-last digit of N is 5, therefore N is stored at index 5 of the child node. </p>
<p>In case hashcodes of different objects collide at a particular digit, adjacent array elements can be used to hold the different objects that share the same 4-bit sub-hashcode; this is a bounded-time variation on the linearly-probed hashtable. In this example, both O and P have zero as their second-last digit. Assuming O is added first, it takes slot [0]; then P takes slot [1]. Up to 3 adjacent entries can be used for a given hashcode; therefore, when searching for an entry it is necessary to search up to 4 locations in each node: the preferred location, plus 3 adjacent locations. </p>
<p>For example, support we search for an item X that is not in the set and has hashcode 0xCCA9A241. In that case, the Find methods starts with the least-significant digit, 1. This points us to the child slot; an invariant of our hashtrie is that if there is a child node, all items with the corresponding sub-hashcode must be placed in the child node. Therefore it is impossible, for example, that X could be located at index 2 of the root node; the existence of the child node guarantees that it is not there. So the Find method looks inside the child node, at index 4 (the second-last digit of X's hashcode) and finds nothing. It also looks at indexes 5, 6, and 7, comparing N to X in the process. Since none of these slots contain X, the Find method returns false. </p>
<p>Something unfortunate happens if five or more objects have the same hashcode: it forces the tree to have maximum depth. Since a particular hashcode can only be repeated four times in a single node, upon adding a fifth item with the same hashcode, child nodes are created for all 8 digits of the hashcode. At the 8th level, a special node type is allocated that contains, in addition to the usual 16 slots, a list of "overflow slots" holds items that cannot fit in the normal slots due to excessive collisions. All of this has a substantial memory penalty; to avoid this problem, use a better hash function that does not create false collisions. </p>
<p>If there are more than 16 items that share the same 28 lower-order bits, the overflow area on the 8th level node will expand to hold all of these items; this is the only way that a node can have more than 16 items. </p>
<p>Fast cloning works by setting the "IsFrozen" flag on the root node. When a node is frozen, all its children are frozen implicitly; since the children are not marked right away, the <a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalSet_3_01T_01_4.html#a432ccca55f47e17bf37202d7206d366e" title="Freezes the hashtrie so that any further changes require paths in the tree to be copied.">CloneFreeze</a> method can return immediately. The frozen flag will be propagated from parents to children lazily, when the tree is modified later. </p>
<p>To "thaw" a node, a copy is made of that node and all of its parents. For example, suppose that the following tree is frozen and cloned: </p><pre>
                             _root*
* IsFrozen=true                |
                               |
      +---------+---------+----+----+---------+---------+
      |         |         |         |         |         |
     0x2       0x3       0x6       0x7       0x9       0xF
                |                   |         |
             +--+--+                |      +--+--+
             |     |                |      |     |
           0x13   0x73             0x57  0x09   0x59
</pre><p> Remember, only the root's IsFrozen flag is set at first; all other nodes do not have the frozen flag yet. </p>
<p>Now suppose that an item is added to node 0x9 (e.g. something with hashcode 0x39 could go in this node). Before the new item can be placed in node 0x9, it must be thawed. To thaw it, an unfrozen copy is made, leaving the original untouched. The copy is not frozen, but it does point to the same frozen children (0x09 and 0x59), so a for-loop sets the IsFrozen flag of each child. Then, the new item is added to the copy of node 0x9. Next, the _root is also unfrozen by making a copy of it with <code>IsFrozen=false</code>. Again, a for-loop sets the IsFrozen flag of each frozen child, and then child slot [9] in the root is replaced with the new copy of 0x9 (which has the new item). </p>
<p>This concludes the thawing process. So at this point, just two nodes are actually unfrozen, and the modified tree looks like this: </p><pre>
! Unfrozen copy              _root!
* IsFrozen=true                |
                               |
      +---------+---------+----+----+---------+---------+
      |         |         |         |         |         |
     0x2*      0x3*      0x6*      0x7*      0x9!      0xF*
                |                   |         |
             +--+--+                |      +--+--+
             |     |                |      |     |
           0x13   0x73             0x57  0x09*  0x59*
</pre><p> There are 12 nodes here and 2 have been copied. The other 10 nodes are still shared between the modified tree and the clone. Next, if you add an item to node 0x6, only that one node has to be thawed; the root has already been thawed and there is no need to make another copy of it. Due to the random nature of hashcodes, it is probable that as you modify the set after cloning it, it is typical for each modification to require approximately one node to be thawed, until the majority of the nodes have been thawed. </p>
<p>InternalSet does not thaw unnecessarily. If you try to remove an item that is not present, none of the tree will be thawed. If you add an item that is already present in a frozen node (and you do not ask for replacement), that node will not be thawed. Contains and Find never cause thawing. </p>
<p>I am not aware whether a data structure quite like this has been described in the comp-sci literature or not (although it probably has). If you see something like this in a paper, let me know. </p>
<p>When attempting to insert a new item in a node, the first available empty slot will be used; and when searching for an item, the search stops at an empty slot. For example, suppose that the root node contains these items: </p><pre>
                    |0|1|2|3|4|5|6|7|8|9|A|B|C|D|E|F|
_root ==&gt; _items    |A| |C| |E|F| | |I| |K|L| |N| | |
</pre><p> Now suppose that you are searching for, or adding, or an item 'D' whose hashcode ends with '3'. Slot 3 is empty, and this data structure works in such a way that the search for 'D' can end immediately with a result of 'false', or it can be added at slot 2 immediately without comparing 'D' with slots 4, 5 and 6 which (if 2 were not empty) might already contain 'D'. </p>
<p>The reasoning behind this rule is that if 'D' already existed in the set, slot 2 should not be empty; since it is empty, 'D' must not be in the set already. However, deletions could violate this logic. For example, imagine that we add two items, first 'd' and then 'D', which both have a hashcode that ends in '3'. Then the node would look like this: </p><pre>
                    |0|1|2|3|4|5|6|7|8|9|A|B|C|D|E|F|
_root ==&gt; _items    |A| |C|d|E|F|D| |I| |K|L| |N| | |
</pre><p> Next, you delete 'd'. Imagine that this leaves the node in the following state: </p><pre>
                    |0|1|2|3|4|5|6|7|8|9|A|B|C|D|E|F|
_root ==&gt; _items    |A| |C| |E|F|D| |I| |K|L| |N| | |
</pre><p> Now 'D' is left outside its 'home' location of 3. If you then attempt to add 'D' to the set, a duplicate copy would be added at position '3'! Or if you search for 'D' instead, the result would be 'false' even though D is present in the set. </p>
<p>I thought of two solutions to this problem; the first was to 'fix' the node after a deletion so that 'D' would move from slot 6 to 3. But there's a big problem with this solution because InternalSet{T}.Enumerator has a <code>RemoveCurrent()</code> method which is supposed to delete the current item and move to the next one. If the node had to be rearranged in response to a deletion, it would be very difficult to guarantee that the enumerator still returns each item in the set exactly once. </p>
<p>The second solution, which I actually implemented, puts a special "deleted" marker in slot 3 (denoted ! on the first diagram). This marker forces the search routine to compare the item being added or searched for with other slots beyond the current one, but otherwise it behaves like an empty slot. </p>
<p>There is a third solution&ndash;always check all four possible slots. But the comparison is not always cheap, so InternalSet{T} does not use this solution unless you are using <code>null</code> as the value of the IEqualityComparer{T}. </p>
<p>Since InternalSet{T} can hold any value of type T, the "deleted" and "empty/in use" indicators cannot physically be stored in the slots of type T. Instead, these indicators are stored separately, with 16 bits for "deleted" flags and 16 bits for "used" flags. </p>
<p>During a normal delete operation, if a node has no children and is using only one or two slots after an item is deleted, the parent is checked for empty slots to find out whether the child is really necessary. If there are enough free slot(s) in the parent node, the remaining items in the child are transferred back back to the parent and the child is deleted (the reference to it is cleared to null). </p>
<p>Unfortunately, this behavior is not available when you call <a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalSet_3_01T_01_4_1_1Enumerator.html#a4f91a0a9516c2b73a2926dde79c0ee91" title="Removes the current item from the set, and moves to the next item.">Enumerator.RemoveCurrent</a>. In order to maintain the integrity of the enumerator, a child node will not be deleted during a call to <code>RemoveCurrent</code> unless the node is completely empty after the removal. Consequently, the tree will use extra memory if you remove most, but not all, items from the set using <code>RemoveCurrent</code>. </p>
<p>By the way, unlike the original implementation, this version of InternalSet allows 'null' to be a member of the set. </p>
<p>Interesting fact: it is possible for two sets to be equal (contain the same items), and yet for those items to be enumerated in different orders in the two sets. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Nested classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalSet_3_01T_01_4_1_1Enumerator.html">Enumerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public fields</h2></td></tr>
<tr class="memitem:a207f077116dafe38131dbba4dd4c118e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a207f077116dafe38131dbba4dd4c118e"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>BitsPerLevel</b> = 4</td></tr>
<tr class="separator:a207f077116dafe38131dbba4dd4c118e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a081268351d3ecd59328ad178644ed093"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a081268351d3ecd59328ad178644ed093"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>FanOut</b> = 1 &lt;&lt; BitsPerLevel</td></tr>
<tr class="separator:a081268351d3ecd59328ad178644ed093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accde9a71d7527ac47da5990af14bb622"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="accde9a71d7527ac47da5990af14bb622"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>Mask</b> = FanOut - 1</td></tr>
<tr class="separator:accde9a71d7527ac47da5990af14bb622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a267c5f705e90d43b61da78021ed9f05e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a267c5f705e90d43b61da78021ed9f05e"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>MaxDepth</b> = 7</td></tr>
<tr class="separator:a267c5f705e90d43b61da78021ed9f05e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a09899266a32900a68a76335ed900c8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0a09899266a32900a68a76335ed900c8"></a>
const uint&#160;</td><td class="memItemRight" valign="bottom"><b>FlagMask</b> = (uint)((1L &lt;&lt; FanOut) - 1)</td></tr>
<tr class="separator:a0a09899266a32900a68a76335ed900c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63cf3ceea39571b0965b265f91245346"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a63cf3ceea39571b0965b265f91245346"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>CounterPerChild</b> = FanOut &lt;&lt; 1</td></tr>
<tr class="separator:a63cf3ceea39571b0965b265f91245346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06fe1099d06da55478252466261c1350"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a06fe1099d06da55478252466261c1350"></a>
const short&#160;</td><td class="memItemRight" valign="bottom"><b>OverflowFlag</b> = 1 &lt;&lt; 12</td></tr>
<tr class="separator:a06fe1099d06da55478252466261c1350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94446473eadf474d90980ed410183a74"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94446473eadf474d90980ed410183a74"></a>
Node&#160;</td><td class="memItemRight" valign="bottom"><b>_root</b></td></tr>
<tr class="separator:a94446473eadf474d90980ed410183a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Public static fields</h2></td></tr>
<tr class="memitem:aa9a8dcb8bdd7d82f867fa3263226cc30"><td class="memItemLeft" align="right" valign="top">static readonly InternalSet&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalSet_3_01T_01_4.html#aa9a8dcb8bdd7d82f867fa3263226cc30">Empty</a> = new InternalSet&lt;T&gt; { _root = FrozenEmptyRoot() }</td></tr>
<tr class="memdesc:aa9a8dcb8bdd7d82f867fa3263226cc30"><td class="mdescLeft">&#160;</td><td class="mdescRight">An empty set. <a href="#aa9a8dcb8bdd7d82f867fa3263226cc30">More...</a><br /></td></tr>
<tr class="separator:aa9a8dcb8bdd7d82f867fa3263226cc30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac7d404cb5692f28823c7688bbb921eb"><td class="memItemLeft" align="right" valign="top">static readonly <br class="typebreak" />
IEqualityComparer&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalSet_3_01T_01_4.html#aac7d404cb5692f28823c7688bbb921eb">DefaultComparer</a> = typeof(<a class="el" href="interfaceLoyc_1_1IReferenceComparable.html">IReferenceComparable</a>).IsAssignableFrom(typeof(T)) ? null : EqualityComparer&lt;T&gt;.Default</td></tr>
<tr class="memdesc:aac7d404cb5692f28823c7688bbb921eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is EqualityComparer{T}.Default, or null if T implements <a class="el" href="interfaceLoyc_1_1IReferenceComparable.html" title="This is a tag which indicates that objects of this type are unique; specifically, any two different o...">IReferenceComparable</a>. <a href="#aac7d404cb5692f28823c7688bbb921eb">More...</a><br /></td></tr>
<tr class="separator:aac7d404cb5692f28823c7688bbb921eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a285f51e8dc037eccf22b594cd887dd8a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a285f51e8dc037eccf22b594cd887dd8a"></a>
static readonly OnFoundExisting&#160;</td><td class="memItemRight" valign="bottom"><b>AddIfNotPresent</b> = _IgnoreExisting_</td></tr>
<tr class="separator:a285f51e8dc037eccf22b594cd887dd8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e8fb4e13571d959174c43236c3608e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a06e8fb4e13571d959174c43236c3608e"></a>
static readonly OnFoundExisting&#160;</td><td class="memItemRight" valign="bottom"><b>AddOrReplace</b> = _ReplaceExisting_</td></tr>
<tr class="separator:a06e8fb4e13571d959174c43236c3608e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecf13c18e3cc0ea57078943e3980d6b5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aecf13c18e3cc0ea57078943e3980d6b5"></a>
static readonly OnFoundExisting&#160;</td><td class="memItemRight" valign="bottom"><b>RemoveMode</b> = _DeleteExisting_</td></tr>
<tr class="separator:aecf13c18e3cc0ea57078943e3980d6b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeb4dcb608aabe831a9cdc1f104471d5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adeb4dcb608aabe831a9cdc1f104471d5"></a>
static Enumerator&#160;</td><td class="memItemRight" valign="bottom"><b>_setOperationEnumerator</b></td></tr>
<tr class="separator:adeb4dcb608aabe831a9cdc1f104471d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:abb2724a69e7292890b0b44f9853176e4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb2724a69e7292890b0b44f9853176e4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsRootFrozen</b><code> [get]</code></td></tr>
<tr class="separator:abb2724a69e7292890b0b44f9853176e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0fe4716a2d535b6c27cff738ae6e412"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab0fe4716a2d535b6c27cff738ae6e412"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>HasRoot</b><code> [get]</code></td></tr>
<tr class="separator:ab0fe4716a2d535b6c27cff738ae6e412"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a17a676afcf6b3a29f7d503aec6a616c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a17a676afcf6b3a29f7d503aec6a616c0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>InternalSet</b> (IEnumerable&lt; T &gt; list, IEqualityComparer&lt; T &gt; comparer, out int count)</td></tr>
<tr class="separator:a17a676afcf6b3a29f7d503aec6a616c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d34c34e48e8fb67a9b7bd14a3d3b688"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d34c34e48e8fb67a9b7bd14a3d3b688"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>InternalSet</b> (IEnumerable&lt; T &gt; list, IEqualityComparer&lt; T &gt; comparer)</td></tr>
<tr class="separator:a3d34c34e48e8fb67a9b7bd14a3d3b688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac11c82d749db054c57747c47cca18e61"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac11c82d749db054c57747c47cca18e61"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>GetSetHashCode</b> (IEqualityComparer&lt; T &gt; comparer)</td></tr>
<tr class="separator:ac11c82d749db054c57747c47cca18e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a432ccca55f47e17bf37202d7206d366e"><td class="memItemLeft" align="right" valign="top">InternalSet&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalSet_3_01T_01_4.html#a432ccca55f47e17bf37202d7206d366e">CloneFreeze</a> ()</td></tr>
<tr class="memdesc:a432ccca55f47e17bf37202d7206d366e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Freezes the hashtrie so that any further changes require paths in the tree to be copied. <a href="#a432ccca55f47e17bf37202d7206d366e">More...</a><br /></td></tr>
<tr class="separator:a432ccca55f47e17bf37202d7206d366e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5de45aaff18329740d9f532a772f8056"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalSet_3_01T_01_4.html#a5de45aaff18329740d9f532a772f8056">Thaw</a> ()</td></tr>
<tr class="memdesc:a5de45aaff18329740d9f532a772f8056"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thaws a frozen root node by duplicating it, or creates the root node if the set doesn't have one. <a href="#a5de45aaff18329740d9f532a772f8056">More...</a><br /></td></tr>
<tr class="separator:a5de45aaff18329740d9f532a772f8056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a769b8ece9af71dd9b97acce26c6d60ac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalSet_3_01T_01_4.html#a769b8ece9af71dd9b97acce26c6d60ac">Add</a> (ref T item, IEqualityComparer&lt; T &gt; comparer, bool replaceIfPresent)</td></tr>
<tr class="memdesc:a769b8ece9af71dd9b97acce26c6d60ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to add an item to the set, and retrieves the existing item if present. <a href="#a769b8ece9af71dd9b97acce26c6d60ac">More...</a><br /></td></tr>
<tr class="separator:a769b8ece9af71dd9b97acce26c6d60ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a70ee762d05a37044c6a2ea083a68a0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalSet_3_01T_01_4.html#a7a70ee762d05a37044c6a2ea083a68a0">Remove</a> (ref T item, IEqualityComparer&lt; T &gt; comparer)</td></tr>
<tr class="memdesc:a7a70ee762d05a37044c6a2ea083a68a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an item from the set. <a href="#a7a70ee762d05a37044c6a2ea083a68a0">More...</a><br /></td></tr>
<tr class="separator:a7a70ee762d05a37044c6a2ea083a68a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba51906b962731d285cdadbc2fb73b70"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba51906b962731d285cdadbc2fb73b70"></a>
delegate bool&#160;</td><td class="memItemRight" valign="bottom"><b>OnFoundExisting</b> (ref Node slots, int i, T item)</td></tr>
<tr class="separator:aba51906b962731d285cdadbc2fb73b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e702ebf3b0445bd78892963703b32f5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4e702ebf3b0445bd78892963703b32f5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Find</b> (ref T item, IEqualityComparer&lt; T &gt; comparer)</td></tr>
<tr class="separator:a4e702ebf3b0445bd78892963703b32f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a803e9b4770ff433d14680c16fa506f41"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a803e9b4770ff433d14680c16fa506f41"></a>
Enumerator&#160;</td><td class="memItemRight" valign="bottom"><b>GetEnumerator</b> ()</td></tr>
<tr class="separator:a803e9b4770ff433d14680c16fa506f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec21df01f2eda74f1877c217743abb73"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec21df01f2eda74f1877c217743abb73"></a>
IEnumerator&lt; T &gt; IEnumerable&lt; T &gt;.&#160;</td><td class="memItemRight" valign="bottom"><b>GetEnumerator</b> ()</td></tr>
<tr class="separator:aec21df01f2eda74f1877c217743abb73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0b0b04857d0a3e24e91418fa5510ed8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac0b0b04857d0a3e24e91418fa5510ed8"></a>
System.Collections.IEnumerator <br class="typebreak" />
System.Collections.IEnumerable.&#160;</td><td class="memItemRight" valign="bottom"><b>GetEnumerator</b> ()</td></tr>
<tr class="separator:ac0b0b04857d0a3e24e91418fa5510ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a801551ad725c73c2fc43835b74a5cc2a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a801551ad725c73c2fc43835b74a5cc2a"></a>
<a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CopyTo</b> (T[] array, int arrayIndex)</td></tr>
<tr class="separator:a801551ad725c73c2fc43835b74a5cc2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc05a59775b8951951c09fca2b877e0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3dc05a59775b8951951c09fca2b877e0"></a>
<a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Clear</b> ()</td></tr>
<tr class="separator:a3dc05a59775b8951951c09fca2b877e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a985cc1cba76c90316deaf94fb5e50cae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a985cc1cba76c90316deaf94fb5e50cae"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Contains</b> (T item, IEqualityComparer&lt; T &gt; comparer)</td></tr>
<tr class="separator:a985cc1cba76c90316deaf94fb5e50cae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2ffe8123dbbe653e36062e771291f92"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac2ffe8123dbbe653e36062e771291f92"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>Count</b> ()</td></tr>
<tr class="separator:ac2ffe8123dbbe653e36062e771291f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67aff8e7df81b991c98919b9074b8f26"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalSet_3_01T_01_4.html#a67aff8e7df81b991c98919b9074b8f26">UnionWith</a> (IEnumerable&lt; T &gt; other, IEqualityComparer&lt; T &gt; thisComparer, bool replaceIfPresent)</td></tr>
<tr class="memdesc:a67aff8e7df81b991c98919b9074b8f26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the contents of 'other' to this set. <a href="#a67aff8e7df81b991c98919b9074b8f26">More...</a><br /></td></tr>
<tr class="separator:a67aff8e7df81b991c98919b9074b8f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6de2eb42dd79b7d7718c12f5995e133a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6de2eb42dd79b7d7718c12f5995e133a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalSet_3_01T_01_4.html#a6de2eb42dd79b7d7718c12f5995e133a">UnionWith</a> (InternalSet&lt; T &gt; other, IEqualityComparer&lt; T &gt; thisComparer, bool replaceIfPresent)</td></tr>
<tr class="separator:a6de2eb42dd79b7d7718c12f5995e133a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce719fab16ac0fc14977360e6d05e23"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalSet_3_01T_01_4.html#afce719fab16ac0fc14977360e6d05e23">IntersectWith</a> (InternalSet&lt; T &gt; other, IEqualityComparer&lt; T &gt; otherComparer)</td></tr>
<tr class="memdesc:afce719fab16ac0fc14977360e6d05e23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all items from this set that are not present in 'other'. <a href="#afce719fab16ac0fc14977360e6d05e23">More...</a><br /></td></tr>
<tr class="separator:afce719fab16ac0fc14977360e6d05e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a465239bdb7620d88cb5574db500651bd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a465239bdb7620d88cb5574db500651bd"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>IntersectWith</b> (ISet&lt; T &gt; other)</td></tr>
<tr class="separator:a465239bdb7620d88cb5574db500651bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa297d94c3edbb0fbe19de9cc7f451df4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalSet_3_01T_01_4.html#aa297d94c3edbb0fbe19de9cc7f451df4">IntersectWith</a> (IEnumerable&lt; T &gt; other, IEqualityComparer&lt; T &gt; comparer)</td></tr>
<tr class="memdesc:aa297d94c3edbb0fbe19de9cc7f451df4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all items from this set that are not present in 'other'. <a href="#aa297d94c3edbb0fbe19de9cc7f451df4">More...</a><br /></td></tr>
<tr class="separator:aa297d94c3edbb0fbe19de9cc7f451df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab10f306eae237b1544f197334e4502be"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalSet_3_01T_01_4.html#ab10f306eae237b1544f197334e4502be">ExceptWith</a> (IEnumerable&lt; T &gt; other, IEqualityComparer&lt; T &gt; thisComparer)</td></tr>
<tr class="memdesc:ab10f306eae237b1544f197334e4502be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all items from this set that are present in 'other'. <a href="#ab10f306eae237b1544f197334e4502be">More...</a><br /></td></tr>
<tr class="separator:ab10f306eae237b1544f197334e4502be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a709c7daa4ebccbcde7495ba7c67f337f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a709c7daa4ebccbcde7495ba7c67f337f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalSet_3_01T_01_4.html#a709c7daa4ebccbcde7495ba7c67f337f">ExceptWith</a> (InternalSet&lt; T &gt; other, IEqualityComparer&lt; T &gt; thisComparer)</td></tr>
<tr class="separator:a709c7daa4ebccbcde7495ba7c67f337f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38c086598fcd2a1173467c5bebe00e00"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38c086598fcd2a1173467c5bebe00e00"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>SymmetricExceptWith</b> (InternalSet&lt; T &gt; other, IEqualityComparer&lt; T &gt; thisComparer)</td></tr>
<tr class="separator:a38c086598fcd2a1173467c5bebe00e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef1799cb5a1f92bdeeb583add3269e08"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalSet_3_01T_01_4.html#aef1799cb5a1f92bdeeb583add3269e08">SymmetricExceptWith</a> (IEnumerable&lt; T &gt; other, IEqualityComparer&lt; T &gt; comparer, bool xorDuplicates=true)</td></tr>
<tr class="memdesc:aef1799cb5a1f92bdeeb583add3269e08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies the current set to contain only elements that were present either in this set or in the other collection, but not both. <a href="#aef1799cb5a1f92bdeeb583add3269e08">More...</a><br /></td></tr>
<tr class="separator:aef1799cb5a1f92bdeeb583add3269e08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e12ea9a899c7dac84aa8febf8aaa1f9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalSet_3_01T_01_4.html#a1e12ea9a899c7dac84aa8febf8aaa1f9">IsSubsetOf</a> (ISet&lt; T &gt; other, int myMinCount)</td></tr>
<tr class="memdesc:a1e12ea9a899c7dac84aa8febf8aaa1f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all items in this set are present in the other set. <a href="#a1e12ea9a899c7dac84aa8febf8aaa1f9">More...</a><br /></td></tr>
<tr class="separator:a1e12ea9a899c7dac84aa8febf8aaa1f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78bc33cf7960c65115048f2f41ce1b16"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78bc33cf7960c65115048f2f41ce1b16"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsSubsetOf</b> (InternalSet&lt; T &gt; other, IEqualityComparer&lt; T &gt; otherComparer)</td></tr>
<tr class="separator:a78bc33cf7960c65115048f2f41ce1b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae591215f86a6fea81722bcbb854ccb16"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae591215f86a6fea81722bcbb854ccb16"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsSubsetOf</b> (IEnumerable&lt; T &gt; other, IEqualityComparer&lt; T &gt; comparer, int myMinCount=0)</td></tr>
<tr class="separator:ae591215f86a6fea81722bcbb854ccb16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c23568605fbfdef2678007b55dd05c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalSet_3_01T_01_4.html#a56c23568605fbfdef2678007b55dd05c">IsSupersetOf</a> (IEnumerable&lt; T &gt; other, IEqualityComparer&lt; T &gt; thisComparer, int myMaxCount=int.MaxValue)</td></tr>
<tr class="memdesc:a56c23568605fbfdef2678007b55dd05c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all items in the other set are present in this set. <a href="#a56c23568605fbfdef2678007b55dd05c">More...</a><br /></td></tr>
<tr class="separator:a56c23568605fbfdef2678007b55dd05c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5426e6c5c34bc18d98a5dcdb163a2a8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa5426e6c5c34bc18d98a5dcdb163a2a8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsSupersetOf</b> (InternalSet&lt; T &gt; other, IEqualityComparer&lt; T &gt; thisComparer)</td></tr>
<tr class="separator:aa5426e6c5c34bc18d98a5dcdb163a2a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50bccc5fbf584aded2ccd670d48038d8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalSet_3_01T_01_4.html#a50bccc5fbf584aded2ccd670d48038d8">Overlaps</a> (IEnumerable&lt; T &gt; other, IEqualityComparer&lt; T &gt; thisComparer)</td></tr>
<tr class="memdesc:a50bccc5fbf584aded2ccd670d48038d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this set contains at least one item from 'other'. <a href="#a50bccc5fbf584aded2ccd670d48038d8">More...</a><br /></td></tr>
<tr class="separator:a50bccc5fbf584aded2ccd670d48038d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd93ab719c0ebf77fdae4aa1b0a28f2d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abd93ab719c0ebf77fdae4aa1b0a28f2d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Overlaps</b> (InternalSet&lt; T &gt; other, IEqualityComparer&lt; T &gt; thisComparer)</td></tr>
<tr class="separator:abd93ab719c0ebf77fdae4aa1b0a28f2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad09a821c318ffd828d1ff887c940818b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalSet_3_01T_01_4.html#ad09a821c318ffd828d1ff887c940818b">IsProperSubsetOf</a> (ISet&lt; T &gt; other, int myExactCount)</td></tr>
<tr class="memdesc:ad09a821c318ffd828d1ff887c940818b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all items in this set are present in the other set, and the other set has at least one item that is not in this set. <a href="#ad09a821c318ffd828d1ff887c940818b">More...</a><br /></td></tr>
<tr class="separator:ad09a821c318ffd828d1ff887c940818b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8503208286c00464a596d80b928aa4c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalSet_3_01T_01_4.html#af8503208286c00464a596d80b928aa4c">IsProperSubsetOf</a> (IEnumerable&lt; T &gt; other, IEqualityComparer&lt; T &gt; comparer, int myExactCount)</td></tr>
<tr class="memdesc:af8503208286c00464a596d80b928aa4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all items in this set are present in the other set, and the other set has at least one item that is not in this set. <a href="#af8503208286c00464a596d80b928aa4c">More...</a><br /></td></tr>
<tr class="separator:af8503208286c00464a596d80b928aa4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6beb6ab37a0af015e6432f799942816b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalSet_3_01T_01_4.html#a6beb6ab37a0af015e6432f799942816b">IsProperSupersetOf</a> (ISet&lt; T &gt; other, IEqualityComparer&lt; T &gt; thisComparer, int myExactCount)</td></tr>
<tr class="memdesc:a6beb6ab37a0af015e6432f799942816b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all items in the other set are present in this set, and this set has at least one item that is not in the other set. <a href="#a6beb6ab37a0af015e6432f799942816b">More...</a><br /></td></tr>
<tr class="separator:a6beb6ab37a0af015e6432f799942816b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6327e90edcf0686ca7672b21f4b89501"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalSet_3_01T_01_4.html#a6327e90edcf0686ca7672b21f4b89501">IsProperSupersetOf</a> (IEnumerable&lt; T &gt; other, IEqualityComparer&lt; T &gt; comparer, int myExactCount)</td></tr>
<tr class="memdesc:a6327e90edcf0686ca7672b21f4b89501"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all items in the other set are present in this set, and this set has at least one item that is not in the other set. <a href="#a6327e90edcf0686ca7672b21f4b89501">More...</a><br /></td></tr>
<tr class="separator:a6327e90edcf0686ca7672b21f4b89501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70aedaba6107df8bc786f77af298fc67"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalSet_3_01T_01_4.html#a70aedaba6107df8bc786f77af298fc67">SetEquals</a> (ISet&lt; T &gt; other, int myExactCount)</td></tr>
<tr class="memdesc:a70aedaba6107df8bc786f77af298fc67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this set and the other set have the same items. <a href="#a70aedaba6107df8bc786f77af298fc67">More...</a><br /></td></tr>
<tr class="separator:a70aedaba6107df8bc786f77af298fc67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad81d5197419bf36f192c0d814b04156e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalSet_3_01T_01_4.html#ad81d5197419bf36f192c0d814b04156e">SetEquals</a> (IEnumerable&lt; T &gt; other, IEqualityComparer&lt; T &gt; comparer, int myExactCount)</td></tr>
<tr class="memdesc:ad81d5197419bf36f192c0d814b04156e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this set and the other set have the same items. <a href="#ad81d5197419bf36f192c0d814b04156e">More...</a><br /></td></tr>
<tr class="separator:ad81d5197419bf36f192c0d814b04156e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e5a175fc9857dc7038387c3c130578"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalSet_3_01T_01_4.html#ab2e5a175fc9857dc7038387c3c130578">CountMemory</a> (int sizeOfT)</td></tr>
<tr class="memdesc:ab2e5a175fc9857dc7038387c3c130578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measures the total size of all objects allocated to this collection, in bytes, including the size of InternalSet{T} itself (which is one word). <a href="#ab2e5a175fc9857dc7038387c3c130578">More...</a><br /></td></tr>
<tr class="separator:ab2e5a175fc9857dc7038387c3c130578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa72ed88672a67fd6799f2c55fa78695b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalSet_3_01T_01_4.html#aa72ed88672a67fd6799f2c55fa78695b">CountMemory</a> (int sizeOfT, out <a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalSetStats.html">InternalSetStats</a> stats)</td></tr>
<tr class="memdesc:aa72ed88672a67fd6799f2c55fa78695b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measures the total size of all objects allocated to this collection, in bytes, and counts the number of nodes of different types. <a href="#aa72ed88672a67fd6799f2c55fa78695b">More...</a><br /></td></tr>
<tr class="separator:aa72ed88672a67fd6799f2c55fa78695b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a8ff7e1138c8a6cd0942a35556ebd6062"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ff7e1138c8a6cd0942a35556ebd6062"></a>
static Node&#160;</td><td class="memItemRight" valign="bottom"><b>FrozenEmptyRoot</b> ()</td></tr>
<tr class="separator:a8ff7e1138c8a6cd0942a35556ebd6062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0831b7facc9489bd8245b2ae98ef4e1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa0831b7facc9489bd8245b2ae98ef4e1"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>Adj</b> (int i, int n)</td></tr>
<tr class="separator:aa0831b7facc9489bd8245b2ae98ef4e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe7c60cc04e8b7fbda5ae821f3c857ba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe7c60cc04e8b7fbda5ae821f3c857ba"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>Equals</b> (T value, ref T item, IEqualityComparer&lt; T &gt; comparer)</td></tr>
<tr class="separator:abe7c60cc04e8b7fbda5ae821f3c857ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a100e97ab9d9803b5f741cba76c827436"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a100e97ab9d9803b5f741cba76c827436"></a>
static uint&#160;</td><td class="memItemRight" valign="bottom"><b>GetHashCode</b> (T item, IEqualityComparer&lt; T &gt; comparer)</td></tr>
<tr class="separator:a100e97ab9d9803b5f741cba76c827436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfed726676cfa5e221061db2b0d8e359"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abfed726676cfa5e221061db2b0d8e359"></a>
static <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PropagateFrozenFlag</b> (Node parent, Node child)</td></tr>
<tr class="separator:abfed726676cfa5e221061db2b0d8e359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32d3b0f0ae099a96fe84b3f516c0ca1e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a32d3b0f0ae099a96fe84b3f516c0ca1e"></a>
static <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ReplaceChild</b> (ref Node slots, int iHome, Node newChild)</td></tr>
<tr class="separator:a32d3b0f0ae099a96fe84b3f516c0ca1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa68641111fd4663d53058410cecb814"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa68641111fd4663d53058410cecb814"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>TryRemoveChild</b> (ref Node slots, int iHome, Node child)</td></tr>
<tr class="separator:aaa68641111fd4663d53058410cecb814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12a25a7851e61f0cf6c396186d99b89a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a12a25a7851e61f0cf6c396186d99b89a"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>_IgnoreExisting_</b> (ref Node slots, int i, T item)</td></tr>
<tr class="separator:a12a25a7851e61f0cf6c396186d99b89a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b2bda8cc8501305be43608771d43db"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa8b2bda8cc8501305be43608771d43db"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>_ReplaceExisting_</b> (ref Node slots, int i, T item)</td></tr>
<tr class="separator:aa8b2bda8cc8501305be43608771d43db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fc20a68aeed12be0583f989a4f1e39b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6fc20a68aeed12be0583f989a4f1e39b"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>_DeleteExisting_</b> (ref Node slots, int i, T item)</td></tr>
<tr class="separator:a6fc20a68aeed12be0583f989a4f1e39b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c0cb4ac976290b417ce3b2edacc814a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c0cb4ac976290b417ce3b2edacc814a"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>AddOrRemove</b> (ref Node slots, ref T item, uint hc, IEqualityComparer&lt; T &gt; comparer, OnFoundExisting mode)</td></tr>
<tr class="separator:a1c0cb4ac976290b417ce3b2edacc814a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b178a86d82070ce429905058e17225"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a20b178a86d82070ce429905058e17225"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>OnFoundInOverflow</b> (ref Node slots, int i, ref T item, OnFoundExisting mode, T existing)</td></tr>
<tr class="separator:a20b178a86d82070ce429905058e17225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a030e6d54fe92d7c006f56522d2bac97d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a030e6d54fe92d7c006f56522d2bac97d"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>SelectBucketToSpill</b> (Node slots, int i0, IEqualityComparer&lt; T &gt; comparer)</td></tr>
<tr class="separator:a030e6d54fe92d7c006f56522d2bac97d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93ded07aff3ec8dfcd6c668810be7d81"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a93ded07aff3ec8dfcd6c668810be7d81"></a>
static <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Spill</b> (Node parent, int i0, IEqualityComparer&lt; T &gt; comparer)</td></tr>
<tr class="separator:a93ded07aff3ec8dfcd6c668810be7d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee9074773f183d21f3cd80d1abf93104"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee9074773f183d21f3cd80d1abf93104"></a>
static Enumerator&#160;</td><td class="memItemRight" valign="bottom"><b>SetOperationEnumerator</b> ()</td></tr>
<tr class="separator:aee9074773f183d21f3cd80d1abf93104"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a769b8ece9af71dd9b97acce26c6d60ac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Loyc.Collections.Impl.InternalSet&lt; T &gt;.Add </td>
          <td>(</td>
          <td class="paramtype">ref T&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IEqualityComparer&lt; T &gt;&#160;</td>
          <td class="paramname"><em>comparer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>replaceIfPresent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to add an item to the set, and retrieves the existing item if present.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the item was added, false if it was already present.</dd></dl>

<p>References <a class="el" href="namespaceLoyc_1_1Collections.html#ab3f241a3b553681db7ce9ce14147e4eea9ed5e57327e6a026f97d80a241955516">Loyc.Collections.AddIfNotPresent</a>, and <a class="el" href="namespaceLoyc_1_1Collections.html#ab3f241a3b553681db7ce9ce14147e4eeabbbe4763739c476985364059d62b8153">Loyc.Collections.AddOrReplace</a>.</p>

</div>
</div>
<a class="anchor" id="a432ccca55f47e17bf37202d7206d366e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">InternalSet&lt;T&gt; Loyc.Collections.Impl.InternalSet&lt; T &gt;.CloneFreeze </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Freezes the hashtrie so that any further changes require paths in the tree to be copied.</p>
<p>This is an O(1) operation. It causes all existing copies of this InternalSet{T}, as well as any other copies you make in the future, to become independent of one another so that modifications to one copy do not affect any of the others. </p>
<p>To unfreeze the hashtrie, simply modify it as usual with (for example) a call to <a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalSet_3_01T_01_4.html#a769b8ece9af71dd9b97acce26c6d60ac" title="Tries to add an item to the set, and retrieves the existing item if present.">Add</a> or <a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalSet_3_01T_01_4.html#a7a70ee762d05a37044c6a2ea083a68a0" title="Removes an item from the set.">Remove</a>, or call <a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalSet_3_01T_01_4.html#a5de45aaff18329740d9f532a772f8056" title="Thaws a frozen root node by duplicating it, or creates the root node if the set doesn&#39;t have one...">Thaw</a>. Frozen parts of the trie are copied on-demand. </p>

</div>
</div>
<a class="anchor" id="ab2e5a175fc9857dc7038387c3c130578"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Loyc.Collections.Impl.InternalSet&lt; T &gt;.CountMemory </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeOfT</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Measures the total size of all objects allocated to this collection, in bytes, including the size of InternalSet{T} itself (which is one word).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sizeOfT</td><td>Size of each T. C# provides no way to get this number so it must be supplied as a parameter. If T is a reference type such as String, IntPtr.Size tells you the size of each reference; please note that this method is does not look "inside" each T, it just measures the "shallow" size of the collection. For instance, if this is a set of strings, then <code>CountMemory(IntPtr.Size)</code> is the size of the set including the references to the strings, but not including the strings themselves.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="aa72ed88672a67fd6799f2c55fa78695b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Loyc.Collections.Impl.InternalSet&lt; T &gt;.CountMemory </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeOfT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out <a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalSetStats.html">InternalSetStats</a>&#160;</td>
          <td class="paramname"><em>stats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Measures the total size of all objects allocated to this collection, in bytes, and counts the number of nodes of different types.</p>

</div>
</div>
<a class="anchor" id="ab10f306eae237b1544f197334e4502be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Loyc.Collections.Impl.InternalSet&lt; T &gt;.ExceptWith </td>
          <td>(</td>
          <td class="paramtype">IEnumerable&lt; T &gt;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IEqualityComparer&lt; T &gt;&#160;</td>
          <td class="paramname"><em>thisComparer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all items from this set that are present in 'other'.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The set whose members should be removed from this set.</td></tr>
    <tr><td class="paramname">thisComparer</td><td>The comparer for this set (not for 'other', which is simply enumerated).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of items that were removed.</dd></dl>

<p>References <a class="el" href="namespaceLoyc_1_1Collections.html#ab3f241a3b553681db7ce9ce14147e4eea1063e38cb53d94d386f21227fcd84717">Loyc.Collections.Remove</a>.</p>

</div>
</div>
<a class="anchor" id="afce719fab16ac0fc14977360e6d05e23"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Loyc.Collections.Impl.InternalSet&lt; T &gt;.IntersectWith </td>
          <td>(</td>
          <td class="paramtype">InternalSet&lt; T &gt;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IEqualityComparer&lt; T &gt;&#160;</td>
          <td class="paramname"><em>otherComparer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all items from this set that are not present in 'other'.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The set whose members should be kept in this set.</td></tr>
    <tr><td class="paramname">otherComparer</td><td>The comparer for 'other' (not for this set, which is simply enumerated).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of items that were removed from the set.</dd></dl>

</div>
</div>
<a class="anchor" id="aa297d94c3edbb0fbe19de9cc7f451df4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Loyc.Collections.Impl.InternalSet&lt; T &gt;.IntersectWith </td>
          <td>(</td>
          <td class="paramtype">IEnumerable&lt; T &gt;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IEqualityComparer&lt; T &gt;&#160;</td>
          <td class="paramname"><em>comparer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all items from this set that are not present in 'other'.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The set whose members should be kept in this set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of items that were removed.</dd></dl>
<p>This method is costly if 'other' is not a set; a temporary set will be constructed to answer the query. Also, this overload has the same subtle assumption as the other overload. </p>

</div>
</div>
<a class="anchor" id="ad09a821c318ffd828d1ff887c940818b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Loyc.Collections.Impl.InternalSet&lt; T &gt;.IsProperSubsetOf </td>
          <td>(</td>
          <td class="paramtype">ISet&lt; T &gt;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>myExactCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if all items in this set are present in the other set, and the other set has at least one item that is not in this set.</p>
<p>This implementation assumes that if the two sets use different definitions of equality (different IEqualityComparer{T}s), that neither set contains duplicates from the point of view of the other set. If this rule is broken&ndash;meaning, if either of the sets were constructed with the comparer of the other set, that set would shrink&ndash; then the results of this method are unreliable. If both sets use the same comparer, though, you have nothing to worry about.</p>

</div>
</div>
<a class="anchor" id="af8503208286c00464a596d80b928aa4c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Loyc.Collections.Impl.InternalSet&lt; T &gt;.IsProperSubsetOf </td>
          <td>(</td>
          <td class="paramtype">IEnumerable&lt; T &gt;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IEqualityComparer&lt; T &gt;&#160;</td>
          <td class="paramname"><em>comparer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>myExactCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if all items in this set are present in the other set, and the other set has at least one item that is not in this set.</p>
<p>This method is costly if 'other' is not a set; a temporary set will be constructed to answer the query. Also, this overload has the same subtle assumption as the other overload. </p>

</div>
</div>
<a class="anchor" id="a6beb6ab37a0af015e6432f799942816b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Loyc.Collections.Impl.InternalSet&lt; T &gt;.IsProperSupersetOf </td>
          <td>(</td>
          <td class="paramtype">ISet&lt; T &gt;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IEqualityComparer&lt; T &gt;&#160;</td>
          <td class="paramname"><em>thisComparer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>myExactCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if all items in the other set are present in this set, and this set has at least one item that is not in the other set.</p>
<p>This implementation assumes that if the two sets use different definitions of equality (different IEqualityComparer{T}s), that neither set contains duplicates from the point of view of the other set. If this rule is broken&ndash;meaning, if either of the sets were constructed with the comparer of the other set, that set would shrink&ndash; then the results of this method are unreliable. If both sets use the same comparer, though, you have nothing to worry about.</p>

</div>
</div>
<a class="anchor" id="a6327e90edcf0686ca7672b21f4b89501"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Loyc.Collections.Impl.InternalSet&lt; T &gt;.IsProperSupersetOf </td>
          <td>(</td>
          <td class="paramtype">IEnumerable&lt; T &gt;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IEqualityComparer&lt; T &gt;&#160;</td>
          <td class="paramname"><em>comparer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>myExactCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if all items in the other set are present in this set, and this set has at least one item that is not in the other set.</p>
<p>This method is costly if 'other' is not a set; a temporary set will be constructed to answer the query. Also, this overload has the same subtle assumption as the other overload. </p>

</div>
</div>
<a class="anchor" id="a1e12ea9a899c7dac84aa8febf8aaa1f9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Loyc.Collections.Impl.InternalSet&lt; T &gt;.IsSubsetOf </td>
          <td>(</td>
          <td class="paramtype">ISet&lt; T &gt;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>myMinCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if all items in this set are present in the other set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">myMinCount</td><td>Specifies the minimum number of items that this set contains (use 0 if unknown)</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a56c23568605fbfdef2678007b55dd05c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Loyc.Collections.Impl.InternalSet&lt; T &gt;.IsSupersetOf </td>
          <td>(</td>
          <td class="paramtype">IEnumerable&lt; T &gt;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IEqualityComparer&lt; T &gt;&#160;</td>
          <td class="paramname"><em>thisComparer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>myMaxCount</em> = <code>int.MaxValue</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if all items in the other set are present in this set.</p>

</div>
</div>
<a class="anchor" id="a50bccc5fbf584aded2ccd670d48038d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Loyc.Collections.Impl.InternalSet&lt; T &gt;.Overlaps </td>
          <td>(</td>
          <td class="paramtype">IEnumerable&lt; T &gt;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IEqualityComparer&lt; T &gt;&#160;</td>
          <td class="paramname"><em>thisComparer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this set contains at least one item from 'other'.</p>

</div>
</div>
<a class="anchor" id="a7a70ee762d05a37044c6a2ea083a68a0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Loyc.Collections.Impl.InternalSet&lt; T &gt;.Remove </td>
          <td>(</td>
          <td class="paramtype">ref T&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IEqualityComparer&lt; T &gt;&#160;</td>
          <td class="paramname"><em>comparer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes an item from the set.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the item was removed, false if it was not found.</dd></dl>

</div>
</div>
<a class="anchor" id="a70aedaba6107df8bc786f77af298fc67"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Loyc.Collections.Impl.InternalSet&lt; T &gt;.SetEquals </td>
          <td>(</td>
          <td class="paramtype">ISet&lt; T &gt;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>myExactCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this set and the other set have the same items.</p>
<p>This implementation assumes that if the two sets use different definitions of equality (different IEqualityComparer{T}s), that neither set contains duplicates from the point of view of the other set. If this rule is broken&ndash;meaning, if either of the sets were constructed with the comparer of the other set, that set would shrink&ndash; then the results of this method are unreliable. If both sets use the same comparer, though, you have nothing to worry about.</p>

</div>
</div>
<a class="anchor" id="ad81d5197419bf36f192c0d814b04156e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Loyc.Collections.Impl.InternalSet&lt; T &gt;.SetEquals </td>
          <td>(</td>
          <td class="paramtype">IEnumerable&lt; T &gt;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IEqualityComparer&lt; T &gt;&#160;</td>
          <td class="paramname"><em>comparer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>myExactCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this set and the other set have the same items.</p>
<p>This method is costly if 'other' is not a set; a temporary set will be constructed to answer the query. Also, this overload has the same subtle assumption as the other overload. </p>

</div>
</div>
<a class="anchor" id="aef1799cb5a1f92bdeeb583add3269e08"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Loyc.Collections.Impl.InternalSet&lt; T &gt;.SymmetricExceptWith </td>
          <td>(</td>
          <td class="paramtype">IEnumerable&lt; T &gt;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IEqualityComparer&lt; T &gt;&#160;</td>
          <td class="paramname"><em>comparer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>xorDuplicates</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modifies the current set to contain only elements that were present either in this set or in the other collection, but not both.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xorDuplicates</td><td>Controls this function's behavior in case 'other' contains duplicates. If xorDuplicates is true, an even number of duplicates has no overall effect and an odd number is treated the same as if there were a single instance of the item. Setting xorDuplicates to false is costly, since a temporary set is constructed in order to eliminate any duplicates. The same comparer is used for the temporary set as for this set.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns the change in set size (positive if items were added, negative if items were removed)</p>

<p>References <a class="el" href="namespaceLoyc_1_1Collections.html#ab3f241a3b553681db7ce9ce14147e4eeaec211f7c20af43e742bf2570c3cb84f9">Loyc.Collections.Add</a>, and <a class="el" href="namespaceLoyc_1_1Collections.html#ab3f241a3b553681db7ce9ce14147e4eea1063e38cb53d94d386f21227fcd84717">Loyc.Collections.Remove</a>.</p>

</div>
</div>
<a class="anchor" id="a5de45aaff18329740d9f532a772f8056"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1void.html">void</a> Loyc.Collections.Impl.InternalSet&lt; T &gt;.Thaw </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Thaws a frozen root node by duplicating it, or creates the root node if the set doesn't have one.</p>
<p>Since InternalSet{T} is a structure rather than a class, it's not immediately obvious what the happens when you copy it with the '=' operator. The InternalList{T} structure, for example, it is unsafe to copy (in general) because as the list length changes, the two (or more) copies immediately go "out of sync" because each copy has a separate Count property and a separate array pointer&ndash;and yet they will share the same array, at least temporarily, which can produce strange results. </p>
<p>It is mostly safe to copy InternalSet instances, however, because they only contain a single piece of data (a reference to the root node), and the root node only changes in two situations: </p><ol>
<li>
When the root node is null and you call <a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalSet_3_01T_01_4.html#a769b8ece9af71dd9b97acce26c6d60ac" title="Tries to add an item to the set, and retrieves the existing item if present.">Add</a> or this method </li>
<li>
When the root node is frozen and you modify the set or call this method </li>
</ol>
<p>In the second case, when you have frozen a set with <a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalSet_3_01T_01_4.html#a432ccca55f47e17bf37202d7206d366e" title="Freezes the hashtrie so that any further changes require paths in the tree to be copied.">CloneFreeze()</a>, all existing copies are frozen, and further changes affect only the specific copy that you change. You can also call <a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalSet_3_01T_01_4.html#a5de45aaff18329740d9f532a772f8056" title="Thaws a frozen root node by duplicating it, or creates the root node if the set doesn&#39;t have one...">Thaw()</a> if you need to make copies that are kept in sync, without actually modifying the set first. </p>
<p>This method has no effect if the root node is already thawed. </p>

</div>
</div>
<a class="anchor" id="a67aff8e7df81b991c98919b9074b8f26"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Loyc.Collections.Impl.InternalSet&lt; T &gt;.UnionWith </td>
          <td>(</td>
          <td class="paramtype">IEnumerable&lt; T &gt;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IEqualityComparer&lt; T &gt;&#160;</td>
          <td class="paramname"><em>thisComparer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>replaceIfPresent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the contents of 'other' to this set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thisComparer</td><td>The comparer for this set (not for 'other', which is simply enumerated).</td></tr>
    <tr><td class="paramname">replaceIfPresent</td><td>If items in 'other' match items in this set, this flag causes those items in 'other' to replace the items in this set.</td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="namespaceLoyc_1_1Collections.html#ab3f241a3b553681db7ce9ce14147e4eeaec211f7c20af43e742bf2570c3cb84f9">Loyc.Collections.Add</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="aac7d404cb5692f28823c7688bbb921eb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">readonly IEqualityComparer&lt;T&gt; Loyc.Collections.Impl.InternalSet&lt; T &gt;.DefaultComparer = typeof(<a class="el" href="interfaceLoyc_1_1IReferenceComparable.html">IReferenceComparable</a>).IsAssignableFrom(typeof(T)) ? null : EqualityComparer&lt;T&gt;.Default</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is EqualityComparer{T}.Default, or null if T implements <a class="el" href="interfaceLoyc_1_1IReferenceComparable.html" title="This is a tag which indicates that objects of this type are unique; specifically, any two different o...">IReferenceComparable</a>.</p>

</div>
</div>
<a class="anchor" id="aa9a8dcb8bdd7d82f867fa3263226cc30"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">readonly InternalSet&lt;T&gt; Loyc.Collections.Impl.InternalSet&lt; T &gt;.Empty = new InternalSet&lt;T&gt; { _root = FrozenEmptyRoot() }</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An empty set.</p>
<p>This property comes with a frozen, empty root node, which Set{T} uses as an "initialized" flag.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Feb 23 2016 09:35:45 for Loyc by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
