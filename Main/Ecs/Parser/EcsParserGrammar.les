//
// Enhanced C# parser: this is designed to accept a superset of C# (Enhanced C#).
// If this spews an error when given a valid C# file, it's a bug. File a bug report.
//
// EC# is more permisive than plain C#; it not only adds new syntax, but it 
// liberalizes the existing syntax rules (e.g. "try Foo(); catch Bar();" is 
// accepted in EC#) and it also accepts a lot of code that is not directly valid in 
// EC# (e.g. "fixed (7) {...}"). Such invalid code is allowed by the parser in 
// case a macro might transform it later into something that makes more sense.
//
// NOTE: LINQ & await are not yet implemented, but "await x" can be accepted if 
// you write "await(x)" instead.
//
#importMacros LeMP.Prelude.Les;
import System;
import System.Collections.Generic;
import System.Linq;
import System.Text;
import System.Diagnostics;
import Loyc;
import Loyc.Syntax;
import Loyc.Syntax.Les;
import Loyc.Syntax.Lexing;
import Loyc.Collections;
import Loyc.Collections.Impl;

namespace Loyc.Ecs.Parser
{
	using TT = TokenType;
	using S = CodeSymbols;
	using EP = EcsPrecedence;

	// 0162=Unreachable code detected; 0642=Possibly mistaken empty statement
	#rawText "\n\t#pragma warning disable 162, 642\n\t"; 

	@[partial] class EcsParser
	{
		// (1) detects method/property/variable (and similar: trait, alias)
		// (2) detects and skips word attributes (not including `this` in `this int x`).
		enum StmtCat { MethodOrPropOrVar = 0; KeywordStmt = 1; IdStmt = 2; ThisConstructor = 3; OtherStmt = 4; };
		fn DetectStatementCategory(out wordAttrCount::int)::StmtCat
		{
			// Scan past identifiers and extra AttrKeywords at the beginning of the statement
			wordAttrCount = 0;
			wordsStartAt::int = InputPosition;
			haveNew::bool = LA0 == TT.@new; // "new" keyword is the most annoying wrinkle
			if (haveNew || LA0 == TT.Id || LA0 == TT.ContextualKeyword) {
				isAttrKw::bool = haveNew;
				do {
					Skip();
					if (isAttrKw) { 
						wordsStartAt = InputPosition;
					} else {
						wordAttrCount++;
					};
					haveNew |= (isAttrKw = (LA0 == TT.@new));
				} while ((isAttrKw |= LA0 == TT.AttrKeyword || LA0 == TT.@new)
					|| LA0 == TT.Id || LA0 == TT.ContextualKeyword);
			};
			
			// At this point we've skipped over all simple identifiers.
			// Now decide: what kind of statement do we appear to have?
			consecutive::int = InputPosition - wordsStartAt;
			if (LA0 != TT.Substitute) { // "$"
				if (LA0 == TT.TypeKeyword) {
					// A built-in data type, which cannot be a word-attribute
					var LA1 = LA(1);
					if (LA1 == TT.Id || LA1 == TT.ContextualKeyword) {
						return StmtCat.MethodOrPropOrVar;
					} else {
						consecutive++;
					}
				} else if (LA0 == TT.(noMacro(this))) {
					if LA(1) == TT.LParen && LA(2) == TT.RParen {
						la3::TT = LA(3);
						if la3 == TT.Colon || la3 == TT.LBrace || la3 == TT.Semicolon && _spaceName != S.Fn {
							return StmtCat.ThisConstructor;
						} else {
							return StmtCat.OtherStmt;
						};
					} else if (consecutive != 0) {
						// Should be a this[] property (there could be a type 
						// param like this<T>[] so looking at LA(1) won't help)
						InputPosition--;
						return StmtCat.MethodOrPropOrVar;
					}
				} else if (LT0.Kind == TokenKind.OtherKeyword) {
					if (LA0 != TT.@if) {
						if (LA0 == TT.@namespace || LA0 == TT.@class || LA0 == TT.@struct 
						    || LA0 == TT.@interface || LA0 == TT.@enum  || LA0 == TT.@using
						    || LA0 == TT.@event     || LA0 == TT.@case  || LA0 == TT.@switch 
						    || LA0 == TT.@while     || LA0 == TT.@fixed || LA0 == TT.@for   
						    || LA0 == TT.@foreach   || LA0 == TT.@goto  || LA0 == TT.@lock 
						    || LA0 == TT.@delegate && LA(1) != TT.LParen
						    || LA0 == TT.@do  || LA0 == TT.(noMacro(@return)) || LA0 ==  TT.(noMacro(break)) 
						    || LA0 == TT.@try || LA0 == TT.(noMacro(@continue)) || LA0 ==  TT.(noMacro(throw))
						    || (LA0 == TT.@checked || LA0 == TT.@unchecked) && LA(1) == TT.LBrace)
						{
							return StmtCat.KeywordStmt;
						};
					};
				} else if (consecutive == 0) {
					return StmtCat.OtherStmt;
				};

				if (consecutive >= 2) {
					InputPosition = wordsStartAt;
					return StmtCat.MethodOrPropOrVar;
				} else if ((LA0 == TT.LParen || LA0 == TT.Set) && !haveNew) {
					InputPosition = wordsStartAt;
					return consecutive != 0 ? StmtCat.IdStmt : StmtCat.OtherStmt;
				};
			};

			// Worst case: need arbitrary lookahead to detect var/property/method
			InputPosition = wordsStartAt;
			using (new SavePosition(this, 0)) {
				if (Scan_DataType(false) && Scan_ComplexNameDecl() && 
					(LA0 == TT.Set || LA0 == TT.Semicolon || LA0 == TT.LBrace || 
					 LA0 == TT.LParen || LA0 == TT.LBrack || LA0 == TT.Comma)) {
					return StmtCat.MethodOrPropOrVar;
				};
			};
			if (haveNew) {
				if (LA(-1) == TT.@new) {
					InputPosition--;
				} else {
					// count 'new' as a word attribute, to trigger an error if it shouldn't be there
					wordAttrCount++;
				}
			};
			return consecutive != 0 ? StmtCat.IdStmt : StmtCat.OtherStmt;
		};

		@[LL(2), Verbosity(1), AddCsLineDirectives(false)]
		LLLPG parser(laType(TokenType), terminalType(Token), matchType(int), 
		             allowSwitch(@true), setType(HashSet!int), castLA(@false));

		alias("(" = TT.LParen);
		alias(")" = TT.RParen);
		alias("[" = TT.LBrack);
		alias("]" = TT.RBrack);
		alias("{" = TT.LBrace);
		alias("}" = TT.RBrace);
		alias("." = TT.Dot);
		alias("->" = TT.PtrArrow);
		alias("::" = TT.ColonColon);
		alias("?." = TT.NullDot);
		alias("=" = TT.Set);
		alias("??=" = TT.CompoundSet);
		alias(":" = TT.Colon);
		alias("@" = TT.At);
		alias("``" = TT.BQString);
		alias("\\" = TT.Backslash);
		alias("*" = TT.Mul);
		alias("/,%" = TT.DivMod);
		alias("**" = TT.Power);
		alias("+" = TT.Add);
		alias("-" = TT.Sub);
		alias("++,--" = TT.IncDec);
		alias("&&" = TT.And);
		alias("||,^^" = TT.OrXor);
		alias("!" = TT.Not);
		alias("&" = TT.AndBits);
		alias("^" = TT.XorBits);
		alias("|" = TT.OrBits);
		alias("~" = TT.NotBits);
		alias("==,!=" = TT.EqNeq);
		alias("<" = TT.LT);
		alias(">" = TT.GT);
		alias("<=,>=" = TT.LEGE);
		alias(".." = TT.DotDot);
		alias("?" = TT.QuestionMark);
		alias("??" = TT.NullCoalesce);
		alias("=:" = TT.QuickBind);
		alias(":=" = TT.QuickBindSet);
		alias("==>" = TT.Forward);
		alias("$" = TT.Substitute);
		alias("=>" = TT.LambdaArrow);
		alias("," = TT.Comma);
		alias(";" = TT.Semicolon);
		
		@[#static, #readonly] _trait::Symbol = GSymbol.Get("trait");
		@[#static, #readonly] _alias::Symbol = GSymbol.Get("alias");
		@[#static, #readonly] _where::Symbol = GSymbol.Get("where");
		@[#static, #readonly] _when::Symbol  = GSymbol.Get("when");
		@[#static, #readonly] _assembly::Symbol = GSymbol.Get("assembly");
		@[#static, #readonly] _module  ::Symbol = GSymbol.Get("module");
		@[#static, #readonly] _from::Symbol  = GSymbol.Get("from");
		@[#static, #readonly] _await::Symbol = GSymbol.Get("await");

		// Used to resolve the constructor ambiguity, in which "Foo()" could be a
		// constructor declaration or a method call. _spaceName is the name of the
		// current space, or #fn (S.Fn) when inside a method or constructor.
		_spaceName::Symbol;
		
		// Inside a LINQ expression, certain ContextualKeywords are to be treated
		// as actual keywords. This flag enables that behavior.
		_insideLinqExpr::bool;

		// A potential contextual keyword that can be treated as an identifier
		@[private] rule UnusualId()::Token @{
			&!{_insideLinqExpr && LinqKeywords.Contains(LT($LI).Value)} t:=TT.ContextualKeyword
			{return t;}
		};
		@[#internal, #static, #readonly] LinqKeywords::HashSet!object = EcsLexer.LinqKeywords;
		
		// ---------------------------------------------------------------------
		// -- Type names and complex identifiers -------------------------------
		// ---------------------------------------------------------------------

		// The complex identifier in EC# is a subset of the language of expressions,
		// and data types are a superset of the language of complex identifiers.
		// Complex identifiers can appear in the following contexts:
		// - Space names: namespace Foo.Bar<$T> {...}
		//   (and yes, I want to support template parameters on namespaces someday)
		// - Method/property names: bool global::System.IEquatable<T>.Equals(T other)
		// Data types can appear in the following contexts:
		// - Fields and properties: int* x { get; set; }
		// - Methods declarations: int[] f(Foo<T>[,][] x);
		// - Certain pseudo-functions: typeof(Foo<T[]>)
		// Note that complex identifiers can contain substitution expressions,
		// which, in turn, can contain expressions of any complexity, e.g. 
		// Foo<$(x*y(++z))>. Of course, complex identifiers also appear within 
		// normal expressions, but the expression grammar doesn't use the
		// main "ComplexId" rule, instead it's handled somewhat separately.

		// LLLPG is unaware of this overload, but when I write DataType(),
		// it unwittingly invokes it.
		def DataType(afterAsOrIs::bool = false)::LNode {
			brack::opt!Token;
			var type = DataType(afterAsOrIs, out brack);
			if (brack != null) {
				Error("A type name cannot include [array dimensions]. The square brackets should be empty.");
			};
			return type;
		};

		@[recognizer(def Scan_DataType(afterAsOrIs::bool = false))]
		rule DataType(afterAsOrIs::bool, out majorDimension::opt!Token)::LNode @{
			result:ComplexId()
			TypeSuffixOpt(afterAsOrIs, out majorDimension, ref result)
		};
		// Complex identifier, e.g. Foo.Bar or Foo<x, y>
		@[FullLLk] // http://loyc-etc.blogspot.ca/2013/12/bogus-ambiguity-warnings-in-lllpg.html
		token ComplexId::LNode @{ // Part of DataType
			e:=IdAtom 
			// There can be only a single "externAlias::" prefix in a complex Id.
			(	"::" e2:=IdAtom 
				{e = F.Call(S.ColonColon, e, e2, e.Range.StartIndex, e2.Range.EndIndex);}
			)?
			TParams(ref e)?
			(	"." rhs:=IdAtom {e=F.Dot(e, rhs)}
				TParams(ref e)?
			)*
			{return e;}
		};
		
		// identifier, $identifier, $(expr), or primitive type (int, string)
		rule IdAtom::LNode @{
			{r::LNode;}
			(	t:="$" e:=Atom {e=AutoRemoveParens(e);}
				{r = F.Call(S.Substitute, e, t.StartIndex, e.Range.EndIndex);}
			|	op:=TT.@operator t:=AnyOperator
				{r = F.Attr(_triviaUseOperatorKeyword, F.Id(t.Value -> Symbol, op.StartIndex, t.EndIndex));}
			|	t:=(TT.Id|TT.TypeKeyword)
				{r = F.Id(t);}
			|	t:=UnusualId
				{r = F.Id(t);}
			) {return r;}
		};

		@[#static] def AutoRemoveParens(node::LNode)::LNode
		{
			i::int = node.Attrs.IndexWithName(S.TriviaInParens);
			if (i > -1) {
				return node.WithAttrs(node.Attrs.RemoveAt(i));
			};
			return node;
		};

		@[recognizer(def Scan_TParams())]
		rule TParams(ref r::LNode)
		@{
			{list::WList!LNode = (new WList!LNode() { r });}
			{end::Token;}
			( "<" (list+=DataType ("," list+=DataType)*)? end=">"
			| "." t:="[" end="]" {list = AppendExprsInside(t, list);}
			| "!" t:="(" end=")" {list = AppendExprsInside(t, list);}
			)
			{
				start::int = r.Range.StartIndex;
				r = F.Call(S.Of, list.ToVList(), start, end.EndIndex);
			}
		};

		count::int; // hack allows Scan_TypeSuffixOpt() to compile

		@[recognizer(def Scan_TypeSuffixOpt(afterAsOrIs::bool))]
		token TypeSuffixOpt(afterAsOrIs::bool, out dimensionBrack::opt!Token, ref e::LNode)::bool
		@{
			{count::int; result::bool = false;}
			{dimensionBrack = null;}
			greedy
			(	// in "x as Foo ? ..." it could be challenging to figure out whether 
				// "?" is part of type Foo or not. Some tests with the standard C# 
				// compiler seem to suggest that checking the next token will suffice,
				// because standard C# rejects potentially valid code such as 
				// "x as Foo? - y", saying "Syntax error, ':' expected" at the end.
				// This seems not to be a precedence issue; although "/" has higher
				// precedence than "as", the C# compiler can parse "x as Foo? / y"
				// (meaning (x as Foo?) / y) or "x as Foo + y" but fails to parse 
				// "x as Foo? + y". I believe this is because "+" can be a prefix 
				// operator. It also fails to parse "x as Foo?*" with a syntax error, 
				// not a semantic error, and for "x as Foo? * x" it again says 
				// "':' expected".
				// 
				// Examples (usually there is more than one syntax error, but the message
				// "':' expected" indicates how the parser sees the situation):
				//       x as Foo ? y        // Syntax error, ':' expected
				//       x as Foo? / y       // Parsed OK
				//       x as Foo? % y       // Parsed OK
				//       x as Foo? < y       // Parsed OK
				//       x as Foo? ?? y      // Parsed OK
				//       x as Foo ?? y       // Parsed OK (?? is null coalesce operator)
				//       x as Foo? + y       // Syntax error, ':' expected
				//       x as Foo? - y       // Syntax error, ':' expected
				//       x as Foo? * -y      // Syntax error, ':' expected
				//       x as Foo? ! y       // Syntax error, ':' expected
				//       (x as Foo?++)       // Invalid expression term ')'
				//       x as Foo?.Value     // Parsed OK
				//       x as Foo?[y]        // Parsed OK
				//       x as Foo ? (y) : z  // Parsed OK
				//       x as Foo?(y)        // Syntax error, ':' expected
				t:="?" (&!{@[Local]afterAsOrIs} | &!(TT.Id | TT.TypeKeyword | TT.Literal | "(" | "{" 
				                               | TT.@new | "+" | "-" | "*" | "&" | "!" | "~" | "==>" | "++,--" 
				                               | "$" | "@" | UnusualId))
				       {e = F.Of(F.Id(t), e, e.Range.StartIndex, t.EndIndex); result=true;}
			|	// Standard C# fails to parse "x as Foo * y", which suggests I can 
				// unconditionally accept "*" as a pointer marker.
				t:="*" {e = F.Of(F.Id(t), e, e.Range.StartIndex, t.EndIndex); result=true;}
			|	// int[][,] means "array of (two-dimensional array of int)", so we
				// must process array adornments in reverse order.
				{var dims = InternalList!(Pair!(int,int)).Empty;}
				{rb::Token;}
				(       &{@[Local] (count=CountDims(LT($LI), true)) > 0} lb:="[" rb="]" {dims.Add(Pair.Create(count, rb.EndIndex));})
				(greedy(&{@[Local] (count=CountDims(LT($LI), false)) > 0}    "[" rb="]" {dims.Add(Pair.Create(count, rb.EndIndex));}))*
				{
					if CountDims(lb, false) <= 0 {
						dimensionBrack = lb;
					};
					for (i::int = dims.Count - 1; i >= 0; i--) {
						e = F.Of(F.Id(S.GetArrayKeyword(dims[i].A)), e, e.Range.StartIndex, dims[i].B);
					};
					result = true;
				}
			)*
			{return result;}
		};

		fn ComplexNameDecl()::LNode { _::bool; return ComplexNameDecl(false, out _); };
		
		// This is the same as ComplexId except that it is used in declaration locations.
		// The difference is that the type parameters can have [normal attributes] and 
		// in/out variance attrbutes. 'this' can only be used as a name of properties.
		@[FullLLk, recognizer(def Scan_ComplexNameDecl(thisAllowed::bool = false))]
		token ComplexNameDecl(thisAllowed::bool, out hasThis::bool)::LNode @{
			(	e:ComplexThisDecl(thisAllowed) {hasThis = true;}
			|	e:IdAtom                      {hasThis = false;}
				// There can be only a single "externAlias::" prefix in a complex Id.
				(	"::" e2:=IdAtom 
					{e=F.Call(S.ColonColon, e, e2, e.Range.StartIndex, e2.Range.EndIndex);}
				)?
				TParamsDecl(ref e)?
				[	"." rhs:=IdAtom
					{e=F.Dot(e, rhs)}
					TParamsDecl(ref e)?
				]*
				[	"." ComplexThisDecl(thisAllowed) {hasThis = true;}
					{e=F.Dot(e, $ComplexThisDecl);}
				]?
			) {return e;}
		};
		// `this` with optional <type arguments>
		token ComplexThisDecl(allowed::bool)::LNode @{
			{if (!allowed) {Error("'this' is not allowed in this location.");};}
			t:=TT.(noMacro(this))    {$result = F.Id(t);}
			TParamsDecl(ref result)?
		};

		@[recognizer(def Scan_TParamsDecl())]
		rule TParamsDecl(ref r::LNode)
		@{
			{list::WList!LNode = (new WList!LNode() { r });}
			{end::Token; complex::bool;}
			( "<" (list+=TParamDecl ("," list+=TParamDecl)*)? end=">"
			| "." t:="[" end="]" {list = AppendExprsInside(t, list);}
			| "!" t:="(" end=")" {list = AppendExprsInside(t, list);}
			)
			{
				start::int = r.Range.StartIndex;
				r = F.Call(S.Of, list.ToVList(), start, end.EndIndex);
			}
		};

		rule TParamDecl()::LNode @{
			{attrs::WList!LNode = null; startIndex::int = GetTextPosition(InputPosition);}
			(	result:ComplexId
			/	NormalAttributes(ref attrs)
				TParamAttributeKeywords(ref attrs)
				result:IdAtom
			)
			{if (attrs != null) { $result = $result.WithAttrs(attrs.ToVList()); };}
		};
			
		// ---------------------------------------------------------------------
		// -- Expressions ------------------------------------------------------
		// ---------------------------------------------------------------------

		// Parsing EC# expressions is very tricky. Here are some of the things 
		// that make it difficult, especially in an LL(k) parser:
		//    
		// 1. Parenthesis: is it a cast or a normal expression?
		//    (A<B,C>)y      is a cast
		//    (A<B,C>)-y     is NOT a cast
		//    (A<B,C>)(-y)   is a cast
		//    (A<B,C>)(as B) is NOT a cast (well, the second part is)
		//    x(A<B,C>)(-y)  is NOT a cast
		//    -(A<B,C>)(-y)  is a cast
		//    $(A<B,C>)(-y)  is NOT a cast
		//    (A<B,C>){y}    is a cast
		//    (A<B,C>)[y]    is NOT a cast
		//    (A<B,C>)++(y)  is NOT a cast (it's post-increment and call)
		//    (A<B> C)(-y)   is NOT a cast
		//    ([] A<B,C>)(y) is NOT a cast (empty attr list defeats cast)
		//    (A+B==C)y      is nonsensical
		//    x(A<B,C>)y     is nonsensical
		// 2. In-expr var declarations: is "(A<B,C>D)" a variable declaration?
		//    (A<B,C>D) => D.Foo() // variable declaration
		//    (A<B,C>D) = Foo()    // variable declaration
		//    (f1, f2) = (A<B,C>D) // tuple
		//    Foo(A<B,C>D)         // method with two arguments
		//    void Foo(A<B,C>D)    // variable declaration at statement level
		//    Foo(A<B,C>D)         // variable declaration at statement level if 'Foo' is the space name
		//                         // (i.e. when 'Foo' is a constructor)
		// 3. Less-than: is it a generics list or an operator? Need unlimited lookahead.
		//    (A<B,C)    // less-than operator
		//    (A<B,C>)   // generics list
		//    (A<B,C>D)  // context-dependent
		// 4. Brackets. Is "Foo[]" a data type, or an indexer with no args?
		//    (Foo[]) x; // data type: #of(#[], Foo)
		//    (Foo[]).x; // indexer:   #[](Foo)
		// 5. Does "?" make a nullable type or a conditional operator?
		//    Foo<B> ? x = null;     // nullable type
		//    Foo<B> ? x = null : y; // conditional operator
		
		/// Context: middle of expression, top level (#var and #namedArg not supported)
		@[#public, #static, #readonly] ContinueExpr::Precedence = (new Precedence(-100));

		// Types of expressions:
		// - identifier
		// - (parenthesized expr)
		// - (tuple,)
		// - ++prefix_operators
		// - suffix_operators++
		// - infix + operators, including x => y
		// - the ? conditional : operator
		// - generic<arguments>, generic!arguments, generic.[arguments]
		// - (old_style) casts
		// - call_style(->casts)
		// - method_calls(with, arguments)
		// - typeof(and other pseudofunctions)
		// - indexers[with, indexes]
		// - new Object()
		// - { code in braces; new scope }
		// - #{ code in braces; old scope }
		// - delegate(...) {...}
		// - from x in expr... (LINQ)
		
		// Atom is: Id, TypeKeyword, $Atom, .Atom, new ..., (ExprStart), {Stmts},
		@[k(3)]
		rule Atom::LNode @{
			{r::LNode;}
			(	t:=("$"|".") e:=Atom {e=AutoRemoveParens(e);}
				{r = F.Call(t.Value -> Symbol, e, t.StartIndex, e.Range.EndIndex);}
			|	op:=TT.@operator t:=AnyOperator
				{r = F.Attr(_triviaUseOperatorKeyword, F.Id(t.Value -> Symbol, op.StartIndex, t.EndIndex));}
			|	t:=(TT.Id | TT.TypeKeyword | TT.(noMacro(this)) | TT.(noMacro(base)))
				{r = F.Id(t);}
			|	t:=UnusualId
				{r = F.Id(t);}
			|	t:=TT.Literal
				{r = F.Literal(t.Value, t.StartIndex, t.EndIndex);}
			|	r=ExprInParensAuto  // (...)
			|	r=BracedBlock       // {...}
			|	r=NewExpr           // new ...
			|	r=TokenLiteral
			|	t:=(TT.@checked | TT.@unchecked)
				args:="(" rp:=")"
				{r = F.Call(t.Value -> Symbol, ExprListInside(args), t.StartIndex, rp.EndIndex);}
			|	t:=(TT.@typeof | TT.(noMacro(@default)) | TT.@sizeof)
				args:="(" rp:=")"
				{r = F.Call(t.Value -> Symbol, TypeInside(args), t.StartIndex, rp.EndIndex);}
			|	t:=TT.@delegate args:="(" ")" block:="{" rb:="}"
				{r = F.Call(S.Lambda, F.List(ExprListInside(args, false, true).ToVList()), F.Braces(StmtListInside(block).ToVList(), block.StartIndex, rb.EndIndex), t.StartIndex, rb.EndIndex);}
			|	t:=TT.@is dt:=DataType
				{r = F.Call(S.Is, dt, t.StartIndex, dt.Range.EndIndex);}
			|	error {r = Error("Invalid expression. Expected (parentheses), {braces}, identifier, literal, or $substitution.");} (greedy(~(","|";")))* 
				/*hack, avoid long analysis time*/ (_ =>{})
			) {return r;}
		};

		token AnyOperator::Token @{ // operators allowed after the "operator" keyword
			op:=
			(	"."  | "->"    | "::"    | "?."  | "="  | "??=" | ":"  | "@"     
			|	"``" | "\\"    | "*"     | "/,%" | "**" | "+"   | "-"  | "++,--" 
			|	"&&" | "||,^^" | "!"     | "&"   | "^"  | "|"   | "~"  | "==,!=" 
			|	"<"  | ">"     | "<=,>=" | ".."  | "?"  | "??"  | "=:" | ":="
			|	"$"  | "=>"    | "==>" )
			{return op;}
		};

		token NewExpr::LNode @{
			{
				majorDimension::opt!Token = null;
				endIndex::int; 
				var list = (new WList!LNode());
			}
			op:=TT.@new
			(	// new [] { ... }  <=>  #new(@`[]`(), ...)
				&{(count=CountDims(LT($LI), false)) > 0}
				lb:="[" rb:="]" 
				{var type = F.Id(S.GetArrayKeyword(count), lb.StartIndex, rb.EndIndex);}
				lb="{" rb="}"
				{
					list.Add(LNode.Call(type, type.Range));
					AppendInitializersInside(lb, list);
					endIndex = rb.EndIndex;
				}
			|	// new { ... }  <=>  #new(@``, ...)
				lb:="{" rb:="}"
				{
					list.Add(F.Missing);
					AppendInitializersInside(lb, list);
					endIndex = rb.EndIndex;
				}
			|	// new Type(...)             <=> #new(Type(...))
				// new Type(...) { ... }     <=> #new(Type(...), ...)
				// new Type { ... }          <=> #new(Type(), ...)
				// new Type[10] { ... }      <=> #new(#of(@`[]`, Type)(10), ...)
				// new Type[10][]            <=> #new(#of(@`[]`, #of(@`#[]`, Type))(10))
				type:=DataType(false, out majorDimension)
				(	// new Type(...)         <=> #new(Type(...))
					// new Type(...) { ... } <=> #new(Type(...), ...)
					lp:="(" rp:=")"
					{
						if (majorDimension != null) {
							Error("Syntax error: unexpected constructor argument list (...)");
						};
						list.Add(F.Call(type, ExprListInside(lp).ToVList(), type.Range.StartIndex, rp.EndIndex));
						endIndex = rp.EndIndex;
					}
					(	lb:="{" rb:="}"
						{
							AppendInitializersInside(lb, list);
							endIndex = rb.EndIndex;
						}
					)?
				/	// new Type { ... }      <=> #new(Type(), ...)
					// new Type[10] { ... }  <=> #new(#of(@`[]`, Type)(10), ...)
					// new Type[10][]        <=> #new(#of(@`[]`, #of(@`[]`, Type))(10))
					{var(lb::Token = op, rb::Token = op); haveBraces::bool = false;}
					( lb="{" rb="}" {haveBraces = true;} )?
					{
						if (majorDimension != null) {
							list.Add(LNode.Call(type, ExprListInside(majorDimension.Value).ToVList(), type.Range))
						} else {
							list.Add(LNode.Call(type, type.Range));
						};
						if (haveBraces) {
							AppendInitializersInside(lb, list);
							endIndex = rb.EndIndex;
						} else {
							endIndex = type.Range.EndIndex;
						};
						if (!haveBraces && majorDimension == null) {
							if IsArrayType(type) {
								Error("Syntax error: missing array size expression")
							} else {
								Error("Syntax error: expected constructor argument list (...) or initializers {...}");
							};
						};
					}
				)
			)
			{return F.Call(S.New, list.ToVList(), op.StartIndex, endIndex);}
		};

		def TypeInside(args::Token)::LNode
		{
			if (!Down(args)) (return F.Id(S.Missing, args.EndIndex, args.EndIndex));
			var type = DataType();
			Match(EOF -> int);
			return Up(type);
		};

		@[private] rule ExprInParensAuto::LNode @{
			// This gate is used to avoid a slug that quadruples analysis time elsewhere in the grammar
			"(" ")" =>
			(	&(ExprInParens(true) ("="|"=>"))
				r:=ExprInParens(true)  {return r;}
			/	r:=ExprInParens(false) {return r;}
			)
		};

		@[private] rule TokenLiteral()::LNode @{
			at:"@" ( L:"[" R:"]" | L:"{" R:"}" )
			{return F.Literal($L.Children, $at.StartIndex, $R.EndIndex);}
		};

		@[private] rule PrimaryExpr()::LNode @{
			e:=Atom
			FinishPrimaryExpr(ref e)
			(
				"?." rhs:=PrimaryExpr {e = F.Call(S.NullDot, e, rhs, e.Range.StartIndex, rhs.Range.EndIndex);}
			)?
			{return e;}
		};

		@[private] rule FinishPrimaryExpr(ref e::LNode) @{
			greedy
			(	op:=("."|"->"|"::"|"=:")
				rhs:=Atom       {e = F.Call(op.Value -> Symbol, e, rhs, e.Range.StartIndex, rhs.Range.EndIndex);}
			/	// x(-> Foo), x(as Foo), x(using Foo)
				e=PrimaryExpr_NewStyleCast(e)
			/	lp:="(" rp:=")" {e = F.Call(e, ExprListInside(lp), e.Range.StartIndex, rp.EndIndex);}
			|	lb:="[" rb:="]" {var list = (new WList!LNode() { e });}
				{e = F.Call(S.IndexBracks, AppendExprsInside(lb, list).ToVList(), e.Range.StartIndex, rb.EndIndex);}
			|	// Tentative tree structure - there is an undesirable inconsistency between ?. and ?[].
				// Specifically, `a.b?.c.d` parses as `(a.b)?.(c.d)` so that the 
				// null-dot macro can manipulate the `.d` on the end; it would be 
				// harder to generate the outut of `a.b != null ? a.b.c.d : null` if 
				// it came in as `((a.b)?.c).d`. Likewise if there were a macro for
				// `?[]`, it would morph `a.b?[c].d` into `a.b != null ? a.b[c].d : null`
				// so it seems like we want a ternary operator, such that `a.b?[c].d`
				// is parsed as @`?[]`(a.b, #(c), d) so we can deal with the `.d`.
				// However, this doesn't really work, because it wouldn't naturally
				// accept an input like `a.b?[c](d)`. So... argh. For now I'll parse
				//   1. `a.b?[c].d`  as ``@`?[]`(a.b, #(c)).d`` 
				//   2. `a.b?[c](d)` as ``@`?[]`(a.b, #(c))(d)``
				// This is the easiest way to parse it, anyhow. And I'll leave `?.` 
				// as-is, even though it works differently than `?[]`.
				t:="?" lb:="[" rb:="]"
				{e = F.Call(S.NullIndexBracks, e, F.List(ExprListInside(lb).ToVList()), e.Range.StartIndex, rb.EndIndex);}
			|	// Post-inc or post-dec
				t:="++,--"      {e = F.Call(t.Value == S.PreInc ? S.PostInc : S.PostDec, e, e.Range.StartIndex, t.EndIndex);}
			|	// <Type parameters>
				&(TParams (~(TT.Id|TT.ContextualKeyword)|EOF)) ("<"|"!"|"." "[") => TParams(ref e)
			|	bb:=BracedBlock 
				{	if (!e.IsCall || e.BaseStyle == NodeStyle.Operator) {
						e = F.Call(e, bb, e.Range.StartIndex, bb.Range.EndIndex)
					} else {
						e = e.WithArgs(e.Args.Add(bb)).WithRange(e.Range.StartIndex, bb.Range.EndIndex);
					};
				}
			)*
		};

		@[private] rule PrimaryExpr_NewStyleCast(e::LNode)::LNode @{
			&{@[Hoist] Down($LI) && Up(LA0 == TT.@as || LA0 == TT.@using || LA0 == TT.PtrArrow)}
			lp:="(" rp:=")"
			(=>
				{Down(lp);}
				{kind::Symbol;}
				{attrs::WList!LNode = null;}
				( "->"      {kind = S.Cast;} 
				| TT.@as    {kind = S.As;}
				| TT.@using {kind = S.UsingCast;})
				NormalAttributes(ref attrs)
				AttributeKeywords(ref attrs)
				type:=DataType EOF
				{
					if attrs != null {
						type = type.PlusAttrs(attrs.ToVList());
					};
					return Up(SetAlternateStyle(SetOperatorStyle(
						F.Call(kind, e, type, e.Range.StartIndex, rp.EndIndex))));
				}
			)
		};

		@[k(3), private] // to distinguish (cast) expr from (parens)
		rule PrefixExpr::LNode @{
			(	op:=("+"|"-"|"!"|"~"|"++,--"|"*"|"&"|".."|"==>") e:=PrefixExpr
				{return SetOperatorStyle(F.Call(op.Value -> Symbol, e, op.StartIndex, e.Range.EndIndex));}
			|	// C-style cast
				&{@[Hoist] Down($LI) && Up(Scan_DataType() && LA0 == EOF)}
				lp:="(" ")"
				(&!("+"|"-"|"."|TT.BQString|("++,--" "(")))
				e:=PrefixExpr
				{Down(lp); return SetOperatorStyle(F.Call(S.Cast, e, Up(DataType()), lp.StartIndex, e.Range.EndIndex));}
			/	op:="**"
				e:=PrefixExpr
				{return SetOperatorStyle(F.Call(S._Dereference, 
						SetOperatorStyle(F.Call(S._Dereference, e, 
						op.StartIndex+1, e.Range.EndIndex)), 
						op.StartIndex, e.Range.EndIndex));}
			// LLLPG takes too long to analyze this. :( Don't have time to fix LLLPG right now.
			// /	&{@[Hoist] Is($LI, _await)} op:=TT.ContextualKeyword e:=PrefixExpr // C# 5 await
			// 	{return SetOperatorStyle(F.Call(_await, e, op.StartIndex, e.Range.EndIndex));}
			/	e:=PrimaryExpr
				{return e;}
			)
		};

		def SetOperatorStyle(node::LNode)::LNode
		{
			return node.SetBaseStyle(NodeStyle.Operator);
		};
		def SetAlternateStyle(node::LNode)::LNode
		{
			node.Style |= NodeStyle.Alternate;
			return node;
		};

		// This rule handles all lower precedence levels, from ** down to assignment
		// (=). This rule uses the "precedence floor" concept, documented in 
		// Loyc.Syntax.Precedence, to handle different precedence levels. The 
		// traditional approach is to define a separate rule for every precedence
		// level. By collapsing many precedence levels into a single rule, there are
		// two benefits: 
		// (1) shorter code.
		// (2) potentially better performance: using a separate rule per precedence
		//     level causes a new stack frame and prediction step to be created for 
		//     each level, regardless of the operators present in the actual 
		//     expression being parsed. For example, to parse the simple expression 
		//     "Hello" the traditional way requires 20 rules and therefore 20 stack 
		//     frames if there are 20 precedence levels. On the other hand, the 
		//     "precedence floor" approach requires an extra precedence check, so 
		//     it may be slower when there are few levels. Note: EC# has 22 
		//     precedence levels, and this method handles the lower 18 of them.
		//
		// The higher levels of the EC# expression parser do not use this trick
		// because the higher precedence levels have some complications, such as 
		// C-style casts and <type arguments>, that I prefer to deal with 
		// separately.
		@[private] rule Expr(context::Precedence)::LNode @{
			{Debug.Assert(context.CanParse(EP.Prefix));}
			{prec::Precedence;}
			e:=PrefixExpr
			greedy
			(	// Infix operator
				&{@[Local] context.CanParse(prec=InfixPrecedenceOf($LA))}
				op:=( "**"|"*"|"/,%"|"+"|"-"|"~"|".."|"<"|">"|"<=,>="|"==,!="
				    | "&"|"|"|"^"|"&&"|"||,^^"|"??"|"="|"??="|"=>"|TT.BQString|TT.@in )
				rhs:=Expr(prec)
				{e = SetOperatorStyle(F.Call(op.Value -> Symbol, e, rhs, e.Range.StartIndex, rhs.Range.EndIndex));}
			|	// is, as, or using cast (special case: #usingCast instead of #using)
				&{@[Local] context.CanParse(prec=InfixPrecedenceOf($LA))}
				op:=(TT.@is | TT.@as | TT.@using)
				rhs:=DataType(true)
				{var opSym = op.Type() == TT.@using ? S.UsingCast : (op.Value -> Symbol);}
				{e = SetOperatorStyle(F.Call(opSym, e, rhs, e.Range.StartIndex, rhs.Range.EndIndex));}
				FinishPrimaryExpr(ref e)
			|	// Shift operators (two LT or GT in a row)
				&{@[Local] context.CanParse(EP.Shift)}
				&{LT($LI).EndIndex == LT($LI+1).StartIndex}
				(	"<" "<" rhs:=Expr(EP.Shift)
					{e = SetOperatorStyle(F.Call(S.Shl, e, rhs, e.Range.StartIndex, rhs.Range.EndIndex));}
				|	">" ">" rhs:=Expr(EP.Shift)
					{e = SetOperatorStyle(F.Call(S.Shr, e, rhs, e.Range.StartIndex, rhs.Range.EndIndex));}
				)
			|	// Conditional operator
				&{@[Local] context.CanParse(EP.IfElse)}
				"?" then:=Expr(ContinueExpr) ":" else:=Expr(EP.IfElse)
				{e = SetOperatorStyle(F.Call(S.QuestionMark, e, then, @else, e.Range.StartIndex, else.Range.EndIndex));}
			)*
			{return e;}
		};
		
		// An expression that can start with attributes [...], attribute keywords 
		// (out, ref, public, etc.), a named argument (a: expr) and/or a variable 
		// declaration (Foo? x = null). Note that we can't treat ":" as a normal 
		// binary operator due to the nullable-type ambiguity. If ":" were treated 
		// as an operator, would (Foo ? x = z : y) be a conditional expression
		// or a variable declaration that uses the ":" operator on the right side?
		// So instead, ":" is only allowed for specifying named arguments. 
		@[FullLLk, public] rule ExprStart(allowUnassignedVarDecl::bool)::LNode @{
			// Detect "keyword argument" expression
			{argName::Token = default(Token);}
			(argName=TT.Id|argName=UnusualId) ":"
			result:ExprStart2(allowUnassignedVarDecl)
			{result = SetOperatorStyle(F.Call(S.NamedArg, F.Id(argName), result, argName.StartIndex, result.Range.EndIndex));}
		|	result:ExprStart2(allowUnassignedVarDecl)
		};
		@[public] rule ExprStart2(allowUnassignedVarDecl::bool)::LNode @{
			{
				e::LNode;
				attrs::WList!LNode = null;
			}
			NormalAttributes(ref attrs)
			AttributeKeywords(ref attrs)
			wc:=WordAttributes(ref attrs)
			(	&DetectVarDecl(allowUnassignedVarDecl)
				IdAtom => e=VarDeclExpr
			/	{if (wc != 0) { NonKeywordAttrError(attrs, "expression"); };}
				e=Expr(ContinueExpr)
			)
			{
				if (attrs != null) {
					e = e.PlusAttrs(attrs.ToVList());
				};
				return e;
			}
		};
		
		fn NonKeywordAttrError(attrs::IList!LNode, stmtType::string)
		{
			var attr = attrs.FirstOrDefault(a => a.AttrNamed(S.TriviaWordAttribute) != null);
			if (attr != null) {
				Error(attr, "'{0}' appears to be a word attribute, which is not permitted before '{1}'", attr.Range.SourceText, stmtType);
			};
		};

		// Only the recognizer is used. TODO: add LLLPG feature to suppress standard rule part
		@[private] rule DetectVarDecl(allowUnassigned::bool) @{
			VarDeclStart (("="|":=") NoUnmatchedColon | &{@[Local] allowUnassigned} (","|EOF) | "{")
		};
		@[private] rule NoUnmatchedColon @{
			// There's currently no way to run actions inside a recognizer, which 
			// makes it difficult to share information between rules. Therefore I will
			// just assume that VarDeclStart may have contained a nullable type (Foo?)
			// and that means we have to guard against the conditional operator ambiguity,
			// for example:
			//
			//     Foo ? a = b ? c : null    , ...  // is a variable declaration
			//     Foo ? a = b ? c : null : 0, ...  // is a conditional expression
			//
			// Strategy: scan to make sure that there is no unmatched colon.
			//
			// FIXME: this fails to handle the case of "(Foo ? v = x as Foo? : b)"
			// since "? :" are matched so this will be treated as a variable decl,
			// which causes a syntax error. This also fails to handle case statements
			// like "case Foo? x = null:" (ugh).
			(	SubConditional
			|	~("?"|":"|","|";")
			)*
			(","|";"|EOF)
		};
		@[private] rule SubConditional @{ "?" nongreedy(SubConditional / ~(","|";"))* ":" };

		@[private] rule VarDeclExpr::LNode @{
			pair:=VarDeclStart
			{var(type::LNode = pair.Item1, name::LNode = pair.Item2);}
			(	// A property is allowed whereever an initialized variable is 
				// allowed, to make possible `Constructor(public int Prop {get;}) {}`
				result:RestOfPropertyDefinition(type, name, true)
			/	name=VarInitializerOpt(name, IsArrayType(type))
				{$result = F.Call(S.Var, type, name, 
					type.Range.StartIndex, name.Range.EndIndex);}
			)
		};

		@[private] rule VarDeclStart::Pair!(LNode, LNode) @{
			e:=DataType
			id:=IdAtom
			{MaybeRecognizeVarAsKeyword(ref e);}
			{return Pair.Create(e, id);}
		};

		@[#static, #readonly] _var::Symbol = GSymbol.Get("var");
		@[#static, #readonly] _dynamic::Symbol = GSymbol.Get("dynamic");
		
		@[private] fn MaybeRecognizeVarAsKeyword(ref type::LNode)
		{
			// Recognize "var" and "dynamic" (but not @var and @dynamic) as contextual keywords.
			rng::SourceRange;
			name::Symbol = type.Name;
			if (name == _var || name == _dynamic) && type.IsId
				&& (rng=type.Range).Source.Text.TryGet(rng.StartIndex, '\0') != '@' {
				type = type.WithName(name == _var ? S.Missing : S.Dynamic);
			}; 
		};

		@[private] rule ExprInParens(allowUnassignedVarDecl::bool)::LNode
		@{
			lp:="(" rp:=")"
			{
				// Note: we invoke ExprInParensOrTuple inside an action, hiding the
				// invocation from LLLPG, to avoid creating a recognizer for Expr.
				if (!Down(lp)) { return F.Call(S.Tuple, lp.StartIndex, rp.EndIndex); };
				return Up(InParens_ExprOrTuple(allowUnassignedVarDecl, lp.StartIndex, rp.EndIndex));
			}
		};
		// Called inside parens by ExprInParens
		rule InParens_ExprOrTuple(allowUnassignedVarDecl::bool, startIndex::int, endIndex::int)::LNode @{
			(	e:=ExprStart(allowUnassignedVarDecl)
				(	"," _* =>
					{var list = (new VList!LNode() { e });}
					(	"," list+=ExprStart(allowUnassignedVarDecl)
					|	","
					)*
					{return F.Tuple(list, startIndex, endIndex);}
				)?
				{return F.InParens(e, startIndex, endIndex);}
			|	// Empty tuple
				{return F.Tuple(VList!LNode.Empty, startIndex, endIndex);} )
			EOF
		};
		@[private] rule BracedBlock(spaceName::Symbol = @null, target::Symbol = @null, startIndex::int = -1)::LNode
		@{
			{	var oldSpace = _spaceName;
				_spaceName = spaceName ?? oldSpace;
			}
			"{" "}"
			{	if (startIndex == -1) { startIndex = $"{".StartIndex; };
				var stmts = StmtListInside($"{").ToVList();
				_spaceName = oldSpace;
				return F.Call(target ?? S.Braces, stmts, $"{".StartIndex, $"}".EndIndex).SetBaseStyle(NodeStyle.Statement);
			}
		};

		// ---------------------------------------------------------------------
		// -- Attributes -------------------------------------------------------
		// ---------------------------------------------------------------------
		
		@[recognizer(fn Scan_NormalAttributes())]
		token NormalAttributes(ref attrs::WList!LNode) @{
			(	&!{Down($LI) && Up(Try_Scan_AsmOrModLabel(0))}
				t:="[" "]" 
				{
					if (Down(t)) {
						AttributeContents(ref attrs);
						Up();
					};
				}
			)*
		};
		token AttributeContents(ref attrs::WList!LNode) @{
			{attrTarget::Token = default(Token);}
			greedy(
				attrTarget=(TT.Id|TT.ContextualKeyword|TT.(noMacro(return))) ":"
			)?
			// Use gate (=>) to avoid hoisting predicate DetectVarDecl(allowUnassignedVarDecl)
			(_ => ExprList(attrs = attrs ?? `new` WList!LNode(), allowTrailingComma: true, allowUnassignedVarDecl: true))
			{
				if attrTarget.Value != null {
					var attrTargetNode = F.Id(attrTarget);
					for (i::int = 0; i < attrs.Count; i++) {
						var attr = attrs[i];
						if (!IsNamedArg(attr)) {
							attrs[i] = SetOperatorStyle(F.Call(S.NamedArg, attrTargetNode, 
								attr, attrTarget.StartIndex, attr.Range.EndIndex))
						} else {
							attrTargetNode = attrs[i].Args[1];
							Error(attrTargetNode, "Syntax error: only one attribute target is allowed");
						};
					};
				};
			}
		};

		fn IsNamedArg(node::LNode)::bool { return node.Calls(S.NamedArg, 2) && node.BaseStyle == NodeStyle.Operator; };

		token AttributeKeywords(ref attrs::WList!LNode) @{
			(	t:=TT.AttrKeyword 
				{(attrs = attrs ?? `new` WList!LNode()).Add(F.Id(t));}
			)*
		};
		@[recognizer(fn Scan_TParamAttributeKeywords())]
		token TParamAttributeKeywords(ref attrs::WList!LNode) @{
			(	t:=(TT.AttrKeyword|TT.@in)
				{(attrs = attrs ?? `new` WList!LNode()).Add(F.Id(t));}
			)*
		};
			
		// "word attributes" are a messy feature of EC#. C# has a few non-
		// keyword attributes that appear at the beginning of a statement, such
		// as "partial", "yield" and "async". EC# generalizes this concept to 
		// "word attributes", which can be any normal identifier.
		//
		// BTW: "word attributes" are not really "contextual keywords" in the C# 
		// sense, because the identifiers are not recognized by the parser. The
		// only true contextual keywords in EC# are "var", "dynamic", "module" 
		// and "assembly" ("var" and "dynamic" are not contextual keywords in C# 
		// in the same way; in EC#, "var" is identified as a keyword by the 
		// parser, but in C# it is identified during semantic analysis.)
		//
		// Since they're not keywords, word attributes are difficult because:
		// 1. Lots of statements start with words that are not word attributes, 
		//    such as "foo=0", "foo* x = null", "foo x { ... }", and "foo x();"
		//    Somehow we have to figure out which words are attributes.
		// 2. Not all statements accept word attributes. But the attributes 
		//    appear before the statement, so how can we tell if we should
		//    be expecting word attributes or not?
		//
		// Using an LL(k) parser generator is quite limiting in this situation;
		// normal lookahead is strictly limited and we can't backtrack except 
		// via "and" predicates or custom code. On the other hand, I still think 
		// LL(k) is the best way to parse, precisely because it minimizes 
		// backtracking.
		// 
		// There are lots of "keyword-based" statements that accept word
		// attributes (think "partial class" and "yield return"), which are easy
		// to handle. Our main difficulty is the non-keyword statements:
		// 1. statements that can begin with an identifier, but also accept
		//    word attributes:
		//    - word type* name ... // field, property or method
		//    - word type? name ... // field, property or method
		//    - word type[,][] name ... // field, property or method
		//    - word type<x> name ... // field, property or method
		//    - word type name(); // method decl
		//    - word type name<x>(); // method decl
		//    - word type<x> name(); // method decl
		//    - word type<x> name<x>(); // method decl
		//    - word this();         // except inside methods
		//    - word this<x>();      // except inside methods
		//    - word label:
		// 2. statements that can start with an identifier, and do not accept 
		//    word attributes:
		//    - foo();     // method call OR constructor
		//    - foo<x>();
		//    - foo = 0;
		//    - foo - bar;
		// Notice that if a word is followed by an operator of any kind, it 
		// can't be an attribute; but if it is followed by another word, it's
		// unclear. In particular, notice that for "A B<x>...", "A" is sometimes
		// an attribute and sometimes not. In "A B<x> C", A is an attribute,
		// but in "A B<x>()" it is a return type. The same difficulty exists
		// in case of alternate generics specifiers such as "A B!(x)" and types
		// with suffixes, like "A int?*".
		// 
		// My strategy here is to use lookahead with &(...) to decide if a word 
		// (or the "new" keyword) is an attribute or not.
		
		// TODO : This is obsolete, need to eliminate the last usage of it
		token WordAttributes(ref attrs::WList!LNode)::int
		@{
			{	// Optimize the common case (non-exhaustive short circuit)
				LA1::TokenType;
				nonKeywords::int = 0;
				if LA0 == TT.Id && ((LA1 = LA(1)) == TT.Set || LA1 == TT.LParen || LA1 == TT.Dot) 
					(return 0);
				t::Token;
			}
			[	t=TT.AttrKeyword {attrs.Add(F.Id(t));}
			|	(t=(TT.Id|TT.(noMacro(@this))|TT.@new) | t=UnusualId)
				&(	// Detect a word attribute before a var decl, function decl, 
					// property decls, alias decls, or trait decls.
					DataType (TT.Id|TT.TypeKeyword|TT.AttrKeyword|UnusualId)
				|	// t is a word attribute in `t this(...)` but not `t this[...]`
					TT.(noMacro(this)) "("
				|	// If the word is followed by an atribute keyword, it must be a word attribute
					(TT.AttrKeyword | TT.@new)
				|	// Most statements that begin with a keyword allow word attributes
					TT.@checked "{" "}" | TT.@unchecked "{" "}" | TT.(noMacro(@default)) ":" | TT.@using "("
				|	( TT.@namespace | TT.@class | TT.@struct | TT.@interface | TT.@enum 
					| TT.@delegate | TT.@event | TT.@case | TT.(noMacro(break)) | TT.(noMacro(continue)) | TT.@do 
					| TT.@fixed | TT.@for | TT.@foreach | TT.@goto | TT.@lock | TT.(noMacro(return))
					| TT.@switch | TT.(noMacro(throw)) | TT.@try | TT.@while )
				)
				{
					node::LNode;
					if (t.Type() == TT.@new || t.Type() == TT.(noMacro(@this))) {
						node = F.Id(t)
					} else {
						node = F.Attr(_triviaWordAttribute, F.Id("#" + t.Value.ToString(), t.StartIndex, t.EndIndex));
					};
					attrs = attrs ?? `new` WList!LNode();
					attrs.Add(node);
					nonKeywords++; // yes, includes 'new'
				}
			]*
			{return nonKeywords;}
		};
		
		// =====================================================================
		// == LINQ =============================================================
		// =====================================================================
/*
		[pub] rule QueryExpression::LNode @{
			LinqFrom QueryBody {return null;}
		};
		
		@[private] rule LinqFrom::LNode @{
			&{@[Hoist] Is($LI, _from)} t:=TT.ContextualKeyword var:=VarIn e:=ExprStart(false)
			{return null;}
		};
		
		@[private] rule QueryBody::LNode @{
			QueryBodyClause* SelectOrGroupClause QueryContinuation?
			{return null;}
		};

		@[private] rule QueryBodyClause::LNode @{
			( LinqFrom
			| LinqLet
			| LinqWhere
			| LinqJoin
			| LinqJoinInto
			| LinqOrderBy
			) {return null;}
		};

		@[private] rule LinqLet @{ _ };
		@[private] rule LinqWhere @{ _ };
		@[private] rule LinqJoin @{ _ };
		@[private] rule LinqJoinInto @{ _ };

		@[private] rule SelectOrGroupClause @{ _ };
		@[private] rule QueryContinuation @{ _ };
*/
		// =====================================================================
		// == Statements =======================================================
		// =====================================================================
		
		_stmtAttrs::WList!LNode = (new WList!LNode());

		@[k(3), pub] rule Stmt::LNode @{
			{_stmtAttrs.Clear();}
			{startIndex::int = LT0.StartIndex;}
			NormalAttributes(ref _stmtAttrs)
			AttributeKeywords(ref _stmtAttrs)
			(_* =>
			{	// Analysis is tough for LLLPG here, especially the question "is
				// this a var/prop/method or something else?", but also things
				// like "is this a `this` constructor, `this[...]` prop, or just 
				// an expression that starts with `this`?", so I've written custom
				// prediction analysis (DetectStatementCategory), which doubles as 
				// a detector for "word attributes" like "partial".
				var oldPosition = InputPosition;
				wordAttrCount::int;
				var cat = DetectStatementCategory(out wordAttrCount);

				// Add word attributes, if any
				for (; oldPosition < InputPosition; oldPosition++) {
					word::Token = _tokens[oldPosition];
					wordAttr::LNode;
					if (word.Kind == TokenKind.AttrKeyword || word.Type() == TT.@new) {
						wordAttr = F.Id(word);
					} else {
						wordAttr = F.Attr(_triviaWordAttribute, F.Id("#" + word.Value.ToString(), word.StartIndex, word.EndIndex));
					};
					_stmtAttrs.Add(wordAttr);
				};

				var attrs = _stmtAttrs.ToVList();
				switch (cat) {
				case StmtCat.MethodOrPropOrVar;
					$result = MethodOrPropertyOrVarStmt(startIndex, attrs); 
					break;
				case StmtCat.KeywordStmt;
					$result = KeywordStmt(startIndex, attrs);
					break;
				case StmtCat.IdStmt;
					$result = IdStmt(startIndex, attrs, wordAttrCount != 0);
					break;
				case StmtCat.OtherStmt;
					$result = OtherStmt(startIndex, attrs, wordAttrCount != 0);
					break;
				case StmtCat.ThisConstructor;
					$result = Constructor(startIndex, attrs);
					break;
				default;
					throw (new Exception("Parser bug"));
				};
			})
		};

		// Methods, properties, variables, and things that look like them (trait & alias)
		rule MethodOrPropertyOrVarStmt(startIndex::int, attrs::VList!LNode)::LNode @{
			(	result:TraitDecl(startIndex)            {result = result.PlusAttrs(attrs);}
			/	result:AliasDecl(startIndex)            {result = result.PlusAttrs(attrs);}
			/	result:MethodOrPropertyOrVar(startIndex, attrs)
			)
		};
		
		// Statements that begin with a keyword AND permit keyword attributes
		rule KeywordStmt(startIndex::int, attrs::VList!LNode)::LNode @{
			{r::LNode;}
			(	r=EventDecl(startIndex)                 {r = r.PlusAttrs(attrs);}
			|	r=DelegateDecl(startIndex, attrs)
			|	r=SpaceDecl(startIndex)                 {r = r.PlusAttrs(attrs);} // namespace, class, struct, interface
			|	r=EnumDecl(startIndex)                  {r = r.PlusAttrs(attrs);}
			|	r=CheckedOrUncheckedStmt(startIndex)    {r = r.PlusAttrs(attrs);}
			|	r=DoStmt(startIndex)                    {r = r.PlusAttrs(attrs);}
			|	r=CaseStmt(startIndex)                  {r = r.PlusAttrs(attrs);}
			|	r=GotoStmt(startIndex)                  {r = r.PlusAttrs(attrs);}
			|	r=GotoCaseStmt(startIndex)              {r = r.PlusAttrs(attrs);}
			|	r=ReturnBreakContinueThrow(startIndex)  {r = r.PlusAttrs(attrs);}
			|	r=WhileStmt(startIndex)                 {r = r.PlusAttrs(attrs);}
			|	r=ForStmt(startIndex)                   {r = r.PlusAttrs(attrs);}
			|	r=ForEachStmt(startIndex)               {r = r.PlusAttrs(attrs);}
			|	r=SwitchStmt(startIndex)                {r = r.PlusAttrs(attrs);}
			|	r=UsingStmt(startIndex)                 {r = r.PlusAttrs(attrs);}
			/	r=UsingDirective(startIndex, attrs)
			|	r=LockStmt(startIndex)                  {r = r.PlusAttrs(attrs);}
			|	r=FixedStmt(startIndex)                 {r = r.PlusAttrs(attrs);}
			|	r=TryStmt(startIndex)                   {r = r.PlusAttrs(attrs);}
			|	error {r = Error("Bug: Keyword statement expected at '{0}'", LT(0).SourceText(SourceFile.Text));}
				ScanToEndOfStmt
			)
			{return r;}
		};

		// Statements that start with an Id and don't allow keyword attributes
		rule IdStmt(startIndex::int, attrs::VList!LNode, hasWordAttrs::bool)::LNode @{
			{
				addAttrs::bool = false;              // causes attrs to be added to result
				showWordAttrErrorFor::string = null; // causes error when hasWordAttrs
			}
			(	result:Constructor(startIndex, attrs)
				{showWordAttrErrorFor = "old-style constructor";}
			/	result:BlockCallStmt(startIndex)
				{showWordAttrErrorFor = "block-call statement"; addAttrs = true;}
			/	result:LabelStmt(startIndex) 
				{addAttrs = true;}
			/	&(DataType TT.(noMacro(@this))) // property this[]
				DataType => result:MethodOrPropertyOrVar(startIndex, attrs)
			/	result:ExprStatement() 
				{showWordAttrErrorFor = "expression"; addAttrs = true;}
			)
			{
				if addAttrs { 
					result = result.PlusAttrs(attrs);
				};
				if hasWordAttrs && showWordAttrErrorFor != null {
					NonKeywordAttrError(attrs, showWordAttrErrorFor);
				};
			}
		};

		// Statements that don't start with an Id but don't allow keyword attributes.
		@[FullLLk]
		rule OtherStmt(startIndex::int, attrs::VList!LNode, hasWordAttrs::bool)::LNode @{
			{
				addAttrs::bool = false;              // causes attrs to be added to result
				showWordAttrErrorFor::string = null; // causes error when hasWordAttrs
			}
			(	result:IfStmt(startIndex)
				{showWordAttrErrorFor = "if statement"; addAttrs = true;}
			/	result:BracedBlock(null, null, startIndex)
				{showWordAttrErrorFor = "braced-block statement"; addAttrs = true;}
			/	&("~" (TT.Id|TT.ContextualKeyword|TT.(noMacro(@this))) "(" ")" "{" "}")
				result:Destructor(startIndex, attrs)
				{showWordAttrErrorFor = "destructor";}
			/	";" {$result = F.Id(S.Missing, startIndex, $";".EndIndex);}
				{showWordAttrErrorFor = "empty statement"; addAttrs = true;}
			/	result:LabelStmt(startIndex) // includes default:
				{addAttrs = true;}
			/	default result:ExprStatement()
				{showWordAttrErrorFor = "expression"; addAttrs = true;}
			/	result:AssemblyOrModuleAttribute(startIndex, attrs)
				{showWordAttrErrorFor = "assembly or module attribute";}
			/	result:OperatorCastMethod(startIndex, attrs) {attrs.Clear();}
			/	ths:TT.(noMacro(@this))
				&(DataType ComplexNameDecl)
				{attrs.Add(F.Id(ths));}
				result:MethodOrPropertyOrVar(startIndex, attrs)
			/	error 
				{$result = Error("Statement expected at '{0}'", LT(0).SourceText(SourceFile.Text));}
				ScanToEndOfStmt
			)
			{
				if addAttrs { 
					result = result.PlusAttrs(attrs);
				};
				if hasWordAttrs && showWordAttrErrorFor != null {
					NonKeywordAttrError(attrs, showWordAttrErrorFor);
				};
			}
		};

		rule ExprStatement::LNode @{
			result:Expr(ContinueExpr)
			(	(EOF | TT.@else | TT.@while | TT.@catch | TT.@finally) => 
				{result = F.Call(S.Result, result, result.Range.StartIndex, result.Range.EndIndex);}
			|	";"
			|	error {result = Error("Syntax error in expression at '{0}'; possibly missing semicolon", LT(0).SourceText(SourceFile.Text));}
				ScanToEndOfStmt
			)
		};
		
		@[private] token ScanToEndOfStmt() @{
			// Used for error recovery
			(greedy(~(";"|"{")))*
			greedy(";" | "{" "}"?)?
		};

		// ---------------------------------------------------------------------
		// namespace, class, struct, interface, trait, alias, using, enum ------
		// ---------------------------------------------------------------------

		@[private] rule SpaceDecl(startIndex::int)::LNode @{
			t:=(TT.@namespace | TT.@class | TT.@struct | TT.@interface)
			{var kind = t.Value -> Symbol;}
			r:=RestOfSpaceDecl(startIndex, kind)
			{return r;}
		};

		rule TraitDecl(startIndex::int)::LNode @{
			&{@[Hoist] Is($LI, _trait)} t:=TT.ContextualKeyword
			r:=RestOfSpaceDecl(startIndex, S.Trait)
			{return r;}
		};

		@[private] rule RestOfSpaceDecl(startIndex::int, kind::Symbol)::LNode @{
			name:=ComplexNameDecl
			bases:=BaseListOpt
			WhereClausesOpt(ref name)
			(	end:=";"
				{return F.Call(kind, name, bases,       startIndex, end.EndIndex);}
			|	body:=BracedBlock(CoreName(name).Name)
				{return F.Call(kind, name, bases, body, startIndex, body.Range.EndIndex);}
			)
		};

		rule AliasDecl(startIndex::int)::LNode
		@{
			&{@[Hoist] Is($LI, _alias)} t:=TT.ContextualKeyword
			newName:=ComplexNameDecl 
			("="|":=") oldName:=ComplexNameDecl
			result:RestOfAlias(oldName, startIndex, newName)
		};

		rule UsingDirective(startIndex::int, attrs::VList!LNode)::LNode @{
			t:TT.@using
			(	// C# 6 "using static"
				&{Is($LI, S.Static)} static_:TT.AttrKeyword
				nsName:ExprStart(true) end:";"
				{attrs.Add(F.Id(static_));}
			/	nsName:ExprStart(true)
				(	// If the name is like something like `X = Y.Z`, it's really an alias
					&{@[Local] nsName.Calls(S.Assign, 2)}
					{aliasedType::LNode = nsName.Args[1, F.Missing];}
					{nsName = nsName.Args[0, F.Missing];}
					r:=RestOfAlias(aliasedType, startIndex, nsName)
					{return r.WithAttrs(attrs).PlusAttr(_filePrivate);}
				/	end:";"
				/	error {Error("Expected ';'");}
				)
			)
			{return F.Call(S.Import, nsName, t.StartIndex, end.EndIndex).WithAttrs(attrs);}
		};

		rule RestOfAlias(oldName::LNode, startIndex::int, newName::LNode)::LNode @{
			bases:=BaseListOpt
			WhereClausesOpt(ref newName)
			{var name = F.Call(S.Assign, newName, oldName, newName.Range.StartIndex, oldName.Range.EndIndex);}
			(	end:=";"
				{return F.Call(S.Alias, name, bases,       startIndex, end.EndIndex);}
			|	body:=BracedBlock(CoreName(newName).Name)
				{return F.Call(S.Alias, name, bases, body, startIndex, body.Range.EndIndex);}
			)
		};

		@[private] rule EnumDecl(startIndex::int)::LNode @{
			t:=TT.@enum
			name:=ComplexNameDecl
			bases:=BaseListOpt
			(	end:=";"
				{return F.Call(S.Enum, name, bases,       startIndex, end.EndIndex);}
			|	lb:="{" rb:="}"
				{
					var list = ExprListInside(lb, true);
					var body = F.Braces(list, lb.StartIndex, rb.EndIndex);
					return F.Call(S.Enum, name, bases, body, startIndex, body.Range.EndIndex);
				}
			)
		};

		@[private] rule BaseListOpt::LNode @{
			(	{var bases = (new VList!LNode());}
				":" bases+=DataType
				("," bases+=DataType)*
				{return F.List(bases);}
			|	{return F.List();}
			)
		};

		// For A.B<T>, returns B
		fn CoreName(complexId::LNode)::LNode
		{
			if complexId.IsId
				(return complexId);
			if complexId.CallsMin(S.Of, 1)
				(return CoreName(complexId.Args[0]));
			if complexId.CallsMin(S.Dot, 1)
				(return complexId.Args.Last);
			if complexId.CallsMin(S.Substitute, 1)
				// this is not a complex identifier, but it can appear where one is expected
				(return complexId);
			Debug.Fail("Not a complex identifier");
			return complexId.Target;
		};

		@[private] rule WhereClausesOpt(ref name::LNode)
		@{
			{var list = (new BMultiMap!(Symbol, LNode));}
			[list+=WhereClause]*
			{	if (list.Count != 0) {
					if (!name.CallsMin(S.Of, 2)) {
						Error("'{0}' is not generic and cannot use 'where' clauses.", name.ToString())
					} else {
						var tparams = name.Args.ToWList();
						for (i::int = 1; i < tparams.Count; i++) {
							var wheres = list[TParamSymbol(tparams[i])];
							tparams[i] = tparams[i].PlusAttrs(wheres);
							wheres.Clear();
						};
						name = name.WithArgs(tparams.ToVList());
						if (list.Count > 0) {
							Error(list[0].Value, "There is no type parameter named '{0}'", list[0].Key);
						};
					};
				};
			}
		};
		fn TParamSymbol(T::LNode)::Symbol
		{
			if T.IsId
				(return T.Name)
			else (if T.Calls(S.Substitute, 1) && T.Args[0].IsId
				(return T.Args[0].Name)
			else
				(return S.Missing));
		};

		@[private] rule WhereClause::KeyValuePair!(Symbol, LNode) @{
			&{@[Hoist] Is($LI,_where)} where:=TT.ContextualKeyword T:=(TT.Id|TT.ContextualKeyword) ":" 
			{var constraints = VList!LNode.Empty;}
			constraints+=WhereConstraint
			("," constraints+=WhereConstraint)*
			{return (new KeyValuePair!(Symbol, LNode)(T.Value -> Symbol, 
				F.Call(S.Where, constraints, where.StartIndex, constraints.Last.Range.EndIndex)));}
		};
		@[private] rule WhereConstraint::LNode @{
			(	t:=(TT.@class | TT.@struct) {return F.Id(t);}
			|	n:=TT.@new &{LT($LI).Count == 0} lp:="(" rp:=")"  
				{return F.Call(S.New, n.StartIndex, rp.EndIndex);}
			|	t:=DataType                 {return t;} )
		};

		fn Is(li::int, value::Symbol)::bool
		{
			return LT(li).Value == value;
		};

		// ---------------------------------------------------------------------
		// -- assembly or module attribute -------------------------------------
		// ---------------------------------------------------------------------

		@[recognizer(fn Scan_AsmOrModLabel()), private] // recognizer used by AssemblyOrModuleAttribute
		rule AsmOrModLabel::Token @{
			&{@[Hoist] LT($LI).Value==_assembly || LT($LI).Value==_module} t:=TT.ContextualKeyword ":"
			{return t;}
		};

		@[private] rule AssemblyOrModuleAttribute(startIndex::int, attrs::VList!LNode)::LNode
		@{
			&{@[Hoist] Down($LI) && Up(Try_Scan_AsmOrModLabel(0))} lb:="[" rb:="]"
			(_* => {Down(lb);} 
				kind:=AsmOrModLabel 
				{var list = (new WList!LNode());}
				ExprList(list) 
				{
					Up();
					var r = F.Call(kind.Value == _module ? S.Module : S.Assembly, list.ToVList(), startIndex, rb.EndIndex);
					return r.WithAttrs(attrs);
				}
			)
		};

		// ---------------------------------------------------------------------
		// methods, properties, variable/field declarations, operators ---------
		// ---------------------------------------------------------------------

		@[private] rule MethodOrPropertyOrVar(startIndex::int, attrs::VList!LNode)::LNode @{
			{hasThis::bool;}
			type:=DataType
			name:ComplexNameDecl(true, out hasThis)
			(	// Variable declaration statement
				&{!hasThis}
				{MaybeRecognizeVarAsKeyword(ref type);}
				{var parts = LNode.List(type);}
				{var isArray = IsArrayType(type);}
				parts+=VarInitializerOpt(name, isArray)
				["," name:ComplexNameDecl
						parts+=VarInitializerOpt(name, isArray)]*
				end:=";"
				{$result = F.Call(S.Var, parts, type.Range.StartIndex, end.EndIndex);}
			/	// Method declaration/definition
				&{!hasThis}
				result:MethodArgListAndBody(startIndex, attrs, S.Fn, type, name)
				{return $result;} // don't add attributes again
			|	// Property definition
				result:RestOfPropertyDefinition(type, name, false)
			|	error {Error("Syntax error in what appears to be a method, property, or variable declaration");}
				ScanToEndOfStmt
				{$result = F.Call(S.Var, type, name, type.Range.StartIndex, name.Range.EndIndex);}
			)
			{$result = $result.PlusAttrs(attrs);}
		};

		@[private] rule VarInitializerOpt(name::LNode, isArray::bool)::LNode @{
			[	expr:VarInitializer(isArray)
				{return F.Call(S.Assign, name, expr, name.Range.StartIndex, expr.Range.EndIndex);}]?
			{return name;}
		};
		@[private] rule VarInitializer(isArray::bool)::LNode @{
			("="|":=")
			// The initializer for an array in C# can be a braced list of expressions.
			// EC# also allows braced blocks as expressions, so I'll distinguish the
			// cases by checking for semicolons. If there's a ";", it's an EC# block.
			(	&{@[Local] isArray}
				&{@[Local] Down($LI) && Up(HasNoSemicolons())} 
				lb:="{" rb:="}"
				{
					var initializers = InitializerListInside(lb).ToVList();
					$result = F.Call(S.ArrayInit, initializers, lb.StartIndex, rb.EndIndex)
					           .SetBaseStyle(NodeStyle.OldStyle);
				}
			/	result:ExprStart(false)
			)
		};

		@[private] rule RestOfPropertyDefinition(type::LNode, name::LNode, isExpression::bool)::LNode @{
			WhereClausesOpt(ref name)
			{args::LNode = F.Missing;}
			[lb:"[" rb:"]" {args = ArgList(lb, rb);}]?
			{initializer::LNode;}
			body:=MethodBodyOrForward(true, out initializer, isExpression)
			{$result = (initializer != null
				? F.Property(type, name, args, body, initializer, type.Range.StartIndex, initializer.Range.EndIndex)
				: F.Property(type, name, args, body, null,        type.Range.StartIndex, body.Range.EndIndex)
				);}
		};

		@[private] rule OperatorCastMethod(startIndex::int, attrs::VList!LNode)::LNode @{
			{r::LNode;}
			op:=TT.@operator type:=DataType
			{var name = F.Attr(_triviaUseOperatorKeyword, F.Id(S.Cast, op.StartIndex, op.EndIndex));}
			r=MethodArgListAndBody(startIndex, attrs, S.Fn, type, name)
			{return r;}
		};

		@[private] rule MethodArgListAndBody(startIndex::int, attrs::VList!LNode, kind::Symbol, type::LNode, name::LNode)::LNode @{
			lp:="(" rp:=")"
			WhereClausesOpt(ref name)
			{var(r::LNode, baseCall::LNode = null); }
			(	":" target:=(TT.(noMacro(this)) | TT.(noMacro(base))) baselp:="(" baserp:=")"
				{
					baseCall = F.Call(target.Value -> Symbol, ExprListInside(baselp), target.StartIndex, baserp.EndIndex);
					if (kind != S.Constructor) {
						Error(baseCall, "This is not a constructor declaration, so there should be no ':' clause.");
					};
				}
			)?
			{	// Check for [return:] attributes and transfer them to the return type
				for (i::int = 0; i < attrs.Count; i++) {
					var attr = attrs[i];
					if IsNamedArg(attr) && attr.Args[0].IsIdNamed(S.Return) {
						type = type.PlusAttr(attr.Args[1]);
						attrs.RemoveAt(i);
						i--;
					};
				};
			}
			(	default end:=";"
				{
					if kind == S.Constructor && baseCall != null {
						Error(baseCall, "A method body is required.");
						// Behave as though the method body were present.
						var parts = (new VList!LNode() { type; name; ArgList(lp, rp); LNode.Call(S.Braces, new VList!LNode(baseCall), baseCall.Range) });
						return F.Call(kind, parts, startIndex, baseCall.Range.EndIndex);
					};
					r = F.Call(kind, type, name, ArgList(lp, rp), startIndex, end.EndIndex);
				}
			|	body:=MethodBodyOrForward
				{
					if kind == S.Delegate { Error("A 'delegate' is not expected to have a method body."); };
					if baseCall != null {
						body = body.WithArgs(body.Args.Insert(0, baseCall)).WithRange(baseCall.Range.StartIndex, body.Range.EndIndex);
					};
					var parts = (new VList!LNode() { type; name; ArgList(lp, rp); body });
					r = F.Call(kind, parts, startIndex, body.Range.EndIndex);
				}
			)
			{return r.PlusAttrs(attrs);}
		};

		@[private] fn MethodBodyOrForward()::LNode { _::LNode; return MethodBodyOrForward(@false, out _); };
		@[private] rule MethodBodyOrForward(isProperty::bool, out propInitializer::LNode, isExpression::bool = false)::LNode @{
			{propInitializer = null;}
			(	op:="==>" e:=ExprStart(true)  StmtSemicolon(isExpression) {return F.Call(S.Forward, e, op.StartIndex, e.Range.EndIndex);}
			|	op:="=>"  e:=ExprStart(false) StmtSemicolon(isExpression) {return e;} // C# 6 lambda-style function
			|	e:=TokenLiteral               StmtSemicolon(isExpression) {return e;}
			|	body:=BracedBlock(S.Fn)
				// TODO: figure out why the hell LLLPG thinks there's an ambiguity here
				greedy[	// C# 6 property initializer
					&{@[Local] isProperty} "=" propInitializer=ExprStart(false) 
					StmtSemicolon(isExpression)
				]?
				{ return body; }
			)
		};
		@[private] rule StmtSemicolon(isExpression::bool) @{
			(";"|","|EOF) =>             // remember that ')','}',']' counts as EOF
			(	&{@[Local] isExpression} // no semicolon needed on expression form
			/	";")
		};

		def IsArrayType(type::LNode)::bool 
		{
			// Detect an array type, which has the form #of(#[,], Type)
			return type.Calls(S.Of, 2) && S.IsArrayKeyword(type.Args[0].Name);
		};

		def ArgList(lp::Token, rp::Token)::LNode
		{
			var list = (new WList!LNode());
			if (Down(lp.Children)) {
				ArgList(list);
				Up();
			};
			return F.List(list.ToVList(), lp.StartIndex, rp.EndIndex);
		};

		@[recognizer(def HasNoSemicolons()::bool), private] 
		rule NoSemicolons @{ ~";"* EOF };

		// ---------------------------------------------------------------------
		// Constructor/destructor ----------------------------------------------
		// ---------------------------------------------------------------------

		@[private] rule Constructor(startIndex::int, attrs::VList!LNode)::LNode @{
			{r::LNode; n::Token;}
			(	&{_spaceName == LT($LI).Value}
				n=(TT.Id|TT.ContextualKeyword)
				&("(" ")" ("{" | ";"))
			/	&{_spaceName != S.Fn || LA($LI+3) == TT.LBrace}
				n=TT.(noMacro(@this))
				&("(" ")" ("{" | ";"))
			/	n=(TT.Id|TT.ContextualKeyword|TT.(noMacro(@this)))
				&("(" ")" ":")
			)
			{name::LNode = F.Id(n.Value -> Symbol, n.StartIndex, n.EndIndex);}
			r=MethodArgListAndBody(startIndex, attrs, S.Constructor, F.Missing, name)
			{return r;}
		};

		@[private] rule Destructor(startIndex::int, attrs::VList!LNode)::LNode @{
			tilde:="~"
			n:=(TT.Id|TT.ContextualKeyword|TT.(noMacro(@this)))
			{	var name = n.Value -> Symbol;
				if name != _spaceName {
					Error("Unexpected destructor '{0}'", name);
				};
				name2::LNode = F.Call(S.NotBits, F.Id(name, n.StartIndex, n.EndIndex), tilde.StartIndex, n.EndIndex);
			}
			result:MethodArgListAndBody(startIndex, attrs, S.Fn, F.Missing, name2)
		};

		// ---------------------------------------------------------------------
		// Delegate & event declarations ---------------------------------------
		// ---------------------------------------------------------------------

		@[private] rule DelegateDecl(startIndex::int, attrs::VList!LNode)::LNode @{
			TT.@delegate type:=DataType name:=ComplexNameDecl
			r:=MethodArgListAndBody(startIndex, attrs, S.Delegate, type, name)
			{return r.WithAttrs(attrs);}
		};

		@[private] rule EventDecl(startIndex::int)::LNode @{
			{r::LNode;}
			TT.@event type:=DataType name:=ComplexNameDecl
			(	default 
				{var parts = (new VList!LNode(type, name));}
				( "," parts+=ComplexNameDecl )*
				end:=";"         
				{r = F.Call(S.Event, parts, startIndex, end.EndIndex);}
			|	body:=BracedBlock(S.Fn)
				{r = F.Call(S.Event, type, name, body, startIndex, body.Range.EndIndex);}
			)
			{return r;}
		};

		// ---------------------------------------------------------------------
		// Statements for executable contexts ----------------------------------
		// ---------------------------------------------------------------------
		
		// Labels, default:, case expr: ----------------------------------------

		rule LabelStmt(startIndex::int)::LNode @{
			id:=(TT.Id|TT.ContextualKeyword|TT.(noMacro(@default))) end:=":"
			{return F.Call(S.Label, F.Id(id), startIndex, end.EndIndex);} 
		};

		rule CaseStmt(startIndex::int)::LNode @{
			{var cases = VList!LNode.Empty;}
			kw:=TT.@case cases+=ExprStart2(true) 
			        ("," cases+=ExprStart2(true))* end:=":"
			{return F.Call(S.Case, cases, startIndex, end.EndIndex);}
		};

		// Block-call statement (e.g. get {...}, unroll(...) {...}) ----------------

		// Block-call statements help support properties (get/set), events (add/
		// remove) and macros. No semicolon is required at the end, and the 
		// statement cannot continue afterward (at statement level, foo {y} = z; 
		// is a syntax error since '}' marks the end of the statement.)
		// The expressions in "foo(exprs) {...}" are parsed subtly differently than
		// for "foo(exprs);" : unassigned variable declarations are allowed only in
		// the former. This enables macro syntax like "on_throw(Exception e) {...}";
		// in contrast we MUST NOT parse "Foo(Bar<T> x);" as a variable declaration.
		@[private] rule BlockCallStmt(startIndex::int)::LNode @{
			id:=(TT.Id|TT.ContextualKeyword)
			&( "(" ")" ("{" "}" | TT.Id) | "{" "}" | "==>" ) // Used by Stmt to disambiguate
			{var args = (new WList!LNode());}
			{block::LNode;}
			(	lp:="(" rp:=")" {AppendExprsInside(lp, args, false, true);}
				(	block=BracedBlock 
				|	TT.Id => block=Stmt
					{	// Braces are now required
						ErrorSink.Write(Severity.Error, block, 
							ColumnOf(block.Range.StartIndex) <= ColumnOf(id.StartIndex)
							? "Probable missing semicolon before this statement."
							: "Probable missing braces around body of '{0}' statement.", id.Value);
					}
				)
			|	fwd:="==>" e:=ExprStart(true) ";"
				{block = SetOperatorStyle(F.Call(S.Forward, e, fwd.StartIndex, e.Range.EndIndex));}
			|	block=BracedBlock
			)
			{
				args.Add(block);
				var result = F.Call(id.Value -> Symbol, args.ToVList(), id.StartIndex, block.Range.EndIndex);
				if block.Calls(S.Forward, 1) {
					result = F.Attr(_triviaForwardedProperty, result);
				};
				return result.SetBaseStyle(NodeStyle.Special);
			}
		};
		def ColumnOf(index::int)::int
		{
			return _sourceFile.IndexToLine(index).PosInLine;
		};

		// break, continue, return, throw --------------------------------------

		@[private] rule ReturnBreakContinueThrow(startIndex::int)::LNode @{
			kw:=(TT.(noMacro(break)) | TT.(noMacro(continue)) | TT.(noMacro(return)) | TT.(noMacro(throw)))
			e:=ExprOrNull(false) end:=";"
			{
				if e != null (return F.Call(kw.Value -> Symbol, e, startIndex, end.EndIndex))
				else         (return F.Call(kw.Value -> Symbol,    startIndex, end.EndIndex));
			}
		};

		// goto, goto case -----------------------------------------------------

		@[private] rule GotoStmt(startIndex::int)::LNode @{
			TT.@goto e:=ExprOrNull(false) end:=";"
			{
				if e != null (return F.Call(S.Goto, e, startIndex, end.EndIndex))
				else         (return F.Call(S.Goto,    startIndex, end.EndIndex));
			}
		};

		@[private] rule GotoCaseStmt(startIndex::int)::LNode @{
			{e::LNode = null;}
			TT.@goto TT.@case
			(	def:=TT.(noMacro(default))
				{e = F.Id(S.Default, def.StartIndex, def.EndIndex);}
			|	e=ExprOpt(false) )
			end:=";"
			{return F.Call(S.GotoCase, e, startIndex, end.EndIndex);}
		};

		// checked & unchecked -------------------------------------------------

		@[private] rule CheckedOrUncheckedStmt(startIndex::int)::LNode @{
			kw:=(TT.@checked | TT.@unchecked)
			bb:=BracedBlock
			{return F.Call(kw.Value -> Symbol, bb, startIndex, bb.Range.EndIndex);}
		};

		// do-while & while ----------------------------------------------------

		@[private] rule DoStmt(startIndex::int)::LNode @{
			TT.@do block:=Stmt TT.@while p:="(" ")" end:=";"
			{
				var parts = (new WList!LNode { block });
				SingleExprInside(p, "while (...)", parts);
				return F.Call(S.DoWhile, parts.ToVList(), startIndex, end.EndIndex);
			}
		};

		@[private] rule WhileStmt(startIndex::int)::LNode @{
			TT.@while p:="(" ")" block:=Stmt
			{
				var cond = SingleExprInside(p, "while (...)");
				return F.Call(S.While, cond, block, startIndex, block.Range.EndIndex);
			}
		};

		// for & foreach -------------------------------------------------------

		@[private] rule ForStmt(startIndex::int)::LNode @{
			TT.@for p:="(" ")" block:=Stmt
			(_* => {Down(p);})
				init:=ExprOpt(true) ";" cond:=ExprOpt(false) ";" inc:=ExprOpt(false)
			(EOF => {Up();})
			{
				var parts = (new VList!LNode { init; cond; inc; block });
				return F.Call(S.For, parts, startIndex, block.Range.EndIndex);
			}
		};

		@[private] rule ForEachStmt(startIndex::int)::LNode @{
			TT.@foreach p:="(" ")" 
			block:=Stmt
			(_ => {Down(p);})
				var:=VarIn
				list:=ExprStart(false)
			(EOF => {Up();})
			{return F.Call(S.ForEach, var, list, block, startIndex, block.Range.EndIndex);}
		};

		@[private] rule VarIn::LNode @{
			{var::LNode;}
			(	&(Atom TT.@in)
				var=Atom
			/	pair:=VarDeclStart
				{var = F.Call(S.Var, pair.A, pair.B, pair.A.Range.StartIndex, pair.B.Range.EndIndex);}
			)
			TT.@in
			{return var;}
		};

		// if-else -------------------------------------------------------------

		@[private] rule IfStmt(startIndex::int)::LNode @{
			{else::LNode = null;}
			TT.@if p:="(" ")" then:=Stmt 
			greedy(TT.@else else=Stmt)?
			{
				var cond = SingleExprInside(p, "if (...)");
				if else == null (return F.Call(S.If, cond, then,       startIndex, then.Range.EndIndex))
				else            (return F.Call(S.If, cond, then, else, startIndex, then.Range.EndIndex));
			}
		};

		@[private] rule SwitchStmt(startIndex::int)::LNode @{
			TT.@switch p:="(" ")" block:=Stmt
			{
				var expr = SingleExprInside(p, "switch (...)");
				return F.Call(S.Switch, expr, block, startIndex, block.Range.EndIndex);
			}
		};

		// using, lock, fixed --------------------------------------------------

		@[private] rule UsingStmt(startIndex::int)::LNode @{
			TT.@using p:="(" ")" block:=Stmt
			{
				var expr = SingleExprInside(p, "using (...)");
				return F.Call(S.UsingStmt, expr, block, startIndex, block.Range.EndIndex);
			}
		};

		@[private] rule LockStmt(startIndex::int)::LNode @{
			TT.@lock p:="(" ")" block:=Stmt
			{
				var expr = SingleExprInside(p, "lock (...)");
				return F.Call(S.Lock, expr, block, startIndex, block.Range.EndIndex);
			}
		};

		@[private] rule FixedStmt(startIndex::int)::LNode @{
			TT.@fixed p:="(" ")" block:=Stmt
			{
				var expr = SingleExprInside(p, "lock (...)");
				return F.Call(S.Fixed, expr, block, startIndex, block.Range.EndIndex);
			}
		};

		// try -----------------------------------------------------------------

		@[private] rule TryStmt(startIndex::int)::LNode @{
			TT.@try header:=Stmt
			{var parts = (new VList!LNode { header });}
			{varExpr::LNode; whenExpr::LNode;}
			greedy[
				kw:=TT.@catch
				( p:="(" ")" { varExpr = SingleExprInside(p, "catch (...)", null, true); }
				/            { varExpr = MissingHere(); } )
				( &{Is($LI, _when)} TT.ContextualKeyword
				  c:="(" ")" { whenExpr = SingleExprInside(c, "when (...)"); }
				/            { whenExpr = MissingHere(); } )
				handler:Stmt
				{parts.Add(F.Call(S.Catch, varExpr, whenExpr, handler, kw.StartIndex, handler.Range.EndIndex));}
			]*
			greedy[
				kw:=TT.@finally handler:Stmt
				{parts.Add(F.Call(S.Finally, handler, kw.StartIndex, handler.Range.EndIndex));}
			]*
			{
				var result = F.Call(S.Try, parts, startIndex, parts.Last.Range.EndIndex);
				if parts.Count == 1 {
					Error(result, "'try': At least one 'catch' or 'finally' clause is required");
				};
				return result;
			}
		};

		// ---------------------------------------------------------------------
		// ExprList and StmtList -----------------------------------------------
		// ---------------------------------------------------------------------

		rule ExprOrNull(allowUnassignedVarDecl::bool = false)::LNode @{
			e:=ExprStart(allowUnassignedVarDecl) {return e;}
			| {return null;}
		};
		rule ExprOpt(allowUnassignedVarDecl::bool = false)::LNode @{
			e:=ExprStart(allowUnassignedVarDecl) {return e;}
			| { return MissingHere(); }
		};
		def MissingHere()::LNode
		{
			var i = GetTextPosition(InputPosition);
			return F.Id(S.Missing, i, i);
		};
		rule ExprList(list::WList!LNode, allowTrailingComma::bool = false, allowUnassignedVarDecl::bool = false) @{
			nongreedy(
				list+=ExprOpt(allowUnassignedVarDecl)
				( "," &{@[Local] allowTrailingComma} EOF
				/ "," list+=ExprOpt(allowUnassignedVarDecl)
				| error {Error("Syntax error in expression list");} ~","*)*
			)?
			EOF
		};
		rule ArgList(list::WList!LNode) @{
			nongreedy(
				list+=ExprOpt(true)
				( "," list+=ExprOpt(true)
				| error {Error("Syntax error in argument list");} ~","*
				)*
			)?
			EOF
		};
		@[k(3)]
		rule InitializerExpr::LNode @{
			( lb:="{" rb:="}"
			  {
				var exprs = InitializerListInside(lb).ToVList();
				$result = F.Call(S.Braces, exprs, lb.StartIndex, rb.EndIndex).SetBaseStyle(NodeStyle.OldStyle);
			  }
			/ lb:="[" rb:="]" "=" e:=ExprStart(false)
			  { $result = F.Call(S.InitializerAssignment, ExprListInside(lb).ToVList().Add(e), lb.StartIndex, e.Range.EndIndex); }
			/ result:ExprOpt(false)
			)
		};
		// Used for new int[][] { ... } or int[][] x = { ... }
		rule InitializerList(list::WList!LNode) @{
			nongreedy(
				list+=InitializerExpr
				( "," EOF
				/ "," list+=InitializerExpr
				| error {Error("Syntax error in initializer list");} ~","*)*
			)?
			EOF
		};
		rule StmtList(list::WList!LNode) @{
			(_ => list+=Stmt)*
			EOF
		};
	};
};
