<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>Enhanced C#: Loyc.Geometry.IPoint&lt; T &gt; Interface Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Enhanced C#
   </div>
   <div id="projectbrief">Language of your choice: library documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Events</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceLoyc.html">Loyc</a></li><li class="navelem"><a class="el" href="namespaceLoyc_1_1Geometry.html">Geometry</a></li><li class="navelem"><a class="el" href="interfaceLoyc_1_1Geometry_1_1IPoint_3_01T_01_4.html">IPoint< T ></a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="interfaceLoyc_1_1Geometry_1_1IPoint_3_01T_01_4-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Loyc.Geometry.IPoint&lt; T &gt; Interface Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A mutable 2D point with X and Y coordinates. 
 <a href="interfaceLoyc_1_1Geometry_1_1IPoint_3_01T_01_4.html#details">More...</a></p>
<hr/><b>Source file</b>:<ul>
<li><a href='https://github.com/qwertie/ecsharp/tree/master/Core/Loyc.Essentials/Geometry/IPoint.cs'>/Core/Loyc.Essentials/Geometry/IPoint.cs</a></li>
</ul>
<div class="dynheader">
Inheritance diagram for Loyc.Geometry.IPoint&lt; T &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="interfaceLoyc_1_1Geometry_1_1IPoint_3_01T_01_4.png" usemap="#Loyc.Geometry.IPoint&lt; T &gt;_map" alt=""/>
  <map id="Loyc.Geometry.IPoint&lt; T &gt;_map" name="Loyc.Geometry.IPoint&lt; T &gt;_map">
<area href="interfaceLoyc_1_1Geometry_1_1IPointBase_3_01T_01_4.html" title="This interface exists to work around a limitation of C#; use IPoint{T} instead." alt="Loyc.Geometry.IPointBase&lt; T &gt;" shape="rect" coords="0,56,226,80"/>
<area href="interfaceLoyc_1_1Geometry_1_1INewPoint_3_01Point_00_01T_01_4.html" title="This interface exists to work around a limitation of C#; see IPoint{T}." alt="Loyc.Geometry.INewPoint&lt; Point, T &gt;" shape="rect" coords="236,56,462,80"/>
<area href="interfaceLoyc_1_1Geometry_1_1IPointReader_3_01T_01_4.html" title="Interface for reading the coordinates of a 2D point." alt="Loyc.Geometry.IPointReader&lt; T &gt;" shape="rect" coords="0,0,226,24"/>
<area href="structLoyc_1_1Geometry_1_1Point_3_01T_01_4.html" title="A 2D point (X-Y pair) structure." alt="Loyc.Geometry.Point&lt; T &gt;" shape="rect" coords="0,168,226,192"/>
<area href="structLoyc_1_1Geometry_1_1Vector_3_01T_01_4.html" title="Represents a two-dimensional vector, i.e. a magnitude and direction or the difference between two poi..." alt="Loyc.Geometry.Vector&lt; T &gt;" shape="rect" coords="236,168,462,192"/>
</map>
 </div></div>
<a name="details" id="details"></a><h2 class="groupheader">Remarks</h2>
<div class="textblock"><p>A mutable 2D point with X and Y coordinates.</p>
<p>WARNING: When casting a point (or vector) structure to this interface, it is boxed, making a copy. Changes made through a reference to IPoint do not affect the original point! </p>
<p>It is important to distinguish between generic code that operates on points (e.g. Foo&lt;Point,T&gt;(Point x) where Point:IPoint&lt;T&gt;) and code that uses the IPoint interface directly (e.g. Foo(IPoint&lt;int&gt;) or even Foo&lt;T&gt;(IPoint&lt;T&gt; x)). The latter uses slow, late-bound interface calls and the boxing-copy issue mentioned before must be kept in mind. Generic code that uses IPoint as a <em>constraint</em>, not as a <em>parameter type,</em> is faster and does not have the same problem because it does not actually box the point, nor does it use late-bound invocation. </p>
<p>Normally this interface is not used directly, and the only operation provided is New(). It is provided in case you want it, but generally it's better to use Point{T}. </p>
<p>In order for this interface to work more easily in generic code, there is no corresponding IVector type for vectors because generic code must declare every type it needs as a separate type parameter, which makes the code very cumbersome to write already, even without a point/vector distinction. </p>
<p>The New() method is not normally used in generic code because it returns IPoint&lt;T&gt;, not the original point type. It is provided mainly in case somebody wants to use the raw interface to manipulate points. </p>
<p>Due to a limitation of C#, the X and Y coordinates are separated into a separate interface (IPointBase{T}) from the New() method in INewPoint{Point,T}. Without this separation, it's impossible to write fast generic code that can operate on both IPoint itself and on concrete types such as Point{T}. The reason for this is very subtle. To understand it, consider the following generic method that adds two points together: </p>
<div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Point <a class="code" href="namespaceLoyc_1_1Collections.html#ab3f241a3b553681db7ce9ce14147e4eeaec211f7c20af43e742bf2570c3cb84f9">Add</a>&amp;lt;Point,T,M&gt;(<span class="keyword">this</span> M m, Point a, Point b)</div>
<div class="line">    where Point : IPoint&amp;lt;T&gt;</div>
<div class="line">    where M : IAdditionGroup&amp;lt;T&gt;</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> a.New(m.Add(a.X, b.X), m.Add(a.Y, b.Y));</div>
<div class="line">}</div>
</div><!-- fragment --><p> As written, this code does not compile. The reason is that a.New() does not return a Point; instead, it returns IPoint{T}, which is a more general (interface) type than Point (which is probably a struct). Therefore, in order for the code above to work, a cast from IPoint to Point would be necessary. However, the boxing performed by new() and the unboxing performed by the cast will slow down the method. My goal, however, is to allow generic code to run fast; otherwise it's hard to justify the extra effort required to make the code generic. After all, the code to add non-generic points is trivial in comparison: </p><div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> PointD <a class="code" href="namespaceLoyc_1_1Collections.html#ab3f241a3b553681db7ce9ce14147e4eeaec211f7c20af43e742bf2570c3cb84f9">Add</a>(PointD a, PointD b) { <span class="keywordflow">return</span> a + b; }</div>
</div><!-- fragment --><p> You might think to yourself, "okay, why don't we just add a new() 
constraint on Point?" In that case the Add() method can be written as follows: </p><div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Point <a class="code" href="namespaceLoyc_1_1Collections.html#ab3f241a3b553681db7ce9ce14147e4eeaec211f7c20af43e742bf2570c3cb84f9">Add</a>&amp;lt;Point,T,M&gt;(<span class="keyword">this</span> M m, Point a, Point b)</div>
<div class="line">    where Point : IPoint&amp;lt;T&gt;, <span class="keyword">new</span>()</div>
<div class="line">    where M : IAdditionGroup&amp;lt;T&gt;</div>
<div class="line">{</div>
<div class="line">    Point p = <span class="keyword">new</span> Point();</div>
<div class="line">    p.X = m.Add(a.X, b.X);</div>
<div class="line">    p.Y = m.Add(a.Y, b.Y);</div>
<div class="line">    <span class="keywordflow">return</span> p;</div>
<div class="line">}</div>
</div><!-- fragment --><p> This works if the input is a concrete point type, but this version of the method cannot be used if Point happens to be IPoint{T} itself; you cannot do "new IPoint" because it is an interface. To solve this I considered splitting out New() into a separate interface and using it as a constraint of the generic method: </p><div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Point <a class="code" href="namespaceLoyc_1_1Collections.html#ab3f241a3b553681db7ce9ce14147e4eeaec211f7c20af43e742bf2570c3cb84f9">Add</a>&amp;lt;Point,T,M&gt;(<span class="keyword">this</span> M m, Point a, Point b)</div>
<div class="line">    where Point : IPoint&amp;lt;T&gt;, INewPoint&amp;lt;Point, T&gt;</div>
<div class="line">    where M : IAdditionGroup&amp;lt;T&gt;</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> a.New(m.Add(a.X, b.X), m.Add(a.Y, b.Y));</div>
<div class="line">}</div>
</div><!-- fragment --><p> This code compiles under one condition: IPoint must <em>not</em> be derived from INewPoint&lt;IPoint&lt;T&gt;,T&gt;. Because if it is, then the call to New() is ambiguous: does a.New() refer to INewPoint&lt;IPoint&lt;T&gt;,T&gt;.New() or to INewPoint&lt;Point,T&gt;.New()? Remember, IPoint is not the same as Point from the compiler's perspective&ndash;IPoint is an interface, but Point is typically a struct (it could be the same as IPoint, but in general, it is not). The compiler doesn't know which version of New() to call, so it refuses to compile the code. It will compile if we change the method body to </p><div class="fragment"><div class="line"><span class="keywordflow">return</span> ((INewPoint&amp;lt;Point,T&gt;)a).New(m.Add(a.X, b.X), m.Add(a.Y, b.Y));</div>
</div><!-- fragment --><p> The cast resolves the ambiguity, but as a side-effect, 'a' is boxed and the call to New() becomes a virtual call that cannot be inlined. So the same performance penalty is back! </p>
<p>But as I was saying, the original code does compile if IPoint is <em>not</em> derived from INewPoint. Unfortunately, if IPoint is not derived from INewPoint then it is impossible to pass a reference to IPoint to this method (because it no longer meets the constraints). Remember, that is the limitation I am trying to avoid! </p>
<p>One more "solution" is not to create any new points: </p><div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Point <a class="code" href="namespaceLoyc_1_1Collections.html#ab3f241a3b553681db7ce9ce14147e4eeaec211f7c20af43e742bf2570c3cb84f9">Add</a>&amp;lt;Point,T,M&gt;(<span class="keyword">this</span> M m, Point a, Point b)</div>
<div class="line">    where Point : IPoint&amp;lt;T&gt;</div>
<div class="line">    where M : IAdditionGroup&amp;lt;T&gt;</div>
<div class="line">{</div>
<div class="line">    a.X = m.Add(a.X, b.X);</div>
<div class="line">    a.Y = m.Add(a.Y, b.Y);</div>
<div class="line">    <span class="keywordflow">return</span> a;</div>
<div class="line">}</div>
</div><!-- fragment --><p> Alas, this version of the code modifies the point 'a' if Point is IPoint, but it does not modify 'a' if Point is a struct, because structs are passed by value. This inconsistency is not acceptable, and besides, there are (of course) situations where creating new points is required. </p>
<p>The problem is that if there is only one New() method defined (in the point structures such as PointI and PointD) then it's impossible to pass references to IPoint to Add(); however, if there are two New() methods (one in the point struct and one in IPoint), it is impossible to tell the C# compiler which method we want to call without slowing down the code as a side-effect. My solution to this very peculiar problem is to split IPoint into two independent interfaces, IPointBase and INewPoint. This separation allows us to tell the C# compiler that Point implements only one of the New() methods, not both: </p><div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Point <a class="code" href="namespaceLoyc_1_1Collections.html#ab3f241a3b553681db7ce9ce14147e4eeaec211f7c20af43e742bf2570c3cb84f9">Add</a>&amp;lt;Point,T,M&gt;(<span class="keyword">this</span> M m, Point a, Point b)</div>
<div class="line">    where Point : IPointBase&amp;lt;T&gt;, INewPoint&amp;lt;Point, T&gt;</div>
<div class="line">    where M : IAdditionGroup&amp;lt;T&gt;</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> a.New(m.Add(a.X, b.X), m.Add(a.Y, b.Y));</div>
<div class="line">}</div>
</div><!-- fragment --><p> IPointBase, unlike IPoint, does not have a New() method, so only the New() method in INewPoint&lt;Point, T&gt; is available to be called, and the C# compiler stops complaining. Also, since IPoint&lt;T&gt; implements both IPointBase&lt;T&gt; and INewPoint&lt;IPoint&lt;T&gt;, T&gt;, it meets the generic constraints of this method and can be passed to it. </p>
<p>Note that you don't have to write methods like Add() yourself (they are provided as extension methods on IPoint.) Still, if you've read this far, you're probably now afraid of the effort required to write generic code! Your fear may be justified. But there is another, easier way that you can write generic code, based on Point{T} instead of IPoint: </p><div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Point&amp;lt;T&gt; <a class="code" href="namespaceLoyc_1_1Collections.html#ab3f241a3b553681db7ce9ce14147e4eeaec211f7c20af43e742bf2570c3cb84f9">Add</a>&amp;lt;T&gt;(Point&amp;lt;T&gt; a, Point&amp;lt;T&gt; b)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> a+b;</div>
<div class="line">}</div>
</div><!-- fragment --><p> A lot easier without all those constraints, yes? The main disadvantage of this version is that it doesn't have great performance, because the additions are done through interface calls. A second disadvantage is that you can't pass an IPoint to it. That's okay because as stated before, normally the IPoint interface is not used directly! </p>
<p>Code that uses Point&lt;T,M&gt; can run faster: </p><div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Point&amp;lt;T,M&gt; <a class="code" href="namespaceLoyc_1_1Collections.html#ab3f241a3b553681db7ce9ce14147e4eeaec211f7c20af43e742bf2570c3cb84f9">Add</a>&amp;lt;T,M&gt;(Point&amp;lt;T,M&gt; a, Point&amp;lt;T,M&gt; b)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> a+b;</div>
<div class="line">}</div>
</div><!-- fragment --><p> So, in summary, supporting fast generic code that can also operate on IPoint requires this odd arrangement of interfaces, and if you want to write such generic code then you will need three type parameters (Point, T and M) with the following constraints: </p><div class="fragment"><div class="line">where Point : IPointBase&amp;lt;T&gt;, INewPoint&amp;lt;Point, T&gt;</div>
<div class="line">where M : IMath&amp;lt;T&gt; <span class="comment">// or another math interface</span></div>
</div><!-- fragment --><p> It may help to place your methods in a generic class (of Point, T and M) so that you only have to write the constraints once. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header properties_interfaceLoyc_1_1Geometry_1_1IPointBase_3_01T_01_4"><td colspan="2" onclick="javascript:toggleInherit('properties_interfaceLoyc_1_1Geometry_1_1IPointBase_3_01T_01_4')"><img src="closed.png" alt="-"/>&#160;Properties inherited from <a class="el" href="interfaceLoyc_1_1Geometry_1_1IPointBase_3_01T_01_4.html">Loyc.Geometry.IPointBase&lt; T &gt;</a></td></tr>
<tr class="memitem:a8ee534b6b2b1d444c87516181584392e inherit properties_interfaceLoyc_1_1Geometry_1_1IPointBase_3_01T_01_4"><td class="memItemLeft" align="right" valign="top">new T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1Geometry_1_1IPointBase_3_01T_01_4.html#a8ee534b6b2b1d444c87516181584392e">X</a><code> [get, set]</code></td></tr>
<tr class="memdesc:a8ee534b6b2b1d444c87516181584392e inherit properties_interfaceLoyc_1_1Geometry_1_1IPointBase_3_01T_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Horizontal coordinate of a point or vector. <a href="#a8ee534b6b2b1d444c87516181584392e">More...</a><br /></td></tr>
<tr class="separator:a8ee534b6b2b1d444c87516181584392e inherit properties_interfaceLoyc_1_1Geometry_1_1IPointBase_3_01T_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a707be43f39d9a7680a9f3e8bc33f446d inherit properties_interfaceLoyc_1_1Geometry_1_1IPointBase_3_01T_01_4"><td class="memItemLeft" align="right" valign="top">new T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1Geometry_1_1IPointBase_3_01T_01_4.html#a707be43f39d9a7680a9f3e8bc33f446d">Y</a><code> [get, set]</code></td></tr>
<tr class="memdesc:a707be43f39d9a7680a9f3e8bc33f446d inherit properties_interfaceLoyc_1_1Geometry_1_1IPointBase_3_01T_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vertical coordinate of a point or vector. <a href="#a707be43f39d9a7680a9f3e8bc33f446d">More...</a><br /></td></tr>
<tr class="separator:a707be43f39d9a7680a9f3e8bc33f446d inherit properties_interfaceLoyc_1_1Geometry_1_1IPointBase_3_01T_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header properties_interfaceLoyc_1_1Geometry_1_1IPointReader_3_01T_01_4"><td colspan="2" onclick="javascript:toggleInherit('properties_interfaceLoyc_1_1Geometry_1_1IPointReader_3_01T_01_4')"><img src="closed.png" alt="-"/>&#160;Properties inherited from <a class="el" href="interfaceLoyc_1_1Geometry_1_1IPointReader_3_01T_01_4.html">Loyc.Geometry.IPointReader&lt; T &gt;</a></td></tr>
<tr class="memitem:a79907cdff0282a6927177f40d966db65 inherit properties_interfaceLoyc_1_1Geometry_1_1IPointReader_3_01T_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a79907cdff0282a6927177f40d966db65"></a>
T&#160;</td><td class="memItemRight" valign="bottom"><b>X</b><code> [get]</code></td></tr>
<tr class="separator:a79907cdff0282a6927177f40d966db65 inherit properties_interfaceLoyc_1_1Geometry_1_1IPointReader_3_01T_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b2b15c489132c13a073e3063af513e inherit properties_interfaceLoyc_1_1Geometry_1_1IPointReader_3_01T_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a93b2b15c489132c13a073e3063af513e"></a>
T&#160;</td><td class="memItemRight" valign="bottom"><b>Y</b><code> [get]</code></td></tr>
<tr class="separator:a93b2b15c489132c13a073e3063af513e inherit properties_interfaceLoyc_1_1Geometry_1_1IPointReader_3_01T_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_interfaceLoyc_1_1Geometry_1_1INewPoint_3_01Point_00_01T_01_4"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_interfaceLoyc_1_1Geometry_1_1INewPoint_3_01Point_00_01T_01_4')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="interfaceLoyc_1_1Geometry_1_1INewPoint_3_01Point_00_01T_01_4.html">Loyc.Geometry.INewPoint&lt; Point, T &gt;</a></td></tr>
<tr class="memitem:ab07cbe25b7ae1fe2a4d34ae5f8000a8a inherit pub_methods_interfaceLoyc_1_1Geometry_1_1INewPoint_3_01Point_00_01T_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab07cbe25b7ae1fe2a4d34ae5f8000a8a"></a>
Point&#160;</td><td class="memItemRight" valign="bottom"><b>New</b> (T x, T y)</td></tr>
<tr class="separator:ab07cbe25b7ae1fe2a4d34ae5f8000a8a inherit pub_methods_interfaceLoyc_1_1Geometry_1_1INewPoint_3_01Point_00_01T_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue May 17 2016 01:22:53 for Enhanced C# by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
