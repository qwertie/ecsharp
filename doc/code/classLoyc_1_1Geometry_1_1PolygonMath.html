<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Enhanced C#: Loyc.Geometry.PolygonMath Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Enhanced C#
   </div>
   <div id="projectbrief">Language of your choice: library documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceLoyc.html">Loyc</a></li><li class="navelem"><a class="el" href="namespaceLoyc_1_1Geometry.html">Geometry</a></li><li class="navelem"><a class="el" href="classLoyc_1_1Geometry_1_1PolygonMath.html">PolygonMath</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classLoyc_1_1Geometry_1_1PolygonMath-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Loyc.Geometry.PolygonMath Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Contains useful basic polygon algorithms: hit testing, area calculation, orientation detection.  
 <a href="classLoyc_1_1Geometry_1_1PolygonMath.html#details">More...</a></p>
<hr/><b>Source file</b>:<ul>
<li><a href='https://github.com/qwertie/ecsharp/tree/master/Core/Loyc.Utilities/Geometry/PolygonMathTT.cs'>/Core/Loyc.Utilities/Geometry/PolygonMathTT.cs</a></li>
</ul>
<a name="details" id="details"></a><h2 class="groupheader">Remarks</h2>
<div class="textblock"><p>Contains useful basic polygon algorithms: hit testing, area calculation, orientation detection. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a1ce8d6de960906471b426676964f7a17"><td class="memItemLeft" align="right" valign="top">static long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Geometry_1_1PolygonMath.html#a1ce8d6de960906471b426676964f7a17">PolygonArea</a> (IEnumerable&lt; <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> &gt; polygon)</td></tr>
<tr class="memdesc:a1ce8d6de960906471b426676964f7a17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the area of a polygon. <a href="#a1ce8d6de960906471b426676964f7a17">More...</a><br /></td></tr>
<tr class="separator:a1ce8d6de960906471b426676964f7a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f9f91c296d9d5af7d256eeb027cf013"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2f9f91c296d9d5af7d256eeb027cf013"></a>
static long&#160;</td><td class="memItemRight" valign="bottom"><b>PolygonArea</b> (IEnumerator&lt; <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> &gt; e)</td></tr>
<tr class="separator:a2f9f91c296d9d5af7d256eeb027cf013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d740cdd4bdd61ee005f0d88557ef9e9"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Geometry_1_1PolygonMath.html#a7d740cdd4bdd61ee005f0d88557ef9e9">Orientation</a> (IEnumerable&lt; <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> &gt; poly)</td></tr>
<tr class="memdesc:a7d740cdd4bdd61ee005f0d88557ef9e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns Math.Sign(PolygonArea(poly)): positive when clockwise and increasing Y goes upward. <a href="#a7d740cdd4bdd61ee005f0d88557ef9e9">More...</a><br /></td></tr>
<tr class="separator:a7d740cdd4bdd61ee005f0d88557ef9e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ca276ed56168f3d97808d8573e41c4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa7ca276ed56168f3d97808d8573e41c4"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>Orientation</b> (IEnumerator&lt; <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> &gt; poly)</td></tr>
<tr class="separator:aa7ca276ed56168f3d97808d8573e41c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b41791dc24a6068bb1d07ac7e978f82"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Geometry_1_1PolygonMath.html#a4b41791dc24a6068bb1d07ac7e978f82">IsPointInPolygon</a> (IEnumerable&lt; <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> &gt; poly, <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> p)</td></tr>
<tr class="memdesc:a4b41791dc24a6068bb1d07ac7e978f82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds out if a point is inside the polygon using a winding test. <a href="#a4b41791dc24a6068bb1d07ac7e978f82">More...</a><br /></td></tr>
<tr class="separator:a4b41791dc24a6068bb1d07ac7e978f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ce733615dfcab07a6820ce12ea1b153"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ce733615dfcab07a6820ce12ea1b153"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsPointInPolygon</b> (IEnumerator&lt; <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> &gt; e, <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> p)</td></tr>
<tr class="separator:a4ce733615dfcab07a6820ce12ea1b153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a19e809868cc4a9d89fe6ca0ab5ec89"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Geometry_1_1PolygonMath.html#a5a19e809868cc4a9d89fe6ca0ab5ec89">GetWindingNumber</a> (this IEnumerable&lt; <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> &gt; poly, <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> p)</td></tr>
<tr class="memdesc:a5a19e809868cc4a9d89fe6ca0ab5ec89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of times the polygon winds around a test point, using a rightward raycasting test. <a href="#a5a19e809868cc4a9d89fe6ca0ab5ec89">More...</a><br /></td></tr>
<tr class="separator:a5a19e809868cc4a9d89fe6ca0ab5ec89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab21ff9c7b0ab224ca5a88d797e4d377"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aab21ff9c7b0ab224ca5a88d797e4d377"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>GetWindingNumber</b> (this IEnumerator&lt; <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> &gt; e, <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> p)</td></tr>
<tr class="separator:aab21ff9c7b0ab224ca5a88d797e4d377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a591c6f3f5915241fa436c897cb80b6d7"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Geometry_1_1PolygonMath.html#a591c6f3f5915241fa436c897cb80b6d7">PolygonArea</a> (IEnumerable&lt; <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> &gt; polygon)</td></tr>
<tr class="memdesc:a591c6f3f5915241fa436c897cb80b6d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the area of a polygon. <a href="#a591c6f3f5915241fa436c897cb80b6d7">More...</a><br /></td></tr>
<tr class="separator:a591c6f3f5915241fa436c897cb80b6d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77fc340df3886783529491e2baaccc85"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a77fc340df3886783529491e2baaccc85"></a>
static float&#160;</td><td class="memItemRight" valign="bottom"><b>PolygonArea</b> (IEnumerator&lt; <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> &gt; e)</td></tr>
<tr class="separator:a77fc340df3886783529491e2baaccc85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d740cdd4bdd61ee005f0d88557ef9e9"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Geometry_1_1PolygonMath.html#a7d740cdd4bdd61ee005f0d88557ef9e9">Orientation</a> (IEnumerable&lt; <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> &gt; poly)</td></tr>
<tr class="memdesc:a7d740cdd4bdd61ee005f0d88557ef9e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns Math.Sign(PolygonArea(poly)): positive when clockwise and increasing Y goes upward. <a href="#a7d740cdd4bdd61ee005f0d88557ef9e9">More...</a><br /></td></tr>
<tr class="separator:a7d740cdd4bdd61ee005f0d88557ef9e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ca276ed56168f3d97808d8573e41c4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa7ca276ed56168f3d97808d8573e41c4"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>Orientation</b> (IEnumerator&lt; <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> &gt; poly)</td></tr>
<tr class="separator:aa7ca276ed56168f3d97808d8573e41c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b41791dc24a6068bb1d07ac7e978f82"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Geometry_1_1PolygonMath.html#a4b41791dc24a6068bb1d07ac7e978f82">IsPointInPolygon</a> (IEnumerable&lt; <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> &gt; poly, <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> p)</td></tr>
<tr class="memdesc:a4b41791dc24a6068bb1d07ac7e978f82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds out if a point is inside the polygon using a winding test. <a href="#a4b41791dc24a6068bb1d07ac7e978f82">More...</a><br /></td></tr>
<tr class="separator:a4b41791dc24a6068bb1d07ac7e978f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ce733615dfcab07a6820ce12ea1b153"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ce733615dfcab07a6820ce12ea1b153"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsPointInPolygon</b> (IEnumerator&lt; <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> &gt; e, <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> p)</td></tr>
<tr class="separator:a4ce733615dfcab07a6820ce12ea1b153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a19e809868cc4a9d89fe6ca0ab5ec89"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Geometry_1_1PolygonMath.html#a5a19e809868cc4a9d89fe6ca0ab5ec89">GetWindingNumber</a> (this IEnumerable&lt; <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> &gt; poly, <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> p)</td></tr>
<tr class="memdesc:a5a19e809868cc4a9d89fe6ca0ab5ec89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of times the polygon winds around a test point, using a rightward raycasting test. <a href="#a5a19e809868cc4a9d89fe6ca0ab5ec89">More...</a><br /></td></tr>
<tr class="separator:a5a19e809868cc4a9d89fe6ca0ab5ec89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab21ff9c7b0ab224ca5a88d797e4d377"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aab21ff9c7b0ab224ca5a88d797e4d377"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>GetWindingNumber</b> (this IEnumerator&lt; <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> &gt; e, <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> p)</td></tr>
<tr class="separator:aab21ff9c7b0ab224ca5a88d797e4d377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a573a0af3ee61c8232696d83cab87c430"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Geometry_1_1PolygonMath.html#a573a0af3ee61c8232696d83cab87c430">PolygonArea</a> (IEnumerable&lt; <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> &gt; polygon)</td></tr>
<tr class="memdesc:a573a0af3ee61c8232696d83cab87c430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the area of a polygon. <a href="#a573a0af3ee61c8232696d83cab87c430">More...</a><br /></td></tr>
<tr class="separator:a573a0af3ee61c8232696d83cab87c430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0099387fc546d5a64fa500e9d5074d6f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0099387fc546d5a64fa500e9d5074d6f"></a>
static double&#160;</td><td class="memItemRight" valign="bottom"><b>PolygonArea</b> (IEnumerator&lt; <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> &gt; e)</td></tr>
<tr class="separator:a0099387fc546d5a64fa500e9d5074d6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d740cdd4bdd61ee005f0d88557ef9e9"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Geometry_1_1PolygonMath.html#a7d740cdd4bdd61ee005f0d88557ef9e9">Orientation</a> (IEnumerable&lt; <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> &gt; poly)</td></tr>
<tr class="memdesc:a7d740cdd4bdd61ee005f0d88557ef9e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns Math.Sign(PolygonArea(poly)): positive when clockwise and increasing Y goes upward. <a href="#a7d740cdd4bdd61ee005f0d88557ef9e9">More...</a><br /></td></tr>
<tr class="separator:a7d740cdd4bdd61ee005f0d88557ef9e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ca276ed56168f3d97808d8573e41c4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa7ca276ed56168f3d97808d8573e41c4"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>Orientation</b> (IEnumerator&lt; <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> &gt; poly)</td></tr>
<tr class="separator:aa7ca276ed56168f3d97808d8573e41c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b41791dc24a6068bb1d07ac7e978f82"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Geometry_1_1PolygonMath.html#a4b41791dc24a6068bb1d07ac7e978f82">IsPointInPolygon</a> (IEnumerable&lt; <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> &gt; poly, <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> p)</td></tr>
<tr class="memdesc:a4b41791dc24a6068bb1d07ac7e978f82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds out if a point is inside the polygon using a winding test. <a href="#a4b41791dc24a6068bb1d07ac7e978f82">More...</a><br /></td></tr>
<tr class="separator:a4b41791dc24a6068bb1d07ac7e978f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ce733615dfcab07a6820ce12ea1b153"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ce733615dfcab07a6820ce12ea1b153"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsPointInPolygon</b> (IEnumerator&lt; <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> &gt; e, <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> p)</td></tr>
<tr class="separator:a4ce733615dfcab07a6820ce12ea1b153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a19e809868cc4a9d89fe6ca0ab5ec89"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Geometry_1_1PolygonMath.html#a5a19e809868cc4a9d89fe6ca0ab5ec89">GetWindingNumber</a> (this IEnumerable&lt; <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> &gt; poly, <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> p)</td></tr>
<tr class="memdesc:a5a19e809868cc4a9d89fe6ca0ab5ec89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of times the polygon winds around a test point, using a rightward raycasting test. <a href="#a5a19e809868cc4a9d89fe6ca0ab5ec89">More...</a><br /></td></tr>
<tr class="separator:a5a19e809868cc4a9d89fe6ca0ab5ec89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab21ff9c7b0ab224ca5a88d797e4d377"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aab21ff9c7b0ab224ca5a88d797e4d377"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>GetWindingNumber</b> (this IEnumerator&lt; <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> &gt; e, <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> p)</td></tr>
<tr class="separator:aab21ff9c7b0ab224ca5a88d797e4d377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a570d1e02b6986c1037634b5081bcf275"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structLoyc_1_1Math_1_1FPL16.html">FPL16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Geometry_1_1PolygonMath.html#a570d1e02b6986c1037634b5081bcf275">PolygonArea</a> (IEnumerable&lt; <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> &gt; polygon)</td></tr>
<tr class="memdesc:a570d1e02b6986c1037634b5081bcf275"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the area of a polygon. <a href="#a570d1e02b6986c1037634b5081bcf275">More...</a><br /></td></tr>
<tr class="separator:a570d1e02b6986c1037634b5081bcf275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4973adf598dd0700a4917d8ce0a143a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae4973adf598dd0700a4917d8ce0a143a"></a>
static <a class="el" href="structLoyc_1_1Math_1_1FPL16.html">FPL16</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PolygonArea</b> (IEnumerator&lt; <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> &gt; e)</td></tr>
<tr class="separator:ae4973adf598dd0700a4917d8ce0a143a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d740cdd4bdd61ee005f0d88557ef9e9"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Geometry_1_1PolygonMath.html#a7d740cdd4bdd61ee005f0d88557ef9e9">Orientation</a> (IEnumerable&lt; <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> &gt; poly)</td></tr>
<tr class="memdesc:a7d740cdd4bdd61ee005f0d88557ef9e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns Math.Sign(PolygonArea(poly)): positive when clockwise and increasing Y goes upward. <a href="#a7d740cdd4bdd61ee005f0d88557ef9e9">More...</a><br /></td></tr>
<tr class="separator:a7d740cdd4bdd61ee005f0d88557ef9e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ca276ed56168f3d97808d8573e41c4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa7ca276ed56168f3d97808d8573e41c4"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>Orientation</b> (IEnumerator&lt; <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> &gt; poly)</td></tr>
<tr class="separator:aa7ca276ed56168f3d97808d8573e41c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b41791dc24a6068bb1d07ac7e978f82"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Geometry_1_1PolygonMath.html#a4b41791dc24a6068bb1d07ac7e978f82">IsPointInPolygon</a> (IEnumerable&lt; <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> &gt; poly, <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> p)</td></tr>
<tr class="memdesc:a4b41791dc24a6068bb1d07ac7e978f82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds out if a point is inside the polygon using a winding test. <a href="#a4b41791dc24a6068bb1d07ac7e978f82">More...</a><br /></td></tr>
<tr class="separator:a4b41791dc24a6068bb1d07ac7e978f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ce733615dfcab07a6820ce12ea1b153"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ce733615dfcab07a6820ce12ea1b153"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsPointInPolygon</b> (IEnumerator&lt; <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> &gt; e, <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> p)</td></tr>
<tr class="separator:a4ce733615dfcab07a6820ce12ea1b153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a19e809868cc4a9d89fe6ca0ab5ec89"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Geometry_1_1PolygonMath.html#a5a19e809868cc4a9d89fe6ca0ab5ec89">GetWindingNumber</a> (this IEnumerable&lt; <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> &gt; poly, <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> p)</td></tr>
<tr class="memdesc:a5a19e809868cc4a9d89fe6ca0ab5ec89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of times the polygon winds around a test point, using a rightward raycasting test. <a href="#a5a19e809868cc4a9d89fe6ca0ab5ec89">More...</a><br /></td></tr>
<tr class="separator:a5a19e809868cc4a9d89fe6ca0ab5ec89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab21ff9c7b0ab224ca5a88d797e4d377"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aab21ff9c7b0ab224ca5a88d797e4d377"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>GetWindingNumber</b> (this IEnumerator&lt; <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> &gt; e, <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> p)</td></tr>
<tr class="separator:aab21ff9c7b0ab224ca5a88d797e4d377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d9b50ead797dbd820b6962e28303ae1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structLoyc_1_1Math_1_1FPL32.html">FPL32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Geometry_1_1PolygonMath.html#a7d9b50ead797dbd820b6962e28303ae1">PolygonArea</a> (IEnumerable&lt; <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> &gt; polygon)</td></tr>
<tr class="memdesc:a7d9b50ead797dbd820b6962e28303ae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the area of a polygon. <a href="#a7d9b50ead797dbd820b6962e28303ae1">More...</a><br /></td></tr>
<tr class="separator:a7d9b50ead797dbd820b6962e28303ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a466076c1714d47d370e16d2174b4633d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a466076c1714d47d370e16d2174b4633d"></a>
static <a class="el" href="structLoyc_1_1Math_1_1FPL32.html">FPL32</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PolygonArea</b> (IEnumerator&lt; <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> &gt; e)</td></tr>
<tr class="separator:a466076c1714d47d370e16d2174b4633d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d740cdd4bdd61ee005f0d88557ef9e9"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Geometry_1_1PolygonMath.html#a7d740cdd4bdd61ee005f0d88557ef9e9">Orientation</a> (IEnumerable&lt; <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> &gt; poly)</td></tr>
<tr class="memdesc:a7d740cdd4bdd61ee005f0d88557ef9e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns Math.Sign(PolygonArea(poly)): positive when clockwise and increasing Y goes upward. <a href="#a7d740cdd4bdd61ee005f0d88557ef9e9">More...</a><br /></td></tr>
<tr class="separator:a7d740cdd4bdd61ee005f0d88557ef9e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ca276ed56168f3d97808d8573e41c4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa7ca276ed56168f3d97808d8573e41c4"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>Orientation</b> (IEnumerator&lt; <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> &gt; poly)</td></tr>
<tr class="separator:aa7ca276ed56168f3d97808d8573e41c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b41791dc24a6068bb1d07ac7e978f82"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Geometry_1_1PolygonMath.html#a4b41791dc24a6068bb1d07ac7e978f82">IsPointInPolygon</a> (IEnumerable&lt; <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> &gt; poly, <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> p)</td></tr>
<tr class="memdesc:a4b41791dc24a6068bb1d07ac7e978f82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds out if a point is inside the polygon using a winding test. <a href="#a4b41791dc24a6068bb1d07ac7e978f82">More...</a><br /></td></tr>
<tr class="separator:a4b41791dc24a6068bb1d07ac7e978f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ce733615dfcab07a6820ce12ea1b153"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ce733615dfcab07a6820ce12ea1b153"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsPointInPolygon</b> (IEnumerator&lt; <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> &gt; e, <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> p)</td></tr>
<tr class="separator:a4ce733615dfcab07a6820ce12ea1b153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a19e809868cc4a9d89fe6ca0ab5ec89"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Geometry_1_1PolygonMath.html#a5a19e809868cc4a9d89fe6ca0ab5ec89">GetWindingNumber</a> (this IEnumerable&lt; <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> &gt; poly, <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> p)</td></tr>
<tr class="memdesc:a5a19e809868cc4a9d89fe6ca0ab5ec89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of times the polygon winds around a test point, using a rightward raycasting test. <a href="#a5a19e809868cc4a9d89fe6ca0ab5ec89">More...</a><br /></td></tr>
<tr class="separator:a5a19e809868cc4a9d89fe6ca0ab5ec89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab21ff9c7b0ab224ca5a88d797e4d377"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aab21ff9c7b0ab224ca5a88d797e4d377"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>GetWindingNumber</b> (this IEnumerator&lt; <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> &gt; e, <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> p)</td></tr>
<tr class="separator:aab21ff9c7b0ab224ca5a88d797e4d377"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a5a19e809868cc4a9d89fe6ca0ab5ec89"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int Loyc.Geometry.PolygonMath.GetWindingNumber </td>
          <td>(</td>
          <td class="paramtype">this IEnumerable&lt; <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> &gt;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Counts the number of times the polygon winds around a test point, using a rightward raycasting test.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the winding number: the number of times that the polygon winds around the point. Positive means clockwise (assuming a coordinate system in which increasing Y goes upward), negative means counterclockwise. Always returns -1, 0 or +1 when the polygon does not self-intersect. Returns 0 for a degenerate polygon.</dd></dl>
<p>The test point is considered to be within the polygon if it lies on a top or left edge, but not on a bottom or right edge (within the precision limits of 'double' arithmetic). The test point will never be considered inside a degenerate (zero-width) area. </p>

<p>References <a class="el" href="classLoyc_1_1Geometry_1_1PolygonMath.html#a5a19e809868cc4a9d89fe6ca0ab5ec89">Loyc.Geometry.PolygonMath.GetWindingNumber()</a>.</p>

<p>Referenced by <a class="el" href="classLoyc_1_1Geometry_1_1PolygonMath.html#a5a19e809868cc4a9d89fe6ca0ab5ec89">Loyc.Geometry.PolygonMath.GetWindingNumber()</a>.</p>

</div>
</div>
<a class="anchor" id="a5a19e809868cc4a9d89fe6ca0ab5ec89"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int Loyc.Geometry.PolygonMath.GetWindingNumber </td>
          <td>(</td>
          <td class="paramtype">this IEnumerable&lt; <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> &gt;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Counts the number of times the polygon winds around a test point, using a rightward raycasting test.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the winding number: the number of times that the polygon winds around the point. Positive means clockwise (assuming a coordinate system in which increasing Y goes upward), negative means counterclockwise. Always returns -1, 0 or +1 when the polygon does not self-intersect. Returns 0 for a degenerate polygon.</dd></dl>
<p>The test point is considered to be within the polygon if it lies on a top or left edge, but not on a bottom or right edge (within the precision limits of 'double' arithmetic). The test point will never be considered inside a degenerate (zero-width) area. </p>

<p>References <a class="el" href="classLoyc_1_1Geometry_1_1PolygonMath.html#a5a19e809868cc4a9d89fe6ca0ab5ec89">Loyc.Geometry.PolygonMath.GetWindingNumber()</a>.</p>

<p>Referenced by <a class="el" href="classLoyc_1_1Geometry_1_1PolygonMath.html#a5a19e809868cc4a9d89fe6ca0ab5ec89">Loyc.Geometry.PolygonMath.GetWindingNumber()</a>.</p>

</div>
</div>
<a class="anchor" id="a5a19e809868cc4a9d89fe6ca0ab5ec89"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int Loyc.Geometry.PolygonMath.GetWindingNumber </td>
          <td>(</td>
          <td class="paramtype">this IEnumerable&lt; <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> &gt;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Counts the number of times the polygon winds around a test point, using a rightward raycasting test.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the winding number: the number of times that the polygon winds around the point. Positive means clockwise (assuming a coordinate system in which increasing Y goes upward), negative means counterclockwise. Always returns -1, 0 or +1 when the polygon does not self-intersect. Returns 0 for a degenerate polygon.</dd></dl>
<p>The test point is considered to be within the polygon if it lies on a top or left edge, but not on a bottom or right edge (within the precision limits of 'double' arithmetic). The test point will never be considered inside a degenerate (zero-width) area. </p>

<p>References <a class="el" href="classLoyc_1_1Geometry_1_1PolygonMath.html#a5a19e809868cc4a9d89fe6ca0ab5ec89">Loyc.Geometry.PolygonMath.GetWindingNumber()</a>.</p>

<p>Referenced by <a class="el" href="classLoyc_1_1Geometry_1_1PolygonMath.html#a5a19e809868cc4a9d89fe6ca0ab5ec89">Loyc.Geometry.PolygonMath.GetWindingNumber()</a>.</p>

</div>
</div>
<a class="anchor" id="a5a19e809868cc4a9d89fe6ca0ab5ec89"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int Loyc.Geometry.PolygonMath.GetWindingNumber </td>
          <td>(</td>
          <td class="paramtype">this IEnumerable&lt; <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> &gt;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Counts the number of times the polygon winds around a test point, using a rightward raycasting test.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the winding number: the number of times that the polygon winds around the point. Positive means clockwise (assuming a coordinate system in which increasing Y goes upward), negative means counterclockwise. Always returns -1, 0 or +1 when the polygon does not self-intersect. Returns 0 for a degenerate polygon.</dd></dl>
<p>The test point is considered to be within the polygon if it lies on a top or left edge, but not on a bottom or right edge (within the precision limits of 'double' arithmetic). The test point will never be considered inside a degenerate (zero-width) area. </p>

<p>References <a class="el" href="classLoyc_1_1Geometry_1_1PolygonMath.html#a5a19e809868cc4a9d89fe6ca0ab5ec89">Loyc.Geometry.PolygonMath.GetWindingNumber()</a>.</p>

<p>Referenced by <a class="el" href="classLoyc_1_1Geometry_1_1PolygonMath.html#a5a19e809868cc4a9d89fe6ca0ab5ec89">Loyc.Geometry.PolygonMath.GetWindingNumber()</a>.</p>

</div>
</div>
<a class="anchor" id="a5a19e809868cc4a9d89fe6ca0ab5ec89"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int Loyc.Geometry.PolygonMath.GetWindingNumber </td>
          <td>(</td>
          <td class="paramtype">this IEnumerable&lt; <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> &gt;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Counts the number of times the polygon winds around a test point, using a rightward raycasting test.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the winding number: the number of times that the polygon winds around the point. Positive means clockwise (assuming a coordinate system in which increasing Y goes upward), negative means counterclockwise. Always returns -1, 0 or +1 when the polygon does not self-intersect. Returns 0 for a degenerate polygon.</dd></dl>
<p>The test point is considered to be within the polygon if it lies on a top or left edge, but not on a bottom or right edge (within the precision limits of 'double' arithmetic). The test point will never be considered inside a degenerate (zero-width) area. </p>

<p>References <a class="el" href="classLoyc_1_1Geometry_1_1PolygonMath.html#a5a19e809868cc4a9d89fe6ca0ab5ec89">Loyc.Geometry.PolygonMath.GetWindingNumber()</a>.</p>

<p>Referenced by <a class="el" href="classLoyc_1_1Geometry_1_1PolygonMath.html#a5a19e809868cc4a9d89fe6ca0ab5ec89">Loyc.Geometry.PolygonMath.GetWindingNumber()</a>.</p>

</div>
</div>
<a class="anchor" id="a4b41791dc24a6068bb1d07ac7e978f82"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Loyc.Geometry.PolygonMath.IsPointInPolygon </td>
          <td>(</td>
          <td class="paramtype">IEnumerable&lt; <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> &gt;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds out if a point is inside the polygon using a winding test.</p>

</div>
</div>
<a class="anchor" id="a4b41791dc24a6068bb1d07ac7e978f82"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Loyc.Geometry.PolygonMath.IsPointInPolygon </td>
          <td>(</td>
          <td class="paramtype">IEnumerable&lt; <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> &gt;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds out if a point is inside the polygon using a winding test.</p>

</div>
</div>
<a class="anchor" id="a4b41791dc24a6068bb1d07ac7e978f82"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Loyc.Geometry.PolygonMath.IsPointInPolygon </td>
          <td>(</td>
          <td class="paramtype">IEnumerable&lt; <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> &gt;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds out if a point is inside the polygon using a winding test.</p>

</div>
</div>
<a class="anchor" id="a4b41791dc24a6068bb1d07ac7e978f82"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Loyc.Geometry.PolygonMath.IsPointInPolygon </td>
          <td>(</td>
          <td class="paramtype">IEnumerable&lt; <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> &gt;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds out if a point is inside the polygon using a winding test.</p>

</div>
</div>
<a class="anchor" id="a4b41791dc24a6068bb1d07ac7e978f82"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Loyc.Geometry.PolygonMath.IsPointInPolygon </td>
          <td>(</td>
          <td class="paramtype">IEnumerable&lt; <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> &gt;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds out if a point is inside the polygon using a winding test.</p>

</div>
</div>
<a class="anchor" id="a7d740cdd4bdd61ee005f0d88557ef9e9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int Loyc.Geometry.PolygonMath.Orientation </td>
          <td>(</td>
          <td class="paramtype">IEnumerable&lt; <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> &gt;&#160;</td>
          <td class="paramname"><em>poly</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns Math.Sign(PolygonArea(poly)): positive when clockwise and increasing Y goes upward.</p>
<p>A common approach to this problem is to look at the topmost point and the two points on either side. However, if one is not careful, this technique may be unable to detect the orientation in case the polygon has duplicate points, horizontal lines on top, or a degenerate top in which the top part of the polygon is zero-width (these problems can occur even if the polygon's lines do not cross one another.) That's why I chose to compute orientation based on area instead.</p>

<p>References <a class="el" href="classLoyc_1_1Math_1_1MathEx.html#afb1ee3b149727b388921cb8f7a041da8">Loyc.Math.MathEx.Sign()</a>.</p>

</div>
</div>
<a class="anchor" id="a7d740cdd4bdd61ee005f0d88557ef9e9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int Loyc.Geometry.PolygonMath.Orientation </td>
          <td>(</td>
          <td class="paramtype">IEnumerable&lt; <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> &gt;&#160;</td>
          <td class="paramname"><em>poly</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns Math.Sign(PolygonArea(poly)): positive when clockwise and increasing Y goes upward.</p>
<p>A common approach to this problem is to look at the topmost point and the two points on either side. However, if one is not careful, this technique may be unable to detect the orientation in case the polygon has duplicate points, horizontal lines on top, or a degenerate top in which the top part of the polygon is zero-width (these problems can occur even if the polygon's lines do not cross one another.) That's why I chose to compute orientation based on area instead.</p>

<p>References <a class="el" href="classLoyc_1_1Math_1_1MathEx.html#afb1ee3b149727b388921cb8f7a041da8">Loyc.Math.MathEx.Sign()</a>.</p>

</div>
</div>
<a class="anchor" id="a7d740cdd4bdd61ee005f0d88557ef9e9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int Loyc.Geometry.PolygonMath.Orientation </td>
          <td>(</td>
          <td class="paramtype">IEnumerable&lt; <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> &gt;&#160;</td>
          <td class="paramname"><em>poly</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns Math.Sign(PolygonArea(poly)): positive when clockwise and increasing Y goes upward.</p>
<p>A common approach to this problem is to look at the topmost point and the two points on either side. However, if one is not careful, this technique may be unable to detect the orientation in case the polygon has duplicate points, horizontal lines on top, or a degenerate top in which the top part of the polygon is zero-width (these problems can occur even if the polygon's lines do not cross one another.) That's why I chose to compute orientation based on area instead.</p>

<p>References <a class="el" href="classLoyc_1_1Math_1_1MathEx.html#afb1ee3b149727b388921cb8f7a041da8">Loyc.Math.MathEx.Sign()</a>.</p>

</div>
</div>
<a class="anchor" id="a7d740cdd4bdd61ee005f0d88557ef9e9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int Loyc.Geometry.PolygonMath.Orientation </td>
          <td>(</td>
          <td class="paramtype">IEnumerable&lt; <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> &gt;&#160;</td>
          <td class="paramname"><em>poly</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns Math.Sign(PolygonArea(poly)): positive when clockwise and increasing Y goes upward.</p>
<p>A common approach to this problem is to look at the topmost point and the two points on either side. However, if one is not careful, this technique may be unable to detect the orientation in case the polygon has duplicate points, horizontal lines on top, or a degenerate top in which the top part of the polygon is zero-width (these problems can occur even if the polygon's lines do not cross one another.) That's why I chose to compute orientation based on area instead.</p>

<p>References <a class="el" href="classLoyc_1_1Math_1_1MathEx.html#afb1ee3b149727b388921cb8f7a041da8">Loyc.Math.MathEx.Sign()</a>.</p>

</div>
</div>
<a class="anchor" id="a7d740cdd4bdd61ee005f0d88557ef9e9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int Loyc.Geometry.PolygonMath.Orientation </td>
          <td>(</td>
          <td class="paramtype">IEnumerable&lt; <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> &gt;&#160;</td>
          <td class="paramname"><em>poly</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns Math.Sign(PolygonArea(poly)): positive when clockwise and increasing Y goes upward.</p>
<p>A common approach to this problem is to look at the topmost point and the two points on either side. However, if one is not careful, this technique may be unable to detect the orientation in case the polygon has duplicate points, horizontal lines on top, or a degenerate top in which the top part of the polygon is zero-width (these problems can occur even if the polygon's lines do not cross one another.) That's why I chose to compute orientation based on area instead.</p>

<p>References <a class="el" href="classLoyc_1_1Math_1_1MathEx.html#afb1ee3b149727b388921cb8f7a041da8">Loyc.Math.MathEx.Sign()</a>.</p>

</div>
</div>
<a class="anchor" id="a1ce8d6de960906471b426676964f7a17"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static long Loyc.Geometry.PolygonMath.PolygonArea </td>
          <td>(</td>
          <td class="paramtype">IEnumerable&lt; <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> &gt;&#160;</td>
          <td class="paramname"><em>polygon</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the area of a polygon.</p>
<dl class="section return"><dt>Returns</dt><dd>The area. The result is positive if the polygon is clockwise (assuming a coordinate system in which increasing Y goes upward), or negative if the polygon is counterclockwise.</dd></dl>
<p><a href="http://www.codeproject.com/Tips/601272/Calculating-the-area-of-a-polygon">http://www.codeproject.com/Tips/601272/Calculating-the-area-of-a-polygon</a></p>

<p>References <a class="el" href="classLoyc_1_1Geometry_1_1PolygonMath.html#a1ce8d6de960906471b426676964f7a17">Loyc.Geometry.PolygonMath.PolygonArea()</a>.</p>

<p>Referenced by <a class="el" href="classLoyc_1_1Geometry_1_1PolygonMath.html#a1ce8d6de960906471b426676964f7a17">Loyc.Geometry.PolygonMath.PolygonArea()</a>.</p>

</div>
</div>
<a class="anchor" id="a591c6f3f5915241fa436c897cb80b6d7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float Loyc.Geometry.PolygonMath.PolygonArea </td>
          <td>(</td>
          <td class="paramtype">IEnumerable&lt; <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> &gt;&#160;</td>
          <td class="paramname"><em>polygon</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the area of a polygon.</p>
<dl class="section return"><dt>Returns</dt><dd>The area. The result is positive if the polygon is clockwise (assuming a coordinate system in which increasing Y goes upward), or negative if the polygon is counterclockwise.</dd></dl>
<p><a href="http://www.codeproject.com/Tips/601272/Calculating-the-area-of-a-polygon">http://www.codeproject.com/Tips/601272/Calculating-the-area-of-a-polygon</a></p>

<p>References <a class="el" href="classLoyc_1_1Geometry_1_1PolygonMath.html#a591c6f3f5915241fa436c897cb80b6d7">Loyc.Geometry.PolygonMath.PolygonArea()</a>.</p>

<p>Referenced by <a class="el" href="classLoyc_1_1Geometry_1_1PolygonMath.html#a591c6f3f5915241fa436c897cb80b6d7">Loyc.Geometry.PolygonMath.PolygonArea()</a>.</p>

</div>
</div>
<a class="anchor" id="a573a0af3ee61c8232696d83cab87c430"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double Loyc.Geometry.PolygonMath.PolygonArea </td>
          <td>(</td>
          <td class="paramtype">IEnumerable&lt; <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> &gt;&#160;</td>
          <td class="paramname"><em>polygon</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the area of a polygon.</p>
<dl class="section return"><dt>Returns</dt><dd>The area. The result is positive if the polygon is clockwise (assuming a coordinate system in which increasing Y goes upward), or negative if the polygon is counterclockwise.</dd></dl>
<p><a href="http://www.codeproject.com/Tips/601272/Calculating-the-area-of-a-polygon">http://www.codeproject.com/Tips/601272/Calculating-the-area-of-a-polygon</a></p>

<p>References <a class="el" href="classLoyc_1_1Geometry_1_1PolygonMath.html#a573a0af3ee61c8232696d83cab87c430">Loyc.Geometry.PolygonMath.PolygonArea()</a>.</p>

<p>Referenced by <a class="el" href="classLoyc_1_1Geometry_1_1PolygonMath.html#a573a0af3ee61c8232696d83cab87c430">Loyc.Geometry.PolygonMath.PolygonArea()</a>.</p>

</div>
</div>
<a class="anchor" id="a570d1e02b6986c1037634b5081bcf275"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structLoyc_1_1Math_1_1FPL16.html">FPL16</a> Loyc.Geometry.PolygonMath.PolygonArea </td>
          <td>(</td>
          <td class="paramtype">IEnumerable&lt; <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> &gt;&#160;</td>
          <td class="paramname"><em>polygon</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the area of a polygon.</p>
<dl class="section return"><dt>Returns</dt><dd>The area. The result is positive if the polygon is clockwise (assuming a coordinate system in which increasing Y goes upward), or negative if the polygon is counterclockwise.</dd></dl>
<p><a href="http://www.codeproject.com/Tips/601272/Calculating-the-area-of-a-polygon">http://www.codeproject.com/Tips/601272/Calculating-the-area-of-a-polygon</a></p>

<p>References <a class="el" href="classLoyc_1_1Geometry_1_1PolygonMath.html#a570d1e02b6986c1037634b5081bcf275">Loyc.Geometry.PolygonMath.PolygonArea()</a>.</p>

<p>Referenced by <a class="el" href="classLoyc_1_1Geometry_1_1PolygonMath.html#a570d1e02b6986c1037634b5081bcf275">Loyc.Geometry.PolygonMath.PolygonArea()</a>.</p>

</div>
</div>
<a class="anchor" id="a7d9b50ead797dbd820b6962e28303ae1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structLoyc_1_1Math_1_1FPL32.html">FPL32</a> Loyc.Geometry.PolygonMath.PolygonArea </td>
          <td>(</td>
          <td class="paramtype">IEnumerable&lt; <a class="el" href="structLoyc_1_1Geometry_1_1Point.html">Point</a> &gt;&#160;</td>
          <td class="paramname"><em>polygon</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the area of a polygon.</p>
<dl class="section return"><dt>Returns</dt><dd>The area. The result is positive if the polygon is clockwise (assuming a coordinate system in which increasing Y goes upward), or negative if the polygon is counterclockwise.</dd></dl>
<p><a href="http://www.codeproject.com/Tips/601272/Calculating-the-area-of-a-polygon">http://www.codeproject.com/Tips/601272/Calculating-the-area-of-a-polygon</a></p>

<p>References <a class="el" href="classLoyc_1_1Geometry_1_1PolygonMath.html#a7d9b50ead797dbd820b6962e28303ae1">Loyc.Geometry.PolygonMath.PolygonArea()</a>.</p>

<p>Referenced by <a class="el" href="classLoyc_1_1Geometry_1_1PolygonMath.html#a7d9b50ead797dbd820b6962e28303ae1">Loyc.Geometry.PolygonMath.PolygonArea()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Dec 4 2016 11:50:51 for Enhanced C# by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
