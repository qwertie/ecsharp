<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html style="direction: ltr;">
<head>











  
  
  
  
  
  
  
  
  
  
  <meta http-equiv="CONTENT-TYPE" content="text/html; charset=windows-1252">










  


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <title>Loyc: 50 hypothetical features</title>
  <meta name="GENERATOR" content="OpenOffice.org 2.0 (Win32)">











  
  
  
  
  
  
  
  
  
  
  <meta name="CREATED" content="20070503;13063501">











  
  
  
  
  
  
  
  
  
  
  <meta name="CHANGED" content="20070503;19431148">











  
  
  
  
  
  
  
  
  
  
  <style>
<!--
@page { size: 8.5in 11in; margin: 0.79in }
P { margin-bottom: 0.08in }
H1 { margin-bottom: 0.08in }
H1.cjk { font-family: "Lucida Sans Unicode"; font-size: 16pt }
H1.ctl { font-family: "Tahoma"; font-size: 16pt }
H3 { margin-bottom: 0.08in }
H3.western { font-family: "Arial", sans-serif }
-->
  </style>
</head>


<body>











<h1>50 features with proposed implementations</h1>








[ <a href="loyc.html">Introduction</a> | <a href="design-ov.html">Design overview</a> | Extension proposals | <a href="http://qism.blogspot.com/">My blog</a> ]


<h3>1. Type Inference</h3>











itsdaesta<br>











<h3>2. Parallel constructs</h3>











esa<br>











<h3>3. Inner functions, lambda expressions, closures</h3>











esa<br>











<h3>4. Unit checking</h3>











Many discussions and implementations of unit checking are focused on
physical units:
metres, kilograms, pounds, newtons, lumens, etc., so some people think
unit checking is something only civil engineers might need. Wrong!
Units are&nbsp;everywhere. If I ask you how many apples you have,
and
you say "three apples", that's a number with a unit attached--the unit
is apples. windows, pixels, bytes, words, blocks, elements,
messages--all of these could be considered units because they can be
used to measure the&nbsp;amount of something. A year or two ago
there
was a bug hidden in some file-management code I had written: I compared
a quantity measured in <span style="font-style: italic;">bytes</span>
with a quantity in <span style="font-style: italic;">DWORD</span>s.
A unit checker could have found that error.<br>











<br>











The rules of unit
checking are very straightforward: some operators have an equality
constraint, while others cause units to be combined. If I add, subtract
or compare two numbers "a" and "b", they should have the same unit:<br>











<br>











a + b, a - b, a == b, a != b, a &gt;= b, a &lt; b<br>











<br>











If "a" is measured in metres and "b"&nbsp;in inches, it makes no
sense
to compare them and adding them produces a result that is not
meaningful. On the other hand a * b and a / b produce a valid result of
metre*inch and metre/inch, respectively (read "inch metres" and "metres
per inch").<br>











<br>











How to do&nbsp;data type conversion is obvious when you understand
unit
checking. If "a" is measured in metres and there are 1.0936133 yards
per metre, then how do I convert "a" to yards? Is the correct answer<br>











<ol>











  <li>a / 1.0936133</li>











  <li>1.0936133 / a</li>











  <li>a *&nbsp;1.0936133</li>











</ol>











Looking at the units:<br>











<ol>











  <li>m / (yd/m) = m<sup>2</sup>/yd</li>











  <li>(yd/m) / m = yd/m<sup>2</sup>&nbsp;</li>











  <li>m * (yd/m) = yd</li>











</ol>











So the answer is (3).<br>











<br>











Practical unit checking requires <span style="font-style: italic;">unit
polymorphism</span>. Even for something as simple as an Abs()
function:<br>











<pre>	Abs(-12 metres) = 12 metres<br>	Abs(3 N&middot;m<sup>2</sup>) = 3 N&middot;m<sup>2</sup> </pre>











The .NET framework implements several Abs() functions, one for each
data type, but it's impossible to implement a separate function for
each unit, particularly because there are an infinite number of
potential units. Besides, it would be dumb to implement separate
functions as they all do the same thing. What's needed is an Abs()
function that takes a polymorphic unit _a and returns the same unit _a:<br>











<pre>	int`_a` Abs(int`_a` x) { return x &gt;= 0 ? x : -x; }<br>	float`_a` Abs(float`_a` x) { return x &gt;= 0 ? x : -x; }<br>	double`_a` Abs(double`_a` x) { return x &gt;= 0 ? x : -x; }</pre>











Backquoted strings are one possible syntax. Some other polymorphic
functions:<br>











<pre>	double`_a*_a` Square(double`_a` x) { return x*x; }<br>	double`_a**3` Cube(double`_a` x) { return x*x*x; }<br>	double`_a` Sqrt(double`_a*_a` x) { ... }</pre>











Unit checking itself is straightforward to implement if all variables
(and return types) must be assigned units when they are declared, as in
the above examples. More difficult to implement, but much more useful,
is unit inference. Unit inference would automatically determine unit
types by solving equations. Unit inference could automatically discover
the polymorphic unit types of the above functions. When presented with
the following code:<br>











<pre>	double a;<br>	double`m` x;<br>	double Flubulate(double b) {<br>	return ((x*b + 2`kg/m`) - a) * 10`m`;<br>	}</pre>











A&nbsp;unit inference engine in the compiler could determine that
'a' is measured in kg/m, 'b' is measured in kg/m<sup>2</sup>
and Flubulate() returns a value in kg. Having written a unit inference
sngine myself (but not having used it very much) it is my supposition
that almost all unit errors can be detected automatically as long as
class member variables are marked with units. In the above example,
suppose the variable 'a' had been marked with `kg/m`. In that case, the
literal 2 in Flubulate()&nbsp;would not have to be explicitly
marked
with&nbsp;units (provided the compiler&nbsp;treats it in a
certain
way), although 10`m` would still need to be marked. With these
changes,&nbsp;the compiler would still be able to determine the
units
of the argument 'b' and the return value.
<h3>5. Coroutines/generators/microthreads</h3>











Generators, coroutines and
microthreads are similar concepts that all rely on non-stack-based
control flow. The simplest of these are generators (called iterators in
C#), which allow a function to stop and resume at a later time,
returning a value each time the function pauses. For example:<br>











<pre class="clsCode">class Cities { <br>	string[] m_Cities = {"New York","Paris","London"};<br>	public IEnumerator&lt;string&gt; GetEnumerator()<br>	{<br>	for(int i = 0; i&lt;m_Cities.Length; i++)<br>	yield return m_Cities[i];<br>	}<br>}<br>...<br>var c = new Cities();<br>for (string s in c)<br>	Console.WriteLine(s);<br></pre>











Conceptually, the function GetEnumerator() pauses each time a yield
statement is reached, but since .NET doesn't support anything like
that, the compiler must transform the code into something quite
different: the GetEnumerator() function becomes a class that contains a
state machine, and the local&nbsp;variables of the function become
members of the class. The function GetEnumerator() itself simply
returns a new instance of this "unnamed" class (it's not really
unnamed; the compiler picks a name, which you need not know).<br>











<br>











The idea of "microthreads" is that several stacks exist for the same
thread and one can switch between them manually. A well-designed
microthreading system can use much less memory than real threads, so
that one can have tens of thousands of microthreads in existence at
once and switching between them is almost as fast as calling a
function. However, microthreads are probably impossible under .NET.
Microthreads are very useful in game programming and simulation,
because each entity in the game can have its own stack and pretend it
is a separate program. I also believe they would be very useful in GUI
programming.<br>











<br>











I've never seen a language with coroutines, so I can't give an exact
definition. One idea of coroutines is that two functions are able to
call each other.<br>











<br>











Generators have the disadvantage that they can only be one level deep.
Within GetEnumerator() above, for instance, you can't call another
function that yields on behalf of the first one. Typically, they are
required to return a value even though there are various reasons you
might want to pause a function without returning something.<br>











<br>











When you generalize the idea of iterators/generators to pausable
functions/microthreads (let's call them PF/M), it becomes clear that
mechanisms for sending information into one is as important as getting
data out. This can be done with arguments, by passing in references to
data structures which a&nbsp;PF/M must check after unpausing. A
more
forceful way to send a signal would be to throw <span style="font-style: italic;">in</span>
an exception, but thus far I have not seen an implementation that
supports this. It doesn't strike me as a hard feature to add, though.<br>











<h3>6. Delegates</h3>











<br>











<h3>7. Overloaded operators</h3>











<br>











<h3>8. Custom&nbsp;operator in an extension</h3>











See also #40<br>











<h3>9. Parameterized types</h3>











<br>











<h3>10. Lexical macros</h3>











<br>











<h3>11. Reflection concerns</h3>











<br>











<h3>12. Preconditions, postconditions, invariants</h3>











<br>











<h3>13. Simulating multiple inheritance</h3>











<br>











<h3>14. Inline assembly</h3>











<br>











<h3>15. Statements that return values</h3>











<br>











<h3>16. Syntax for array/matrix manipulation</h3>











<br>











<h3>17. Extension methods</h3>











<br>











<h3>18. Extension classes and&nbsp;localized APIs</h3>











<br>











<h3>19. Nullable types</h3>











<br>











<h3>20. Embedded SQL</h3>











<br>











<h3>21. String interpolation</h3>











<br>











<h3>22. regex strings</h3>











<br>











<h3>23. multiline strings</h3>











<br>











<h3>24. Variant types (like algebraic types)</h3>











<br>











<h3>25. Tuples</h3>











<h3>26. Automatic properties</h3>











<pre>	tes<br></pre>











<ul>











  <li>Custom &ldquo;attribute&rdquo; keywords will be
allowed. An actual .NET attribute could be used, too. </li>











  <li>The extension registers an interest in properties with this
attribute when it initializes </li>











  <li>Let's take a moment to discuss the second part. Remember,
the syntax is merely C#-like. It won't follow ECMA strictly. By
relaxing the rules of C#, two property declarations can be allowed. I
propose separating logically necessary rules (e.g. two getters with the
same name are not allowed) from arbitrary rules (e.g. two same-named
property blocks are not allowed). This would make the unnecessary rules
easier to disable. Besides, the arbitrary rules may apply&nbsp;to
one syntax style (e.g. C#) but not another. </li>











</ul>











<h3>
27. Reference counting in any class</h3>











It's hard to get automatic reference counting in .NET languages because
assigning one object to another normally implies a bitwise copy. Of
course, .NET has garbage collection, but what if somebody writes a
back-end for a platform without garbage collection? Or what if we need
to reference-count an unmanaged resource?<br>











<br>











Automatic reference counting in C++ requires&nbsp;behavior
triggered by
an assignment; we can do the same thing in Loyc. In C++ a "smart
pointer" class ir required; can we do the same thing in Loyc? Maybe...<br>











<br>











In Loyc there is a separation between the name you use to refer to a
variable and the variable itself. Figuring out how to access a variable
is a two-stage process:<br>











<ol>











  <li>The expression parser extracts an "identifier ref" into the
AST</li>











  <li>Registered hooks are called to process the reference</li>











</ol>











<h3>28. Efficient mode switching</h3>

In .NET there is an interesting class called HybridDictionary, which
"Implements <b>IDictionary</b> by using a <a onclick="javascript:Track('ctl00_LibFrame_ctl07|ctl00_LibFrame_ctl09',this);" href="http://msdn2.microsoft.com/en-us/library/system.collections.specialized.listdictionary%28VS.80%29.aspx">ListDictionary</a>
while the collection is small, and then switching to a <a onclick="javascript:Track('ctl00_LibFrame_ctl07|ctl00_LibFrame_ctl10',this);" href="http://msdn2.microsoft.com/en-us/library/system.collections.hashtable%28VS.80%29.aspx">Hashtable</a>
when the collection gets large." The implementation of this class
surely goes something like this:<br>











<pre>public class HybridDictionary : IDictionary <br>{<br>	private ListDictionary lst;<br>	private Hashtable hsh;<br><br>	// A method must be written for each method shared between hsh and lst<br>	// (that's more than a dozen methods)<br>	public void Add(object o) {<br>		if (lst != null) {<br>			lst.Add(lst);<br>			if (lst.Length &gt; 10)<br>				Morph();<br>		} else<br>			hsh.Add(lst);<br>	}<br>	...<br>}</pre>











I want to&nbsp;draw your attention to the attention to the
inefficiency
of this approach: it requires two separate container objects,
HybridDictionary and ListDictionary/Hashtable, and each time you call a
function, a sequence of two calls results. Thus it uses more memory
(notably for small collections) and is slower than Hashtable for large
collections. Besides that, the code of HybridDictionary must have
been&nbsp;<span style="font-style: italic;">really</span>
boring to write.<br>











<br>











What if, instead, the list and the hashtable were both contained in the
same object? And what if there were a way to switch between them by
flipping some kind of switch?<br>











<br>











Suppose there is a "mode switch" feature which can swap out one set
of methods for another at run-time. We could use it to switch between
list and hash behavior without requiring two objects. And suppose the
implementation of the list and hashtable is&nbsp;available in
traits
called "ListDictionary and&nbsp;Hashtable". It might look like this:<br>











<pre>public class HybridDictionary : IDictionary <br>{<br>	private switch(Mode) {<br>	default case List:<br>		using ListDictionary { DictAdd -&gt; Add }<br>		public void Add(object o)<br>		{<br>			DictAdd(o);<br>			if (Count &gt; 10)<br>				Morph();<br>		}<br>	case Hash:<br>		using Hashtable { DictClear -&gt; Clear, DictRemove -&gt; Remove }<br>		public void Clear() <br>		{<br>			HashClear();<br>			switch Mode to Mode.List;<br>		}<br>		public void Remove(object o) <br>		{<br>			DictRemove(o);<br>			if (Count &lt; 10)<br>				Morph();<br>		}<br>		public void Morph()<br>		{<br>			if (Mode == Mode.List) {<br>				Mode.Hash.AddAll(this);<br>				Clear();<br>				switch Mode to Mode.Hash;<br>			} else {<br>				Mode.List.AddAll(this);<br>				Clear();<br>				switch Mode to Mode.List;<br>			}<br>		}<br>	}<br>}</pre>











Please forgive the clumsy syntax - it can be debated.<br>











<br>











Firstly, notice that the programmer can be more productive, because he
need not write as much code.<br>











<br>











Here I'm assuming that each part of the switch remains in existence at
all times; it should also be possible to support unions (where only one
side exists at a time.) This would save memory but complicate the
implementation, both of the compiler and of this particular class.
Under .NET, unions are somewhere between difficult and&nbsp;
impossible.<br>











<br>











How would the compiler&nbsp;implement this? Well, first of all,
there
would be two sets of state variables, one for each collection; but
since there would only be one object, memory might still be saved
provided that the amount of state information in each type of
collection is small. At run-time the program must somehow decide
whether to call the "List" version or the "Hash" version of a function.
How? Well, the most interesting possibility is that the virtual
function table is replaced when the mode changes. In this way a single
virtual function call resolves the method to call. Problems could
arise, however, if another class is derived from HybridDictionary and
overrides some functions; and multiple virtual function tables might be
needed if there are multiple sets of switchable functions.<br>











<br>











A more general solution is an AST processor which combines separate
functions into one. Such a processor might replace this:<br>











<pre>class Foo {<br>	switch(Mode) {<br>	default case A:<br>	void F() { Console.WriteLine("Hello world!"); }<br>	case B:<br>	void F() { Console.WriteLine("Joy to the world!"); }<br>	}<br>}<br></pre>











with this:<br>











<pre>class Foo {<br>.	enum Mode { A, B };<br>.	Mode _Mode;<br>.	void F() {<br>.	.	if (_Mode == Mode.A) {<br>.	.	.	Console.WriteLine("Hello world!"); }<br>.	.	} else {<br>.	.	.	Console.WriteLine("Joy to the world!");<br>.	.	}<br>.	}<br>}</pre>











In the case of HybridDictionary, this solution offers no performance
benefits (in fact, the assembly will be larger than if the original
solution from the beginning of this section were used). However, the
benefit of shorter source code still remains.<br>











<br>











This feature would come in handy for implementing
file&nbsp;classes. If
you write a class that represents a file, there is no guarantee that
the file is always open. If the file is closed, most operations
(seeking, loading, reading, writing) are invalid. Thus, each time an
operation is invoked, there must be a state check:<br>











<pre>class MyFile <br>{<br>.	bool isOpen = false;<br>.	void Seek(int pos) {<br>.	.	if (!isOpen)<br>.	.	.	throw new Exception("The file is not open!");<br>.	.	// Code for seeking<br>.	}<br>.	byte ReadByte(int pos) {<br>.	.	if (!isOpen)<br>.	.	.	throw new Exception("The file is not open!");<br>.	.	// Code for reading a byte<br>.	}<br>.	short ReadShort(int pos) {<br>.	.	if (!isOpen)<br>.	.	.	throw new Exception("The file is not open!");<br>.	.	// Code for reading a short<br>.	}<br>.	...<br>}<br></pre>











This gets old fast. What an easy mistake it would be to leave out the
test! Now what if this feature allowed a default method implementation?
Then we could go like this:<br>











<pre>class MyFile {<br>.	switch(IsOpen) {<br>.	case true:<br>.	.	void Seek(int pos) {<br>.	.	.	// Code for seeking<br>.	.	}<br>.	.	byte ReadByte(int pos) {<br>.	.	.	// Code for reading a byte<br>.	.	}<br>.	.	short ReadShort(int pos) {<br>.	.	.	// Code for reading a short<br>.	.	}<br>.	.	...<br>.	case false:<br>.	.	void default() {<br>.	.	.	throw new Exception("The file is not open!");<br>.	.	.	}<br>.	.	}<br>.	...<br>}</pre>











This technique could shorten the code significantly if the same check
is required in many functions.<br>











<br>











<small>Inspiration for this idea came from another language whose
name I have forgotten.</small><br>







<h3>



29. Automatic enum resolution</h3>











Why do I have to type <br>











<br>











x = <br>







<h3>



30.Symbols</h3>


This feature, which I learned from Ruby, is a convenient alternative to
enums. Ruby's symbol syntax is "<span style="font-family: monospace;">:symbol_id</span>";
at run-time, a symbol is represented by a unique integer. It's as
though there is a "global" enumeration to which <span style="font-family: monospace;">symbol_id</span> is
automatically added.<br>











<br>











It can't safely be implemented as a single global enum, however, in the
face of dynamic linking. If two different DLLs use the same symbol
string, that string should be represented by the same number. So what
to do? Well, suppose that there is a number factory for symbols&nbsp;in a
shared library, which creates and looks up mappings between name
strings and entity numbers:<br>











<pre>class _SymbolMapper {<br>	static int Lookup(string name);<br>	static string NameOf(int entity);<br>};<br></pre>











And suppose that one of our DLLs uses the entities :Yes, :No, :Retry
and :Abort. Then this DLL will have a private array of mappings:<br>











<pre>private class _SymbolMap { // Compiler-generated<br>.	static int[] n;<br>.	static _EntityMap() {<br>.	.	n = new int[] {<br>.	.	.	_EntityMapper.Lookup("Yes"),<br>.	.	.	_EntityMapper.Lookup("No"),<br>.	.	.	_EntityMapper.Lookup("Retry"),<br>.	.	.	_EntityMapper.Lookup("Abort")<br>.	.	};<br>.	}<br>};<br></pre>











Then, for example, code like <span style="font-family: monospace;">x
= :Retry</span> will be replaced with <span style="font-family: monospace;">x = _EntityMap.n[2]</span>.<br>











<br>











Of course, it is probably desirable that entities have a type separate
from integers, so they could be represented by something like<br>











<pre>class Entity { int number; } // Defined in shared library</pre>











Now the real difficulty is adding entity syntax to the language. TODO:
figure out how<br>











<br>











Entities are a very useful for making code clearer. I mean how many
times have you written methods with boolean flags like so?<br>











<pre>void FindFile(string path, string name, bool recursive = false);</pre>











The problem is that the meaning of "true" or "false" is hard to tell
unless you find the method definition (or use intellisense). Yes, you
could make an enum like<br>











<pre>enum FindFileFlags { Recursive, NotRecursive }</pre>











but that's a pain in the ass&nbsp;because (1) FindFileFlags (by
convention) must be defined outside the class where FindFile() is
located, and (2) the caller must write FindFileFlags.Recursive, which
is&nbsp;very long. Using :Recursive&nbsp;is
relatively&nbsp;brief and
thus convenient.<br>











<br>











With another compiler extension, the compiler could&nbsp;accept
signatures like<br>











<pre>void FindFile(string path, string name, Entity{:Recursive, :NotRecursive} recursive =&nbsp;:NotRecursive);</pre>











and statically check&nbsp;that the user specifies&nbsp;a valid
value.<br>











<br>











<h3>31. Chainable comparison operators</h3>











After writing&nbsp;code like<br>





<pre>if (foo.the_string[i] &gt;= '0' &amp;&amp;&nbsp;foo.the_string[i] &lt;= '9') { ... }</pre>





too many times to count, I made a C++ function to help, so I could write<br>





<pre>if (IsInRange(foo.my_string[i], '0', '9') { ... }</pre>





instead. Unfortunately, in C# and Java one would have to write a
separate version of the IsInRange() function for each data type you
want to test. But there is another notation that has been used in
mathematics since the dinosaur age, which programmers should be able to
use too:<br>





<pre>if ('0' &lt;= foo.the_string[i] &lt;= '9') { ... }</pre>





A chainable comparison operator would allow this.<br>





<br>





Although&nbsp;the regular (non-chainable operators) may be built into a
language, it is&nbsp;possible to replace them with Loyc. There are two
ways to replace them:<br>





<ol>





  <li>Set the chainable operators to have a higher priority than the standard ones</li>





  <li>Remove the standard operators from the list of operators</li>





</ol>





Because of how ONEP works, the first solution may cause every
expression that contains a comparison to be parsed twice, once for the
standard operators and once for the chainable operators. So the second
solution is better.<br>





<br>





One may think of&nbsp;the chainable operators as a single variable-length operator of the form<br>





<pre>expr (comparison-op expr)*</pre>





But ONEP only supports operators of a fixed length. Instead, what you
need to do is create a series of binary operators and then perform a
transformation when they are nested. Assuming the operators are
left-associative, an expression like "0&nbsp;&lt; x &lt;= 10" is
interpreted as "(0 &lt; x) &lt;= 10". Once the expression has been
parsed, ONEP will call OnExpressionComplete() on the &lt;= operator,
after it has done so on the &lt; operator. At that point you have the
opportunity to transform the expression into another form. You could
use the form<br>





<pre>	(0 &lt; x) &amp;&amp; (x &lt;= 10)</pre>





but this would be foolish, for x will now be evaluated twice, and in
general "x" could be an expensive operation like
ComputeCostOfHeartSurgery(). No. What you really want is something that
means<br>





<pre>	(let temp = x in (0 &lt; temp) &amp;&amp; (temp &lt;= 10))</pre>





TODO.<br>









<h3>

32. Making local variables in highter stack frames visible...?</h3>











<br>









<h3>

33. Expansion sequences</h3>











<br>











<br>











<pre>class BoundingBox {<br> float XMin, YMin, ZMin, XMax, YMax, ZMax;<br> bool Contains(PointF p) {<br> expand X as (X, Y, Z) in<br> bool in##X = p.X &gt;= X##Min &amp;&amp; p.X &lt;= X##Max;<br> return inX &amp;&amp; inY &amp;&amp; inZ;<br> }<br> bool Contains(PointF p) {<br> bool inX = p.X &gt;= XMin &amp;&amp; p.X &lt;= XMax;<br> bool inY = p.Y &gt;= YMin &amp;&amp; p.Y &lt;= YMax;<br> bool inZ = p.Z &gt;= ZMin &amp;&amp; p.Z &lt;= ZMax;<br>ttes return inX &amp;&amp; inY &amp;&amp; inZ;<br> }<br>}<br></pre>











esa<br>











&nbsp; &nbsp;<br>











<h3>33. Defining AST nodes at compile time</h3>









<br>









<h3>34. Two-stage programming: running code at compile time</h3>









<br>









<h3>35. A compiler compiler</h3>









<br>









Let's say I want to write a simple lexer in Loyc....<br>









<br>









<h3>36. Case-insensitive identifier lookup</h3>








<br>








<h3>37. Suggesting code corrections</h3>







<br>







Programmers usually have to fix errors manually, but often the compiler can suggest a fix. For instance if you write<br>







<br>







&nbsp;int x = "String";<br>







<br>







within a smart code editor, perhaps the compiler could offer to change
x into a string for you. If you forget a closing bracket or a
semicolon, perhaps it could fix that too. If you misspell retrun--I
mean return--or a function name, maybe it could offer a spelling
correction.<br>







<br>







This particular extension doesn't strike me as something that would be
easy to do without changing Loyc's main codebase. And of course, if
it's going to offer solutions, the compiler needs some way to carry out
its suggestions. For example, <br>







<ol>







  <li>the compiler could output the suggestions to the smart editor
through a special communication channel. Each suggestion would include
an instruction saying which part of the file to replace and what to
replace it with</li>







  <li>the smart editor would display the suggestions beside the errors with a button labelled "do it"</li>







  <li>when the user says "do it", the editor would run the instruction from the compiler (although the compiler has already quit).</li>







</ol>







Somebody should give some thought to how this can be done and get back to me.<br>





<h3>
38. Call forwarding</h3>






Often you want to pass a call to a function through to the same
function in another class. This is called delegation or forwarding. <br>





<br>





Sometimes you'll do it because you're writing a decorator class, in
which case extension #39 is for you. But sometimes you have a class
that delegates some functionality to a subsystem that is implemented in
another class and you just want to forward one or two functions. In
that case it would really be nice if, instead of writing<br>





<pre>void DoTheDew(string location, int intensity) { _dewDoer.DoTheDew(location, intensity); }</pre>





you could write<br>





<pre>void DoTheDew(string location, int intensity) { forward to _dewDoer; }</pre>





Often you want to add some code in addition to the forward:<br>





<pre>void DoTheDew(string, int) {<br>	forward to _dewDoer;<br>	_dewDone = true;<br>}</pre>





If you're passing through a bunch of functions, you might even like to write this:<br>





<pre>forward to _dewDoer {<br>	void BuyTheDew(double price);<br>	void DoTheDew(string, int);<br>	void EmptyTheBladder(int quantity);<br>	// To forward without having to write out the arguments:<br>	method PourTheDew;<br>	// Forward all overloads with the same name:<br>	all named DoSnowBoardTrick;<br>}</pre>






<br>





<h3>
39. The decorator pattern</h3>





"Decorator" is a design pattern, and a <a href="http://en.wikipedia.org/wiki/Software_design_pattern">design pattern</a>
is a general repeatable solution to a commonly occurring problem in
software design. The dumb part about design patterns is the repetition
involved in using them: every time you want to use a design pattern,
you have to explain to the compiler all the details of the pattern as
it applies to your particular case. If a design pattern is a solution
that thousands of programmers around the world are using over and over
again, we shouldn't have to explain to our computer&nbsp;how the
pattern works over and over again. Computers are supposed to help us
avoid repetition!<br>





<br>





A decorator class is a kind of wrapper class that replicates an
interface while changing the behavior of another object that implements
the interface. For instance, the .NET framework collection classes
offer an "AsReadOnly" function that returns a read-only interface to
the class. The read-only version is implemented with a decorator such
as ReadOnlyCollection, which is implemented something like this:<br>





<pre><span class="keyword">public</span> <span class="keyword">class</span> <span class="identifier">ReadOnlyCollection</span>&lt;T&gt; : <a href="T_System_Collections_Generic_IList%601.htm">IList</a>&lt;T&gt; <br>{<br>	IList&lt;T&gt; _list;<br>	<span class="identifier">ReadOnlyCollection(IList&lt;T&gt; list) {<br>		_list = list;<br>	}<br></span>	public int Count {<br>		get { return _list.Count; }<br>	}<br>	public T this[int index] {<br>		get { return _list[index]; }<br>		set { throw new NotSupportedException(<br>		      "Hey! What do you think you're doing?!"); }<br>	}<br>	public IEnumerator&lt;T&gt; GetEnumerator() {<br>		return _list.GetEnumerator();<br>	}<br>	public bool Contains(T value) {<br>		return _list.Contains(value);<br>	}<br>	...<br>}<br></pre>





All functions that read from the list are passed through to the
underlying list, and those that would modify it throw an exception
instead. But it's so tedius to write all those damn wrapper functions
that I have never bothered to use the decorator pattern. I'm just too
lazy! But I might use it if I could simply write this instead:<br>





<pre><span class="keyword">public</span> <span class="keyword">class</span> <span class="identifier">ReadOnlyCollection</span>&lt;T&gt; : <a href="T_System_Collections_Generic_IList%601.htm">IList</a>&lt;T&gt; <br>{<br>	// "decorates": causes forwarding methods to be added automatically!<br>	decorates IList&lt;T&gt; _list;<br>	<span class="identifier">ReadOnlyCollection(IList&lt;T&gt; list) {<br>		_list = list;<br>	}<br></span>	public T this[int index] {<br>		set { throw new NotSupportedException(<br>		      "Hey! What do you think you're doing?!"); }<br>	}<br>	...<br>}</pre>





That's more like it! And if I may change the subject a moment, the following&nbsp;shortcut would also be helpful in this case:<br>





<pre>set method bodies of {<br>	public T this[int index] { set; }<br>	void IList&lt;T&gt;.Insert(int index, T value);<br>	void ICollection&lt;T&gt;.Clear();<br>	...<br>} to {<br>	throw new NotSupportedException(<br>	      "Hey! What do you think you're doing?!");<br>}<br></pre>





<h3>40. User-defined custom operators</h3>





As&nbsp;#8 explained, an extension can add a new operator to a
language. But what a bother it is to write a whole extension when all
you want is a simple little&nbsp;operator. Most programmers shouldn't
have to write extensions, although they might want to try their hand at
creating standalone operators.<br>





<br>





The extension described here would allow a programmer to write code like this:<br>





<pre>define macro operators with precedence of e==e {<br>	parse in-situ;<br>	(a |==| b)  means (Math.Abs(a) == Math.Abs(b));<br>	(a |!=| b)  means (Math.Abs(a) != Math.Abs(b));<br>	(a |&gt;=| b)  means (Math.Abs(a) &gt;= Math.Abs(b));<br>	(a |&lt;=| b)  means (Math.Abs(a) &lt;= Math.Abs(b));<br>	(a |&gt;|  b)  means (Math.Abs(a) &gt; Math.Abs(b));<br>	(a |&lt;|  b)  means (Math.Abs(a) &lt; Math.Abs(b));<br>	(a in b)    means (b.Contains(a));<br>}<br></pre>





First, let's look at the syntax of this block statement. Assuming the
precedence spec is optional, the outer syntax might be described as
follows:<br>





<br>





'define' 'macro' ('operator' | 'operators') ('with' 'precedence' ('of' | 'above' | 'below') e {<br>





}<br>





<br>





The statements of the&nbsp;inner syntax do not start with a code word,
so they may be considered a special list of expressions: expressions
that are only evaluated at compile time. The extension could parse the
inner lines itself, or it could use ONEP to parse the inner statements
by defining<br>





<ol>





  <li>two&nbsp;statement type inside the block (expression-statements and an "interpret" statement)</li>





  <li>a single&nbsp;operator type, "() means ()"</li>





</ol>





The parse statement would have the syntax <br>





<br>





parse (now | in-situ);<br>





<br>





"parse now" would mean that the expression should be pre-parsed
using a&nbsp;standard set of operators, while "parse in-situ" (the default) would
mean that the expressions are to be parsed in the context where they
appear. The difference lies in the fact that a different set of
operators may be available now than in the place where the
newly-defined operator is used. But in most cases, it wouldn't matter
whether an expression is parsed now or later, and "parse now" is
more efficient&nbsp;because parsing only occurs once, rather than every
time the operator is encountered.<br>





<br>





The extension would parse the left-hand side into a ???? object. As for
the right-hand side, it will be parsed either now or in-situ according
to the "parse" statement.<br>
<h3>





41. "Rules"</h3>






http://www.program-transformation.org/Transform/ObjectOrientedRules<br>
<h3>





42. Call-time acquisition (sort of like in Zope)</h3>



<br>



One possible approach:<br>



<ul>



  <li>A line of code says X.Y.Z.F(argument1, argument2) where X, Y, Z are objects of type XType, YType, ZType respectively</li>



  <li>Or, a method in X calls Y.Z.F(argument1, argument2)</li>



  <li>Or, a method in Y, which acquired X,&nbsp;calls Z.F(argument1, argument2)</li>



  <li>And</li>



  
  
  
  <ul>



    <li>F&nbsp;is declared as def F(within YType in XType, arg1, arg2)</li>



    <li>Or, F&nbsp;is declared as def F(within_stack, arg1, arg2)</li>



    <li>Or, Z is declared as [within&nbsp;YType&nbsp;in XType] class Z: ...</li>



    <li>Or, Z is declared as [within_stack] class Z: ...</li>



    <li>Can also name arguments: def F(within y as YType in x as XType, arg1, arg2)</li>



  
  
  
  </ul>



</ul>



Then, the parent objects are automatically inserted into the argument
list when F() is called. If the arguments are left unnamed, then the
container is used automatically when a symbol is not found by the usual
means. For example if F calls Foo(), but there is no Foo() in Z or its
base classes, then the YType container is searched for&nbsp;Foo(),
followed by XType.<br>



<h3>43. Default arguments</h3>



def Foo(vegetable as string&nbsp;= null, animal as string&nbsp;= null, mineral as string&nbsp;= null): ...<br>



<h3>44. Named arguments for any function</h3>



<ul>



  <li>def Foo(vegetable as string, animal as string = null, mineral as string): ...</li>



  <li>At the call site: Foo(vegetable := "carrot", mineral := "sulfur")</li>



  <li>Or perhaps simply: Foo(vegetable: "carrot" mineral: "sulfur")</li>



  <li>And this should be allowed: Foo(vegetable: "carrot", mineral: "sulfur")</li>



</ul>



Operators:<br>



<ul>



  <li>Regular comma syntax is e70 ',' e70</li>



  <li>":=" syntax A: e70 ',' ID ':=' e70</li>



  <li>":=" syntax B: ^ ID ':=' e70</li>



  <li>":" syntax A: e70 ID ':' e70</li>



  <li>":" syntax B: ^ ID ':' e70</li>



  <li>":" syntax C: e70 ',' ID ':' e70</li>



</ul>



<h3>45. Syntactic sugar for function calls and overload resolution</h3>



<ul>



  <li>def Throw("from" From as Point "to" To as Point)</li>



  <li>def Throw("from here to" To as Point)</li>



  <li>def Throw(exception as Exception)</li>



</ul>



Could differentiate constructors:<br>



<ul>



  <li>def constructor("load" filename as string)</li>



  <li>def constructor("parse string"&nbsp;name as string)</li>



</ul>
<h3>46. Interface subsets</h3>
In my opinion, certain interfaces in the .NET framework are poorly
designed because&nbsp;they force you to implement too much. The
ICollection interface, for example, requires you to provide Add() and
Remove() methods, for example, even though your collection might be
read-only. You can write code that attempts to call Add() or Remove()
on such a collection, and it will fail at run-time with no compile-time
warning. I propose an interface subset feature to get around this
problem. The following code declares an interface that only provides a <span style="font-style: italic;">subset</span> of ICollection&lt;T&gt;:<br>
<pre>public interface IReadOnlyCollection&lt;T&gt; <br>.	: IEnumerable&lt;T&gt;, subset of ICollection&lt;T&gt;<br>{<br>.	int Count { get; }<br>.	bool IsReadOnly { get { return true; } }<br>.	bool Contains (T item);<br>.	void CopyTo(T[] array, int arrayIndex);<br>}</pre>
The phrase "subset of" means that although IReadOnlyCollection&lt;T&gt;
is, strictly speaking, derived from ICollection&lt;T&gt;, it does not
include any ot the methods of ICollection&lt;T&gt; by default. Instead,
only those parts of ICollection&lt;T&gt; that are specifically
referenced have to be defined by an implementor. Therefore, a class
that implements IReadOnlyCollection would only have to implement
IEnumerable&lt;T&gt;, Count, Contains() and CopyTo(). For all other
members of ICollection&lt;T&gt;, Loyc would automatically throw
NotImplementedException. Furthermore, at compile time, Loyc would
prevent unavailable methods from being called if the compiler is aware
that the collection is read-only:<br>
<pre>class Family {<br>.	IReadOnlyCollection&lt;Person&gt; Parents { get {...} }<br>.	IReadOnlyCollection&lt;Person&gt; Children { get {...} }<br>}<br><br>void Oops(Family f)<br>{<br>	f.Parents.Add(new Person());<br>}</pre>
Loyc would give an error here because although the Parents property can
be casted to ICollection&lt;Person&gt;, Loyc pretends Add() does not
exist in IReadOnlyCollection&lt;Person&gt;.<br>











</body>
</html>
