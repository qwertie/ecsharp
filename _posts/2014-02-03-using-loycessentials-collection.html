---
title: "Using Loyc.Essentials: collection interfaces"
layout: post
# Pulled from Blogger. Last updated there on: 2014-05-28
---
<small><p><i>This post was imported from <a href='http://loyc-etc.blogspot.com/2014/02/using-loycessentials-collection.html'>blogspot</a>.</i></p></small>
{% raw %}
Loyc.Essentials is a library of "stuff that should be in the <a href="http://en.wikipedia.org/wiki/Base_Class_Library">.NET BCL</a>, but isn't." Today I will present one of the most important parts of Loyc.Essentials: its collection interfaces. <br/>
<br/>


The .NET 4 version of Loyc.Essentials defines the .NET 4.5 interfaces IReadOnlyCollection&lt;T>, IReadOnlyList&lt;T> and IReadOnlyDictionary&lt;T> (handy if you are still targeting Windows XP, which does not support .NET 4.5), and on top of that defines numerous additional interfaces for queues, stacks, slices, bidirectional enumerators, ranges, sinks, and more. (The new .NET 3.5 version relies on <a href="https://github.com/theraot/Theraot">Theraot.Core</a> instead to provide these interfaces and other features of .NET 4/4.5.) Several of these interfaces are widely used throughout Loyc.Essentials itself and other projects such as Loyc.Collections and <a href="http://www.codeproject.com/Articles/664785/A-New-Parser-Generator-for-Csharp">LLLPG</a>. <br/>
<br/>
Programmers with less experience, or that don't work in areas where performance is important, may underestimate the importance of data structures and collection interfaces in software engineering. I have come to believe that collection interfaces are very important, and that the built-in collection interfaces of the .NET framework are somewhat impoverished and inflexible. I like to work with a variety of data structures and I like to have a variety of collection interfaces available to reflect that variety. There's so much more out there than just List&lt;T>: linked lists, <a href="http://en.wikipedia.org/wiki/B%2B_tree">B+ trees</a>, <a href="http://www.codeproject.com/Articles/26171/VList-data-structures-in-C">VLists</a>, <a href="http://www.codeproject.com/Articles/568095/The-List-Trifecta-Part-1">ALists</a>, <a href="http://en.wikipedia.org/wiki/Hash_array_mapped_trie">Hash Array Mapped Tries</a>, <a href="http://en.wikipedia.org/wiki/Bloom_filter">Bloom filters</a>, other search trees and <a href="http://en.wikipedia.org/wiki/Trie">tries</a>... the possibilities are endless. <br/>
<br/>
First, let me talk a little about the limitations that the current BCL interfaces suffer from. <br/>
<br/>
The .NET framework does not support much diversity. Traditionally it defined just four collection interfaces: IEnumerable&lt;T>, ICollection&lt;T>, IList&lt;T>, and IDictionary&lt;T>, and all but one were mutable.  <br/>
<br/>
<b>Flaw #1</b>: IList&lt;T>/ICollection&lt;T> contain some methods that are almost never used, like CopyTo(), but lack methods that are often desired, like AddRange() and RemoveRange(), and they lack methods that <i>would</i> be often used if they existed, like Slice(). <br/>
<br/>
<b>Flaw #2</b>: Lack of support for read-only interfaces. In .NET 4.5, they <b>finally</b> introduced IReadOnlyCollection&lt;T>, IReadOnlyList&lt;T> and IReadOnlyDictionary&lt;T>, but they didn't derive IList&lt;T> from IReadOnlyList&lt;T> and they didn't declare that the core collection classes actually implement these interfaces. Plus, "IReadOnlyCollection" is an terribly long name for simply adding a Count property to IEnumerable (Loyc.Essentials used to define exactly the same interface, but it was called IEnumerableCount&lt;T>). <br/>
<br/>
Ideologically, I'm opposed to the idea that a mutable interface such as IList&lt;T> should not implement IReadOnlyList&lt;T>. If a method takes an argument of type IReadOnlyList&lt;T>, it should mean that the method will not modify the list; it should not mean that the caller has to create a special read-only wrapper object on the heap, and it certainly should not mean that the caller has to guarantee that the list will never change. <tt>IReadOnlyList&lt;T></tt> should not be a <i>burden</i> or difficulty that the caller must overcome, rather it should simply be a <i>promise</i> that the called method will not modify the list. That leads me to flaw #3... <br/>
<br/>
<b>Flaw #3</b>: because IReadOnlyList&lt;T> and IList&lt;T> are officially unrelated, and IReadOnlyList&lt;T> is not supported very well, if a data structure implements both interfaces, C# "ambiguity" errors are inevitable. Here's how it typically happens: you want to declare a method that takes a list but doesn't modify it: 
<pre>
  void Foo(IReadOnlyList&lt;T> list) {...}
</pre>But you notice that most collection classes don't implement IReadOnlyList&lt;T>, so you add an overload that automatically converts IList&lt;T> to IReadOnlyList&lt;T> with an extension method (e.g. <tt>AsListSource()</tt> in the Loyc.Collections namespace): 
<pre>
  // Alias for Foo(IReadOnlyList&lt;T>)
  void Foo(IList&lt;T> list) { Foo(list.AsListSource()); }
</pre>So far, so good. But as new data structures are implemented, they will naturally implement IReadOnlyList&lt;T>. If they are mutable, they will want to implement IReadOnlyList&lt;T> so that it will be possible to pass them to methods that accept IReadOnlyList; meanwhile, <i>immutable</i> data structures might choose to <a href="http://msdn.microsoft.com/en-us/library/ms173157.aspx">explicitly implement</a> IList&lt;T> in order to <i>stay compatible</i> with the large amount of older code based on IList&lt;T> for read-only access. So what's the problem? Suppose I have a data structure MyList&lt;T> that implements both interfaces. Look what happens when I call Foo: 
<pre>
Foo(new MyList&lt;T>()); // ERROR: The call is ambiguous 
  // between the following methods or properties: 
  // '...Foo(System.Collections.Generic.IList&lt;T>)' and 
  // '...Foo(System.Collections.Generic.IReadOnlyList&lt;T>)'
</pre> <b>Flaw #4</b>: A lack of variety and flexibility. If you actually survey the various data structures that exist, you'll find a wide variety of capabilities that they may or may not offer.  <ul>
<li>A data structure might support an indexing operator but not a Count property (consider the <a href="http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes">Sieve of Eratosthenes</a> of infinite size). Other data structures may <i>support</i> a Count property in theory, but <i>calling</i> it should be avoided because it may be expensive (in Loyc.Essentials, BufferedSequence&lt;T> has this property). </li>
<li>A data structures may be queue- or stack-like, offering access to the beginning/end of a data structure but not the middle.</li>
<li>A data structure might not be zero-based, e.g. the range of valid indexes could be 1..100 or -100..100 or 35..39.</li>
<li>A data structure may be <i>sparse</i>, in which case scanning it for items with a for-loop from 0..Count is inefficient.</li>
<li>A data structure may be a <i>sink</i>, allowing insertion of data but not reading (write-only files and pipes may be viewed this way).</li>
<li>Most list data structures could allow enumeration to start at any point in the middle, but .NET ignores this possibility; in addition, indexing is less efficient than enumeration for some lists (e.g. <a href="http://www.codeproject.com/Articles/568095/The-List-Trifecta-Part-1">AList</a>), so this should be supported.</li>
<li>A data structures may not support access by integer index, but could still allow bi-directional enumeration moving both forward and backward), e.g. a doubly-linked list, with insertion locations denoted by enumerator positions.</li>
<li>Many data structures can easily tell you if they are empty, but require O(N) time to report their Count. .NET almost forces you to use <tt>Count == 0</tt> to detect emptiness; you can use LINQ's <tt>Any()</tt> function instead, but this requires a heap allocation and two interface calls.</li>
</ul> This list is certainly incomplete; the possible combinations of operations that data structures may or may not support is just about endless. <br/>
<br/>
Other collection libraries outside .NET have recognized this diversity, and provide more concepts or interfaces to address it, such as the C++ STL's various iterator and container concepts, or <a href="http://ddili.org/ders/d.en/ranges.html">D's ranges</a>. <br/>
<br/>
Suppose I write a method that reads a list starting at the outside and moving inward (e.g. first element, last element, second element, second-last element, etc.). A linked list can certainly support this order of traversal; unfortunately, in .NET, the only standard collection interface that can be used in this situation is IList&lt;T>, which a linked list data structure cannot support efficiently. Thanks to .NET's simplistic interfaces, my method can either support <a href="http://msdn.microsoft.com/en-us/library/he2s3bh7(v=vs.110).aspx">standard linked lists</a>, or normal lists, but not both at once. <br/>
<br/>
This is the central problem that the .NET interfaces fail to solve. When you write a method or a class that operates on a collection, you cannot declare precisely what kind of collection you accept, so most of the time you have to <i>mandate</i> functionality you don't need. Some collection types will not be able to provide that functionality that you <i>mandated but didn't need</i>, so they won't implement the interface and will be incompatible, unnecessarily. Meanwhile, other collection types might implement the interface even though they are <i>not</i> compatible, and then throw an exception when you try to use unsupported functionality.  <h4>How Loyc.Essentials improves the situation</h4> Loyc.Essentials improves the situation mainly by providing a much wider variety of interfaces. The new interfaces mostly address flaw #4, but can only partly alleviate the pain of flaws 1, 2 and 3. <br/>
<br/>
Interfaces are cheap to define: they are only a few lines of code plus some documentation, so it's well worth the effort of defining a variety of them, even if no implementations are provided (too bad Microsoft didn't see it that way). Before I get to the actual interfaces, here's a list of the key concepts that are supported:  <ul>
<li>Sources: objects that <i>provide</i> data. Source interfaces are read-only.</li>
<li>Sinks: objects that <i>accept</i> data. Sink interfaces are write-only.</li>
<li>Slices: subsections of an indexed list, e.g. elements 5..10 of a larger list. The broad class of <a href="http://en.wikipedia.org/wiki/Divide_and_conquer_algorithm">Divide-and-conquer algorithms</a> benefit from these.</li>
<li>Ranges: Similar to slices, ranges represent a subsection of a collection, but they may only allow access to the first, or first and last, elements of that subsection. For performance reasons, ranges are <i>mutable</i> in the sense that you can shrink the range one element at a time. This does not modify the underlying collection, it just causes the range to point to a smaller area in the same collection. Ranges were popularized by D, and while they don't work as well in .NET, I thought that the interfaces were still worth providing. Here is a <a href="http://www.codeproject.com/Articles/604345/D-styleplusrangesplusinplusC-23plus-NET">long-ish article about my design of Ranges in .NET</a>.</li>
<li>Fancy enumerators: after designing the range interfaces, I realized that often all you need is an enumerator that can go backward. <i>Binumerators</i> can travel both backward and forward through a collection, and mutable variants allow the current item to be changed or deleted.</li>
<li>Specific categories of data structures: queues, arrays, and sparse lists.</li>
<li>"Neg" non-zero-based lists: indexed lists for which the minimum index is not necessarily zero.</li>
</ul> <h4>The Loyc.Essentials collection interfaces</h4> The full documentation of these interfaces can be seen in the <a href="https://sourceforge.net/p/loyc/code/HEAD/tree/Src/Loyc.Essentials/Collections/Interfaces/">source code</a> and will be provided automatically by Visual Studio Intellisense, as long as you have the Loyc.Essentials.xml file alongside your copy of Loyc.Essentials.dll. <br/>
<br/>
First, an interface you won't use: ICount: 
<pre>
  public interface ICount : IIsEmpty
  {
    int Count { get; }
  }
</pre>I thought the concept of "having a count" should be separated because some collections may have a count but do not allow enumeration or vice versa. For example, I defined IStack&lt;T> as a collection that had a Count but did not allow enumeration. However, Microsoft made ICount unusable in .NET 4.5 by defining IReadOnlyCollection: 
<pre>
  public interface IReadOnlyCollection<out T> : IEnumerable<T>
  {
    int Count { get; }
  }
</pre>How does this new interface make it impossible to use ICount? Well, if I define any interface that inherits from both <tt>IReadOnlyCollection</tt> and <tt>ICount</tt>, it becomes impossible (well, quite difficult) to call <tt>Count</tt> on that interface because the C# compiler says that the reference to Count is "ambiguous". The end result is that people won't bother using <tt>ICount</tt> at all (admittedly, the number of cases where somebody needs the Count of a collection, and nothing else, is very small). For completeness, I recently added IIsEmpty, because as I mentioned, IsEmpty can run much faster than Count in some data structures: 
<pre>
  public interface IIsEmpty
  {
    bool IsEmpty { get; }
  }
</pre>However, I decided not to mandate this property as part of the common Loyc.Essentials interface <tt>IListSource&lt;T></tt>, although it is a part of <tt>IFRange&lt;T></tt> (listed near the bottom of this article). <br/>
<br/>
My single most favorite interface in Loyc.Essentials is <tt>IListSource&lt;T></tt>. As its name implies, it is a kind of <i>source</i>; it's basically <tt>IReadOnlyCollection&lt;T></tt> with extra functionality: 
<pre>
  public interface IListSource&lt;out T> : IReadOnlyList&lt;T>
  {
    // If index is invalid, sets fail=true and returns default(T)
    T TryGet(int index, out bool fail); 
    IRange&lt;T> Slice(int start, int count = int.MaxValue);
  }
</pre>Both of these new functions are favorites of mine, although it's usually easier to call one of the standard TryGet() extension methods (especially the first one): 
<pre>
  public static partial class LCInterfaces
  {
    public static T TryGet&lt;T>(this IListSource&lt;T> list,
                              int index, T defaultValue);
    public static bool TryGet&lt;T>(this IListSource&lt;T> list, 
                                 int index, ref T value);
  }
</pre>Plus, a couple of standard methods of IList&lt;T> are added as extension methods: 
<pre>
  public static partial class LCInterfaces
  {
    public static int IndexOf&lt;<T>(this IReadOnlyList&lt;T> list, T item)
    public static void CopyTo&lt;T>(this IReadOnlyList&lt;T> c, T[] array, int arrayIndex)
  }
</pre>And there are other extension methods that will be covered in a future article. <br/>
<br/>
I don't know about you, but in my code I often have to check whether the index is in range before I call the indexer: 
<pre>
  if (index &lt; list.Count && list[index] >= 0) {...}
</pre>With <tt>IListSource</tt> this is easier: 
<pre>
  if (list.TryGet(index, -1) >= 0) {...}
</pre>In theory, this version should be faster too, because it needs only one interface dispatch, not two. That's not the only reason for <tt>TryGet()</tt> to exist, though; there are a few collection types for which it is expensive to call Count. <br/>
<br/>
The second extension method uses <tt>ref T value</tt> to allow the caller to set a default T value before calling the method, since you will not always want to use <tt>default(T)</tt> as the default. If the index is invalid, <tt>value</tt> is left unchanged. <br/>
<br/>
Meanwhile, the Slice() method returns a sub-section of the list without allocating a new list. For example, list.Slice(10, 10) gets the collection of 10 items starting at index 10. IRange&lt;T> is a superset of IListSource&lt;T>; see definition below. Don't worry, if you're creating a collection class, you never actually have to write a class that implements IRange&lt;T>. Just use this implementation: 
<pre>
  public IRange&lt;T> Slice(int start, int count) {
    return new Slice_&lt;T>(this, start, count);
  }
</pre>or the potentially more efficient version, 
<pre>
  IRange&lt;T> IListSource&lt;T>.Slice(int start, int count)
    { return Slice(start, count); }
  public Slice_&lt;T> Slice(int start, int count)
    { return new Slice_&lt;T>(this, start, count); }
</pre>Slice_ is a struct in Loyc.Essentials that provides a "view" on part of a read-only list. Why the underscore? I wanted to simply call it "Slice", but that is illegal in C# because <tt>Slice_</tt> itself implements IListSource&lt;T>, so it contains a method named <tt>Slice</tt>, and a method is not allowed to have the same name as its containing class. By the way, there's also a <tt>ListSlice&lt;T></tt> class and <tt>Slice()</tt> extension method for slicing <tt>IList&lt;T></tt>. <br/>
<br/>
Next up, here are the "neg lists". These are list interfaces that do not (necessarily) use zero as the minimum index. So far, I haven't used these interfaces in practice. 
<pre>
  public interface INegListSource&lt;T> : IReadOnlyCollection&lt;T>
  {
    int Min { get; }
    int Max { get; }
    T this[int index] { get; }
    T TryGet(int index, out bool fail);
    IRange&lt;T> Slice(int start, int count = int.MaxValue);
  }
  public interface INegArray<T> : INegListSource<T>
  {
    new T this[int index] { set; get; }
    bool TrySet(int index, T value);
  }
  public interface INegAutoSizeArray&lt;T> : INegArray&lt;T>
  {
    void Optimize();
  }
  public interface INegDeque&lt;T> : INegArray&lt;T>, IDeque&lt;T> 
  {
  }
</pre>Here's <a href="http://sourceforge.net/p/loyc/code/HEAD/tree/Src/Loyc.Essentials/Collections/Interfaces/INegListSource.cs">documentation</a>, if you're interested. INegAutoSizeArray is interesting: it automatically enlarges itself when you write to an index below Min or above Max.  <br/>
<br/>
Next there's a higher-performance variation on <a href="http://msdn.microsoft.com/en-us/library/system.collections.specialized.inotifycollectionchanged(v=vs.110).aspx">INotifyCollectionChanged</a>, which can only be implemented by collections that implement IListSource&lt;T>: 
<pre>
  public interface INotifyListChanging&lt;T>
  {
    event ListChangingHandler&lt;T> ListChanging;
  }
  public delegate void ListChangingHandler&lt;T>(
    IListSource&lt;T> sender, ListChangeInfo&lt;T> args);
  [Serializable]
  public class ListChangeInfo&lt;T> : EventArgs
  {
    public ListChangeInfo(NotifyCollectionChangedAction action,
      int index, int sizeChange, IListSource&lt;T> newItems);

    public readonly NotifyCollectionChangedAction Action;
    public readonly int Index;
    public readonly int SizeChange;
    public readonly IListSource&lt;T> NewItems;
  }
</pre>Why is this faster? Because unlike INotifyCollectionChanged, this interface requires as little as one memory allocation each time the list changes (for the ListChangeInfo object). INotifyCollectionChanged requires the collection to allocate a list of OldItems and NewItems; but because ListChanging fires <i>before</i> the list changes rather than afterward, there is no need to allocate a list of old items--the event handler can simply look at the current state of the list. Meanwhile, it is possible to optimize NewItems not to require an allocation. <br/>
<br/>
Admittedly, I have found that sometimes an event handler would really prefer to see the list after it changes rather than before. But if performance matters, this interface may be better. You be the judge. <br/>
<br/>
Next I present this peculiar bunch of interfaces, which reflects the difficulty I had designing an interface for immutable sets: 
<pre>
  public interface ISetTests&lt;SetT>
  {
    bool IsProperSubsetOf(SetT other);
    bool IsProperSupersetOf(SetT other);
    bool IsSubsetOf(SetT other);
    bool IsSupersetOf(SetT other);
    bool Overlaps(SetT other);
    bool SetEquals(SetT other);
  }
  public interface ISetOperations&lt;in T, SetT> 
    : ISetOperations&lt;T, SetT, SetT> { }
  public interface ISetOperations&lt;in T, in InSetT, out OutSetT>
  {
    OutSetT With(T item);
    OutSetT Without(T item);
    OutSetT Union(InSetT other);
    OutSetT Intersect(InSetT other);
    OutSetT Except(InSetT other);
    OutSetT Xor(InSetT other);
  }
  public interface ISetImm&lt;T, SetT> : ISetOperations&lt;T, SetT>, 
    ISetTests&lt;SetT>, IReadOnlyCollection&lt;T> //, ICount
  {
    bool IsInverted { get; }
  }
  public interface ISetImm&lt;T> : ISetOperations&lt;T, IEnumerable&lt;T>>, 
    ISetTests&lt;IEnumerable&lt;T>>, IReadOnlyCollection&lt;T>
  {
  }
</pre>The most important interface is at the end: ISetImm&lt;T>. If you work through it logically, you can see that ISetImm&lt;T> contains the following members: 
<pre>
public interface ISetImm&lt;T> : ...
{
  bool IsProperSubsetOf(IEnumerable&lt;T> other);
  bool IsProperSupersetOf(IEnumerable&lt;T> other);
  bool IsSubsetOf(IEnumerable&lt;T> other);
  bool IsSupersetOf(IEnumerable&lt;T> other);
  bool Overlaps(IEnumerable&lt;T> other);
  bool SetEquals(IEnumerable&lt;T> other);
  ISetImm&lt;T> With(T item);
  ISetImm&lt;T> Without(T item);
  ISetImm&lt;T> Union(IEnumerable&lt;T> other);
  ISetImm&lt;T> Intersect(IEnumerable&lt;T> other);
  ISetImm&lt;T> Except(IEnumerable&lt;T> other);
  ISetImm&lt;T> Xor(IEnumerable&lt;T> other);
  bool IsInverted { get; }
}
</pre>.NET already defines a set interface for <i>mutable</i> sets, <a href="http://msdn.microsoft.com/en-us/library/dd412081(v=vs.110).aspx">ISet&lt;T></a>, but immutable sets are more convenient to work with so I added this interface. In Loyc.Collections.dll, I implemented a very nice immutable set class called Set&lt;T>, which is a kind of <a href="http://en.wikipedia.org/wiki/Hash_tree_(persistent_data_structure)">Hash Tree</a>. Originally my Set&lt;T> structure implemented only ISetImm&lt;T, Set&lt;T>>, because it was easier, but eventually I also implemented the more generic ISetImm&lt;T> interface. I also made a mutable variant of Set&lt;T>, the MSet&lt;T> class, which implements both ISet&lt;T> and ISetImm&lt;T>. <br/>
<br/>
Finally, I created an <i>InvertibleSet&lt;T></i> class, which can represent everything that is <b>not</b> in some other set; to account for this possibility, I added the <tt>IsInverted</tt> property to ISetImm. <br/>
<br/>
<i>Sparse lists</i> are indexed lists in which regions of indexes may be unused. Here are the <a href="https://sourceforge.net/p/loyc/code/HEAD/tree/Src/Loyc.Essentials/Collections/Interfaces/ISparseList.cs">sparse list interfaces</a> I defined: 
<pre>
  public interface ISparseListSource&lt;T> : IListSource&lt;T>
  {
    int? NextHigher(int index);
    int? NextLower(int index);
    bool IsSet(int index);
  }
  public partial class LCInterfaces
  {
    public static IEnumerable&lt;KeyValuePair&lt;int, T>> Items&lt;T>(
      this ISparseListSource&lt;T> list);
  }
  public interface ISparseList&lt;T>
    : ISparseListSource&lt;T>, IListAndListSource&lt;T>
  {
    void Clear(int index, int count = 1);
    void InsertSpace(int index, int count = 1);
  }
  public interface ISparseListEx&lt;T> 
    : ISparseList&lt;T>, IListEx&lt;T>, IAutoSizeArray&lt;T>
  {
    void InsertRange(ISparseListSource&lt;T> list);
  }
</pre>ISparseListSource is a read-only sparse list, while ISparseList is mutable and ISparseListEx additionally allows you to insert the contents of one entire sparse list into another. According to the definitions shown here, an ISparseList&lt;T> is fundamentally different from an IDictionary&lt;int, T> because when you insert or remove an item from a sparse list at index <tt>i</tt>, the index associated with each and every item above index <tt>i</tt> also changes. A Dictionary can't do that, while a good sparse list implementation can do it efficiently. <br/>
<br/>
The motivating example that led me to create these interfaces is the concept of anchor points in a text editor, such as the locations of error messages, breakpoints, and syntax highlighting markers. Clearly, this data is sparse: the majority of characters do not have an associated error message or color change, so ideally we should store this information in some sort of "compressed" data structure. As the user types new text in the middle of the file, all of these associated locations that appear in the second half should be shifted; that's what a sparse list does. Loyc.Collections offers one implementation if ISparseList&lt;T>, called <a href="https://sourceforge.net/p/loyc/code/HEAD/tree/Src/Loyc.Collections/ALists/SparseAList.cs">SparseAList&lt;T></a>. It is not always a fast data structure, but it scales up effectively to very large files. <br/>
<br/>
Next up, here are the <a href="https://sourceforge.net/p/loyc/code/HEAD/tree/Src/Loyc.Essentials/Collections/Interfaces/Queue%20interfaces.cs">IQueue, IStack and IDeque interfaces</a>, with associated extension methods for added convenience, which are mostly self-explanatory if you know what queues and stacks are: 
<pre>
  public interface IPush&lt;in T>
  {
    void Push(T item);
  }
  
  public interface IPop&lt;out T>
  {
    T TryPop(out bool isEmpty);
    T TryPeek(out bool isEmpty);
    bool IsEmpty { get; }
  }
  public static partial class LCInterfaces
  {
    public static T Pop&lt;T>(this IPop&lt;T> c);
    public static T Peek&lt;T>(this IPop&lt;T> c);
    public static bool TryPop&lt;T>(this IPop&lt;T> c, out T value);
    public static bool TryPeek&lt;T>(this IPop&lt;T> c, out T value);
    public static T TryPop&lt;T>(this IPop&lt;T> c);
    public static T TryPop&lt;T>(this IPop&lt;T> c, T defaultValue);
    public static T TryPeek&lt;T>(this IPop&lt;T> c);
    public static T TryPeek&lt;T>(this IPop&lt;T> c, T defaultValue);
  }
  
  public interface IQueue&lt;T> : IPush&lt;T>, IPop&lt;T>, ICount
  {
  }
  public interface IStack&lt;T> : IPush&lt;T>, IPop&lt;T>, ICount
  {
  }
  
  public interface IDeque&lt;T>: ICount, IIsEmpty
  {
    void PushFirst(T item);
    void PushLast(T item);
    T TryPopFirst(out bool isEmpty);
    T TryPeekFirst(out bool isEmpty);
    T TryPopLast(out bool isEmpty);
    T TryPeekLast(out bool isEmpty);

    T First { get; set; }
    T Last { get; set; }
    bool IsEmpty { get; }
  }

  public static partial class LCInterfaces
  {
    public static T PopFirst&lt;T>(this IDeque&lt;T> c)
    public static T PopLast&lt;T>(this IDeque&lt;T> c)
    public static T PeekFirst&lt;T>(this IDeque&lt;T> c)
    public static T PeekLast&lt;T>(this IDeque&lt;T> c)
    public static bool TryPopFirst&lt;T>(this IDeque&lt;T> c, out T value)
    public static bool TryPopLast&lt;T>(this IDeque&lt;T> c, out T value)
    public static bool TryPeekFirst&lt;T>(this IDeque&lt;T> c, out T value)
    public static bool TryPeekLast&lt;T>(this IDeque&lt;T> c, out T value)
    public static T TryPopFirst&lt;T>(this IDeque&lt;T> c)
    public static T TryPopFirst&lt;T>(this IDeque&lt;T> c, T defaultValue)
    public static T TryPopLast&lt;T>(this IDeque&lt;T> c)
    public static T TryPopLast&lt;T>(this IDeque&lt;T> c, T defaultValue)
    public static T TryPeekFirst&lt;T>(this IDeque&lt;T> c)
    public static T TryPeekFirst&lt;T>(this IDeque&lt;T> c, T defaultValue)
    public static T TryPeekLast&lt;T>(this IDeque&lt;T> c)
    public static T TryPeekLast&lt;T>(this IDeque&lt;T> c, T defaultValue)
  }
</pre>Currently IQueue and IStack are not being used, but IDeque&lt;T> is implemented by <a href="https://sourceforge.net/p/loyc/code/HEAD/tree/Src/Loyc.Essentials/Collections/Implementations/DList.cs">DList&lt;T></a>.  Next up, here are the <i>sink interfaces</i>, which let you put data in but not take it out. 
<pre>
  /// &lt;summary>An interface for depositing items. Includes only an Add(T) method.&lt;/summary>
  public interface IAdd&lt;in T>
  {
    void Add(T item);
  }
  /// &lt;summary>Represents a write-only collection: you can modify it, but you
  /// cannot learn what it contains.&lt;/summary>
  public interface ISinkCollection&lt;in T> : IAdd&lt;T>
  {
    void Clear();
    bool Remove(T item);
  }
  /// &lt;summary>Represents a write-only array.&lt;/summary>
  public interface ISinkArray&lt;in T>
  {
    T this[int index] { set; }
  }
  /// &lt;summary>Represents a write-only indexable list class.&lt;/summary>
  public interface ISinkList&lt;in T> : ISinkCollection&lt;T>, ISinkArray&lt;T>
  {
  }
</pre>These interfaces are not often useful, but sometimes people actually do write code that only modifies a collection, without reading it. One useful property of these interfaces is <i>contravariance</i>: if a method needs an ISinkCollection&lt;Foo> for example, you can pass it a ISinkCollection&lt;object> instead. <br/>
<br/>
Here's an interface that models built-in arrays: 
<pre>
  public interface IArray&lt;T> : IListSource&lt;T>, ISinkArray&lt;T>
  {
    new T this[int index] { get; set; }
    bool TrySet(int index, T value);
  }
  public interface IAutoSizeArray&lt;T> : IArray&lt;T>
  {
    void Optimize();
  }
</pre>But of course, since T[] does not implement IArray, it's not very useful and is only included for completeness. The derived interface is a little more interesting: it represents a list whose size increases automatically when you write to an index beyond the end of the array. If supported, the Optimize() method optimizes the data structure to consume less storage space (if not supported, it has no effect.) <br/>
<br/>
Next, here are some interfaces that add or remove items "in bulk": 
<pre>
  public interface IAddRange&lt;T> : ICount
  {
    void AddRange(IEnumerable&lt;T> e);
    void AddRange(IReadOnlyCollection&lt;T> s);
  }
  public interface IListRangeMethods&lt;T> : IAddRange&lt;T>
  {
    void InsertRange(int index, IEnumerable&lt;T> e);
    void InsertRange(int index, IReadOnlyCollection&lt;T> s);
    void RemoveRange(int index, int amount);
  }
  public static partial class LCInterfaces
  {
    public static void Resize&lt;T>(
      this IListRangeMethods&lt;T> list, int newSize);
  }
</pre>It's often more efficient to use a bulk insertion or deletion method rather than calling Insert or RemoveAt in a loop. <br/>
<br/>
Next up, here are some interfaces that are used to work around the dreaded ambiguity errors that are caused by the fact that ICollection&lt;T> is officially unrelated to IReadOnlyCollection&lt;T>, and the fact that IList&lt;T> is officially unrelated to IReadOnlyList&lt;T>: 
<pre>
  public interface ICollectionAndReadOnly&lt;T> 
    : ICollection&lt;T>, IReadOnlyCollection&lt;T> { }
  public interface IListAndListSource&lt;T> : IList&lt;T>, 
    IListSource&lt;T>, ICollectionAndReadOnly&lt;T>  { }
</pre>Any collection that implements both ICollection&lt;T> and IReadOnlyCollection&lt;T> should implement ICollectionAndReadOnly&lt;T>, and any collection that implements both IList&lt;T> and IReadOnlyList&lt;T> should go the extra mile and implement IListAndListSource&lt;T>. <br/>
<br/>
By itself, these interfaces don't solve any problems. To recap, if you write these two methods: 
<pre>
  void Foo(IReadOnlyList&lt;T> list) {...}
  void Foo(IList&lt;T> list) { Foo(list.AsListSource()); }
</pre>The C# compiler will give an "ambiguity" error when you try to call <tt>Foo(list)</tt>, if the list implements both IList&lt;T> and IReadOnlyList&lt;T>. To work around this problem, it is necessary to define a third method that takes IListAndListSource&lt;T>: 
<pre>
  void Foo(IReadOnlyList&lt;T> list) {...}
  void Foo(IList&lt;T> list) { Foo(list.AsListSource()); }
  void Foo(IListAndListSource&lt;T> list) { Foo((IReadOnlyList&lt;T>) list); }
</pre>This workaround only works if the list class implements IListAndListSource&lt;T>, so all mutable collections in Loyc.Essentials and Loyc.Collections do so. <br/>
<br/>
Next, here are some "enhanced" collection interfaces, which just add extra functionality to the standard interfaces. ICollectionEx combines ICollection with AddRange(list) and RemoveAll(lambda), while IListEx combines IList with ICollectionEx, InsertRange(index, list) and RemoveRange(index, count): 
<pre>
  public interface ICollectionEx&lt;T> : ICollectionAndReadOnly&lt;T>, 
      ISinkCollection&lt;T>, IAddRange&lt;T>, IIsEmpty { }
  {
    int RemoveAll(Predicate&lt;T> match);
  }
  public interface IListEx&lt;T> : IListAndListSource&lt;T>, 
    ICollectionEx&lt;T>, IArray&lt;T>, IListRangeMethods&lt;T> { }
</pre> <i><a href="http://sourceforge.net/p/loyc/code/HEAD/tree/Src/Loyc.Essentials/Collections/Interfaces/New%20enumerators.cs">Binumerators</a></i> are enumerators that can move backward through a collection, not just forward. The IBinumerable interface can be implemented by a collection that supports binumerators. Mutable enumerators additionally allow elements of the collection to be modified during enumeration. Mutable enumerators <i>optionally</i> support removing the current element.  
<pre>
public interface IBinumerator&lt;T> : IEnumerator&lt;T>
{
  bool MovePrev();
}

interface IMEnumerator&lt;T> : IEnumerator&lt;T>
{
  /// &lt;summary>Gets or sets the value of the current item.&lt;/summary>
  new T Current { get; set; }
  /// &lt;summary>Removes the current item and moves to the next one. Remember
  /// NOT to call MoveNext() immediately after Remove().&lt;/summary>
  /// &lt;returns>True if there is a next item after this one, 
  /// false if the removed item was the last one.&lt;/returns>
  /// &lt;exception cref="NotSupportedException">The collection does not permit
  /// this operation.&lt;/exception>
  bool Remove();
}

interface IMBinumerator&lt;T> : IBinumerator&lt;T>, IMEnumerator&lt;T>
{
}

interface IBinumerable&lt;T>
{
  /// &lt;summary>Returns a binumerator that points before the beginning of 
  /// the current collection.&lt;/summary>
  IBinumerator&lt;T> Begin();
  /// &lt;summary>Returns a binumerator that points after the end of the 
  /// current collection.&lt;/summary>
  IBinumerator&lt;T> End();
}
</pre> Finally, here are the range interfaces, which were inspired by the D programming language. These were described in a <a href="http://www.codeproject.com/Articles/604345/D-styleplusrangesplusinplusC-23plus-NET">much earlier article</a> but I tweaked the interfaces after that article was written. You can see the current documentation in the <a href="https://sourceforge.net/p/loyc/code/HEAD/tree/Src/Loyc.Essentials/Collections/Interfaces/IRanges.cs">source code</a>; I won't say anything more about these interfaces here, since this article is getting pretty long already.  
<pre>
  public interface IFRange&lt;out T> : IEnumerable&lt;T>,
    ICloneable&lt;IFRange&lt;T>>, IIsEmpty
  {
    T Front { get; }
    T PopFront(out bool fail);
  }
  public interface IMFRange&lt;T> : IFRange&lt;T>
  {
    new T Front { get; set; }
  }
  public interface IBRange&lt;out T> : IFRange&lt;T>,
    ICloneable&lt;IBRange&lt;T>>
  {
    T Back { get; }
    T PopBack(out bool fail);
  }
  public interface IMBRange&lt;T> : IBRange&lt;T>, IMFRange&lt;T>
  {
    new T Back { get; set; }
  }
  public interface IRange&lt;out T> : IBRange&lt;T>,
    IListSource&lt;T>, ICloneable&lt;IRange&lt;T>>
  {
  }
  public interface IBRangeEx&lt;R, T> : IBRange&lt;T> 
    where R : IBRangeEx&lt;R, T>, ICloneable&lt;R>
  {
    IEnumerable&lt;T> InnerList { get; }
    int SliceStart { get; }
    R Intersect(R other);
    R Union(R other);
  }
  public interface IBRangeEx&lt;T> : IBRangeEx&lt;IBRangeEx&lt;T>, T>, 
    ICloneable&lt;IBRangeEx&lt;T>>
  {
  }
  public interface IRangeEx&lt;R, T> : IRange&lt;T>, 
    IBRangeEx&lt;R, T> where R : IRangeEx&lt;R, T>, ICloneable&lt;R>
  {
  }
  public interface IRangeEx&lt;T> : IRangeEx&lt;IRangeEx&lt;T>, T>, 
    ICloneable&lt;IRangeEx&lt;T>>
  {
  }
  public interface IMRange&lt;T> : IMBRange&lt;T>, IRange&lt;T>
  {
    new T this[int index] { get; set; }
  }
</pre>That's it! That's all the general-purpose collection interfaces.  <h4>Performance: one flaw I didn't fix</h4> It bothers me that the IEnumerator&lt;T> interface requires two interface calls to retrieve each element of a collection: MoveNext() and Current. That's just a pointless waste of clock cycles. In the past, I defined an interface that fixes that problem by moving to the next item and returning it with a single method call. It was called Iterator&lt;T> and it was a delegate (alternate possible design: a derived interface of IEnumerator&lt;T>): 
<pre>
  public delegate T Iterator&lt;out T>(ref bool fail);
</pre>Note that I really would have preferred to use the signature <tt>bool Iterator&lt;T>(out T value)</tt> instead, but .NET this second version of the method is illegal. Why? Unfortunately, the CLR actually doesn't have the concept of an "out" parameter; to the CLR, "out" and "ref" are the same thing. Therefore, type T would have to be invariant, &lt;out T> would not be allowed. The latter signature can still be provided as an extension method, at the cost of some performance. <br/>
<br/>
I actually wrote a whole implementation of LINQ for Iterator and IIterable&lt;T> (the counterpart to IEnumerable&lt;T>), but then I decided to abandon the concept before I got around to benchmarking the LINQ implementation (early microbenchmarks showed that <a href="http://loyc-etc.blogspot.ca/2011/04/iiterable-dilemma.html">IIterable was modestly faster</a> when called directly, but not when using the extension method). <br/>
<br/>
Ultimately I decided that I didn't want to burden potential implementors of collection classes by including IIterable&lt;T> in the interface hierarchy. that is, it seemed natural to derive other interfaces such as IListSource&lt;T> from IIterable&lt;, but this placed a substantial burden on my collection class implementations, and might have confused end-users. Obviously, if you're writing a collection class, you want to support things like <tt>foreach</tt> loops and traditional LINQ, so you will definitely implement IEnumerable&lt;T>; IIterable&lt;T> can only be a bonus, not the central mechanism of enumeration. Then you have the dillema of whether to optimize your code for IEnumerable&lt;T> or IIterable&lt;T>, plus there's the fact that <a href="http://msdn.microsoft.com/en-us/library/dscyy5s0.aspx">C#'s iterator feature</a> supports only IEnumerator, not Iterator. So I found that the implementation costs for Iterator tended to be high, while few people would appreciate or take advantage of the performance enhancement. <br/>
<br/>
For certain applications that need <b>both</b> high performance and flexibility, another technique for avoiding interface calls makes sense: returning data in groups, such as arrays. Consider this method of ICollection&lt;T> that is almost never used: 
<pre>
  void CopyTo(T[] array, int arrayIndex);
</pre>Imagine that method was gone and replaced with this method in IList: 
<pre>
  // copy this[startIndex..startIndex+count] to array[arrayIndex..arrayIndex+count]
  void CopySlice(T[] array, int arrayIndex, int startIndex, int count);
</pre>Now you would have a technique for optimizing access when you need it. Rather than requesting the <i>entire</i> list as an array, which requires unbounded memory, you request a section. How can this be used to optimize a program? Well, you can read the list in small blocks, e.g., 50 elements at a time. Then you can use a for-loop like this one: 
<pre>
  for (int i = 0; i < array.Length; i++) {
    /* do something with array[i] */
  }
</pre>which avoids the cost of (1) interface calls and (2) bounds checking (the JIT eliminates the bounds check in a loop that is structured this way), in exchange for the need to allocate a small temporary array (which is usually cheap). Obviously, this is not a convenient way to access a list; again, this would only be for the (rare?) situation that calls for high performance, but still requires the flexibility of interfaces (so you can swap in multiple implementations). <br/>
<br/>
For <a href="http://loyc.net">Loyc</a>, I decided to define a specialized interface for lexers: 
<pre>
public interface ICharSource : IListSource&lt;char>
{
  /// &lt;summary>
  /// Returns a substring from the character source. If some of the
  /// requested characters are past the end of the stream, the string
  /// is truncated to the available number of characters.
  /// &lt;/summary>
  /// &lt;param name="startIndex">Index of first character to return.
  /// If startIndex >= Count, an empty string is returned.&lt;/param>
  /// &lt;param name="length">Number of characters desired.&lt;/param>
  new StringSlice Slice(int startIndex, int length);
}
</pre>This interface was created to read characters efficiently. Although a lexer could read characters one-at-a-time from IReadOnlyList&lt;char> or IListSource&lt;char>, it requires at least one dynamic interface dispatch for every character (multiple, if the lexer reads the same character more than once). On the other hand, if lexers avoid this overhead by requiring the entire file in the form of a string, it becomes necessary to hold the entire file in memory at once, in a very specific format (one huge string), which may not be ideal. <br/>
<br/>
<tt>StringSlice</tt> is a structure in Loyc.Essentials that represents a slice of a string (a tuple of <tt>(string str, int startIndex, int length)</tt>). Slice() is a compromise that allows the lexer to request small pieces of the file that it can read without dynamic dispatch. If the file happens to be stored as a string, Slice() can simply return a slice of that string (no memory allocation required), otherwise it will build a string and return that. <br/>
<br/>
It's unfortunate that .NET treats strings as something completely different than arrays. In a perfect world (or in D), an interface like this one could support not just substrings, but read-only subarrays of any element type, which would be useful any time you want to optimize your code by reducing dynamic dispatch.  <h4>By the way: we're doing it wrong.</h4> Defining zillions of interfaces isn't the best solution. <br/>
<br/>
As I said, the possible combinations of operations that data structures may or may not support is just about endless. Some may support adding items but not removing; others may support removing but not adding; some lists may be read-only but have a specialized, fast IndexOf() method (recall that IListSource&lt;T> does not include IndexOf()). It would be crazy to define a separate interface, and invent a separate name, for every possible combination of operations. Inevitably, there are some data structures for which Loyc.Essentials will offer no appropriate interface. But in .NET, that's inevitable. <br/>
<br/>
My favorite thing about the <a href="http://golang.org/">Go language</a> (which, admittedly, I haven't actually used) is the way they do interfaces. In Go, a data structure does not have to explicitly declare in advance every interface it satisfies. Instead, a data structure can satisfy any interface defined by a third party if it provides the necessary operations. If .NET worked like this, then it wouldn't matter that List&lt;T> does not <i>say</i> it implements IReadOnlyList&lt;T>; you would still be allowed to pass it to a method that takes IReadOnlyList&lt;T>. <br/>
<br/>
So, suppose I define an indexable data structure that supports add-at-the-end, but no other modifications. Then I could define an interface that exactly matches my data structure: 
<pre>
interface IAppendableList&lt;T> : IReadOnlyList&lt;T> { void Add(T item); }

class GuestBook : IAppendableList&lt;GuestEntry> { ... }
</pre> Later, someone else who is using MyDataStructure&lt;T> in their code could decide to declare a method that accepts IAppendableList&lt;T>:  
<pre>
void Foo(IAppendableList&lt;T> x) { ... }
</pre> We can tell that Foo() will probably add items to x, but won't remove items. If .NET supported Go's ability to adapt to new interfaces with almost no extra run-time cost, it would not only accept an argument of type <tt>GuestBook</tt>, but it would also accept any of the standard collection classes like List&lt;T>. Nice. This feature could neatly fix flaws 2 and 3 above, even if Microsoft itself never defined any read-only or specialized interfaces. <br/>
<br/>
IMO, this is how it should be, and I would point out that by not supporting this feature, it is not practical for .NET as a platform to support languages like Go that do support it (so much for being a "common language runtime"). Now, I assume we can't add this feature <i>directly</i> to C# because it would break existing code, but the feature could still be supported in .NET itself, if Microsoft had the willpower. <br/>
<br/>
Some people argue against this feature, saying that an "interface" is more than just a set of methods but a contract for how those methods behave. And in Loyc.Essentials itself you'll see two interfaces that reflect that idea: 
<pre>
public interface IQueue&lt;T> : IPush&lt;T>, IPop&lt;T>, ICount
{
}
public interface IStack&lt;T> : IPush&lt;T>, IPop&lt;T>, ICount
{
}
</pre>The way I defined queues and stacks is that both of them have the same methods--pushing, popping, and Count--but because they behave quite differently, I defined two separate interfaces. So the argument against "Go interfaces" makes sense, but in my opinion their advantages clearly outweigh the disadvantages, and anyway the feature <i>already exists</i> in some languages, so if Microsoft truly wants a many-language platform, they <i>must</i> make features like this possible, and efficient. <br/>
<br/>
Another argument in favor of Go interfaces is that they make it easier to satisfy dependencies. For example, I defined ICharSource inside Loyc.Essentials even though the interface was designed for lexers (which suggests Loyc.Syntax.dll would be a better place for it), because Loyc.Essentials contains StringSlice and I wanted StringSlice to implement ICharSource. Since Loyc.Syntax depends on Loyc.Essentials, the only way this can work is if ICharSource is part of Loyc.Essentials. Luckily I control both DLLs, otherwise StringSlice could not implement ICharSource. <br/>
<br/>
In general, I find it to be a big nuisance that when two DLLs define identical interfaces, with the same name in the same namespace, the CLR considers them completely unrelated and incompatible, and there is no workaround. If two DLLs want to implement the same interface, they must always have a reference to a third DLL that contains the interface, and both DLLs must rely on the same <i>version</i> of that third DLL even if the interface in question is identical across different versions. The Go approach gets you out of versioning hell (at least it would in the .NET context. Whether Go itself has a similar issue, I have no idea). But I digress...  <h4>Conclusion.</h4> Loyc.Essentials is a library of "stuff that should be in the BCL, but isn't." Although it was created for the <a href="http://loyc.net">Loyc</a> project, it is meant as a general-purpose library for any developer's .NET toolbox. If there's a general-purpose interface that you think should be part of the BCL, write it in a comment and we'll discuss whether it should be added to Loyc.Essentials.dll. <br/>
<br/>
Some of these interfaces are used heavily in Loyc, while others are not used at all. In future posts I'll introduce the other classes, structures, and handy methods of Loyc.Essentials.dll, and then I'll move on to Loyc.Collections.dll. <br/>
<br/>
<b>Edit</b>: I missed an interesting interface: <tt>IEnumeratorFrame&lt;Frame, T></tt>, which goes with the <tt>NestedEnumerator&lt;Frame, T></tt> structure, and is used for enumerating tree-like data structures or manually-implemented coroutines. See <a href="http://sourceforge.net/p/loyc/code/HEAD/tree/Src/Loyc.Essentials/Collections/HelperClasses/NestedEnumerator.cs">the code</a> if you're curious, although this interface would work best as part of a built-in compiler feature for stream flattening like <a href="http://research.microsoft.com/en-us/um/cambridge/projects/comega/doc/comega_whatis.htm">CÏ‰ had</a>.
{% endraw %}
