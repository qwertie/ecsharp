---
title: "Status update: Loyc tree rewritten"
layout: post
# Pulled from Blogger. Last updated there on: 2013-05-25
---
<small><p><i>This post was imported from <a href='http://loyc-etc.blogspot.com/2013/05/status-update-loyc-tree-rewritten.html'>blogspot</a>.</i></p></small>
{% raw %}
I have made and implemented the changes that I planned to make to the Loyc tree. The code was rewritten from scratch; the new code is not as fancy or complete, but it's easier to use. <ul>
<li>Red nodes are gone (and GreenNode is now called LNode, for "Loyc Node")</li>
<li>Mutable nodes are gone, and the data type for Args and Attrs has changed to RVList&lt;T> (<a href="http://www.codeproject.com/Articles/26171/VList-data-structures-in-C">Reverse V-List</a>--since this tends to make people think of Recreational Vehicles, I'm thinking about changing the name to simply VList, with the forward VList still being named FVList). RVList provides a natural way to support the common pattern of gathering a list of statements and then freezing them into a read-only node; you can create a list with RWList&lt;LNode>, mutate it however you like (similar performance to List&lt;T>), and then when the list is complete, call ToRVList() to convert it to RVList&lt;LNode> instantly.</li>
<li>There are now three kinds of nodes: symbols (now called Ids, i.e. identifiers), literals, and calls. I'm considering whether to add a fourth type for nodes that have both a name and a value, perhaps calling it the Token kind (StdTriviaNode already has both a Name and Value, but it is currently a subclass of StdIdNode.).</li>
<li>An empty Name is now allowed. A literal now has a blank name (instead of #literal) and a method that calls anything other than a simple symbol will also have a blank Name. Note: the <see cref="Name"/> property will still never return null.</li>
<li>I decided to represent expressions in parenthesis using a call with the empty target @``, that is, the empty identifier. But now I am considering whether to eliminate the representation of parenthesis completely, because it's a significant inconvenience for node printers: if parenthesis are represented explicitly, a printer cannot add parenthesis to clarify precedence without changing the syntax tree. So far the EC# printer has managed to avoid adding parenthesis in almost all cases, but there's still the issue of "tightly bound attributes": if the "f" part of "f(x)" has an attribute, it must be printed with the special "grouping parenthesis", ##(), as in ##([attr] f)(x). It's clunky, but it works*. But now I'm designing another language (more on that in my next post) and I haven't figured out what to do about this yet. Perhaps I should just define an exception where "the parenthesis don't count if there are attributes inside"; we'll see.</li><div class="sidebox">* ##() is also used in constructor disambiguation. In "class Foo { ##(Foo()); }", Foo() is a method call rather than a constructor declaration.</div>
</ul>During the redesign I decided on some small changes to the representation of certain expressions in EC#: <ul>
<li>The '.' operator is now treated more like a normal binary operator;   <c>a.b.c</c> is now represented <c>#.(#.(a, b), c)</c> rather than   <c>#.(a, b, c)</c> mainly because it's easier that way, and because the   second representation doesn't buy anything significant other than a   need for special-casing.</li>
<li><c>int x = 0</c> will now be represented <c>#var(int, x = 0)</c> rather than <c>#var(int, x(0))</c>. I chose the latter representation   initially because it is slightly more convenient, because you can   always learn the name of the declared variable by calling   <c>var.Args[1].Name</c>. However, I decided that it was more important  for the syntax tree to be predictable, with obvious connections between  normal and prefix notations. Since I decided that <c>alias X = Y;</c>   was to be represented <c>#alias(X = Y, #())</c>, it made sense for the   syntax tree of a variable declaration to also resemble its C# syntax.   There's another small reason: C++ has both styles <c>Foo x(y)</c> and   <c>Foo x = y</c>; if Loyc were to ever support C++, it would make sense   to use <c>#var(Foo, x(y))</c> and <c>#var(Foo, x = y)</c> for these two   cases, and I believe C#'s variable declarations are semantically closer   to the latter. (Note: another possibility was #var(int, x) = 0, but I   decided this wasn't an improvement, it would just shift the pain around.)</li>
<li>An constructor argument list is required on <i>all</i> types using the #new  operator, e.g. <c>new int[] { x }</c> must have an empty set of arguments  on int[], i.e. <c>#new(#of(#[],int)(), x)</c>; this rule makes the   different kinds of new expressions easier to interpret by making them   consistent with each other.</li>
<li>A missing syntax element is now represented by an empty symbol instead   of the symbol #missing.</li>
<li>I've decided to adopt the "in-expression" generics syntax from Nemerle   as an unambiguous alternative to angle brackets: List.[int] means   List&lt;int> and the printer will use this syntax in cases where angle   brackets are ambiguous.</li>
<li>By popular demand, constructors will be written this(...) instead  of new(...), since both D and Nemerle use the latter notation.</li>
<li>The \ and $ characters have been swapped; \S now denotes a symbol S,  while $S now denotes a substitution. Originally EC# was designed just         as an extension of C#, so \ made sense as a substitution operator for         string interpolation because it doesn't hurt backward compatibility:         "Loaded '\(filename)' successfully". But now that my focus has shifted          to multi-language interoperability, $ makes more sense, as it is used          for string interpolation in at least five other languages and it makes         sense to use the same character for both string substitution and code         substitution.</li>
</ul>LLLPG is also improved; I have implemented two more major features: <ul>
<li>Implemented support for terminals of unknown value. I observed that if the inputs are integers (or enums) LLLPG shouldn't have to know the actual integer value of each integer. The user should be able to use a symbolic name like "NUMBER" or "DQString" without actually telling LLLPG what the value is. So I eliminated the code-snippet generator for Symbols and replaced it with GeneralCodeGenHelper, which supports inputs of any data type: integers, enums, Symbols, strings, whatever. Note that switch() statements require constant cases, so switch() must be disabled for non-constant possibilities such as Symbols. A constructor argument controls whether  GeneralCodeGenHelper is allowed to generate switch() statements (ideally individual terminal symbols could be marked constant or non-constant, but a global switch will suffice for now.)</li>
<li>Replaced redundant Match() calls with Skip(), i.e. if prediction learns that "LA(0) is in the set ('0'..'9')"  then a test like MatchRange('0', '9', '.', '.') is redundant and can be replaced by Skip(). Also, I eliminated redundant Check() calls. These two features together are called "prematch analysis".</li>
</ul>Only two major features are left and LLLPG 1.0 will be ready: <ul>
<li>Syntactic predicate support (only semantic predicates work right now)</li>
<li>Input from source code, and a command-line interface. Currently grammars have to be constructed with overloaded C# operators and printed at run-time, which of course is clumsy.</li>
</ul>
{% endraw %}
