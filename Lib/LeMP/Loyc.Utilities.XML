<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Loyc.Utilities</name>
    </assembly>
    <members>
        <member name="T:Loyc.Collections.AListStatisticTrackerBase`3">
            <summary>Base class that helps efficiently keep track of statistics about the 
            contents of one or more <see cref="T:Loyc.Collections.AListBase`2"/> objects (including derived 
            classes such as AList, BList, BDictionary and BMultiMap). Usually you'll use one of
            the derived classes instead, e.g. <see cref="T:Loyc.Collections.AListSumTracker`2"/>.</summary>
            <typeparam name="K">Key type of the AListBase</typeparam>
            <typeparam name="T">Value type of the AListBase</typeparam>
            <typeparam name="TSummary">Type of value that will be derived from the contents of the list(s)</typeparam>
            <remarks>
            This class keeps track of a "summary" of each node in each attached AList.
            It is assumed that there is some way to combine ("aggregate") summaries.
            For example, one common "summary" is the sum of a list of items, and 
            multiple summaries can be combined simply by adding them.
            <para/>
            This class can observe multiple lists at once and combine their results.
            </remarks>
        </member>
        <member name="T:Loyc.Collections.AListStatisticTracker`3">
            <summary>This class efficiently lets you keep track of simple commutative statistics 
            (such as total, average, sum of squares, and min/max) derived from the items of 
            <see cref="T:Loyc.Collections.AList`1"/> and its variants (BList, BDictionary, and BMultiMap).</summary>
            <remarks>
            Note: this class relies on the "tree observer" feature of ALists, but SparseAList 
            doesn't support tree observers as of 2020/01.
            <para/>
            Typically a statistic tracker is created by calling an extension method on AList, BList, etc.
            </remarks>
        </member>
        <member name="T:Loyc.Collections.AListStatisticTracker`2">
            <summary>This class incrementally updates a <see cref="P:Loyc.Collections.AListStatisticTracker`2.Statistic"/> object based on
            changes to <see cref="T:Loyc.Collections.AList`1"/> and its variants (BList, BDictionary, and BMultiMap).</summary>
        </member>
        <member name="T:Loyc.Collections.AListSumTracker`2">
            <summary>This class incrementally recomputes the sum of an <see cref="T:Loyc.Collections.AList`1"/> 
            (or its variants - BList, BDictionary, and BMultiMap).</summary>
        </member>
        <member name="M:Loyc.Collections.Impl.CPBitArrayLeaf`1.MoveFirst(Loyc.Collections.Impl.CPEnumerator{`0})">
            (1) Add()s an Entry to e.Stack pointing to the first (lowest) item in 
                the node, using e.Key.Offset as the value of Entry.KeyOffset;
            (2) extracts the key to e.Key such that e.Key.Offset+e.Key.Left is the
                length of the complete key (if e.Key.Buffer is too small, it is
                copied to a larger buffer as needed);
            (3) if the current item points to a child, this method advances e.Key 
                to the end of the key so that e.Key.Left is 0, and calls MoveFirst 
                on the child;
            (4) otherwise, this method leaves e.Key.Offset equal to
                e.Stack.Last.KeyOffset, so that e.Key.Left is the number of bytes
                of the key that are stored in this node.
        </member>
        <member name="T:Loyc.Collections.Impl.CPBNode`1">
            <summary>This CPTrie "bitmap" node splits the 8-bit alphabet space into 8
            buckets of 5 bytes each; a CPSNode is used to store the keys in each
            bucket.</summary>
            <typeparam name="T">Type of values associated with each key</typeparam>
        </member>
        <member name="F:Loyc.Collections.Impl.CPBNode`1._zlk">
            <summary>The value associated with a zero-length key, if any, is stored
            here directly rather than in any of the children.</summary>
        </member>
        <member name="T:Loyc.Collections.Impl.CPByteTrie`1">
            <summary>A compact patricia trie that uses byte arrays as keys.</summary>
            <typeparam name="TValue">Type of value associated with each key.</typeparam>
        </member>
        <member name="M:Loyc.Collections.Impl.CPByteTrie`1.Add(System.Byte[],`0)">
            <summary>Adds the specified key-value pair to the trie, throwing an
            exception if the key is already present.</summary>
        </member>
        <member name="M:Loyc.Collections.Impl.CPByteTrie`1.Add(System.Byte[],System.Int32,System.Int32,`0)">
            <summary>Adds the specified key-value pair to the trie, throwing an
            exception if the key is already present.</summary>
            <param name="key">An array that contains the key to add. The offset
            and length parameters specify a substring of this array to use as the key.</param>
        </member>
        <member name="M:Loyc.Collections.Impl.CPByteTrie`1.TryAdd(System.Byte[],`0)">
            <summary>Adds the specified key-value pair only if the specified key is
            not already present in the trie.</summary>
            <param name="value">A value to associate with the specified key if the
            key does not already exist.</param>
            <returns>Returns true if the key-value pair was added or false if
            the key already existed. In the false case, the trie is not modified.</returns>
        </member>
        <member name="M:Loyc.Collections.Impl.CPByteTrie`1.TryAdd(System.Byte[],System.Int32,System.Int32,`0@)">
            <summary>Adds the specified key-value pair only if the specified key is
            not already present in the trie.</summary>
            <param name="key">An array that contains the key to find. The offset
            and length parameters specify a substring of this array to use as the key.</param>
            <param name="value">On entry, value specifies the value to associate
            with the specified key, but if the key already exists, value is changed
            to the value associated with the existing key.</param>
            <returns>Returns true if the key-value pair was added or false if
            the key already existed. In the false case, the trie is not modified.</returns>
        </member>
        <member name="M:Loyc.Collections.Impl.CPByteTrie`1.ContainsKey(System.Byte[])">
            <summary>Searches for the specified key, returning true if it is
            present in the trie.</summary>
        </member>
        <member name="M:Loyc.Collections.Impl.CPByteTrie`1.ContainsKey(System.Byte[],System.Int32,System.Int32)">
            <summary>Searches for the specified key, returning true if it is
            present in the trie.</summary>
            <param name="key">An array that contains the key to find. The offset
            and length parameters specify a substring of this array to use as the key.</param>
        </member>
        <member name="M:Loyc.Collections.Impl.CPByteTrie`1.Remove(System.Byte[])">
            <summary>Removes the specified key and associated value, returning true
            if the entry was found and removed.</summary>
        </member>
        <member name="M:Loyc.Collections.Impl.CPByteTrie`1.Remove(System.Byte[],System.Int32,System.Int32,`0@)">
            <summary>Removes the specified key and associated value, returning true
            if the entry was found and removed.</summary>
            <param name="key">An array that contains the key to find. The offset
            and length parameters specify a substring of this array to use as the key.</param>
            <param name="oldValue">If the key is found, the associated value is
            assigned to this parameter. Otherwise, this parameter is not changed.</param>
        </member>
        <member name="M:Loyc.Collections.Impl.CPByteTrie`1.TryGetValue(System.Byte[],`0@)">
            <summary>Finds the specified key and gets its associated value,
            returning true if the key was found.</summary>
        </member>
        <member name="P:Loyc.Collections.Impl.CPByteTrie`1.Item(System.Byte[],`0)">
            <summary>Finds the specified key and returns its associated value. If 
            the key did not exist, TryGetValue returns defaultValue instead.</summary>
        </member>
        <member name="T:Loyc.Collections.Impl.CPIntTrie`1">
            <summary>A trie that supports signed and unsigned keys with sizes up to 64
            bits. Special encodings are used to preserve the sort order among integers
            of different sizes while using variable-length keys.</summary>
            <typeparam name="TValue">Type of value associated with each key.</typeparam>
            <remarks>This trie allows you to insert integers of different sizes. Two
            integers of different sizes that have the same value are considered
            equivalent. You can insert a key as an Int16, then extract it as an Int32,
            for example.
            <para/>
            This collection implements two versions of IDictionary: one using Int32
            keys and another using Int64 keys. When calling a method on the class
            itself (i.e. not on an interface), Int64 is used in case of ambiguity (for
            example, GetEnumerator() doesn't know if you want to decode the keys into
            Int32 or Int64, so it uses Int64.) When not accessing CPIntTrie through an
            interface, most methods accept any of the following integer types: Int16,
            UInt16, Int32, UInt32, Int64, UInt64.
            <para/>
            The trie does not choose the key length based on an integer's size (e.g.
            Int32 or Int64), rather it is chosen based on the key's magnitude. Keys
            ranging from -0x10000 to 0xFAFFFF are encoded most compactly (usually in one
            4-byte cell); 40-bit keys as low as -0xFFFFFFFFFF and as high as
            0xFFFFFFFFFF are usually encoded in 2 cells; and all larger keys require 3 
            cells.
            <para/>
            I say "usually" because normally CPSNode can hold 3 bytes per cell, but
            keys whose low-order byte is 0xFD, 0xFE or 0xFF require one extra cell.
            <para/>
            Negative 64-bit numbers can be held in the same trie as unsigned 64-bit 
            numbers; therefore, there is no way to represent all keys using a single
            primitive data type. The LongEnumerator returns Int64s, and you will find 
            that if a huge unsigned number like 0x8877665544332211 is in the trie, it 
            will come out as a negative Int64. To find out whether the long number is 
            signed or unsigned, call ContainsKey(Int64) - if it returns true, the
            number is signed, otherwise it is unsigned (so its signed representation
            was not found). If it is unsigned, convert the key returned by the
            enumerator to UInt64.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.Impl.CPIntTrie`1.TryAdd(System.Int32,`0)">
            <summary>Adds the specified key-value pair only if the specified key is
            not already present in the trie.</summary>
            <param name="value">A value to associate with the specified key if the
            key does not already exist.</param>
            <returns>Returns true if the key-value pair was added or false if
            the key already existed. In the false case, the trie is not modified.</returns>
        </member>
        <member name="M:Loyc.Collections.Impl.CPIntTrie`1.TryAdd(System.Int32,`0@)">
            <summary>Adds the specified key-value pair only if the specified key is
            not already present in the trie.</summary>
            <param name="value">On entry, value specifies the value to associate
            with the specified key, but if the key already exists, value is changed
            to the value associated with the existing key.</param>
            <returns>Returns true if the key-value pair was added or false if
            the key already existed. In the false case, the trie is not modified.</returns>
        </member>
        <member name="M:Loyc.Collections.Impl.CPIntTrie`1.Add(System.Int32,`0)">
            <summary>Adds the specified key-value pair to the trie, throwing an
            exception if the key is already present.</summary>
        </member>
        <member name="M:Loyc.Collections.Impl.CPIntTrie`1.ContainsKey(System.Int32)">
            <summary>Searches for the specified key, returning true if it is
            present in the trie.</summary>
        </member>
        <member name="M:Loyc.Collections.Impl.CPIntTrie`1.Remove(System.Int32)">
            <summary>Removes the specified key and associated value, returning true
            if the entry was found and removed.</summary>
        </member>
        <member name="M:Loyc.Collections.Impl.CPIntTrie`1.Remove(System.Int32,`0@)">
            <summary>Removes the specified key and associated value, returning true
            if the entry was found and removed.</summary>
            <param name="key">Key to remove.</param>
            <param name="oldValue">If the key is found, the associated value is
            assigned to this parameter. Otherwise, this parameter is not changed.</param>
        </member>
        <member name="M:Loyc.Collections.Impl.CPIntTrie`1.TryGetValue(System.Int32,`0@)">
            <summary>Finds the specified key and gets its associated value,
            returning true if the key was found.</summary>
        </member>
        <member name="P:Loyc.Collections.Impl.CPIntTrie`1.Item(System.Int32,`0)">
            <summary>Finds the specified key and returns its associated value. If 
            the key did not exist, returns defaultValue instead.</summary>
        </member>
        <member name="T:Loyc.Collections.Impl.SCell">
            <summary>Standard cell, used to encode keys in a CPSNode</summary>
        </member>
        <member name="T:Loyc.Collections.Impl.CPSNode`1">
            <summary>This CPTrie "sparse" or "standard" node stores up to 34 keys or
            partial keys and their associated values. See my CPTrie article on 
            CodeProject.com for more information.</summary>
            <typeparam name="T">Type of values associated with each key</typeparam>
        </member>
        <member name="M:Loyc.Collections.Impl.CPSNode`1.PrepareSpace(System.Int32,Loyc.Collections.Impl.CPNode{`0}@)">
            <summary>
            Makes sure there is a free cell at _count, and that there are enough 
            free cells for a new key of the specified length. Child node(s) are 
            created if necessary; in the worst case, the whole node is converted
            to a bitmap node.
            </summary>
            <param name="keyLeft"></param>
            <param name="self"></param>
            <returns>Returns the first index affected by any modifications, or -1 
            if 'self' changed</returns>
            <remarks>
            Sparse nodes are "reorganized" when they run out of free space, when
            Count reaches MaxCount, or when the number of values reaches 32.
            <para/>
            Well, actually if we run out of free space we can either reorganize, or
            allocate more space, unless the number of cells reaches MaxCells.
            <para/>
            Another problem that this method must address is what to do if there are
            enough free cells, but the cell at _count is in use. This problem only 
            occurs if there is fragmentation in the free cell list.  In that case an
            O(_count+_extraCellsUsed) scan would be needed to find who is using the 
            cell and relocate it, but it's easier (and not much slower) just to do 
            the same compaction process that is done when enlarging _cells.
            <para/>
            Compaction moves all free cells to the middle of the array, which helps
            ensure that when _count needs to increase, _cells[_count] is free.
            <para/>
            There are two "reorganizing" options:
            1. Create a child node to free up space (can be done repeatedly)
            2. Convert this node to a JPBitmap node (TODO)
            <para/>
            </remarks>
        </member>
        <member name="M:Loyc.Collections.Impl.CPSNode`1.ExtractKey(System.Int32,Loyc.Collections.Impl.KeyWalker@,System.Int32@)">
            <summary>Appends the key at the specified index to kw, allocating new 
            buffer space if needed.</summary>
            <param name="index">Index of the key to extract</param>
            <param name="kw">The key is written to kw starting at kw.Buffer[kw.Offset]</param>
            <param name="finalP">The value of LCell.P in the key's final cell.</param>
            <remarks>kw.Left is 0 on exit.</remarks>
        </member>
        <member name="M:Loyc.Collections.Impl.CPSNode`1.FindCommonPrefix(System.Int32@,System.Int32@,System.Int32@)">
            <summary>Finds the "best" common prefix to factor out into a child node.</summary>
            <param name="bestIndex">First index of a range of items with a common prefix</param>
            <param name="bestLength">Number of items with a common prefix (minimum 2)</param>
            <param name="bestPrefixBytes">Number of bytes this range of items has in common</param>
            <returns>An estimate of the number of cells that will be freed up by 
            creating a child node, or 0 if there are no common prefixes in this 
            node.</returns>
        </member>
        <member name="P:Loyc.Collections.Impl.CPSNode`1.CellInfo">
            <summary>Debugging aid: spits out the contents of each 4-byte cell</summary>
        </member>
        <member name="T:Loyc.Collections.Impl.CPEnumerator`1">
            <summary>Traverses a <see cref="T:Loyc.Collections.CPTrie`1"/>. Returned by 
            <see cref="M:Loyc.Collections.CPTrie`1.ValueEnumerator"/>.</summary>
        </member>
        <member name="P:Loyc.Collections.Impl.CPEnumerator`1.IsValid">
            <summary>Returns true if this enumerator points to an item and Current
            is valid.</summary>
        </member>
        <member name="T:Loyc.Collections.Impl.KeyWalker">
            <summary>Internal implementation class. Represents a pointer to a location 
            within a byte array.</summary>
        </member>
        <member name="M:Loyc.Collections.Impl.CPNode`1.MoveFirst(Loyc.Collections.Impl.CPEnumerator{`0})">
            <summary>Sets up the specified enumerator to point at the first item in
            this node.</summary>
            <remarks>
            On entry to the method, e.Key.Buffer[0..e.Key.Offset] specifies the
            prefix on all keys in the node. On exit, e.Key.Offset should remain the
            same unless MoveFirst was called on a child node.
            <para/>
            This method
            (1) Add()s an Entry to e.Stack pointing to the first (lowest) item in 
                the node, using e.Key.Offset as the value of Entry.KeyOffset;
            (2) extracts the key to e.Key such that e.Key.Offset+e.Key.Left is the
                length of the complete key (if e.Key.Buffer is too small, it is
                copied to a larger buffer as needed);
            (3) if the current item points to a child, this method advances e.Key 
                to the end of the key so that e.Key.Left is 0, and calls MoveFirst 
                on the child;
            (4) otherwise, this method leaves e.Key.Offset equal to
                e.Stack.Last.KeyOffset, so that e.Key.Left is the number of bytes
                of the key that are stored in this node.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.Impl.CPNode`1.MoveLast(Loyc.Collections.Impl.CPEnumerator{`0})">
            <summary>Does the same thing as MoveFirst except that the last item is
            retrieved instead of the first one.</summary>
        </member>
        <member name="M:Loyc.Collections.Impl.CPNode`1.MoveNext(Loyc.Collections.Impl.CPEnumerator{`0})">
            <summary>Moves to the next item in the node.</summary>
            <returns>Returns true if the next item was extracted or false if the 
            end of the node was reached.</returns>
            <remarks>
            Upon entry to this method, e.Stack.Last.Node == this
                                   and e.Stack.Last.KeyOffset == e.Key.Offset.
            <para/>
            This method
            (1) increases e.Stack.Last.Index to point to the next item in the node;
            (2) returns false if Index has advanced past the last item in the node;
            (3) otherwise, repeats steps (2)-(4) in the documentation of
                MoveFirst() and returns true.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.Impl.CPNode`1.MovePrev(Loyc.Collections.Impl.CPEnumerator{`0})">
            <summary>Does the same thing as MovePrev except that it moves to the
            previous item instead of the next item.</summary>
        </member>
        <member name="T:Loyc.Collections.Impl.KeylessHashtable`1">
            <summary>
            A fairly obscure space-saving hashtable that offers no built-in way to 
            store keys, only values. Because there are no keys, the hashtable cannot
            be rehashed when it is full, and searching for a given key finds all
            values in the same bucket, some of which may be unrelated.
            </summary>
            <remarks>
            My primary primary motivation for this data structure is compactness. It's 
            comparable to a "counting bloom filter", in that searching for a key can
            find false positives, but not false negatives, but it offers the additional
            feature that one or more values can be associated with each key.
            <para/>
            The size per entry dependends on the size of the hashtable. This data 
            structure is the most compact when its size is limited to 65536 entries and 
            buckets; its overhead doubles when you exceed this limit, since "shorts" 
            become "ints".
            <para/>
            The Count is allowed to exceed the Capacity, but it is not allowed to cross
            a size threshold (255 or 65535). Capacity returns the number of buckets,
            so if Count exceeds Capacity, it simply means there are more items than 
            buckets, so there will be a larger-than-normal amount of "false positives" 
            (multiple items will typically be returned from a search).
            <para/>
            The size requirement per entry is 2 bytes (plus sizeof(T)) for a table of
            size 255 or less, 4 bytes (plus sizeof(T)) for a table of size 65535 or 
            less, and 8 bytes (plus sizeof(T)) for larger tables. Prime number sizes
            are generally preferred for best performance.
            <para/>
            The memory for buckets (1-4 bytes) is allocated up-front, but other memory
            is allocated on-demand. For example, if you create a new hashtable with 
            capacity 251 and add 50 items, 251 bytes are allocated up-front, but less
            than 100 * (1+sizeof(T)) additional bytes are allocated.
            <para/>
            By its very nature, KeylessHashtable allows multiple values to be 
            associated with a single key.
            <para/>
            A normal hashtable could theoretically be built on top of this one by
            storing the key and value together in type T.
            </remarks>
        </member>
        <member name="T:Loyc.Collections.Impl.KeylessHashtable`3">
            <summary>The concrete implementation of <see cref="T:Loyc.Collections.Impl.KeylessHashtable`1"/>.
            Do not use directly; instead, call <see cref="M:Loyc.Collections.Impl.KeylessHashtable`1.New(System.Int32)"/>.</summary>
        </member>
        <member name="T:Loyc.Collections.CPStringTrie`1">
            <summary>A compact patricia trie that uses strings as keys.</summary>
            <remarks>This data structure can be very space-efficient when asked to 
            store a large numbers of keys with common prefixes; maximum efficiency is
            achieved when the associated values are all (or almost all) null.</remarks>
            <typeparam name="TValue">Type of value associated with each key.</typeparam>
        </member>
        <member name="M:Loyc.Collections.CPStringTrie`1.TryAdd(System.String,`0)">
            <summary>Adds the specified key-value pair only if the specified key is
            not already present in the trie.</summary>
            <returns>Returns true if the key-value pair was added or false if
            the key already existed. In the false case, the trie is not modified.</returns>
        </member>
        <member name="M:Loyc.Collections.CPStringTrie`1.TryAdd(System.String,`0@)">
            <summary>Adds the specified key-value pair only if the specified key is
            not already present in the trie.</summary>
            <param name="value">On entry, value specifies the value to associate
            with the specified key, but if the key already exists, value is changed
            to the value associated with the existing key.</param>
            <returns>Returns true if the key-value pair was added or false if
            the key already existed. In the false case, the trie is not modified.</returns>
        </member>
        <member name="T:Loyc.Collections.CPStringTrie`1.Enumerator">
            <summary>Enumerates key-value pairs in a CPStringTrie.</summary>
            <remarks>Reading the key is more expensive than reading the value
            because the key must be decoded from the bytes it is made up of.
            If you call CurrentValue instead of Current or CurrentKey, the
            work of decoding the key will be avoided. If you only need to
            enumerate the values, enumerate the Values collection instead of 
            the trie class itself.
            </remarks>
        </member>
        <member name="T:Loyc.Collections.CPStringTrie`1.KeyEnumerator">
            <summary>Enumerates keys of a CPStringTrie.</summary>
            <remarks>
            Avoid calling Current more than once per key, as each call requires the
            key to be decoded from the bytes it is made up of.
            </remarks>
        </member>
        <member name="T:Loyc.Collections.CPStringTrie`1.KeyCollection">
            <summary>Return value of <see cref="P:Loyc.Collections.CPStringTrie`1.Keys"/>.</summary>
        </member>
        <member name="T:Loyc.Collections.CPTrie`1">
            <summary>Compact patricia tree class that stores keys as byte arrays.
            This class is intended to be use as a base class; a derived class can
            give meaning to the byte arrays, e.g. CPStringTrie encodes strings into
            byte arrays so they can be placed in the trie.</summary>
            <remarks>
            An <a href="http://www.codeproject.com/Articles/61230/CPTrie-A-sorted-data-structure-for-NET">article</a>
            is available online the CPTrie data types.
            </remarks>
            <typeparam name="T">Type of values to be associated with the keys. CPTrie
            can save memory if many or all values are null; therefore, if you wish
            to store a set rather than a dictionary, set T=object and associate null
            with every key.</typeparam>
        </member>
        <member name="M:Loyc.Collections.CPTrie`1.StringToBytes(System.String)">
            <summary>Converts a string to a sequence of bytes suitable for use in 
            the trie. For speed, a simplified UTF-8 encoding is used, where 
            surrogate pairs are not specially handled.</summary>
            <param name="key">Key to convert to bytes.</param>
            <returns>The key encoded in bytes.</returns>
        </member>
        <member name="M:Loyc.Collections.CPTrie`1.BytesToString(System.Byte[],System.Int32)">
            <summary>Converts a sequence of bytes (key[0..keyLength-1]) that was 
            previously encoded with StringToBytes to a string</summary>
            <remarks>The buffer length is not relevant, as this method may store 
            the key in a scratch buffer that is longer than the key; therefore
            the second parameter specifies the length.</remarks>
        </member>
        <member name="M:Loyc.Collections.CPTrie`1.Find(Loyc.Collections.Impl.KeyWalker@,`0@)">
            <summary>
            Retrieves the value associated with the specified key; does nothing if
            the key does not exist.
            </summary>
            <returns>Returns true if the key was found.</returns>
        </member>
        <member name="M:Loyc.Collections.CPTrie`1.Set(Loyc.Collections.Impl.KeyWalker@,`0@,Loyc.Collections.Impl.CPMode)">
            <summary>
            Associates the specified value with the specified key.
            </summary>
            <param name="key">A key to find or create; if key.Offset > 0, bytes
            before that offset are ignored.</param>
            <param name="value">Value to assign to the node, depending on the value
            of mode. On return, value is set to the previous value for the given key.</param>
            <param name="mode">Specifies whether to create an entry if the key is
            not present, and whether to change an existing entry. If mode is Find,
            Set() only retrieves an existing value; it does not change the trie.</param>
            <returns>Returns true if the specified key already existed and false if 
            it did not.</returns>
        </member>
        <member name="M:Loyc.Collections.CPTrie`1.Remove(Loyc.Collections.Impl.KeyWalker@,`0@)">
            <summary>
            Removes the specified key and associated value.
            </summary>
            <param name="key">Key to find; if key.Offset > 0, bytes before that 
            offset are ignored.</param>
            <param name="value">If the key was found, its associated value is
            stored in this parameter; otherwise, the parameter is left unchanged.</param>
            <returns>Returns true if the specified key was found and removed.</returns>
        </member>
        <member name="M:Loyc.Collections.CPTrie`1.CountMemoryUsage(System.Int32)">
            <summary>Calculates the memory usage of this object, assuming a 32-bit
            architecture.</summary>
            <param name="sizeOfT">Size of data type T. CountMemoryUsage doesn't use
            sizeof(T), as it would force the code to be marked "unsafe".</param>
            <returns>Estimated number of bytes used by this object</returns>
        </member>
        <member name="T:Loyc.Collections.CPValueCollection`1">
            <summary>Provides read-only access to the values of a CPTrie.</summary>
            <typeparam name="T">Type of values in the collection</typeparam>
        </member>
        <member name="M:Loyc.Collections.CPTrieBenchmark.GetIntClusters(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>Builds a set of clustered keys for benchmarking CPIntTrie.
            "clustered" means that keys come in groups called clusters. Keys in a
            cluster are near one other.</summary>
            <param name="clusterMax">Number of keys per cluster will be in the range clusterMax/2..clusterMax.</param>
            <param name="spacerMax">Each cluster is separated by a spacer of size 1..spacerMax.</param>
            <param name="clusterSpread">Difference between consecutive keys within the cluster is 1..clusterSpread.</param>
            <param name="numKeys">Number of keys total</param>
            <returns></returns>
        </member>
        <member name="M:Loyc.Collections.CPTrieBenchmark.GetLongClusters(System.Int32,System.Int32,System.Int64,System.Int32,System.Int64)">
            <summary>Same as GetIntClusters, but gets longs instead.</summary>
        </member>
        <member name="T:Loyc.Collections.CPTrieTests">
            <summary>
            Test suite for CPStringTrie, CPByteTrie and CPIntTrie
            </summary>
            <remarks>
            This is a fairly basic set of tests. Quite a few methods are untested,
            incuding the entire CPValueCollection, CPStringTrie.KeyCollection and
            CPByteTrie.KeyCollection classes. Also, the benchmark (CPTrieBenchmark) is
            meant to serve as a large-scale stress test, but there is no stress test
            for CPBNode, as the alphabet in the benchmark is not large enough to cause
            CPSNode to split into CPBNode.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.ByteArrayComparer.Compare(System.Byte[],System.Byte[])">
            <summary>Compares two byte arrays, returning -1 if A is less than B and
            1 if A is greater than B.</summary>
            <remarks>null is considered "less" than any non-null array.</remarks>
        </member>
        <member name="T:Loyc.Utilities.GoInterface">
            <summary>Mainly for internal use by the other GoInterface classes.</summary>
        </member>
        <member name="M:Loyc.Utilities.GoInterface.Unwrap(System.Object)">
            <summary>Unwraps an object if it was wrapped by GoInterface. Unwrapping
            is recursive, so that if a wrapper is inside another wrapper, the
            underlying object is returned.</summary>
            <param name="obj">Any object.</param>
            <returns>Returns the original object wrapped by GoInterface. If the
            specified object is not a GoInterface wrapper, returns obj itself.</returns>
        </member>
        <member name="M:Loyc.Utilities.GoInterface.UnwrapOnce(System.Object)">
            <summary>Unwraps an object if it was wrapped by GoInterface. This
            unwrapping is not recursive--if a wrapper is inside another wrapper,
            only the outer wrapper is removed.</summary>
            <param name="obj">Any object.</param>
            <returns>Returns the original object wrapped by GoInterface. If the
            specified object is not a GoInterface wrapper, returns obj itself.</returns>
        </member>
        <member name="T:Loyc.Utilities.IGoInterfaceWrapper">
            <summary>All GoInterface wrappers implement this interface.</summary>
        </member>
        <member name="T:Loyc.Utilities.GoInterface`1">
             <summary>GoInterface&lt;Interface> creates wrappers around objects of your 
             choosing that implement the specified Interface, forwarding calls to 
             methods in the wrapped object. It is inspired by the duck-typed interfaces 
             in the Go programming language.</summary>
             <remarks>
             In the Go programming language, you do not say explicitly that your type 
             implements a given interface. Instead, a type is convertable to <i>any</i>
             interface, just so long as it implements all the methods in the interface.
             This often reminds people of "duck typing" in dynamic languages such as 
             Python or Ruby, but it is faster; in fact, Go interface calls are the same 
             speed as virtual method calls in C++ and C#!
             <para/>
             To put it in C# terms, if you have a class T...
             <pre>public class T {
                 public void Foo(int x);
             }</pre>
             
             ...and an interface called "Interface"...
             
             <pre>public interface Interface {
                 void Foo(int x);
             }</pre>
            
             ...then you can cast T to Interface even though T does not explicitly implement it.
            
             <pre>Interface t = new T();</pre>
             
             This cast can be implicit since the compiler can tell at compile time that
             T implements the Interface. However, you can cast any object to Interface 
             and, at run-time, Go will determine whether it implements the Interface.
             <para/>
             I asked how Go dispatch works on the "Go Nuts" google group and was pointed 
             to two articles:
             <para/>
             http://research.swtch.com/2009/12/go-data-structures-interfaces.html
             http://www.airs.com/blog/archives/281
             <para/>
             To summarize those, the first time you convert a type "T" to an interface 
             "Interface", a vtable (virtual function table) is generated just like the 
             kind used for virtual calls in .NET and C++. However, instead of storing 
             the vtable in the object itself like C++ and .NET do, Go stores the vtable 
             pointer alongside the interface pointer (i.e. an interface pointer is 
             really two pointers). This simple but unique design allows a single object
             to implement an unlimited number of interfaces with overall performance 
             that is competitive with C# and Java.
             <para/>
             Unfortunately, as far as I can tell, there is no way to efficiently
             implement this same technique in .NET without changing the CLR itself. A
             virtual method table is just a list of pointers to functions; importantly,
             function pointers in a virtual method table are not associated with a
             specific object, which makes them different from .NET delegates. By not
             associating the vtable with a specific object, it is possible to re-use the
             same vtable with any number of objects (as long as they are of the same
             class). However, .NET delegates are associated with specific objects, so we
             can't use them to form a reusable vtable.
             <para/>
             Even if .NET allowed delegates that are not associated with a specific
             object, delegate invocation on .NET is slower than virtual method
             invocation; why this is so is not entirely clear to me, but part of the
             reason may be that Microsoft decided to make delegates reference types when
             they should have been a simpler 8-byte value type (just bundling a function
             pointer with a 'this' pointer).
             <para/>
             However, just a few days ago I learned that Visual Basic 9 has a very
             similar feature to Go called "dynamic interfaces", which pretty much lets
             you do as described above (albeit only in Visual Basic). So far I've heard
             nothing about how VB's dynamic interfaces work, but I got to thinking: how
             hard would it be to bring go-style interfaces to all .NET languages, and
             would it be possible to get good performance?
             <para/>
             The technique I chose doesn't have performance as good as you would get from
             Go, but in exchange for a small performance hit (which I believe to be
             unavoidable anyway), the GoInterface classes provide automatic interface
             adaptations that you can't get in Go itself. Specifically, my GoInterface
             classes can automatically do small type conversion tasks like enlarging
             "int" to "long", boxing value types, and allowing return type covariance
             (for instance, if the wrapped method returns a "string", the Interface can
             return an "object".) And since GoInterface returns heap objects that
             actually implement the interface you ask for (rather than, say, an 8-byte
             structure imitating the Go implementation), it's very easy to use.
             <para/>
             The GoInterface classes use .NET Reflection.Emit to generate wrapper classes
             in a "dynamic assembly"--basically a DLL that exists only in memory. Each
             wrapper class implements a single interface of your choosing, and forwards
             calls on that interface to an object of your choosing.
             <para/>
             Given the types from above...
             
             <pre>public class T {
                 public void Foo(int x);
             }
             public interface Interface {
                 void Foo(int x);
             }</pre>
             
             ...you can use GoInterface to cast T to Interface like this:
             
             <pre>Interface t = GoInterface&lt;Interface>.From(new T());</pre>
             
             The first time you cast a T to Interface, GoInterface generates a wrapper 
             class such as the following on-the-fly:
             
             <pre>public class T_46F3E18_46102A0 : Interface
             {
                 T _obj;
                 public T_46F3E18_46102A0(T obj) { _obj = obj; }
                 void Foo(int x) { _obj.Foo(x); }
             }</pre>
             
             The hex numbers in the name of the type are simply handles to interface and 
             type being wrapped, in order to guarantee no name collisions occur when you 
             are wrapping a lot of different classes with GoInterface.
             <para/>
             After the first cast, all future casts are fairly fast, especially if you
             call GoInterface&lt;Interface,T>.From() instead of just
             GoInterface&lt;Interface>.From(). That's because after
             GoInterface&lt;Interface,T> is fully initialized, all its From() method does
             is invoke a delegate that contains the following code:
             
             <pre>delegate(T obj) { return new T_46F3E18_46102A0(obj); }</pre>
             
             You can create wrappers with either GoInterface&lt;Interface> or
             GoInterface&lt;Interface, T> (note the extra type argument "T").
             <ul>
             <li>GoInterface&lt;Interface> is intended for creating wrappers when you do
             not know the type of the object at compile time. For example, if you have a
             list of objects of unknown type and you want to cast them to an interface,
             use this one.</li>
             <li>GoInterface&lt;Interface, T> creates wrappers when you already know the
             type of the object at compile time. This version assumes that T itself (and
             not some derived class!) contains the methods you want to call.
             GoInterface&lt;Interface, T> has the disadvantage that it is unable to call
             methods in a derived class of T. For example, you should not use
             GoInterface&lt;Interface, object> because the object class does not contain
             a Foo method.</li>
             </ul>
             If you're not sure which one to use, use GoInterface&lt;Interface>. If you
             need to adapt a large number of objects to a single interface, you should
             use GoInterface&lt;Interface, T> where possible, because it is slightly
             faster. GoInterface&lt;Interface>, in contrast, has to examine each object
             it is given to find out its most derived type. However, this process is
             optimized so that an expensive analysis is only done once per derived type,
             after which only a hashtable lookup is required.
             <para/>
             Compared to interfaces in the Go programming language, which have a 1-word
             overhead for every interface pointer (the vtable pointer, which is 4 bytes
             in 32-bit code), GoInterface wrappers normally have 3 words of overhead (2
             words for the wrapper's object header and 1 word for a reference to the
             wrapped object). Also, GoInterface wrapper classes are no doubt much more
             costly to produce (since they involve run-time code generation), which will
             increase your program's startup time and have a fixed memory overhead that
             dwarfs Go's implementation. However, once you are up-and-running with
             GoInterface wrappers, their performance should be pretty good. TODO:
             benchmarks
             <para/>
             Note: GoInterface can create wrappers for value types (structures), not just
             classes. Such wrappers have the same memory overhead as boxed structures,
             which is one word less than wrappers for reference types.
             <para/>
             GoInterface wrappers automatically forward calls to object.ToString(),
             object.GetHashCode() and object.Equals(), even though these methods are 
             not technically part of the interface being wrapped.
             <para/>
             GoInterface cannot wrap explicit interface implementations in the target
             class. For instance, if the target class implements IEnumerable(of T), that
             interface has two versions of the GetEnumerator function that differ only by
             return type (one returns IEnumerator and the other returns IEnumerator(of
             T)), so one of them must be implemented "explicitly". GoInterface will
             typically only see the version that returns IEnumerator(of T), but this is
             not a problem since IEnumerator(of T) is implicitly convertable to
             IEnumerator, so GoInterface can use that one method to represent either of 
             them. In Visual Basic there is a caveat, since an explicit interface
             implementation is allowed to be public. In that case, GoInterface will only 
             see the method's public name (not the name used in the interface).
             </remarks>
        </member>
        <member name="T:Loyc.Utilities.CastOptions">
            <summary>Options you can pass to GoInterface.From()</summary>
        </member>
        <member name="F:Loyc.Utilities.CastOptions.As">
            <summary>If there is a mismatch, return null instead of throwing InvalidCastException</summary>
        </member>
        <member name="F:Loyc.Utilities.CastOptions.AllowUnmatchedMethods">
            <summary>Allow the cast even if NumberOfUnmatchedMethods > 0</summary>
        </member>
        <member name="F:Loyc.Utilities.CastOptions.AllowRefMismatch">
            <summary>Allow the cast even if NumberOfMethodsWithRefMismatch > 0</summary>
        </member>
        <member name="F:Loyc.Utilities.CastOptions.AllowMissingParams">
            <summary>Allow the cast even if NumberOfMethodsMissingParameters > 0</summary>
        </member>
        <member name="F:Loyc.Utilities.CastOptions.NoUnwrap">
            <summary>If the object to be wrapped is already wrapped, 
            GoInterface&lt;Interface> will normally unwrap it before wrapping the
            original object in another interface. Pass this flag to 
            GoInterface&lt;Interface>.From() if you would like to make a wrapper 
            around another wrapper.
            <para/>
            Note 1: This flag only works in GoInterfaceFactory&lt;Interface>, 
            not GoInterfaceFactory&lt;Interface,T>.
            Note 2: Unwrapping occurs recursively until an object is reached that
            does not implement IGoInterfaceWrapper.
            </summary>
        </member>
        <member name="T:Loyc.Utilities.GoInterfaceFactory`1">
            <summary>For internal use. Base class of GoInterface&lt;Interface,T>.Factory 
            and GoDirectCaster&lt;Interface>.</summary>
        </member>
        <member name="T:Loyc.Utilities.GoDirectCaster`1">
            <summary>Used by GoInterface&lt;Interface> to cast objects directly to an 
            interface when it turns out that they implement that interface.</summary>
        </member>
        <member name="T:Loyc.Utilities.GoInterface`2">
            <summary>GoInterface&lt;Interface,T> creates a wrapper that implements 
            the specified Interface, forwarding calls to methods in T. It is inspired 
            by the duck-typed interfaces in the Go programming language.</summary>
            <remarks>
            Please see <see cref="T:Loyc.Utilities.GoInterface`1"/> for more information.
            </remarks>
        </member>
        <member name="M:Loyc.Utilities.GoInterface`2.ForceFrom(`1)">
            <summary>Creates a wrapper regardless of whether or not T could be 
            wrapped completely.</summary>
            <exception cref="T:System.InvalidOperationException">The Interface is not 
            valid (e.g. it is not public or is not abstract)</exception>
            <remarks>
            GoInterface maps methods in certain cases where you might not 
            want it to--for example, if the Interface takes two ints and T only 
            takes one, GoInterface maps one to the other by omitting the second 
            parameter. To accept these mappings, call ForceFrom(T) or From(T, 
            CastOptions.AllowMissingParams | CastOptions.AllowRefMismatch); to 
            reject them, call From(T).
            <para/>
            ForceFrom always creates a wrapper, even if some methods of Interface
            couldn't be matched with T at all. If you then call a method that 
            couldn't be wrapped, you'll get a MissingMethodException.
            </remarks>
        </member>
        <member name="M:Loyc.Utilities.GoInterface`2.From(`1)">
            <summary>Creates a wrapper if the interface matches T well.</summary>
            <exception cref="T:System.InvalidCastException">T does not match the Interface 
            very well. Specifically, NumberOfUnmatchedMethods>0, 
            NumberOfMethodsMissingParameters>0 or NumberOfMethodsWithRefMismatch>0.</exception>
            <returns>A pointer to a wrapper that implements the Interface.</returns>
        </member>
        <member name="M:Loyc.Utilities.GoInterface`2.From(`1,Loyc.Utilities.CastOptions)">
            <summary>Creates a wrapper if T matches Interface according to the 
            specified CastOptions.</summary>
            <returns>A pointer to a wrapper that implements the Interface.</returns>
            <remarks>See CastOptions for more information.</remarks>
        </member>
        <member name="P:Loyc.Utilities.GoInterface`2.IsValidInterface">
            <summary>If this value is false, Interface is not valid and ForceFrom 
            will throw InvalidOperationException if called. In that case, the other 
            values such as NumberOfUnmatchedMethods are zero, but have no meaning.</summary>
            <remarks>Calling this property or any of the "int" properties forces 
            the wrapper class to be generated, during which the relationship 
            between Interface and T is analyzed.</remarks>
        </member>
        <member name="P:Loyc.Utilities.GoInterface`2.NumberOfUnmatchedMethods">
            <summary>The number of methods in the interface for which a matching 
            method in T could not be found.</summary>
        </member>
        <member name="P:Loyc.Utilities.GoInterface`2.NumberOfAmbiguousMethods">
            <summary>The number of methods in the interface for which a matching 
            method in T could not be found because T contained more than one 
            equally suitable match.</summary>
        </member>
        <member name="P:Loyc.Utilities.GoInterface`2.NumberOfMethodsMissingParameters">
            <summary>The number of methods in the interface that were matched to 
            a method in T with one or more parameters dropped. For instance, if a
            method in the interface takes two ints but T's method only takes one
            int, the second int of </summary>
        </member>
        <member name="P:Loyc.Utilities.GoInterface`2.NumberOfMethodsWithRefMismatch">
            <summary>The number of methods in the interface that were matched to a 
            method in T, in which there was a mismatch that one parameter was 
            passed by reference ("ref") and the other was passed by value.</summary>
        </member>
        <member name="M:Loyc.Utilities.GoInterface`2.DefineCustomWrapperCreator(Loyc.Utilities.GoInterface{`0,`1}.GoWrapperCreator,Loyc.Utilities.GoInterface{`0,`1}.GoWrapperCreator)">
            <summary>Defines a custom wrapper class for the type pair (Interface, 
            T). If you want to install a custom wrapper, you must do so before 
            From() or ForceFrom() is ever called on this pair of types, otherwise 
            an exception is thrown. Also, you cannot call this method twice on 
            the same pair of types.</summary>
            <param name="from">A method to be invoked by From().</param>
            <param name="forceFrom">A method to be invoked by ForceFrom().</param>
            <remarks>
            Since generating a wrapper is expensive and the wrapper cannot be 
            garbage-collected, I decided to make sure you don't waste time and
            memory generating a wrapper you don't intend to use, by restricting 
            this method only to be used on type pairs that have never been used 
            before. Make sure you call this method as soon as possible, before 
            anybody calls From() or ForceFrom().
            </remarks>
        </member>
        <member name="T:Loyc.Utilities.GoInterface`2.Factory">
            <summary>This helper class allows GoInterface&lt;Interface> to cache 
            access to the static methods in GoInterface&lt;Interface, T>, so that 
            it only needs to use reflection once.</summary>
        </member>
        <member name="T:Loyc.Utilities.GoInterface`2.MethodAndParams">
            <summary>A MethodInfo with cached parameter information.</summary>
        </member>
        <member name="M:Loyc.Utilities.GoInterface`2.ContainsIdenticalMethod(System.Reflection.MethodInfo,System.Collections.Generic.List{Loyc.Utilities.GoInterface{`0,`1}.MethodAndParams})">
            <summary>Returns true if 'otherMethods' contains a method identical to
            'method' (IGNORING the return value!)</summary>
        </member>
        <member name="M:Loyc.Utilities.GoInterface`2.GenerateWrapperMethod(System.Reflection.Emit.TypeBuilder,System.Collections.Generic.List{Loyc.Utilities.GoInterface{`0,`1}.MethodAndParams},System.Int32,System.Collections.Generic.List{Loyc.Utilities.GoInterface{`0,`1}.MethodAndParams})">
            <summary>Generates a method that implements baseMethod (a method of
            Interface) and forwards the call to the same method on T.</summary>
            <remarks>"Safe" parameter variance is allowed between Interface and T,
            such as return type covariance.</remarks>
        </member>
        <member name="M:Loyc.Utilities.GoInterface`2.GetMatchingMethods(System.Reflection.MethodInfo,System.Collections.Generic.List{Loyc.Utilities.GoInterface{`0,`1}.MethodAndParams})">
            <summary>Scans methods of T looking for a method matching a method 
            of Interface (baseMethod)</summary>
            <remarks>
            Before generating code for the method, we must find a matching 
            method of T. Note that we want to support various kinds of
            "variance", including boxing if necessary:
            <para/>
            - Return type covariance. If T's method returns a derived class,
              Interface's method can return a base class or interface. Also, 
              allow any return type if baseMethod returns void.
            - "out" parameter covariance.
            - T's "out" argument(s) can be absent from Interface, as long as
              they are at the end of the argument list.
            - Interface's input arguments can be absent from T, as long as the
              missing parameters come at the end of the argument list.
            - Input parameter contravariance. If T's method accepts a base class
              (or interface) such as "object", Interface's method can accept a 
              derived class (or a class that implements said interface).
            - If T takes a "ref" argument, allow the method in Interface not to
              be "ref" and vice versa.
            - T's method can be static
            <para/>
            Implicit conversion operators are not currently detected, except 
            primitive type conversions like Int16 to Float that C# allows you 
            to do implicitly. Information-losing conversions like Int64 to 
            Int32 are not supported.
            <para/>
            Variable argument lists are not supported specifically (they are 
            treated as arrays).
            <para/>
            Generic methods in T and Interface are not supported.
            <para/>
            Default (optional) arguments are generally supported.
            <para/>
            Argument names are ignored and need not match.
            <para/>
            Methods that differ only in case are not considered, but Aliases 
            specified with GoAliasAttribute are considered if a matching method 
            with the original name could not be found. All matching aliases are 
            considered together, as if they were overloads of each other.
            <para/>
            We scan all methods of "T" with a matching name and find the best
            match, since there may be multiple methods matching these
            requirements. For the most part I try to follow the rules of 
            the C# standard (ECMA-334 14.4.2.1 and 14.4.2.2), but be a little 
            more liberal. The way I figure it, "void" should be treated like a
            base class of "object". Note that this matching algorithm may reject
            all overloads due to "ambiguity", in case one overload is not better
            than all others.
            </remarks>
        </member>
        <member name="M:Loyc.Utilities.GoInterface`2.ImplicitConvType(System.Type,System.Type)">
            <summary>Figures out what kind of conversion you need to get from 
            "from" to "to", returning ConvType.IsA if no conversion is needed.</summary>
        </member>
        <member name="M:Loyc.Utilities.GoInterface`2.PrimSize(System.Type,System.Boolean@)">
            <summary>Returns the size of a primitive integer or float type and 
            also tells you if the type is unsigned; note that IntPtr and 
            UIntPtr are not handled.</summary>
            <returns>The size of type t, or 0 for unhandled types.</returns>
        </member>
        <member name="T:Loyc.Utilities.GoAliasAttribute">
            <summary>This attribute is applied to a method of an interface to specify 
            alternate names that a method can have in T when you use GoInterface
            &lt;Interface, T> to produce a wrapper.</summary>
            <example>
            public class MyCollection
            {
                 void Insert(object obj);
                 int Size { get; }
                 object GetAt(int i);
            }
            public interface ISimpleList
            {
                [GoAlias("Insert")] void Add(object item);
                
                int Count 
                {
                    [GoAlias("get_Size")] get;
                }
                object this[int index]
                {
                    [GoAlias("GetAt")] get;
                }
            }
            void Example()
            {
                ISimpleList list = GoInterface&lt;ISimpleList>.From(new MyCollection());
                list.Add(10); // calls MyCollection.Insert(10)
            }
            </example>
        </member>
        <member name="T:Loyc.Utilities.GoDecoratorFieldAttribute">
            <summary>
            This attribute marks a field in an abstract class as pointing to a wrapped
            object to which GoInterface should forward calls. It is used when you want
            GoInterface to "complete" a decorator pattern for you.
            </summary>
            <remarks>
            After writing the basic functionality of GoInterface, I realized it could
            also serve as a handy way to implement the Decorator pattern. A decorator
            is a class that wraps around some target class (usually sharing the same
            interface or base class), while modifying the functionality of the target.
            For instance, you could write a decorator for TextWriter that filters out 
            curse words, replacing them with asterisks.
            <para/>
            Writing decorators is sometimes inconvenient because you only want to 
            modify the behavior of some functions while leaving others alone. 
            Without GoInterface, you must write a wrapper for every method, manually 
            forwarding calls from the decorator to the target.
            <para/>
            GoInterface can help by generating forwarding functions automatically.
            <para/>
            The example shows how to use GoInterface to help you make a decorator.
            </remarks>
            <example>
            // A view of an IList in which the order of the elements is reversed.
            // The test suite offers this example in full; this partial implementation
            // just explains the concepts.
            public abstract class ReverseView&lt;T> : IList&lt;T> 
            {
                // Use the GoDecoratorField attribute so that GoInterface will access
                // the list through this field instead of creating a new field.
                // Important: the field must be "protected" or "public" and have 
                // exactly the right data type; otherwise, GoInterface will ignore 
                // it and create its own field in the generated class.
            	[GoDecoratorField]
            	protected IList&lt;T> _list;
            
            	// The derived class will init _list for you if you have a default 
            	// constructor. If your constructor instead takes an IList argument,
            	// you are expected to initialize _list yourself.
            	protected ReverseView() { Debug.Assert(_list != null); }
            
                // The downside of using GoInterface to help you make decorators is 
                // that GoInterface creates a derived class that overrides abstract
                // methods in your own class, which means your class must be abstract,
                // and users can't write "new ReverseView"--instead you must provide
                // a static method like this one to create the wrapper.
            	public static ReverseView&lt;T> From(IList&lt;T> list)
            	{
            		return GoInterface&lt;ReverseView&lt;T>, IList&lt;T>>.From(list);
            	}
            
                // Here are two of several methods whose functionality we need to 
                // modify in order to reverse a list.
            	public int IndexOf(T item)
            	{ 
            		int i = _list.IndexOf(item); 
            		return i == -1 ? -1 : Count - 1 - i;
            	}
            	public void Insert(int index, T item)
            	{
            		_list.Insert(Count - index, item);
            	}
            	
            	// Here are the functions that we don't have to implement, which we
            	// allow GoInterface to implement automatically. Unfortunately, when 
            	// implementing an interface you can't simply leave out the functions 
            	// you want to remain abstract. C#, at least, requires you to make a
            	// list of the interface methods that you don't want to implement. 
            	// This inconvenience is only when implementing an interface; if you
            	// are just deriving from an abstract base class, you don't have to 
            	// do this because the base class already did it.
            	public abstract void Add(T item);
            	public abstract void Clear();
            	public abstract bool Contains(T item);
            	public abstract void CopyTo(T[] array, int arrayIndex);
            	public abstract int Count { get; }
            	public abstract bool IsReadOnly { get; }
            	public abstract bool Remove(T item);
            	public abstract IEnumerator&lt;T> GetEnumerator();
            	
            	// IEnumerable has two GetEnumerator functions so you must use an 
            	// "explicit interface implementation" for the second one. 
            	// You must write this one yourself, as it can't be marked abstract.
            	System.Collections.IEnumerator
            	System.Collections.IEnumerable.GetEnumerator()
            	{
            		return GetEnumerator();
            	}
            }
            </example>
        </member>
        <member name="T:Loyc.Utilities.SimpleTimer">
            <summary>
            A fast, simple timer class with a more convenient interface than 
            System.Diagnostics.Stopwatch. Its resolution is typically 10-16 ms
            on desktop Windows systems.
            </summary>
            <remarks>
            With SimpleTimer, the timer starts when you construct the object and 
            it is always counting. You can get the elapsed time and restart the 
            timer from zero with a single call to Restart(). The Stopwatch class 
            requires you to make three separate method calls to do the same thing:
            you have to call ElapsedMilliseconds, then Reset(), then Start().
            <para/>
            SimpleTimer cannot be used to measure time periods longer than 24.8 
            days. The 32-bit millisecond counter will overflow and Millisec will 
            become negative.
            </remarks>
        </member>
        <member name="P:Loyc.Utilities.SimpleTimer.Millisec">
            <summary>
            The getter returns the number of milliseconds since the timer was 
            started; the resolution of this property depends on the system timer.
            The setter changes the value of the timer.
            </summary>
        </member>
        <member name="M:Loyc.Utilities.SimpleTimer.Restart">
            <summary>Restarts the timer from zero (unpausing it if it is paused), 
            and returns the number of elapsed milliseconds prior to the reset.</summary>
        </member>
        <member name="M:Loyc.Utilities.SimpleTimer.ClearAfter(System.Int32)">
            <summary>Restarts the timer from zero if the specified number of 
            milliseconds have passed, and returns the former value of Millisec.</summary>
            <returns>If the timer was restarted, this method returns the number of 
            elapsed milliseconds prior to the reset. Returns 0 if the timer was not 
            reset.</returns>
            <remarks>If this method resets a paused timer, it remains paused but 
            Millisec is set to zero.</remarks>
        </member>
        <member name="T:Loyc.Utilities.Statistic">
            <summary>
            A lightweight class to help you compute the minimum, maximum, average
            and standard deviation of a set of values. Call Clear(), then Add(each
            value); you can compute the average and standard deviation at any time by 
            calling Avg() and StdDeviation().
            </summary>
        </member>
        <member name="T:Loyc.Utilities.TagsInWList`1">
            <summary>An implementation of ITags designed for AstNode.</summary>
            <remarks>
            It is supposed to be possible to clone AstNode quickly; to support extra 
            tags, we need to be able to clone the tags quickly too, so it makes sense
            to store them in a WList. To make cloning as quick as possible, we derive
            from WListProtected. To optimize access to tags, we use the UserByte of
            WListProtected to hold the index of the last tag that was used. This 
            ensures tags can be accessed quickly by code that only uses a single tag.
            </remarks>
        </member>
        <member name="T:Loyc.Utilities.UG">
            <summary>Contains global functions of Loyc.Utilities that don't belong in any specific class.</summary>
        </member>
        <member name="M:Loyc.Utilities.UG.ProcessCommandLineArguments(System.Collections.Generic.IList{System.String},System.Collections.Generic.ICollection{System.Collections.Generic.KeyValuePair{System.String,System.String}},System.String,System.Collections.Generic.IDictionary{System.Char,System.String},Loyc.Collections.InvertibleSet{System.String},System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Expands environment variables (e.g. %TEMP%) and @files in a list of
            command-line arguments, and adds any options of the form "--opt" or
            "--opt=value" to a dictionary.
            </summary>
            <param name="args">The original arguments to process.</param>
            <param name="options">Any long options (arguments that start with "--") 
            will be added to this dictionary, and removed from <c>args</c>. This 
            parameter cannot be null. 
              By default, long options are not case sensitive. In that case, the 
            user's option name is converted to lower case.
            <para/>
            Long options are expected to have the form --ID or --ID=value, where ID 
            matches the regex "[a-zA-Z_0-9-]+". If there is no "=" or ":", that's 
            okay too. For example, --Id{foo} is equivalent to --Id={foo}; both yield
            in the name-value pair ("id", "{foo}"). If there is no value (no equals
            or colon), the value associated with the option is null.</param>
            <param name="atFolder">If a parameter has the form @filename, the folder
            specified by atFolder will be searched for an options text file with the
            user-specified filename, and the contents of the file will be expanded 
            into the list of arguments (split using SplitCommandLineArguments). The
            expanded list can contain new @filenames, which are also processed. To
            search in the current directory, use "". The @filename may use an absolute
            path, which overrides this folder. To disable @filename expansion, set 
            this parameter to null. Whether the feature is enabled or disabled, 
            @filenames are <i>not</i> removed from <c>args</c>, in case you want to 
            be aware of the filenames afterward.</param>
            <param name="shortOptions">A map from one-letter options that start with 
            "-" rather than "--", to the name of the corresponding long option (this
            option can be null to ignore all short options.) For example, if this 
            contains (<c>'a', "all"</c>), and the input <c>args</c> contains "-a:foo",
            the pair ("all", "foo") will be added to <c>options</c>. If a value in 
            this map is null, the key itself is used. Short options can be combined; 
            for example <c>-abc:foo</c> is equivalent to <c>-a -b -c:foo</c>. Short 
            options are always case-sensitive; to define an option that is not case 
            sensitive, place two entries in the dictionary e.g. ('a', "all") and 
            ('A', "all"). If the user specifies a short option letter that is not 
            recognized, the entire command will be ignored and left in args. For 
            example, if <c>shortOptions</c> contains only ('a', "all") but <c>args</c>
            contains "-ab=foo", the command is ignored and left in <c>args</c>. 
            Rationale: -ab=foo might be a filename.
            <para/>
            On the other hand, if -a is a valid option then <c>-a123</c> is also 
            valid even when there is no option called '1'; the number "123" is 
            treated as an argument to -a. Now, if '1' is a registered short option 
            but '2' is not, then <c>-a123</c> is equivalent to <c>-a -1=23</c>.
            </param>
            <param name="twoArgOptions">A set of options in which the argument can
            be separated by a space from the option. For example, if the input is 
            "--out foo.txt" and you want to recognize "foo.txt" as the argument to
            "--out", add the string "out" to this set. If you want to treat <i>all</i>
            options this way, use <c>InvertibleSet{string}.All</c>. Note: 
            If the input is "--out:foo bar", "foo" is recognized as the argument to
            "--out" and "bar" is left alone, i.e. it is treated as unrelated.
              Short options participate automatically. For example if "-f" means 
            "--foo", and twoArgOptions contains "foo", then "-f arg" is interpreted 
            like "--foo=arg".
            <para/>
            The argument will not be treated as an argument if it starts with a 
            dash, e.g. in <c>--foo -*</c>, <c>-*</c> will not be treated as an 
            argument to <c>--foo</c>, even if <c>-*</c> is not a registered option.
            </param>
            <param name="argLimit">A limit placed on the number of arguments when
            expanding @files. Such a file may refer to itself, and this is the only
            protection provided against infinite recursive expansion.</param>
            <param name="expandEnvVars">If true, environment variable references
            such as <c>%TEMP%</c> are expanded by calling the standard method
            <see cref="M:System.Environment.ExpandEnvironmentVariables(System.String)"/>.</param>
            <param name="caseSensitiveLongOpts">If true, long options are case-
            sensitive. By default, long options are not case sensitive.</param>
            <remarks>
            Two types of options are recognized, short (-s) and long (--long), and
            only one argument is supported per option. The documentation is above.
            <para/>
            You can choose whether to permit duplicate options or not. If you use
            a standard <see cref="T:System.Collections.Generic.Dictionary`2"/> to hold the options, an 
            exception will occur when this method calls Add() to add the duplicate. 
            The exception is caught, the first ocurrance is kept, and a warning 
            message is printed to <see cref="P:Loyc.MessageSink.Default"/>.
            <para/>
            To allow duplicates, store options in a different data structure such as 
            <c>List(KeyValuePair(string, string))</c> or <c>BMultiMap(string,string)</c>.
            <para/>
            DOS-style slash-options like /foo are not supported. Since Windows
            recognizes the forward slash as a path separator, forward-slash options
            can be recognized as paths. If you want to recognize them as options 
            instead, you can preprocess the argument list, replacing every command 
            that starts with "/" with a "--" command:
            <code>
              for (int i = 0; args.Count > i; i++)
                if (args[i].StartsWith("/")) 
                  args[i] = "--" + args[i].Substring(1);
            </code>
            <para/>
            Globs (e.g. *.txt) are not recognized or expanded, but environment 
            variables are expanded when <c>expandEnvVars</c> is true.
            <para/>
            Quote marks are not processed. An argument of <c>"--a"</c>, with quote 
            marks, is not recognized as an option (these quote marks should be 
            removed before calling this method, e.g. 
            <see cref="M:Loyc.G.SplitCommandLineArguments(System.String)"/> handles this.)
            </remarks>
        </member>
        <member name="T:Loyc.LLParserGenerator.IntSet">
            <summary>Represents a set of characters (e.g. 'A'..'Z' | 'a'..'z' | '_'), 
            or a set of token IDs.</summary>
            <remarks>This class was written for, and is used by, LLLPG. In addition to
            set operations like union and Subtract, one of its main features is that it 
            can convert a set of integers or characters to/from a string form like 
            "[A-Z]" or "(65..90)".</remarks>
        </member>
        <member name="F:Loyc.LLParserGenerator.IntSet._ranges">
            <summary>A list of non-overlapping character ranges, sorted by code 
            point. EOF can be included in this list as character -1 (hence CharRange 
            holds ints instead of chars).</summary>
        </member>
        <member name="P:Loyc.LLParserGenerator.IntSet.IsInverted">
            <summary>When Inverted is true, the set behaves as if it contains the
            opposite set of items. That is, membership tests that succeeded when
            Inverted was false will fail, and vice versa.</summary>
        </member>
        <member name="F:Loyc.LLParserGenerator.IntSet.IsCharSet">
            <summary>Controls the default stringization mode. When IsCharSet, the
            set "(36, 65..90, 126)" prints as "[$A-Z~]". IsCharSet is false by default.
            </summary>
        </member>
        <member name="P:Loyc.LLParserGenerator.IntSet.IsEmptySet">
            <summary>Returns true iff the set is empty. When the set is inverted 
            and contains the set of all integers, that also counts as empty.</summary>
        </member>
        <member name="P:Loyc.LLParserGenerator.IntSet.ContainsEverything">
            <summary>Returns true iff the set covers all integers. This includes 
            the common scenario that the set is empty but inverted.</summary>
        </member>
        <member name="M:Loyc.LLParserGenerator.IntSet.EquivalentInverted">
            <summary>Computes the equivalent inverted set, e.g. if the set is 
            <c>'b'..'y'</c>, the equivalent inverted set is 
            <c>~(int.MinValue..'a' | 'z'..int.MaxValue)</c>.</summary>
        </member>
        <member name="M:Loyc.LLParserGenerator.IntSet.ToString">
            <summary>Prints the character set using regex syntax, e.g. [\$a-z] 
            means "EOF or a to z", [^\n\r] means "not \n or \r". Use 
            ToString(false) if this is an integer set.</summary>
        </member>
        <member name="P:Loyc.LLParserGenerator.IntSet.Size">
            <summary>Gets the number of integers whose membership test would 
            succeed (the maximum possible value is 0x100000000L).</summary>
        </member>
        <member name="T:Loyc.LLParserGenerator.IntRange">
            <summary>Represents a range of single characters (e.g. 'A'..'Z').</summary>
        </member>
        <member name="M:Loyc.LLParserGenerator.IntRange.CompareTo(Loyc.LLParserGenerator.IntRange)">
            <summary>Compares only the <see cref="F:Loyc.LLParserGenerator.IntRange.Lo"/> values of two ranges.</summary>
        </member>
    </members>
</doc>
