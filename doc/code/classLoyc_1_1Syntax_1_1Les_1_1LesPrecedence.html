<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>Loyc: Loyc.Syntax.Les.LesPrecedence Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Loyc
   </div>
   <div id="projectbrief">Language of your choice: library documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Events</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceLoyc.html">Loyc</a></li><li class="navelem"><a class="el" href="namespaceLoyc_1_1Syntax.html">Syntax</a></li><li class="navelem"><a class="el" href="namespaceLoyc_1_1Syntax_1_1Les.html">Les</a></li><li class="navelem"><a class="el" href="classLoyc_1_1Syntax_1_1Les_1_1LesPrecedence.html">LesPrecedence</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-static-attribs">Public static fields</a> &#124;
<a href="classLoyc_1_1Syntax_1_1Les_1_1LesPrecedence-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Loyc.Syntax.Les.LesPrecedence Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Contains <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html" title="A four-byte tuple that represents the precedence and miscibility of an operator.">Precedence</a> objects that represent the precedence levels of LES. 
 <a href="classLoyc_1_1Syntax_1_1Les_1_1LesPrecedence.html#details">More...</a></p>
<hr/><b>Source file</b>:<ul>
<li><a href='https://github.com/qwertie/Loyc/tree/master/Core/Loyc.Syntax/LES/LesPrecedence.cs'>/Core/Loyc.Syntax/LES/LesPrecedence.cs</a></li>
</ul>
<a name="details" id="details"></a><h2 class="groupheader">Remarks</h2>
<div class="textblock"><p>Contains <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html" title="A four-byte tuple that represents the precedence and miscibility of an operator.">Precedence</a> objects that represent the precedence levels of LES.</p>
<p>In LES, the precedence of an operator is decided based simply on the text of the operator. The precedence of each one-character operator is predefined; the precedence of any operator with two or more characters is decided based on the last character, or the first and last character; the middle characters, if any, do not affect precedence. </p>
<p>The LES precedence table is designed to be comparable with popular programming languages, with a couple of "corrections" that I felt were appropriate; for example, in LES, <code>x ^ 7 != 0</code> is parsed <code>(x ^ 7) != 0</code>, rather than <code>x ^ (7 != 0)</code> as in the C family of languages. Similarly, <code>x &gt;&gt; 1 + y</code> is parsed <code>(x &gt;&gt; 1) + y</code> rather than <code>x &gt;&gt; (1 + y)</code>. Shifting is often used as a substitute for multiplication and division, so it has the same precedence. </p>
<p>As a nod to functional languages, the arrow operator "-&gt;" is right- associative and has a precedence below '*' so that <code>int * int -&gt; int</code> parses as <code>(int * int) -&gt; int</code> rather than <code>int * (int -&gt; int)</code> as in the C family of languages. </p>
<p>An operator consists of a sequence of the following characters: </p><pre>
   ~ ! % ^ &amp; * \ - + = | &lt; &gt; / ? : . $
</pre><p> Or a backslash () followed by a sequence of the above characters and/or letters, numbers, underscores or #s. Or a string with <code>backtick quotes</code>. </p>
<p>"@" is not considered an operator. It is used to mark a sequence of punctuation and/or non-punctuation characters as an identifier, a symbol, or a special literal. "#" is not an operator; like an underscore, the hash sign is considered to be an identifier character, and while it is conventionally used to mark "keywords", the parser does not assign any special meaning to it. </p>
<p>"," and ";" are not considered operators; rather they are separators, and they cannot be combined with operators. For example, "?,!" is parsed as three separate tokens. </p>
<p>The following table shows all the precedence levels and associativities of the "built-in" LES operators, except <code>backtick</code> and the "lambda" operator =&gt;, which is special. Each precedence level has a name, which corresponds to a static field of this class. All binary operators are left-associative unless otherwise specified. </p><ol>
<li>
Substitute: prefix $ . : </li>
<li>
Primary: binary . =:, generic arguments List!(int), suffix ++ &ndash;, method calls f(x), indexers a[i] </li>
<li>
NullDot: binary ?. :: </li>
<li>
DoubleBang: binary right-associative !! </li>
<li>
Prefix: prefix ~ ! % ^ &amp; * - + <code>backtick</code> </li>
<li>
Power: binary ** </li>
<li>
Suffix2: suffix \ </li>
<li>
Multiply: binary * / % \ &gt;&gt; &lt;&lt; </li>
<li>
Add: binary + - </li>
<li>
Arrow: binary right-associative -&gt; &lt;- </li>
<li>
AndBits: binary &amp; </li>
<li>
OrBits: binary | ^ </li>
<li>
OrIfNull: binary ?? </li>
<li>
PrefixDots: prefix .. </li>
<li>
<a class="el" href="classLoyc_1_1Range.html">Range</a>: binary right-associative .. </li>
<li>
Compare: binary != == &gt;= &gt; &lt; &lt;= </li>
<li>
And: binary &amp;&amp; </li>
<li>
Or: binary || ^^ </li>
<li>
IfElse: binary right-associative ? : </li>
<li>
Assign: binary right-associative = </li>
<li>
PrefixOr: | </li>
</ol>
<p>Not listed in table: binary =&gt; ~ &lt;&gt; <code>backtick</code>; prefix / \ &lt; &gt; ? = </p>
<p>Notice that the precedence of an operator depends on how it is used. The prefix operator '-' has higher precedence than the binary operator '-', so for example <code>- y * z</code> is parsed as <code>(- y) * z</code>, while <code>x - y * z</code> is parsed as <code>x - (y * z)</code>. </p>
<p>The Lambda operator =&gt;, which is right-associative, has a precedence level above Multiply on the left side, but below Assign on the right side. For example, the expression <code>a = b =&gt; c = d</code> is parsed as <code>a = (b =&gt; (c = d))</code>, and similarly <code>a + b =&gt; c + d</code> is parsed as <code>a + (b =&gt; (c + d))</code>, but <code>a ** b =&gt; c ** d</code> is parsed <code>(a ** b) =&gt; (c ** d)</code>. The idea of two different precedences on the two sides of an operator may seem strange; see the documentation of <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html" title="A four-byte tuple that represents the precedence and miscibility of an operator.">Precedence</a> for more explanation. </p>
<p>In addition to these, the binary <code>backtick</code> operators have a "precedence range" that is above Compare and below Power. This means that they are immiscible with the Multiply, Add, Arrow, AndBits, OrBits, OrIfNull, PrefixDots, and <a class="el" href="classLoyc_1_1Range.html">Range</a> operators, as explained in the documentation of <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html" title="A four-byte tuple that represents the precedence and miscibility of an operator.">Precedence</a>. </p>
<p>After constructing an initial table based on common operators from other languages, I noticed that </p><ul>
<li>
All the suffix operators (++ &ndash;) had the same precedence, so I added ... as an extra suffix operator with a lower precedence (but, not seeing a purpose for low-precedence suffixes, it's still above * and /.) </li>
<li>
None of the high-precedence operators were right-associative, so I added the !! operator to "fill in the gap". </li>
<li>
There were no prefix operators with low precedence, so I added ".." whose precedence is just above binary "..", and "|" which has a precedence lower than anything except attributes (this "operator" is inspired by Nemerle, which uses "|" in pattern matching and variants.) </li>
</ul>
<p>I also wanted to have a little "room to grow"&ndash;to defer the precedence decision to a future time for some operators. So the precedence of the binary operators ~ and &lt;&gt; is constrained to be above Compare and below NullDot; mixing one of these operators with any operator in this range will produce a "soft" parse error (meaning that parsing still proceeds but the exact precedence is undefined.) </p>
<p>The operators / \ &lt; &gt; ? = can be used as prefix operators, but their precedence is is similarly undefined (but definitely above Compare and below NullDot). </p>
<p>The way that low-precedence prefix operators are parsed deserves some discussion... TODO. </p>
<p>Most operators can have two roles. Most operators can either be binary operators or prefix operators; for example, <code>!*!</code> is a binary operator in <code>x !*! y</code> but a prefix operator in <code>x + !*! y</code>. </p>
<p>The operators <code>++ &ndash;</code> also have two roles, but different roles: they can be either prefix or suffix operators, but not binary operators. For example, <code>-*-</code> is a suffix operator in <code>x -*- + y</code> and a prefix operator in <code>x + -*- y</code>. Please note that <code>x -*- y</code> is ambiguous (it could be parsed as either of two superexpressions, <code>(x -*-) (y)</code> or <code>(x) (-*- y)</code>) and it is illegal. </p>
<p>Operators that end with $ can only be prefix operators (not binary or suffix). Operators that start and end with \ can only be suffix (not binary or prefix) operators. Having only a single role makes these operators unambiguous inside superexpressions. </p>
<p>An operator cannot have all three roles (suffix, prefix and binary); that would be overly ambiguous. For example, if "-" could also be a suffix operator then <code>x - + y</code> could be parsed as <code>(x -) + y</code> as well as <code>x - (+ y)</code>. More subtly, LES does not define any operators that could take binary or suffix roles, because that would also be ambiguous. For example, suppose <code>|?|</code> is a binary or suffix operator, but not a prefix operator. Clearly <code>x |?| y</code> and <code>x |?| |?| y</code> are unambiguous, but <code>x |?| + y</code> is ambiguous: it could be parsed as <code>(x |?|) + y</code> or <code>x |?| (+ y)</code>. It turns out that a computer language can contain operators that serve as binary and prefix operators, OR it can contain operators that serve as binary and suffix operators, but a language is ambiguous if it has both kinds of operators at the same time.</p>
<h3>How to detect an operator's precedence</h3>
<p>To determine the precedence of any given operator, first you must decide, mainly based on the context in which the operator appears and the text of the operator, whether it is a prefix, binary, or suffix operator. Suffix operators can only be derived from the operators <code>++, &ndash;, \</code> ("derived" means that you can add additional operator characters in the middle, e.g. <code>+++</code> and <code>-%-</code> are can be prefix or suffix operators.) </p>
<p>If an operator starts with a backslash (), the backslash is not considered part of the operator name and it not used for the purpose of choosing precedence either (rather, it is used to allow letters and digits in the operator name). A <code>backquoted</code> operator always has precedence of Backtick and again, the backticks are not considered part of the operator name. </p>
<p>Next, if the operator is only one character, simply find it in the above table. If the operator is two or more characters, take the first character A and the last character Z, and apply the following rules in order: </p><ol>
<li>
If the operator is binary and it is exactly equal to "&gt;=" or "&amp;lt;=" or "!=", the precedence is Compare. </li>
<li>
If the operator is binary, A is NOT '=', and Z is '=', then the precedence is Assign. </li>
<li>
Look for an operator named AZ. If it is defined, the operator will have the same precedence. For example, binary "=|&gt;" has the same precedence as binary "=&gt;". </li>
<li>
Otherwise, look for an entry in the table for Z. For example, binary "%+" has the same precedence as binary "+" and unary "%+" has the same precedence as unary "+". </li>
<li>
If no other rule applies (e.g. -operator), use Reserved for punctuation-based operators with undefined precedence and BackslashWord for all other operators (which will have started with a backslash). </li>
</ol>
<p>The first two rules are special cases that exist for the sake of the shift operators, so that "&gt;&gt;=" has the same precedence as "=" instead of "&gt;=". </p>
<p>Please note that the plain colon ':' is not treated as an operator at statement level; it is assumed to introduce a nested block, as in the languages Python and boo (e.g. in "if x: y();" is interpreted as "if x { y(); }"). However, ':' is allowed as an operator inside a parenthesized expression. ([June 2014] Python-style blocks are not yet implemented.) </p>
<p>The double-colon :: has the "wrong" precedence according to C# and C++ rules; <code>a.b::c.d</code> is parsed <code>(a.b)::(c.d)</code> although it would be parsed <code>((a.b)::c).d</code> in C# and C++. The change in precedence allows double colon to be used for variable declarations in <a class="el" href="namespaceLeMP.html" title="The lexical macro processor. Main classes: LeMP.Compiler and LeMP.MacroProcessor.">LeMP</a>, as in <code>x::System.Drawing.Point</code>. The lower precedence allows this to be parsed properly, but it sacrifices full fidelity with C#/C++. </p>
<p>There are no ternary operators in LES. '?' and ':' are right-associative binary operators, so <code>c ? a : b</code> is parsed as <code>c ? (a : b)</code>. The lack of an official ternary operator reduces the complexity of the parser; C-style conditional expressions could still be parsed in LEL with the help of a macro, but they are generally not necessary since the if-else superexpression is preferred: <code>if c a else b</code>. </p>
<p>I suppose I should also mention the way operators map to function names. In LES, there is no semantic distinction between operators and functions; <code>x += y</code> is equivalent to the function call <code>@+=(x, y)</code>, and the actual name of the function is "+=" (the @ character informs the lexer that a special identifier name follows.) Thus, the name of most operators exactly matches the operator; the + operator is named "+", the |*| operator is named "|*|", and so forth. There are a couple of exceptions: </p><ul>
<li>
While prefix ++ and &ndash; are named "++" and "--", the suffix versions are named "suf++" and "suf--" to distinguish them. </li>
<li>
The backslash is stripped from operators that start with a backslash. So + is named "+" and \ is named "foo\". + means the same thing as the normal + operator, it just has a different precedence. However, a single backslash () followed by whitespace is named "\". </li>
<li>
For operators surrounded by <code>backquotes</code>, the backquotes are not part of the name either; &gt; and <code>&gt;</code> and &gt; differ only in precedence. </li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html" title="A four-byte tuple that represents the precedence and miscibility of an operator.">Precedence</a></dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Public static fields</h2></td></tr>
<tr class="memitem:aa9bb5712f99ff67bd856e332d50f1d01"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa9bb5712f99ff67bd856e332d50f1d01"></a>
static readonly <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Substitute</b> = new <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>(106, 105)</td></tr>
<tr class="separator:aa9bb5712f99ff67bd856e332d50f1d01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6edd74b62cc04e05ac3d6f8c28912d80"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6edd74b62cc04e05ac3d6f8c28912d80"></a>
static readonly <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Primary</b> = new <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>(100)</td></tr>
<tr class="separator:a6edd74b62cc04e05ac3d6f8c28912d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5853313fb3a547b31be9e4ffd0e9d04"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad5853313fb3a547b31be9e4ffd0e9d04"></a>
static readonly <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><b>NullDot</b> = new <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>(95)</td></tr>
<tr class="separator:ad5853313fb3a547b31be9e4ffd0e9d04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cdd6e3a35ccc435f91952c69e5b6072"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3cdd6e3a35ccc435f91952c69e5b6072"></a>
static readonly <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><b>DoubleBang</b> = new <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>(91, 90)</td></tr>
<tr class="separator:a3cdd6e3a35ccc435f91952c69e5b6072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22b018cf348cd17f3ef2c3cf2a4cd150"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a22b018cf348cd17f3ef2c3cf2a4cd150"></a>
static readonly <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Prefix</b> = new <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>(85)</td></tr>
<tr class="separator:a22b018cf348cd17f3ef2c3cf2a4cd150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd3643f997f23a10e9eb60ec53073ce5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abd3643f997f23a10e9eb60ec53073ce5"></a>
static readonly <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Power</b> = new <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>(80)</td></tr>
<tr class="separator:abd3643f997f23a10e9eb60ec53073ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a678d0b145ed481c8e675576915d0cec9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a678d0b145ed481c8e675576915d0cec9"></a>
static readonly <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Suffix2</b> = new <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>(75)</td></tr>
<tr class="separator:a678d0b145ed481c8e675576915d0cec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd730beb81800989d1baf39cd14e8e4a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abd730beb81800989d1baf39cd14e8e4a"></a>
static readonly <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Multiply</b> = new <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>(70)</td></tr>
<tr class="separator:abd730beb81800989d1baf39cd14e8e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff3034b4106944c716aee464d6494ec2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff3034b4106944c716aee464d6494ec2"></a>
static readonly <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Arrow</b> = new <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>(65)</td></tr>
<tr class="separator:aff3034b4106944c716aee464d6494ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade4ddb4ba8c513e7206a52f5d910a81c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade4ddb4ba8c513e7206a52f5d910a81c"></a>
static readonly <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Add</b> = new <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>(60)</td></tr>
<tr class="separator:ade4ddb4ba8c513e7206a52f5d910a81c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a932f4658b28a49e4a3f75a5bcebaa0d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a932f4658b28a49e4a3f75a5bcebaa0d1"></a>
static readonly <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Shift</b> = new <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>(55, 55, 55, 70)</td></tr>
<tr class="separator:a932f4658b28a49e4a3f75a5bcebaa0d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5949b3175ffb1048122a8ffed7bc0d3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af5949b3175ffb1048122a8ffed7bc0d3"></a>
static readonly <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PrefixDots</b> = new <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>(50)</td></tr>
<tr class="separator:af5949b3175ffb1048122a8ffed7bc0d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab052fc9d1095a99bebdc17d6a1e45677"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab052fc9d1095a99bebdc17d6a1e45677"></a>
static readonly <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Range</b> = new <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>(45)</td></tr>
<tr class="separator:ab052fc9d1095a99bebdc17d6a1e45677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64f9c846992b5c44be8e41f211e3387b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a64f9c846992b5c44be8e41f211e3387b"></a>
static readonly <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><b>OrIfNull</b> = new <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>(40, 40, 40, 76)</td></tr>
<tr class="separator:a64f9c846992b5c44be8e41f211e3387b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a147fb98f032417f7633beb5ce412d51b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a147fb98f032417f7633beb5ce412d51b"></a>
static readonly <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Backtick</b> = new <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>(40, 40, 40, 75)</td></tr>
<tr class="separator:a147fb98f032417f7633beb5ce412d51b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a811d7887714c5d4cf5398ed78f3c08fa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a811d7887714c5d4cf5398ed78f3c08fa"></a>
static readonly <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Reserved</b> = new <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>(40, 40, 40, 90)</td></tr>
<tr class="separator:a811d7887714c5d4cf5398ed78f3c08fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a185d971d56531e611cf75bb4d95a9cd9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a185d971d56531e611cf75bb4d95a9cd9"></a>
static readonly <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Compare</b> = new <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>(35)</td></tr>
<tr class="separator:a185d971d56531e611cf75bb4d95a9cd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a5da27c4ee9c4ee5099d934eed2bc1a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a5da27c4ee9c4ee5099d934eed2bc1a"></a>
static readonly <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AndBits</b> = new <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>(30, 30, 25, 50)</td></tr>
<tr class="separator:a2a5da27c4ee9c4ee5099d934eed2bc1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46008db0862f5210f48568347c7c15f4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a46008db0862f5210f48568347c7c15f4"></a>
static readonly <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><b>OrBits</b> = new <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>(25, 25, 25, 50)</td></tr>
<tr class="separator:a46008db0862f5210f48568347c7c15f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8bbf445cfa6a8d2213fc5442b0f25f6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8bbf445cfa6a8d2213fc5442b0f25f6"></a>
static readonly <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><b>And</b> = new <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>(20)</td></tr>
<tr class="separator:ab8bbf445cfa6a8d2213fc5442b0f25f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e4ee7b7939ea8136ba9e4db6c25a181"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e4ee7b7939ea8136ba9e4db6c25a181"></a>
static readonly <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Or</b> = new <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>(15)</td></tr>
<tr class="separator:a8e4ee7b7939ea8136ba9e4db6c25a181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8df17dd1636a6d89d3459bee50d4cc7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8df17dd1636a6d89d3459bee50d4cc7"></a>
static readonly <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><b>IfElse</b> = new <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>(11, 10)</td></tr>
<tr class="separator:af8df17dd1636a6d89d3459bee50d4cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac33c3738835ef2fadb907f22cac08bdb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac33c3738835ef2fadb907f22cac08bdb"></a>
static readonly <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Assign</b> = new <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>(6, 5)</td></tr>
<tr class="separator:ac33c3738835ef2fadb907f22cac08bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46260591bdf468d70b22f019872fa212"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a46260591bdf468d70b22f019872fa212"></a>
static readonly <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Lambda</b> = new <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>(77, 0, -1, -1)</td></tr>
<tr class="separator:a46260591bdf468d70b22f019872fa212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcfd4d7292af5964f33be3117ee4d92b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abcfd4d7292af5964f33be3117ee4d92b"></a>
static readonly <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PrefixOr</b> = new <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>(0)</td></tr>
<tr class="separator:abcfd4d7292af5964f33be3117ee4d92b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92c6be7119cc38dd5e2cf720c4e2b146"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a92c6be7119cc38dd5e2cf720c4e2b146"></a>
static readonly <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><b>SuperExpr</b> = new <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>(-5)</td></tr>
<tr class="separator:a92c6be7119cc38dd5e2cf720c4e2b146"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Mar 18 2016 22:22:49 for Loyc by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
