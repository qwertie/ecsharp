<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>Loyc: Loyc.Syntax.Precedence Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Loyc
   </div>
   <div id="projectbrief">Language of your choice: library documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Events</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceLoyc.html">Loyc</a></li><li class="navelem"><a class="el" href="namespaceLoyc_1_1Syntax.html">Syntax</a></li><li class="navelem"><a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Public fields</a> &#124;
<a href="#pub-static-attribs">Public static fields</a> &#124;
<a href="#properties">Properties</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="structLoyc_1_1Syntax_1_1Precedence-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Loyc.Syntax.Precedence Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents the precedence and miscibility of an operator. 
 <a href="structLoyc_1_1Syntax_1_1Precedence.html#details">More...</a></p>
<hr/>Source code:<ul>
<li><a href='https://github.com/qwertie/Loyc/blob/master/Src/Loyc.Syntax/Precedence.cs'>/Src/Loyc.Syntax/Precedence.cs</a></li>
</ul>
<div class="dynheader">
Inheritance diagram for Loyc.Syntax.Precedence:</div>
<div class="dyncontent">
 <div class="center">
  <img src="structLoyc_1_1Syntax_1_1Precedence.png" usemap="#Loyc.Syntax.Precedence_map" alt=""/>
  <map id="Loyc.Syntax.Precedence_map" name="Loyc.Syntax.Precedence_map">
</map>
 </div></div>
<a name="details" id="details"></a><h2 class="groupheader">Remarks</h2>
<div class="textblock"><p>Represents the precedence and miscibility of an operator.</p>
<p>This class contains four numbers. The first two, Lo and Hi, are a precedence range that describes how the operator can be mixed with other operators. If one operator's range overlaps another AND the ranges are not equal, then the two operators are immiscible. For example, == and != have the same precedence in EC#, 38..39, so they can be mixed with each other, but they cannot be mixed with &amp; which has the overlapping range 32..45 (this will be explained below.) </p>
<p>The "actual" precedence is encoded in the other two numbers, <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html#aa336b14413bbed1bc0192bf90d297295" title="Left and Right denote the precedence level on the left and right sides of an operator; see the remark...">Left</a> and Right. These numbers encode the knowledge that, for example, <code>x &amp; y == z</code> will be parsed as <code>x &amp; (y == z)</code>. Normally, Left and Right are the same. However, some operators have different precedence on the left than on the right, a prime example being the =&gt; operator: <code>x = a =&gt; y = a</code> is parsed <code>x = (a =&gt; (y = a))</code>; it has very high precedence on the left, but very low precedence on the right. </p>
<p>To understand how this works, remember that a parser scans from left to right. Each time it encounters a new operator, it needs to figure out whether to include that operator in the current (inner) expression or whether to "complete" the inner expression and bind the operator to an outer expression instead. The concept of a "precedence floor" can be used to make this decision. </p>
<p>For example, suppose we start parsing the expression <code>-a.b + c * d + e</code>. The parser sees "-" first, which must be a prefix operator since there is no expression on the left. The Right precedence of unary '-' is 90 in EC#, so that will be the "precedence floor" to parse the right-hand side. Operators above 90 will be permitted in the right-hand side; operators at 90 or below will not. </p>
<p>The next token is 'a', which is an expression by itself and doesn't have any precedence, so it becomes the initial right-hand expression of '-'. Next we have '.', which has a <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html#aa336b14413bbed1bc0192bf90d297295" title="Left and Right denote the precedence level on the left and right sides of an operator; see the remark...">Left</a> precedence of 100, which is above the precedence floor of 90 so it can be bound to 'a'. The precedence floor (PF) is raised to 100, and the next token 'b' is bound to '.'. </p>
<p>However, the next token '+' (which must be the binary operator rather than the prefix operator, because there is an expression on the left) cannot be accepted with its precedence of 60. Therefore the expression "a.b" is deemed complete, and the PF is lowered back to 90. Again 60 is less than 90, so the expression "-a.b" is also deemed complete and the PF drops to int.MinValue. This expression becomes the left-hand side of the '+' operator. The PF rises to 60, and "c * d" becomes a subexpression because the precedence of '*' is 70 &gt; 60. However, next we have '+' with precedence 60, which is not above the PF of 60. Therefore, the subexpression "c * d" is deemed complete and the PF lowers to int.MinValue again. Now the '+' can be accepted with a left-hand side of <code>(-(a.b)) + (c * d)</code>, and the right-hand side is, of course, 'e', so the completed expression is <code>((-(a.b)) + (c * d)) + e</code>. Hope that helps! </p>
<p>Notice that <code>a + b + c</code> is parsed <code>(a + b) + c</code>, not <code>a + (b + c)</code>. This is the natural result when the operator's precedence is the same on the left and on the right. However, <code>a = b = c</code> is parsed <code>a = (b = c)</code>, because its precedence is 1 on the left and 0 on the right. When the parser sees the first '=' it sets the PF to 0 because it is about to parse the right side. When it encounters the second '=', the left-hand precedence of that operator is 1 which is higher than the current PF (0) so it is included in the right-hand side of the first '='. This behavior is called "right associativity"; <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html#ac587c783e958192a3d409fb8a973b39a" title="Returns true if this object represents a right-associative operator such as equals (x = (y = z))...">IsRightAssociative</a> returns true when <code>Left &gt; Right</code>. </p>
<p>Prefix and suffix operators only have one "side"; you can imagine that the unused side (e.g. the left side of prefix -) has infinite precedence, so that EC# can parse $-x as $(-x) even though the precedence of '-' is supposedly lower than '$'. </p>
<p>Some languages have a conditional operator (a?b:c) with three parts. In the middle part, the PF must drop to Precedence.MinValue so that it is possible to parse <code>a?b=x:c</code> even though '=' supposedly has lower precedence than the conditional operator. Note that <code>a=b ? c=d : e=f</code> is interpreted <code>a=(b ? c=d : e)=f</code>, so you can see that the precedence of the conditional operator is higher at the "edges". </p>
<p>The above explanation illustrates the meaning of Left and Right from the perspective of a parser, but an actual parser may or may not use the PF concept and PrecedenceRange objects. </p>
<p>The printer (e.g. LesNodePrinter) has a different way of analyzing precedence. It starts with a known parse tree and then has to figure out how to output something that the parser will reconstruct into the original tree. Making this more difficult is the fact that in <a class="el" href="namespaceLoyc.html" title="Main Loyc namespace. This namespace includes all general-purpose code in the Loyc megaproject...">Loyc</a> trees, parens are significant; therefore the printer cannot simply put expressions in parens "just to be safe"&ndash;extra parenthesis will change the syntax tree, so round- tripping will fail. </p>
<p>Generally, the printer has two ways of printing any expression tree: (1) with operators (e.g. a+b), and (2) with prefix notation (e.g. #+(a, b)). The tree <code>#+(#*(a, b), c)</code> will be printed as "a*b+c" (unless prefix notation is specifically requested) because the precedence rules allow it, but <code>#*(#+(a, b), c)</code> will be printed as <code>#+(a, b)*c</code> because both "a+b*c" and "(a+b)*c" are different from the original tree. </p>
<p>While a parser proceeds from left to right, a printer proceeds from parents to children. So the printer for #*(#+(a, b), c) starts at #* with no precedence restrictions, and roughly speaking will set the precedence floor to LesPrecedence.Multiply in order to print its two children. Since the precedence of #+ (Add) is below Multiply, the + operator is not allowed in that context and either prefix notation or extra parenthesis is used as a fallback (depending on the LesNodePrinter.AllowExtraParenthesis option that permits <code>(a+b)*c</code>). </p>
<p>Printing has numerous "gotchas"; the ones related to precedence are </p><ol>
<li>
Although LesPrecedence.Add has the "same" precedence on the Left and Right, <code>#-(#-(a, b), c)</code> can be printed <code>a - b - c</code> but <code>#-(a, #-(b, c))</code> would have to be printed <code>a - #-(b, c)</code> instead. Clearly, the left and right sides must be treated somehow differently. </li>
<li>
Similarly, the different arguments in <code>a?b:c</code> and <code>a=&gt;b</code> must be treated differently. And careful handling is needed for the dot operator in particular due to its high precedence; e.g. <code>#.(a(b))</code> cannot be printed <code>.a(b)</code> because that would mean <code>#.(a)(b)</code>. </li>
<li>
The LES parser, at least, allows a prefix operator to appear on the right-hand side of any infix or prefix operator, regardless of the precedence of the two operators; "$ ++x" is permitted even though ++ has lower precedence than $. Another example is that <code>a.-b.c</code> can be parsed with the interpretation <code>a.(-b).c</code>, even though #- has lower precedence than #$. Ideally the printer would replicate this rule, but whether it does ot not, it also must take care that <code>#.(a, -b.c)</code> is not printed as <code>a.-b.c</code> even though the similar expression <code>#*(a, #-(b.c))</code> can be printed as <code>a*-b.c</code>. </li>
<li>
Prefix notation is needed when an operator's arguments have attributes; <code>#+([Foo] a, b)</code> cannot be printed <code>[Foo] a + b</code> because that would mean <code>[Foo] #+(a, b)</code>. </li>
</ol>
<h3>Printing and parsing are different</h3>
<p>This type contains different methods for printers and parsers. A basic difference between them is that printers must make decisions (of whether an operator is allowed or not in a given context) based on both sides of the operator and both sides of the context (Left and Right), while parsers only have to worry about one side. For example, consider the following expression: </p><div class="fragment"><div class="line">a = b + c ?? d</div>
</div><!-- fragment --><p> When the parser encounters the "+" operator, it only has to consider whether the precedence of the <em>left-hand side</em> of the "+" operator is above the <em>right-hand side</em> of the "=" operator. The fact that there is a "??" later on is irrelevant. In contrast, when printing the expression "b + c", both sides of the "+" operator and both sides of the context must be considered. The right-hand side is relevant because if the right-hand operator was "*" instead of "??", the following printout would be wrong: </p><div class="fragment"><div class="line">a = b + c * d   <span class="comment">// actual syntax tree: a = #+(b, c) * d</span></div>
</div><!-- fragment --><p> The same reasoning applies to the left-hand side (imagine if "=" was "*" instead.) </p>
<p>So, naturally there are different methods for parsing and printing. For printing you can use <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html#aeca528a19eac804f3d8609337361ce0e" title="For use in printers. Returns true if an infix operator with this precedence can appear in the specifi...">CanAppearIn(Precedence)</a>, <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html#af07a82282e299b44ea73a18eac73afd9" title="For use in printers. Auto-raises the precedence floor to prepare to print an expression on the left s...">LeftContext</a> and <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html#af7cc55f4627e92274a930ee9021a203e" title="For use in printers. Auto-raises the precedence floor to prepare to print an expression on the right ...">RightContext</a>, while for parsing you only need <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html#a2d2b5a804370c95545031ed1f5da0df3" title="For use in parsers. Returns true if &#39;rightOp&#39;, an operator on the right, has higher precedence than t...">CanParse</a> (to raise the precedence floor, simply replace the current <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html" title="Represents the precedence and miscibility of an operator.">Precedence</a> value with that of the new operator). In a parser, the "current" precedence is represented by Right; the value of <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html#aa336b14413bbed1bc0192bf90d297295" title="Left and Right denote the precedence level on the left and right sides of an operator; see the remark...">Left</a> doesn't matter. </p>
<p>Both printers and parsers can use <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html#a494101430520b6ca70b21de7627b1c74" title="Returns true if an operator with this precedence is miscible without parenthesis with the specified o...">CanMixWith</a>.</p>
<h3>Miscibility (mixability)</h3>
<p>Certain operators should not be mixed because their precedence was originally chosen incorrectly, e.g. x &amp; 3 == 1 should be parsed (x &amp; 3) == 1 but is actually parsed x &amp; (3 == 1). To allow the precedence to be repaired eventually, expressions like x &amp; y == z are deprecated in EC#: the parser will warn you if you have mixed operators improperly. PrecedenceRange describes both precedence and miscibility with a simple range of integers. As mentioned before, two operators are immiscible if their ranges overlap but are not identical. </p>
<p>In LES, the precedence range feature (a.k.a. immiscibility) is used to indicate that a specific precedence has not been chosen for an operator. If a precedence is chosen in the future, it will be somewhere within the range.</p>
<h3>Overall Range</h3>
<p>By convention, precedence scales range from 0 to 100 (or slightly higher). The precedence numbers are stored in this structure as <code>sbyte</code>s, so the standard range cannot be exceeded by much. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public fields</h2></td></tr>
<tr class="memitem:a960ac158fb2d0d01817f5a15d4adf694"><td class="memItemLeft" align="right" valign="top">readonly sbyte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html#a960ac158fb2d0d01817f5a15d4adf694">Lo</a></td></tr>
<tr class="memdesc:a960ac158fb2d0d01817f5a15d4adf694"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lo and Hi specify the miscibility of an operator; see the remarks of <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html" title="Represents the precedence and miscibility of an operator.">Precedence</a> for details. <a href="#a960ac158fb2d0d01817f5a15d4adf694">More...</a><br /></td></tr>
<tr class="separator:a960ac158fb2d0d01817f5a15d4adf694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96860f88e7aa19e0e82295c24e5df515"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96860f88e7aa19e0e82295c24e5df515"></a>
readonly sbyte&#160;</td><td class="memItemRight" valign="bottom"><b>Hi</b></td></tr>
<tr class="separator:a96860f88e7aa19e0e82295c24e5df515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa336b14413bbed1bc0192bf90d297295"><td class="memItemLeft" align="right" valign="top">readonly sbyte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html#aa336b14413bbed1bc0192bf90d297295">Left</a></td></tr>
<tr class="memdesc:aa336b14413bbed1bc0192bf90d297295"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left and Right denote the precedence level on the left and right sides of an operator; see the remarks of <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html" title="Represents the precedence and miscibility of an operator.">Precedence</a> for details. <a href="#aa336b14413bbed1bc0192bf90d297295">More...</a><br /></td></tr>
<tr class="separator:aa336b14413bbed1bc0192bf90d297295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4be1fbcbc9124c7ae6b258bc76bcace1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4be1fbcbc9124c7ae6b258bc76bcace1"></a>
readonly sbyte&#160;</td><td class="memItemRight" valign="bottom"><b>Right</b></td></tr>
<tr class="separator:a4be1fbcbc9124c7ae6b258bc76bcace1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Public static fields</h2></td></tr>
<tr class="memitem:a746276b3b14c203aeb110b1d1ee42f03"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a746276b3b14c203aeb110b1d1ee42f03"></a>
static readonly <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><b>MinValue</b> = new <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>(sbyte.MinValue, sbyte.MinValue, sbyte.MinValue)</td></tr>
<tr class="separator:a746276b3b14c203aeb110b1d1ee42f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87c8fb4fe8a04f294ebffe506fa6020b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a87c8fb4fe8a04f294ebffe506fa6020b"></a>
static readonly <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><b>MaxValue</b> = new <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>(sbyte.MaxValue, sbyte.MaxValue, sbyte.MaxValue)</td></tr>
<tr class="separator:a87c8fb4fe8a04f294ebffe506fa6020b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:ac587c783e958192a3d409fb8a973b39a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html#ac587c783e958192a3d409fb8a973b39a">IsRightAssociative</a><code> [get]</code></td></tr>
<tr class="memdesc:ac587c783e958192a3d409fb8a973b39a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this object represents a right-associative operator such as equals (x = (y = z)), in contrast to left- associative operators such as division ((x / y) / z). <a href="#ac587c783e958192a3d409fb8a973b39a">More...</a><br /></td></tr>
<tr class="separator:ac587c783e958192a3d409fb8a973b39a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a11dcada0dea777c4e7514e3233799983"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a11dcada0dea777c4e7514e3233799983"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Precedence</b> (int actual)</td></tr>
<tr class="separator:a11dcada0dea777c4e7514e3233799983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a0b5f109f06e9a376ab06895ec27c6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af9a0b5f109f06e9a376ab06895ec27c6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Precedence</b> (int lo, int hi, int actual)</td></tr>
<tr class="separator:af9a0b5f109f06e9a376ab06895ec27c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af88c434b86e0e7a4a828098e40685d6e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af88c434b86e0e7a4a828098e40685d6e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Precedence</b> (int lo, int hi, int left, int right)</td></tr>
<tr class="separator:af88c434b86e0e7a4a828098e40685d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b95cbe44d73fc56cd43000c90615611"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b95cbe44d73fc56cd43000c90615611"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Precedence</b> (sbyte lo, sbyte hi, sbyte left, sbyte right)</td></tr>
<tr class="separator:a4b95cbe44d73fc56cd43000c90615611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af07a82282e299b44ea73a18eac73afd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html#af07a82282e299b44ea73a18eac73afd9">LeftContext</a> (<a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a> outerContext)</td></tr>
<tr class="memdesc:af07a82282e299b44ea73a18eac73afd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">For use in printers. Auto-raises the precedence floor to prepare to print an expression on the left side of an operator. <a href="#af07a82282e299b44ea73a18eac73afd9">More...</a><br /></td></tr>
<tr class="separator:af07a82282e299b44ea73a18eac73afd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7cc55f4627e92274a930ee9021a203e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html#af7cc55f4627e92274a930ee9021a203e">RightContext</a> (<a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a> outerContext)</td></tr>
<tr class="memdesc:af7cc55f4627e92274a930ee9021a203e"><td class="mdescLeft">&#160;</td><td class="mdescRight">For use in printers. Auto-raises the precedence floor to prepare to print an expression on the right side of an operator. <a href="#af7cc55f4627e92274a930ee9021a203e">More...</a><br /></td></tr>
<tr class="separator:af7cc55f4627e92274a930ee9021a203e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeca528a19eac804f3d8609337361ce0e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html#aeca528a19eac804f3d8609337361ce0e">CanAppearIn</a> (<a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a> context)</td></tr>
<tr class="memdesc:aeca528a19eac804f3d8609337361ce0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">For use in printers. Returns true if an infix operator with this precedence can appear in the specified context. <a href="#aeca528a19eac804f3d8609337361ce0e">More...</a><br /></td></tr>
<tr class="separator:aeca528a19eac804f3d8609337361ce0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f6debe554f34455cbee81f97bb9a40"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html#a54f6debe554f34455cbee81f97bb9a40">CanAppearIn</a> (<a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a> context, bool prefix)</td></tr>
<tr class="memdesc:a54f6debe554f34455cbee81f97bb9a40"><td class="mdescLeft">&#160;</td><td class="mdescRight">For use in printers. Returns true if a prefix operator with this precedence can appear in the specified context's right-hand precedence floor. <a href="#a54f6debe554f34455cbee81f97bb9a40">More...</a><br /></td></tr>
<tr class="separator:a54f6debe554f34455cbee81f97bb9a40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a494101430520b6ca70b21de7627b1c74"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html#a494101430520b6ca70b21de7627b1c74">CanMixWith</a> (<a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a> context)</td></tr>
<tr class="memdesc:a494101430520b6ca70b21de7627b1c74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if an operator with this precedence is miscible without parenthesis with the specified other operator. <a href="#a494101430520b6ca70b21de7627b1c74">More...</a><br /></td></tr>
<tr class="separator:a494101430520b6ca70b21de7627b1c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d2b5a804370c95545031ed1f5da0df3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html#a2d2b5a804370c95545031ed1f5da0df3">CanParse</a> (<a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a> rightOp)</td></tr>
<tr class="memdesc:a2d2b5a804370c95545031ed1f5da0df3"><td class="mdescLeft">&#160;</td><td class="mdescRight">For use in parsers. Returns true if 'rightOp', an operator on the right, has higher precedence than the current operator 'this'. <a href="#a2d2b5a804370c95545031ed1f5da0df3">More...</a><br /></td></tr>
<tr class="separator:a2d2b5a804370c95545031ed1f5da0df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dce0d00dabbd53ce08926e61a3774a9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9dce0d00dabbd53ce08926e61a3774a9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>RangeEquals</b> (<a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a> b)</td></tr>
<tr class="separator:a9dce0d00dabbd53ce08926e61a3774a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb5e600402693a977c1f98321d5de869"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb5e600402693a977c1f98321d5de869"></a>
override bool&#160;</td><td class="memItemRight" valign="bottom"><b>Equals</b> (object obj)</td></tr>
<tr class="separator:afb5e600402693a977c1f98321d5de869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1feb2fda4a8db0e918c86beef577ce2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1feb2fda4a8db0e918c86beef577ce2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Equals</b> (<a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a> other)</td></tr>
<tr class="separator:af1feb2fda4a8db0e918c86beef577ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a330e39fe07690c49bc0313b73bcd1b42"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a330e39fe07690c49bc0313b73bcd1b42"></a>
override int&#160;</td><td class="memItemRight" valign="bottom"><b>GetHashCode</b> ()</td></tr>
<tr class="separator:a330e39fe07690c49bc0313b73bcd1b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:af476498a3535eec467058cccec99be76"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af476498a3535eec467058cccec99be76"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (<a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a> a, <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a> b)</td></tr>
<tr class="separator:af476498a3535eec467058cccec99be76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dabb7ccb718d67ff482ed4399a01b1d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4dabb7ccb718d67ff482ed4399a01b1d"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (<a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a> a, <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a> b)</td></tr>
<tr class="separator:a4dabb7ccb718d67ff482ed4399a01b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aeca528a19eac804f3d8609337361ce0e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Loyc.Syntax.Precedence.CanAppearIn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For use in printers. Returns true if an infix operator with this precedence can appear in the specified context.</p>
<p>Miscibility must be checked separately (<a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html#a494101430520b6ca70b21de7627b1c74" title="Returns true if an operator with this precedence is miscible without parenthesis with the specified o...">CanMixWith</a>).</p>

</div>
</div>
<a class="anchor" id="a54f6debe554f34455cbee81f97bb9a40"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Loyc.Syntax.Precedence.CanAppearIn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For use in printers. Returns true if a prefix operator with this precedence can appear in the specified context's right-hand precedence floor.</p>
<p>It is assumed that the left side of a prefix operator has "infinite" precedence so only the right side is checked. This rule is used by the EC# printer but may not be needed or allowed in all languages (if in doubt, set prefix=false).</p>

<p>References <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html#aa336b14413bbed1bc0192bf90d297295">Loyc.Syntax.Precedence.Left</a>.</p>

</div>
</div>
<a class="anchor" id="a494101430520b6ca70b21de7627b1c74"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Loyc.Syntax.Precedence.CanMixWith </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if an operator with this precedence is miscible without parenthesis with the specified other operator.</p>
<p><a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html#aeca528a19eac804f3d8609337361ce0e" title="For use in printers. Returns true if an infix operator with this precedence can appear in the specifi...">CanAppearIn(Precedence)</a> is for parsability, this method is to detect a deprecated or undefined mixing of operators. </p>

</div>
</div>
<a class="anchor" id="a2d2b5a804370c95545031ed1f5da0df3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Loyc.Syntax.Precedence.CanParse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td>
          <td class="paramname"><em>rightOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For use in parsers. Returns true if 'rightOp', an operator on the right, has higher precedence than the current operator 'this'.</p>
<dl class="section return"><dt>Returns</dt><dd><code>rightOp.Left &gt; this.Right</code></dd></dl>

</div>
</div>
<a class="anchor" id="af07a82282e299b44ea73a18eac73afd9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a> Loyc.Syntax.Precedence.LeftContext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td>
          <td class="paramname"><em>outerContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For use in printers. Auto-raises the precedence floor to prepare to print an expression on the left side of an operator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outerContext</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p>References <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html#aa336b14413bbed1bc0192bf90d297295">Loyc.Syntax.Precedence.Left</a>.</p>

</div>
</div>
<a class="anchor" id="af7cc55f4627e92274a930ee9021a203e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a> Loyc.Syntax.Precedence.RightContext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td>
          <td class="paramname"><em>outerContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For use in printers. Auto-raises the precedence floor to prepare to print an expression on the right side of an operator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outerContext</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="aa336b14413bbed1bc0192bf90d297295"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly sbyte Loyc.Syntax.Precedence.Left</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Left and Right denote the precedence level on the left and right sides of an operator; see the remarks of <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html" title="Represents the precedence and miscibility of an operator.">Precedence</a> for details.</p>

<p>Referenced by <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html#a54f6debe554f34455cbee81f97bb9a40">Loyc.Syntax.Precedence.CanAppearIn()</a>, and <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html#af07a82282e299b44ea73a18eac73afd9">Loyc.Syntax.Precedence.LeftContext()</a>.</p>

</div>
</div>
<a class="anchor" id="a960ac158fb2d0d01817f5a15d4adf694"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly sbyte Loyc.Syntax.Precedence.Lo</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lo and Hi specify the miscibility of an operator; see the remarks of <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html" title="Represents the precedence and miscibility of an operator.">Precedence</a> for details.</p>

</div>
</div>
<h2 class="groupheader">Property Documentation</h2>
<a class="anchor" id="ac587c783e958192a3d409fb8a973b39a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Loyc.Syntax.Precedence.IsRightAssociative</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this object represents a right-associative operator such as equals (x = (y = z)), in contrast to left- associative operators such as division ((x / y) / z).</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jul 6 2014 23:54:43 for Loyc by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
