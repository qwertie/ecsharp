<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Loyc.Essentials</name>
    </assembly>
    <members>
        <member name="T:Loyc.Collections.ListExt">
            <summary>Extension methods and helper methods for <see cref="T:System.Collections.Generic.List`1"/>,
            <see cref="T:System.Collections.Generic.IList`1"/>, <see cref="T:System.Collections.Generic.IReadOnlyList`1"/>, arrays, 
            <see cref="T:Loyc.Collections.IListSource`1"/>, and for related mutable interfaces such as 
            <see cref="T:Loyc.Collections.IArray`1"/>. 
            </summary>
            <remarks>
            Extension methods that only apply to Loyc's new interfaces, or adapt a 
            list to those interfaces, will go in <see cref="T:Loyc.Collections.LCExt"/> instead.
            <para/>
            The source code for adapter extension methods such as the Slice() method for 
            arrays, which returns an <see cref="T:Loyc.Collections.ArraySlice`1"/> adapter, is now 
            placed in the source file for each adapter class (e.g. ArraySlice.cs)
            to make it easier to create custom versions of Loyc.Essentials with parts 
            removed.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.ListExt.Repeat``1(``0,System.Int32)">
            <summary>Returns a helper object that stores one value, but acts like 
            a read-only list that repeats the value the specified number of times.</summary>
            <returns><c>new Repeated&lt;T>(value, count)</c></returns>
        </member>
        <member name="M:Loyc.Collections.ListExt.Single``1(``0)">
            <summary>Returns a helper object that stores one value, but acts like 
            a read-only list of one item.</summary>
            <returns><c>new Repeated&lt;T>(value, 1)</c></returns>
        </member>
        <member name="M:Loyc.Collections.ListExt.RemoveRange``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32)">
            <summary>Removes <c>count</c> items from <c>list</c> starting at the specified <c>index</c>.</summary>
        </member>
        <member name="M:Loyc.Collections.ListExt.Resize``1(System.Collections.Generic.List{``0},System.Int32)">
            <summary>Resizes a list by removing items from the list (if it is too 
            long) or adding <c>default(T)</c> values to the end (if it is too short).</summary>
        </member>
        <member name="M:Loyc.Collections.ListExt.Resize``1(System.Collections.Generic.IList{``0},System.Int32)">
            <summary>Resizes a list by removing items from the list (if it is too 
            long) or adding <c>default(T)</c> values to the end (if it is too short).</summary>
        </member>
        <member name="M:Loyc.Collections.ListExt.Zip``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
            <summary>Returns a sequence of length <c>Min(a.Count(), b.Count())</c> 
            of items from <c>a</c> and <c>b</c> paired together. The output is
            produced lazily, so infinite input sequences are supported.</summary>
        </member>
        <member name="M:Loyc.Collections.ListExt.ZipLeft``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},``1)">
            <summary>Returns a sequence that has the same length as the first sequence,
            with items from the first and second sequence paired together.</summary>
            <param name="defaultB">If the second sequence <c>b</c> is shorter than the 
            first sequence, the remaining items of the first sequence are paired with 
            this value. Otherwise, this value is not used.</param>
        </member>
        <member name="M:Loyc.Collections.ListExt.ZipLeft``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},``1,System.Func{``0,``1,``2})">
            <summary>An alternate version of <see cref="M:Loyc.Collections.ListExt.ZipLeft``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},``1)"/>
            in which a user-defined function is used to combine the items from the two lists.</summary>
            <param name="defaultB">If the second sequence <c>b</c> is shorter than the 
            first sequence, the remaining items of the first sequence are paired with 
            this value. Otherwise, this value is not used.</param>
            <param name="resultSelector">A function that combines items from the two lists.</param>
        </member>
        <member name="M:Loyc.Collections.ListExt.ZipLonger``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
            <summary>Returns a sequence as long as the longer of two sequences.
            Items from the first and second sequence are initially paired together, and when
            one sequence ends, the other sequence's remaining values are paired 
            with a default value.</summary>
        </member>
        <member name="M:Loyc.Collections.ListExt.ZipLonger``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},``0,``1)">
            <summary>Returns a sequence as long as the longer of two sequences.
            Items from the first and second sequence are initially paired together, 
            and when one sequence ends, the other sequence's remaining values are 
            paired with a default value provided as a parameter.</summary>
            <param name="defaultA">If the first sequence <c>a</c> is shorter than the 
            second sequence, the remaining items of the second sequence are paired with 
            this value. Otherwise, this value is not used.</param>
            <param name="defaultB">If the second sequence <c>b</c> is shorter than the 
            first sequence, the remaining items of the first sequence are paired with 
            this value. Otherwise, this value is not used.</param>
        </member>
        <member name="M:Loyc.Collections.ListExt.ZipLonger``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},``0,``1,System.Func{``0,``1,``2})">
            <summary>An alternate version of <see cref="M:Loyc.Collections.ListExt.ZipLonger``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},``0,``1)"/>
            in which a user-defined function is used to combine the items from the two lists.</summary>
            <param name="resultSelector">A function that combines items from the two lists.</param>
        </member>
        <member name="M:Loyc.Collections.ListExt.RangeArray(System.Int32)">
            <summary>Returns an array of Length <c>count</c> containing the numbers 0 through <c>count-1</c>.</summary>
        </member>
        <member name="M:Loyc.Collections.ListExt.Sort``1(System.Collections.Generic.IList{``0})">
            <inheritdoc cref="M:Loyc.Collections.ListExt.Sort``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32,System.Comparison{``0})"/>
        </member>
        <member name="M:Loyc.Collections.ListExt.Sort``1(System.Collections.Generic.IList{``0},System.Comparison{``0})">
            <inheritdoc cref="M:Loyc.Collections.ListExt.Sort``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32,System.Comparison{``0})"/>
        </member>
        <member name="M:Loyc.Collections.ListExt.Sort``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32,System.Comparison{``0})">
            <summary>Performs a quicksort using a Comparison function.</summary>
            <param name="index">Index at which to begin sorting a portion of the list.</param>
            <param name="count">Number of items to sort starting at 'index'.</param>
            <remarks>
            This method exists because the .NET framework offers no method to
            sort <see cref="T:System.Collections.Generic.IList`1"/>--you can sort arrays and <see cref="T:System.Collections.Generic.List`1"/>, 
            but not IList.
            <para/>
            This quicksort algorithm uses a best-of-three pivot so that it remains
            performant (fast) if the input is already sorted. It is designed to 
            perform reasonably well in case the data contains many duplicates (not
            verified). It is also designed to avoid using excessive stack space if 
            a worst-case input occurs that requires O(N^2) time.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.ListExt.StableSort``1(System.Collections.Generic.IList{``0},System.Comparison{``0})">
            <summary>Performs a stable sort, i.e. a sort that preserves the 
            relative order of items that compare equal.</summary>
            <remarks>
            On larger inputs, this algorithm uses a quicksort and therefore runs 
            in O(N log N) time, but it requires O(N) temporary space (specifically, 
            an array of N integers) and is slower than a standard quicksort, so 
            you should use it only if you need a stable sort or if the input is
            usually small (in which case insertion sort is used).
            </remarks>
        </member>
        <member name="M:Loyc.Collections.ListExt.SortLowestK``1(System.Collections.Generic.IList{``0},System.Int32)">
            <summary>Uses a partial quicksort, known as "quickselect", to find and
            sort the lowest k elements in a list.</summary>
            <typeparam name="T"></typeparam>
            <param name="list">A list that will be partially sorted.</param>
            <param name="k">Number of elements that will be sorted at the beginning 
            of the list when this method returns. If <c>k > list.Count</c>, the 
            entire list is sorted.</param>
            <returns>Although the list is modified in-place, a slice of the 
            beginning of the same list is returned. The slice will have k elements 
            (or list.Count elements, whichever is less).</returns>
            <remarks>Whereas quicksort typically runs in O(N log N) time,
            quickselect typically requires O(N) time for small values of k, 
            although the worst-case performance remains O(N^2).</remarks>
        </member>
        <member name="M:Loyc.Collections.ListExt.SortLowestKStable``1(System.Collections.Generic.IList{``0},System.Int32)">
            <summary>A stable version of <see cref="M:Loyc.Collections.ListExt.SortLowestK``1(System.Collections.Generic.IList{``0},System.Int32)"/>. This means 
            that when k>1 and adjacent results at the beginning of <c>list</c> 
            compare equal, they keep the same order that they had originally.</summary>
            <typeparam name="T"></typeparam>
            <param name="list">A list that will be partially sorted.</param>
            <param name="k">Number of elements that will be sorted at the beginning 
            of the list when this method returns. If <c>k > list.Count</c>, the 
            entire list is sorted.</param>
            <returns>This method uses the quickselect algorithm and stability is
            achieved using a temporary array of <c>list.Count</c> integers.</returns>
        </member>
        <member name="M:Loyc.Collections.ListExt.InsertionSort``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32,System.Comparison{``0})">
            <summary>Performs an insertion sort.</summary>
            <remarks>The insertion sort is a stable sort algorithm that is slow in 
            general (O(N^2)). It should be used only when (a) the list to be sorted
            is short (less than 10-20 elements) or (b) the list is very nearly
            sorted already.</remarks>
            <seealso cref="M:Loyc.Collections.Impl.InternalList.InsertionSort``1(``0[],System.Int32,System.Int32,System.Comparison{``0})"/>
        </member>
        <member name="M:Loyc.Collections.ListExt.SortPair``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32,System.Comparison{``0})">
            <summary>Sorts two items to ensure that list[i] is less than list[j].</summary>
            <returns>True if the array elements were swapped, false if not.</returns>
        </member>
        <member name="M:Loyc.Collections.ListExt.Swap``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32)">
            <summary>Swaps list[i] with list[j].</summary>
        </member>
        <member name="M:Loyc.Collections.ListExt.Randomized``1(System.Collections.Generic.IReadOnlyList{``0})">
            <summary>Quickly makes a copy of a list, as an array, in random order.</summary>
        </member>
        <member name="M:Loyc.Collections.ListExt.SelectArray``2(``0[],System.Func{``0,``1})">
            <summary>Maps an array to another array of the same length.</summary>
        </member>
        <member name="M:Loyc.Collections.ListExt.SelectArray``2(System.Collections.Generic.IReadOnlyList{``0},System.Func{``0,``1})">
            <summary>Maps a list to an array of the same length.</summary>
        </member>
        <member name="M:Loyc.Collections.ListExt.SelectArray``2(Loyc.Collections.IListAndListSource{``0},System.Func{``0,``1})">
            <summary>Maps a list to an array of the same length.</summary>
        </member>
        <member name="M:Loyc.Collections.ListExt.RemoveAll``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
            <summary>Removes the all the elements that match the conditions defined by the specified predicate.</summary>
            <returns>The number of elements removed from the list</returns>
        </member>
        <member name="M:Loyc.Collections.ListExt.InsertRangeHelper``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32)">
            <summary>Increases the list size by <c>spaceNeeded</c> and copies 
            elements starting at <c>list[index]</c> "rightward" to make room 
            for inserted elements that will be initialized by the caller.</summary>
        </member>
        <member name="T:Loyc.Collections.ROLSlice`2">
            <summary>Adapter: a random-access range for a slice of an <see cref="T:System.Collections.Generic.IReadOnlyList`1"/>.</summary>
            <typeparam name="T">Item type in the list</typeparam>
            <typeparam name="TList">List type</typeparam>
        </member>
        <member name="M:Loyc.Collections.ROLSlice`2.#ctor(`0,System.Int32,System.Int32)">
            <summary>Initializes a slice.</summary>
            <exception cref="T:System.ArgumentException">The start index was below zero.</exception>
            <remarks>The (start, count) range is allowed to be invalid, as long
            as 'start' and 'count' are zero or above. 
            <ul>
            <li>If 'start' is above the original Count, the Count of the new slice 
            is set to zero.</li>
            <li>if (start + count) is above the original Count, the Count of the new
            slice is reduced to <c>list.Count - start</c>.</li>
            </ul>
            </remarks>
        </member>
        <member name="T:Loyc.Collections.EnumerableExt">
            <summary>
            Additional extension methods for <see cref="T:System.Collections.Generic.IEnumerable`1"/>,
            <see cref="T:System.Collections.Generic.IReadOnlyCollection`1"/>, and <see cref="T:System.Collections.Generic.ICollection`1"/>,
            beyond what LINQ provides.
            </summary>
            <remarks>
            The methods include <see cref="M:Loyc.Collections.EnumerableExt.WithIndexes``1(System.Collections.Generic.IEnumerable{``0})"/>, which pairs each item of 
            a sequence with a 0-based index of that item; <see cref="M:Loyc.Collections.EnumerableExt.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})"/>, which 
            runs a lambda for each member of a sequence; <see cref="M:Loyc.Collections.EnumerableExt.IndexWhere``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})"/>, which
            finds the index where a predicate is true; <see cref="M:Loyc.Collections.EnumerableExt.AdjacentPairs``1(System.Collections.Generic.IEnumerable{``0})"/>, 
            which pairs each list item with the next one, and <see cref="M:Loyc.Collections.EnumerableExt.MinOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32},``0)"/>,
            which finds the item such that some associated value is minimized (in contrast 
            to LINQ's Min(), which just returns the minimum value itself.) And there's more.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.EnumerableExt.AsReadOnlyDictionary``2(System.Collections.Generic.IReadOnlyCollection{``0},System.Func{``0,Loyc.Maybe{``1}},System.Func{``0,``1})">
            <summary>Converts a collection of keys to an IReadOnlyDictionary,
            based on a function that can obtain a value for a given key.</summary>
            <param name="keys">A collection of dictionary keys.</param>
            <param name="tryGetValue">This function is used both to test membership and to get values.</param>
            <param name="getValue">This function is optional. It is used to get values when it is known 
            in advance that the key exists (in GetEnumerator() and in the Values property). If this is 
            null, tryGetValue is used instead. Providing this function can increase performance.</param>
            <example>
            This function is useful, for example, when you need to implement an interface that 
            provides a dictionary of values, but your data is in the wrong format. You don't
            want to convert the entire dictionary, since the caller might only need to look
            up one item from it.
            <code>
            interface ICompany
            {
            	IReadOnlyDictionary&lt;long, string> Employees { get; }
            	...
            }
            class Company : ICompany
            {
            	Dictionary&lt;int, Person> _employees = new Dictionary&lt;int, Person>();
            
            	public IReadOnlyDictionary&lt;long, string> Employees => 
            		LinqToLists.Select(_employees.Keys, k => (long)k)
            		.AsReadOnlyDictionary(k => {
            		    var v = _employees.TryGetValue((int)k);
            		    return v.HasValue ? (Maybe&lt;string>)v.Value.ToString() : Maybe&lt;string>.NoValue;
            		});		
            	...
            }
            class Person
            {
            	string FirstName, LastName;
            	public override string ToString() => FirstName + " " + LastName;
            }
            </code>
            </example>
        </member>
        <member name="M:Loyc.Collections.EnumerableExt.FirstIndexWhere``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>Gets the lowest index at which a condition is true, or null if nowhere.</summary>
        </member>
        <member name="M:Loyc.Collections.EnumerableExt.IndexWhere``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>Gets the lowest index at which a condition is true, or -1 if nowhere.</summary>
        </member>
        <member name="M:Loyc.Collections.EnumerableExt.MinOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32},``0)">
            <summary>Returns the item in the list that has the minimum value for some selector.</summary>
            <inheritdoc cref="M:Loyc.Collections.EnumerableExt.MaxOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32},``0)"/>
        </member>
        <member name="M:Loyc.Collections.EnumerableExt.MinOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double},``0)">
            <inheritdoc cref="M:Loyc.Collections.EnumerableExt.MinOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32},``0)"/>
        </member>
        <member name="M:Loyc.Collections.EnumerableExt.SelectFilter``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Loyc.Maybe{``1}})">
            <summary>Combines 'Select' and 'Where' in a single operation.</summary>
            <param name="filter">If this function returns <see cref="P:Loyc.Maybe`1.NoValue"/> 
            then the element is suppressed from the output; otherwise the 
            <see cref="P:Loyc.Maybe`1.Value"/> is sent to the output.</param>
            <returns>A sequence filtered and changed by <c>filter</c>.</returns>
        </member>
        <member name="M:Loyc.Collections.EnumerableExt.MaxOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32},``0)">
            <summary>Returns the <i>item</i> in the list that has the maximum value for some selector.</summary>
            <typeparam name="T"></typeparam>
            <param name="list">A list to search</param>
            <param name="selector">A function that takes a number from the list</param>
            <param name="defaultValue">A value </param>
            <remarks>Unfortunately, the standard LINQ methods Max(lambda) and 
            Min(lambda) return the minimum or maximum value returned from the 
            lambda function, which is unfortunate because you often want the
            original value from the list, not the number returned by the lambda.
            That's a flawed design, because often you want the original T value
            and not the projected number; if the developer actually wanted the 
            min/max <i>number</i>, he could have just used 
            <c>list.Select(lambda).Max()</c> instead of <c>list.Max(lambda)</c>.
            <para/>
            So MinOrDefault() and MaxByDefault() are different in two ways: 
            (1) they returns the original T value from the collection, and
            (2) if the collection is empty, they return a default value.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.EnumerableExt.MaxOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double},``0)">
            <inheritdoc cref="M:Loyc.Collections.EnumerableExt.MaxOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32},``0)"/>
        </member>
        <member name="M:Loyc.Collections.EnumerableExt.IndexOf``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>Determines the index of a specific value.</summary>
            <returns>The index of the value, if found, or -1 if it was not found.</returns>
            <remarks>
            At first, this method was a member of IListSource itself, just in 
            case the source might have some kind of fast lookup logic (e.g. binary 
            search) or custom comparer. However, since the item to find is an "in" 
            argument, it would prevent IListSource from being marked covariant when
            I upgrade to C# 4.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.EnumerableExt.SequenceHashCode``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>A companion to <see cref="M:System.Linq.Enumerable.SequenceEqual``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})"/> that 
            computes a hashcode for a list.</summary>
        </member>
        <member name="M:Loyc.Collections.EnumerableExt.Upcast``2(System.Collections.Generic.IEnumerable{``1})">
            <summary>Upcasts a sequence.</summary>
            <remarks>In .NET 4+ this is a no-op that just returns <c>list</c>,
            but in .NET 3.5 that's illegal, so this method creates an adapter.</remarks>
        </member>
        <member name="M:Loyc.Collections.EnumerableExt.AdjacentPairs``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Returns all adjacent pairs (e.g. for the list {1,2,3}, returns {(1,2),(2,3)})</summary>
        </member>
        <member name="M:Loyc.Collections.EnumerableExt.AdjacentPairsCircular``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Returns all adjacent pairs, treating the first and last 
            pairs as adjacent (e.g. for the list {1,2,3,4}, returns the pairs
            {(1,2),(2,3),(3,4),(4,1)}.)</summary>
        </member>
        <member name="M:Loyc.Collections.EnumerableExt.AsReadOnly``1(System.Collections.Generic.ICollection{``0})">
            <summary>Treats any ICollection{T} object to IReadOnlyCollection{T}.</summary>
            <remarks>This method is named "AsReadOnly" and not "ToReadOnly" because,
            in contrast to methods like ToArray(), and ToList() it does not make a 
            copy of the sequence, although it does create a new wrapper object.</remarks>
        </member>
        <member name="T:Loyc.Collections.SelectDictionaryFromKeys`2">
            <summary>An adapter that converts a collection of keys to an IReadOnlyDictionary.
            Used by <see cref="M:Loyc.Collections.EnumerableExt.AsReadOnlyDictionary``2(System.Collections.Generic.IReadOnlyCollection{``0},System.Func{``0,Loyc.Maybe{``1}},System.Func{``0,``1})"/>based on a function that can obtain a value for a given key.</summary>
            <typeparam name="K">Key type</typeparam>
            <typeparam name="V">Value type</typeparam>
        </member>
        <member name="M:Loyc.Collections.SelectDictionaryFromKeys`2.#ctor(System.Collections.Generic.IReadOnlyCollection{`0},System.Func{`0,Loyc.Maybe{`1}},System.Func{`0,`1})">
            <summary>Initializes the adapter.</summary>
            <param name="keys">A collection of dictionary keys.</param>
            <param name="tryGetValue">This function is used both to test membership and to get values.</param>
            <param name="getValue">This function is optional. It is used to get values when it is known 
            in advance that the key exists (in GetEnumerator() and in the Values property). If this is 
            null, tryGetValue is used instead. Providing this function can increase performance.</param>
        </member>
        <member name="T:Loyc.Collections.LinqToLists">
            <summary>
            This class enhances LINQ-to-Objects with extension methods that preserve the
            interface (e.g. Take(IList&lt;int>) returns a struct that implements IList&lt;int>)
            or have higher performance than the ones in System.Linq.Enumerable.
            </summary><remarks>
            Helpful article: http://core.loyc.net/essentials/linq-to-lists.html
            <para/>
            For example, the <see cref="M:System.Linq.Enumerable.Last``1(System.Collections.Generic.IEnumerable{``0})"/> extension 
            method scans the entire list before returning the last item, while 
            <see cref="M:Loyc.Collections.LinqToLists.Last``1(System.Collections.Generic.IReadOnlyList{``0})"/> and <see cref="!:Last&lt;T&gt;(IList&lt;T&gt;)"/> simply
            return the last item directly.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.LinqToLists.Last``1(System.Collections.Generic.IReadOnlyList{``0})">
            <summary>Gets the last item from the list (at <c>list.Max</c>).</summary>
            <exception cref="T:Loyc.Collections.EmptySequenceException">The list is empty</exception>
        </member>
        <member name="M:Loyc.Collections.LinqToLists.LastOrDefault``1(System.Collections.Generic.IReadOnlyList{``0},``0)">
            <summary>Gets the last item from the list (Count - 1), or <c>defaultValue</c> if the list is empty.</summary>
        </member>
        <member name="M:Loyc.Collections.LinqToLists.Last``1(Loyc.Collections.INegListSource{``0})">
            <summary>Gets the last item from the list (at <c>list.Max</c>).</summary>
            <exception cref="T:Loyc.Collections.EmptySequenceException">The list is empty</exception>
        </member>
        <member name="M:Loyc.Collections.LinqToLists.LastOrDefault``1(Loyc.Collections.INegListSource{``0},``0)">
            <summary>Gets the last item from the list (at <c>list.Max</c>), or <c>defaultValue</c> if the list is empty.</summary>
        </member>
        <member name="M:Loyc.Collections.LinqToLists.Skip``1(Loyc.Collections.IListSource{``0},System.Int32)">
            <summary>Skips the specified number of elements immediately and 
            returns a slice of part of the list that remains, or an empty 
            slice if <c>start</c> is greater than or equal to the <c>list.Count</c>.</summary>
        </member>
        <member name="M:Loyc.Collections.LinqToLists.Take``1(Loyc.Collections.IListSource{``0},System.Int32)">
            <summary>Returns a slice of the specified number of elements from 
            the beginning of the list, or a slice of the entire list if <c>count</c> 
            is greater than or equal to the <c>list.Count</c>.</summary>
        </member>
        <member name="M:Loyc.Collections.LinqToLists.Skip``1(Loyc.Collections.IListAndListSource{``0},System.Int32)">
            <summary>Skips the specified number of elements immediately and 
            returns a slice of part of the list that remains, or an empty 
            slice if <c>start</c> is greater than or equal to the <c>list.Count</c>.</summary>
        </member>
        <member name="M:Loyc.Collections.LinqToLists.Take``1(Loyc.Collections.IListAndListSource{``0},System.Int32)">
            <summary>Returns a slice of the specified number of elements from 
            the beginning of the list, or a slice of the entire list if <c>count</c> 
            is greater than or equal to the <c>list.Count</c>.</summary>
        </member>
        <member name="M:Loyc.Collections.LinqToLists.TakeNowWhile``1(Loyc.Collections.IListSource{``0},System.Func{``0,System.Boolean})">
            <summary>Returns a slice of the initial elements of the list that meet the provided criteria. 
            The word "now" is added to the name because unlike Enumerable.TakeWhile, this method scans 
            the list immediately.</summary>
            <remarks>Example: new[] { 13, 16, 19, 2, 11, 12 }.TakeNowWhile(n => n > 10) returns a slice 
            (not a copy) of the first 3 elements.</remarks>
        </member>
        <member name="M:Loyc.Collections.LinqToLists.SkipNowWhile``1(Loyc.Collections.IListSource{``0},System.Func{``0,System.Boolean})">
            <summary>Returns a slice without the initial elements of the list that meet the specified
            criteria. The word "now" is added to the name because unlike Enumerable.SkipWhile, this 
            method scans the list immediately.</summary>
            <remarks>Example: new[] { 24, 28, 2, 12, 11 }.SkipNowWhile(n => n > 10) returns a slice 
            (not a copy) of the last 2 elements.</remarks>
        </member>
        <member name="M:Loyc.Collections.LinqToLists.TakeNowWhile``1(Loyc.Collections.INegListSource{``0},System.Func{``0,System.Boolean})">
            <summary>Returns a slice of the initial elements of the list that meet the provided criteria. 
            The word "now" is added to the name because unlike Enumerable.TakeWhile, this method scans 
            the list immediately.</summary>
            <remarks>Example: new[] { 13, 16, 19, 2, 11, 12 }.TakeNowWhile(n => n > 10) returns a slice 
            (not a copy) of the first 3 elements.</remarks>
        </member>
        <member name="M:Loyc.Collections.LinqToLists.SkipNowWhile``1(Loyc.Collections.INegListSource{``0},System.Func{``0,System.Boolean})">
            <summary>Returns a slice without the initial elements of the list that meet the specified
            criteria. The word "now" is added to the name because unlike Enumerable.SkipWhile, this 
            method scans the list immediately.</summary>
            <remarks>Example: new[] { 24, 28, 2, 12, 11 }.SkipNowWhile(n => n > 10) returns a slice 
            (not a copy) of the last 2 elements.</remarks>
        </member>
        <member name="M:Loyc.Collections.LinqToLists.ToArray``1(System.Collections.Generic.IReadOnlyList{``0})">
            <summary>Copies the contents of a list to an array.</summary>
        </member>
        <member name="M:Loyc.Collections.LinqToLists.ToArray``1(Loyc.Collections.INegListSource{``0})">
            <summary>Copies the contents of an <see cref="T:Loyc.Collections.INegListSource`1"/> to an array.</summary>
        </member>
        <member name="M:Loyc.Collections.LinqToLists.Reverse``1(Loyc.Collections.IListSource{``0})">
            <summary>Returns a reversed view of a read-only list.</summary>
            <remarks>This was originally named <c>ReverseView</c>. Changed to <c>Reverse</c> to match Linq's <c>Reverse(IEnumerable)</c>.</remarks>
        </member>
        <member name="M:Loyc.Collections.LinqToLists.Reverse``1(System.Collections.Generic.IList{``0})">
            <summary>Returns an editable reversed view of a list.</summary>
            <remarks>This was originally named <c>ReverseView</c>. Changed to <c>Reverse</c> to match Linq's <c>Reverse(IEnumerable)</c>.</remarks>
        </member>
        <member name="M:Loyc.Collections.MutableListExtensionMethods.LinqToLists.Last``1(System.Collections.Generic.IList{``0})">
            <summary>Gets the last item from the list (at <c>list.Max</c>).</summary>
            <exception cref="T:Loyc.Collections.EmptySequenceException">The list is empty</exception>
        </member>
        <member name="M:Loyc.Collections.MutableListExtensionMethods.LinqToLists.LastOrDefault``1(System.Collections.Generic.IList{``0},``0)">
            <summary>Gets the last item from the list (Count - 1), or <c>defaultValue</c> if the list is empty.</summary>
        </member>
        <member name="M:Loyc.Collections.MutableListExtensionMethods.LinqToLists.Skip``1(System.Collections.Generic.IList{``0},System.Int32)">
            <summary>Skips the specified number of elements immediately and 
            returns a slice of part of the list that remains, or an empty 
            slice if <c>start</c> is greater than or equal to the <c>list.Count</c>.</summary>
        </member>
        <member name="M:Loyc.Collections.MutableListExtensionMethods.LinqToLists.Take``1(System.Collections.Generic.IList{``0},System.Int32)">
            <summary>Returns a slice of the specified number of elements from 
            the beginning of the list, or a slice of the entire list if <c>count</c> 
            is greater than or equal to the <c>list.Count</c>.</summary>
        </member>
        <member name="M:Loyc.Collections.MutableListExtensionMethods.LinqToLists.TakeNowWhile``1(System.Collections.Generic.IList{``0},System.Func{``0,System.Boolean})">
            <summary>Returns a slice of the initial elements of the list that meet the provided criteria. 
            The word "now" is added to the name because unlike Enumerable.TakeWhile, this method scans 
            the list immediately.</summary>
            <remarks>Example: new[] { 13, 16, 19, 2, 11, 12 }.TakeNowWhile(n => n > 10) returns a slice 
            (not a copy) of the first 3 elements.</remarks>
        </member>
        <member name="M:Loyc.Collections.MutableListExtensionMethods.LinqToLists.SkipNowWhile``1(System.Collections.Generic.IList{``0},System.Func{``0,System.Boolean})">
            <summary>Returns a slice without the initial elements of the list that meet the specified
            criteria. The word "now" is added to the name because unlike Enumerable.SkipWhile, this 
            method scans the list immediately.</summary>
            <remarks>Example: new[] { 24, 28, 2, 12, 11 }.SkipNowWhile(n => n > 10) returns a slice 
            (not a copy) of the last 2 elements.</remarks>
        </member>
        <member name="T:Loyc.Collections.MutableListExtensionMethods.ICollectionExt">
            <summary>Extension methods for <see cref="T:System.Collections.Generic.ICollection`1"/>.</summary>
        </member>
        <member name="M:Loyc.Collections.MutableListExtensionMethods.ICollectionExt.AddRange``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>Adds data to a set (<c>set.Add(value)</c> for all values in a sequence.)</summary>
        </member>
        <member name="M:Loyc.Collections.MutableListExtensionMethods.ICollectionExt.RemoveRange``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>Removes data from a set (<c>set.Remove(value)</c> for all values in a sequence.)</summary>
            <returns>The number of items removed (that had been present in the set).</returns>
        </member>
        <member name="M:Loyc.Collections.MutableListExtensionMethods.ICollectionExt.SelectArray``2(System.Collections.Generic.ICollection{``0},System.Func{``0,``1})">
            <summary>Maps a list to an array of the same length.</summary>
        </member>
        <member name="T:Loyc.Collections.MutableListExtensionMethods.IListExt">
            <summary>Extension methods and helper methods for <see cref="T:System.Collections.Generic.IList`1"/>.
            </summary>
            <remarks>
            Extension methods that only apply to Loyc's new interfaces, or adapt a 
            list to those interfaces, will go in <see cref="T:Loyc.Collections.MutableListExtensionMethods.LCExt"/> instead.
            <para/>
            The source code for adapter extension methods such as the Slice() method for 
            arrays, which returns an <see cref="T:Loyc.Collections.ArraySlice`1"/> adapter, is now 
            placed in the source file for each adapter class (e.g. ArraySlice.cs)
            to make it easier to create custom versions of Loyc.Essentials with parts 
            removed.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.MutableListExtensionMethods.IListExt.FinalIndexWhere``1(System.Collections.Generic.IList{``0},System.Func{``0,System.Boolean})">
            <summary>Gets the highest index at which a condition is true, or null if nowhere.</summary>
        </member>
        <member name="M:Loyc.Collections.MutableListExtensionMethods.IListExt.LastIndexWhere``1(System.Collections.Generic.IList{``0},System.Func{``0,System.Boolean})">
            <summary>Gets the highest index at which a condition is true, or -1 if nowhere.</summary>
        </member>
        <member name="M:Loyc.Collections.MutableListExtensionMethods.IListExt.FinalIndexWhere``1(Loyc.Collections.IListAndListSource{``0},System.Func{``0,System.Boolean})">
            <summary>Gets the highest index at which a condition is true, or null if nowhere.</summary>
        </member>
        <member name="M:Loyc.Collections.MutableListExtensionMethods.IListExt.LastIndexWhere``1(Loyc.Collections.IListAndListSource{``0},System.Func{``0,System.Boolean})">
            <summary>Gets the highest index at which a condition is true, or -1 if nowhere.</summary>
        </member>
        <member name="M:Loyc.Collections.MutableListExtensionMethods.IListExt.Randomized``1(System.Collections.Generic.IList{``0})">
            <summary>Quickly makes a copy of a list, as an array, in random order.</summary>
        </member>
        <member name="M:Loyc.Collections.MutableListExtensionMethods.IListExt.Randomized``1(Loyc.Collections.IListAndListSource{``0})">
            <summary>Quickly makes a copy of a list, as an array, in random order.</summary>
        </member>
        <member name="M:Loyc.Collections.MutableListExtensionMethods.LCExt.AsNegList``1(System.Collections.Generic.IList{``0},System.Int32)">
            <inheritdoc cref="M:Loyc.Collections.NegList`1.#ctor"/>
        </member>
        <member name="M:Loyc.Collections.MutableListExtensionMethods.LCExt.AsNegList``1(Loyc.Collections.IListAndListSource{``0},System.Int32)">
            <inheritdoc cref="M:Loyc.Collections.NegList`1.#ctor"/>
        </member>
        <member name="T:Loyc.Collections.NumRange`2">
            <summary>Represents a range of integers of a specified data type.</summary>
            <typeparam name="Num">Any numeric type</typeparam>
            <typeparam name="Math">Trait type that implements math operations for the 
            type, e.g. for Int32, use Loyc.Math.MathI.</typeparam>
            <remarks>
            TODO: unit tests.
            <para/>
            Note: if the low value is the minimum value of an integer type (e.g. 
            int.MinValue of int) then the Enumerator will not work (MoveNext() will return
            false). Also, if the difference between the min and max value is int.MaxValue 
            or more, the Count property will overflow and return an incorrect value.
            </remarks>
        </member>
        <member name="T:Loyc.Collections.Repeated`1">
            <summary>Helper struct. A sequence that stores one value, but acts like a list in which
            that value is repeated a specified number of times. Returned from 
            <see cref="M:Loyc.Collections.ListExt.Repeat``1(``0,System.Int32)"/>.</summary>
        </member>
        <member name="T:Loyc.Collections.ReverseComparer`1">
            <summary>Reverses the order used by an IComparer object.</summary>
        </member>
        <member name="T:Loyc.Collections.ReverseComparer`2">
            <summary>Reverses the order used by an IComparer object.</summary>
        </member>
        <member name="T:Loyc.Collections.SelectList`3">
            <summary>
            Helper class: provides a modified view of an IList by transforming each element 
            on-demand. Objects of this type are returned from 
            <see cref="M:Loyc.Collections.MutableListExtensionMethods.LinqToLists.Select``2(System.Collections.Generic.IList{``0},System.Func{``0,``1})"/>
            </summary>
            <typeparam name="T">input type</typeparam>
            <typeparam name="TResult">output type</typeparam>
            <typeparam name="ListT">Type of list being wrapped</typeparam>
        </member>
        <member name="T:Loyc.Collections.SelectReadOnlyList`3">
            <summary>
            Helper class: provides a modified view of an IListSource by transforming each element 
            on-demand. Objects of this type are returned from 
            <see cref="M:Loyc.Collections.LinqToLists.Select``2(Loyc.Collections.IListSource{``0},System.Func{``0,``1})"/>
            </summary>
            <typeparam name="T">input type</typeparam>
            <typeparam name="TResult">output type</typeparam>
            <typeparam name="ListT">Type of list being wrapped</typeparam>
        </member>
        <member name="T:Loyc.Collections.SelectListSource`3">
            <summary>
            Helper class: provides a modified view of an IListSource by transforming each element 
            on-demand. Objects of this type are returned from 
            <see cref="M:Loyc.Collections.LinqToLists.Select``2(Loyc.Collections.IListSource{``0},System.Func{``0,``1})"/>
            </summary>
            <typeparam name="T">input type</typeparam>
            <typeparam name="TResult">output type</typeparam>
            <typeparam name="ListT">Type of list being wrapped</typeparam>
        </member>
        <member name="T:Loyc.Collections.SelectCollection`3">
            <summary>Helper class for <see cref="T:Loyc.Collections.LinqToLists"/>.</summary>
        </member>
        <member name="T:Loyc.Collections.SelectReadOnlyCollection`3">
            <summary>Helper class for <see cref="T:Loyc.Collections.LinqToLists"/>.</summary>
        </member>
        <member name="T:Loyc.Collections.EnumeratorBase`1">
            <summary>Base class to help you implement the standard IEnumerator{T}
            interface. All you have to do is override MoveNext() and, when successful,
            set the Current property.</summary>
        </member>
        <member name="T:Loyc.Collections.Impl.ListExBase`1">
            <summary>A base class for classes that wish to implement <see cref="T:Loyc.Collections.IListEx`1"/>.
            Provides default implementations for most of the methods.</summary>
        </member>
        <member name="T:Loyc.Collections.Impl.ListSourceBase`1">
            <summary>A base class for read-only collections that wish to implement 
            <see cref="T:System.Collections.Generic.IList`1"/> and <see cref="T:Loyc.Collections.IListSource`1"/>. Provides
            default implementations for most of the methods.</summary>
            <remarks>
            You only need to implement two methods yourself:
            <code>
                public abstract int Count { get; }
                public abstract T TryGet(int index, out bool fail);
            </code>
            </remarks>
        </member>
        <member name="T:Loyc.Collections.Impl.ReadOnlyCollectionBase`1">
            <summary>Helps you implement read-only collections by providing
            default implementations for most methods of <see cref="T:System.Collections.Generic.ICollection`1"/> 
            and <see cref="T:System.Collections.Generic.IReadOnlyCollection`1"/>.</summary>
            <remarks>
            You only need to implement two methods yourself:
            <code>
                public abstract int Count { get; }
                public abstract IEnumerator&lt;T> GetEnumerator();
            </code>
            </remarks>
        </member>
        <member name="T:Loyc.Collections.Impl.InternalDList`1">
            <summary>A compact auto-enlarging deque structure that is intended to be 
            used within other data structures. It should only be used internally in
            "private" or "protected" members of low-level code. In most cases, you
            should use <see cref="T:Loyc.Collections.DList`1"/> instead.
            </summary>
            <remarks>
            This type is implemented with what is commonly called a "circular buffer".
            There is a single array plus a "start index" and a count. The array may or 
            may not be divided into two "halves", depending on the circumstances.
            The first element of the DList (returned from this[0] and from the
            First property) is located at the "start index" of the array; and if the 
            start index + count is greater than the array size, then the end of the 
            DList wraps around to the beginning of the array.
            <para/>
            InternalDeque is a struct, not a class, in order to save memory; and for 
            maximum performance, it asserts rather than throwing an exception 
            when an incorrect array index is used (the one exception is the iterator,
            which throws in case the collection is modified during enumeration; this 
            is for the sake of <see cref="T:Loyc.Collections.DList`1"/>.)
            <para/>
            Passing this structure by value is dangerous because changes to a copy 
            of the structure may or may not be reflected in the original list. It's
            best not to pass it around at all, but if you must pass it, pass it by
            reference. For these and other reasons, one should not expose this struct 
            in a public API, and it should only be used when performance is important.
            <para/>
            Also, do not use the <c>default(InternalDList{T})</c> or the equivalent
            "default constructor", which only exists because C# requires it. Always 
            specify an initial capacity or copy InternalDeque.Empty so that the 
            internal array gets a value. All methods in this structure assume _array 
            is not null.
            <para/>
            This class does not implement <see cref="T:Loyc.Collections.IDeque`1"/> and <see 
            cref="T:System.Collections.Generic.IList`1"/> in order to help you not to shoot yourself in the foot.
            The problem is that any extension methods used with those interfaces that 
            change the list, such as PopLast(), malfunction because the structure is
            implicitly boxed, producing a shallow copy. By not implementing those 
            interfaces, the extension methods are not available, ensuring you don't
            accidently box the structure. If you need those interfaces, You can always 
            call <see cref="M:Loyc.Collections.Impl.InternalDList`1.AsDList"/> to construct a <see cref="T:Loyc.Collections.DList`1"/> in O(1) 
            time.
            <para/>
            You may be curious why <see cref="T:Loyc.Collections.Impl.InternalList`1"/>, in contrast, DOES
            implement <see cref="T:System.Collections.Generic.IList`1"/>. It's because there is no way to convert
            <see cref="T:Loyc.Collections.Impl.InternalList`1"/> into a class in O(1) time, so boxing the 
            <see cref="T:Loyc.Collections.Impl.InternalList`1"/> is the only fast way to get an instance of 
            <see cref="T:System.Collections.Generic.IList`1"/> from it.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.Impl.InternalDList`1.Add(`0)">
            <summary>An alias for PushLast().</summary>
        </member>
        <member name="M:Loyc.Collections.Impl.InternalDList`1.AsDList">
            <summary>Returns a <see cref="T:Loyc.Collections.DList`1"/> wrapped around this list.</summary>
            <remarks>WARNING: in order to run in O(1) time, the two lists 
            (InternalDList and DList) share the same array, but not the same 
            internal state. You must stop using one list after modifying the 
            other, because changes to one list may have strange effects in
            the other list.</remarks>
        </member>
        <member name="T:Loyc.Collections.Impl.InternalList`1">
            <summary>A compact auto-enlarging array structure that is intended to be 
            used within other data structures. It should only be used internally in
            "private" or "protected" members of low-level code.
            </summary>
            <remarks>
            An <a href="http://core.loyc.net/collections/internal-list.html">article</a>
            about this class is available.
            <para/>
            InternalList is a struct, not a class, in order to save memory; and for 
            maximum performance, it asserts rather than throwing an exception 
            when an incorrect array index is used. Besides that, it has an 
            InternalArray property that provides access to the internal array. 
            For all these reasons one should not expose it in a public API, and 
            it should only be used when performance trumps all other concerns.
            <para/>
            Passing this structure by value is dangerous because changes to a copy 
            of the structure may or may not be reflected in the original list. It's
            best not to pass it around at all, but if you must pass it, pass it by
            reference. Avoid using extension methods on this struct because an 
            extension method will receive a copy of the struct.
            <para/>
            Also, do not use the default contructor. Always specify an initial 
            capacity or copy InternalList.Empty so that _array gets a value. 
            This is required because methods such as Add(), Insert() and Resize() 
            assume _array is not null.
            <para/>
            InternalList has one nice thing that List(of T) lacks: a <see cref="M:Loyc.Collections.Impl.InternalList`1.Resize(System.Int32)"/>
            method and an equivalent Count setter. Which dork at Microsoft decided no 
            one should be allowed to set the list length directly? This type also 
            provides a handy <see cref="P:Loyc.Collections.Impl.InternalList`1.Last"/> property and a <see cref="M:Loyc.Collections.Impl.InternalList`1.Pop"/> 
            method to respectively get or remove the last item.
            <para/>
            Finally, alongside InternalList(T), the static class InternalList comes 
            with some static methods (CopyToNewArray, Insert, RemoveAt, Move) to help
            manage raw arrays. You might want to use these in a data structure 
            implementation even if you choose not to use InternalList(T) instances.
            </remarks>
        </member>
        <member name="P:Loyc.Collections.Impl.InternalList`1.Capacity">
            <summary>Gets or sets the array length.</summary>
            <remarks>Changing this property requires O(Count) time and temporary 
            space. Attempting to set the capacity lower than Count has no effect.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.Impl.InternalList`1.Resize(System.Int32)">
            <inheritdoc cref="M:Loyc.Collections.Impl.InternalList`1.Resize(System.Int32,System.Boolean)"/>
        </member>
        <member name="M:Loyc.Collections.Impl.InternalList`1.Resize(System.Int32,System.Boolean)">
            <summary>Makes the list larger or smaller, depending on whether 
            <c>newSize</c> is larger or smaller than <see cref="P:Loyc.Collections.Impl.InternalList`1.Count"/>.</summary>
            <param name="allowReduceCapacity">If this is true, and the new size is 
            smaller than one quarter the current <see cref="P:Loyc.Collections.Impl.InternalList`1.Capacity"/>, the array
            is reallocated to a smaller size. If this parameter is false, the array 
            is never reallocated when shrinking the list.</param>
            <param name="newSize">New value of <see cref="P:Loyc.Collections.Impl.InternalList`1.Count"/>. If the Count
            increases, copies of default(T) are added to the end of the the list; 
            otherwise items are removed from the end of the list.</param>
        </member>
        <member name="M:Loyc.Collections.Impl.InternalList`1.Clear">
            <summary>Clears the list and frees the memory used by the list. Can 
            also be used to initialize a list whose constructor was never called.</summary>
        </member>
        <member name="M:Loyc.Collections.Impl.InternalList`1.Clone">
            <summary>Makes a copy of the list with the same capacity</summary>
        </member>
        <member name="M:Loyc.Collections.Impl.InternalList`1.CloneAndTrim">
            <summary>Makes a copy of the list with Capacity = Count</summary>
        </member>
        <member name="M:Loyc.Collections.Impl.InternalList`1.ToArray">
            <summary>Makes a copy of the list, as an array</summary>
        </member>
        <member name="M:Loyc.Collections.Impl.InternalList`1.Move(System.Int32,System.Int32)">
            <summary>Slides the array entry at [from] forward or backward in the
            list, until it reaches [to].</summary>
            <remarks>
            For example, if a list of integers is [0, 1, 2, 3, 4, 5] then Move(4,1)
            produces the following result: [0, 4, 1, 2, 3, 5].
            </remarks>
        </member>
        <member name="T:Loyc.Collections.Impl.InternalList">
            <summary>
            Contains static methods to help manage raw arrays with even less
            overhead than <see cref="T:Loyc.Collections.Impl.InternalList`1"/>.
            </summary>
            <remarks>
            The methods of this class are used by some data structures that contain
            arrays but, for whatever reason, don't use <see cref="T:Loyc.Collections.Impl.InternalList`1"/>.
            These methods are also used by InternalList(T) itself.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.Impl.InternalList.AsInternalList``1(``0[])">
            <summary>Converts an array to InternalList (exists to help infer type params)</summary>
        </member>
        <member name="M:Loyc.Collections.Impl.InternalList.BinarySearch``2(``0[],System.Int32,``1,System.Func{``0,``1,System.Int32},System.Boolean)">
            <summary>Performs a binary search with a custom comparison function.</summary>
            <param name="_array">Array to search</param>
            <param name="_count">Number of elements used in the array</param>
            <param name="k">A key to compare with elements of the array</param>
            <param name="compare">Lambda function that knows how to compare Ts with 
            Ks (T and K can be the same). It is passed a series of elements from 
            the array. It must return 0 if the element has the desired value, 1 if 
            the supplied element is higher than desired, and -1 if it is lower than 
            desired.</param>
            <param name="lowerBound">Whether to find the "lower bound" in case there
            are duplicates in the list. If duplicates exist of the search key k, the 
            lowest index of a matching duplicate is returned. This search mode may be 
            slightly slower when a match exists.</param>
            <returns>The index of the matching array entry, if found. If no exact
            match was found, this method returns the bitwise complement of an
            insertion location that would preserve the order.</returns>
            <example>
                // The first 6 elements are sorted. The seventh is invalid,
                // and must be excluded from the binary search.
                int[] array = new int[] { 0, 10, 20, 30, 40, 50, -1 };
                // The result will be 2, because array[2] == 20.
                int a = InternalList.BinarySearch(array, 6, i => i.CompareTo(20));
                // The result will be ~2, which equals -3, because index 2 would
                // be the correct place to insert 17 to preserve the sort order.
                int b = InternalList.BinarySearch(array, 6, i => i.CompareTo(17));
            </example>
        </member>
        <member name="M:Loyc.Collections.Impl.InternalList.BinarySearchByIndex``1(``0,System.Int32,System.Func{System.Int32,``0,System.Int32},System.Boolean)">
            <summary>A binary search function that knows nothing about the list 
            being searched.</summary>
            <typeparam name="Anything">Any data type relevant to the caller.</typeparam>
            <param name="data">State information to be passed to compare()</param>
            <param name="count">Number of items in the list being searched</param>
            <param name="compare">Comparison method that is given the current index 
            to examine and the state parameter "data".</param>
            <param name="lowerBound">Whether to find the "lower bound" in case there
            are duplicates in the list. If duplicates exist of the search key k 
            exist, the lowest index of a matching duplicate is returned. This
            search mode may be slightly slower when a match exists.</param>
            <returns>The index of the matching index, if found. If no exact
            match was found, this method returns the bitwise complement of an
            insertion location that would preserve the sort order.</returns>
        </member>
        <member name="M:Loyc.Collections.Impl.InternalList.NextLargerSize(System.Int32)">
            <summary>As an alternative to the typical enlarging pattern of doubling
            the array size when it overflows, this function proposes a 75% size
            increase instead (100% when the array is small), while ensuring that
            the array length stays even.</summary>
            <remarks>
            With a seed of 0, 2, or 4: 0, 2, 4, 8, 16, 30, 54, 96, 170, 298, 522...<br/>
            With a seed of 1: 1, 2, 4, 8, 16, 30, 54, 96, 170, 298, 522...<br/>
            With a seed of 3: 3, 6, 12, 22, 40, 72, 128, 226, 396...<br/>
            With a seed of 5: 5, 10, 18, 32, 58, 102, 180, 316, 554...<br/>
            With a seed of 7: 7, 14, 26, 46, 82, 144, 254, 446, 782...
            <para/>
            75% size increases require 23.9% more allocations than size doubling
            (1.75 to the 1.239th power is about 2.0), but memory utilization is
            increased. With size doubling, the average list uses 2/3 of its 
            entries, but with this resizing pattern, the average list uses 72.72%
            of its entries. The average size of a list is 8.3% lower. Originally
            I used 50% size increases, but they required 71% more allocations, 
            which seemed like too much.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.Impl.InternalList.NextLargerSize(System.Int32,System.Int32)">
            <summary>Same as <see cref="M:Loyc.Collections.Impl.InternalList.NextLargerSize(System.Int32)"/>, but allows you to 
            specify a capacity limit, to avoid wasting memory when a collection has 
            a known maximum size.</summary>
            <param name="than">Return value will be larger than this number.</param>
            <param name="capacityLimit">Maximum value to return. This parameter is
            ignored if it than >= capacityLimit.</param>
            <returns>Produces the same result as <see cref="M:Loyc.Collections.Impl.InternalList.NextLargerSize(System.Int32)"/>
            unless the return value would be near capacityLimit (and capacityLimit
            > than). If the return value would be more than capacityLimit, 
            capacityLimit is returned instead. If the return value would be slightly
            less than capacityLimit (within 20%) then capacityLimit is returned, 
            to ensure that another reallocation will not be required later.</returns>
        </member>
        <member name="M:Loyc.Collections.Impl.InternalList.Sort``1(``0[],System.Int32,System.Int32,System.Comparison{``0})">
            <summary>Performs a quicksort using a Comparison function.</summary>
            <remarks>
            Normally one uses Array.Sort for sorting arrays.
            This method exists because there is no Array.Sort overload that
            accepts both a Comparison and a range (index, count), nor does the
            .NET framework provide access to its internal adapter that converts 
            Comparison to IComparer.
            <para/>
            This quicksort algorithm uses a best-of-three pivot so that it remains
            performant (fast) if the input is already sorted. It is designed to 
            perform reasonably well in case the data contains many duplicates (not
            verified). It is also designed to avoid using excessive stack space if 
            a worst-case input occurs that requires O(N^2) time.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.Impl.InternalList.InsertionSort``1(``0[],System.Int32,System.Int32,System.Comparison{``0})">
            <summary>Performs an insertion sort.</summary>
            <remarks>The insertion sort is a stable sort algorithm that is slow in 
            general (O(N^2)). It should be used only when (a) the list to be sorted
            is short (less than about 20 elements) or (b) the list is very nearly
            sorted already.</remarks>
            <seealso cref="M:Loyc.Collections.ListExt.InsertionSort``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32,System.Comparison{``0})"/>
        </member>
        <member name="T:Loyc.Collections.CollectionDebugView`1">
            <summary>
            This helper class gives a nice view of a custom collection within the 
            debugger.
            </summary>
            <remarks>
            For ISource or IListSource collections, use ListSourceDebugView instead.
            <para/>
            Use the following custom attributes on your class that implements 
            ICollection(of T) or IList(of T):
            <code>
            [DebuggerTypeProxy(typeof(CollectionDebugView&lt;>)), DebuggerDisplay("Count = {Count}")]
            </code>
            See the following link for more information:
            http://www.codeproject.com/Articles/28405/Make-the-debugger-show-the-contents-of-your-custom
            </remarks>
        </member>
        <member name="T:Loyc.Collections.DictionaryDebugView`2">
            <summary>Workaround for a limitation of the debugger: it doesn't support
            <see cref="T:Loyc.Collections.CollectionDebugView`1"/> when T is <see cref="T:System.Collections.Generic.KeyValuePair`2"/>.
            This class is identical, except that T is replaced with KeyValuePair{K,V}.
            </summary>
        </member>
        <member name="T:Loyc.Collections.ListSourceDebugView`1">
            <summary>
            This helper class gives a nice view of a custom collection within the 
            debugger.
            </summary>
            <remarks>
            Use the following custom attributes on your class that implements 
            IListSource(of T) or ISource(of T):
            <code>
            [DebuggerTypeProxy(typeof(ListSourceDebugView&lt;>)), DebuggerDisplay("Count = {Count}")]
            </code>
            See the following link for more information:
            http://www.codeproject.com/KB/dotnet/DebugIList.aspx
            </remarks>
        </member>
        <member name="T:Loyc.Collections.DictionaryExt">
            <summary>Extension methods for <see cref="T:System.Collections.Generic.Dictionary`2"/>, 
            <see cref="T:System.Collections.Generic.IDictionary`2"/> and <see cref="T:Loyc.Collections.IDictionaryEx`2"/>.</summary>
        </member>
        <member name="M:Loyc.Collections.DictionaryExt.GetOrAdd``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
            <summary>Adds a key/value pair to the dictionary if the key is not already present,
            and returns the existing or new value.</summary>
            <returns>The existing value (if the key already existed) or the new value.</returns>
            <remarks>This is not thread-safe. Only one thread should access the dictionary at once.</remarks>
        </member>
        <member name="M:Loyc.Collections.DictionaryExt.GetOrAdd``2(System.Collections.Generic.IDictionary{``0,``1},``0,System.Func{``0,``1})">
            <summary>Adds a key/value pair to the dictionary if the key is not already present, by 
            using the specified function to obtain a value, and returns the existing or new value.</summary>
            <returns>The existing value (if the key already existed) or the new value.</returns>
            <remarks>This is not thread-safe. Only one thread should access the dictionary at once.</remarks>
        </member>
        <member name="M:Loyc.Collections.DictionaryExt.AddOrUpdate``2(System.Collections.Generic.IDictionary{``0,``1},``0,System.Func{``0,``1},System.Func{``0,``1,``1})">
            <summary>Uses the specified functions either to add a key/value pair to the dictionary 
            if the key does not already exist, or to update a key/value pair in the dictionary if 
            the key already exists.</summary>
            <returns>The new value associated with the key, which is either the result of addValueFactory or 
            updateValueFactory.</returns>
            <remarks>This is not thread-safe. Only one thread should access the dictionary at once.</remarks>
        </member>
        <member name="M:Loyc.Collections.DictionaryExt.AddOrUpdate``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1,System.Func{``0,``1,``1})">
            <summary>Adds a key/value pair to the dictionary if the key does not already exist, or, 
            if it does, updates a key/value pair in the dictionary using the specified function.</summary>
            <returns>The new value associated with the key, which is either addValue or the result 
            of updateValueFactory.</returns>
            <remarks>This is not thread-safe. Only one thread should access the dictionary at once.</remarks>
        </member>
        <member name="M:Loyc.Collections.DictionaryExt.TryGetValue``2(System.Collections.Generic.Dictionary{``0,``1},``0,``1)">
            <summary>An alternate version TryGetValue that returns a default value 
            if the key was not found in the dictionary, and that does not throw if 
            the key is null.</summary>
            <returns>The value associated with the specified key, or defaultValue 
            if no value is associated with the key.</returns>
        </member>
        <member name="M:Loyc.Collections.DictionaryExt.TryGetValue``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
            <inheritdoc cref="M:Loyc.Collections.DictionaryExt.TryGetValue``2(System.Collections.Generic.Dictionary{``0,``1},``0,``1)"/>
        </member>
        <member name="M:Loyc.Collections.DictionaryExt.TryGetValue``2(System.Collections.Generic.IReadOnlyDictionary{``0,``1},``0,``1)">
            <inheritdoc cref="M:Loyc.Collections.DictionaryExt.TryGetValue``2(System.Collections.Generic.Dictionary{``0,``1},``0,``1)"/>
        </member>
        <member name="M:Loyc.Collections.DictionaryExt.TryGetValue``2(System.Collections.Generic.IDictionary{``0,``1},``0)">
            <summary>Same as IDictionary.TryGetValue() except that this method does 
            not throw an exception when <c>key==null</c> (it simply returns NoValue),
            and it returns the result as <see cref="T:Loyc.Maybe`1"/> instead of storing
            the result in an "out" parameter.</summary>
        </member>
        <member name="M:Loyc.Collections.DictionaryExt.TryGetValue``2(System.Collections.Generic.IReadOnlyDictionary{``0,``1},``0)">
            <inheritdoc cref="M:Loyc.Collections.DictionaryExt.TryGetValue``2(System.Collections.Generic.IDictionary{``0,``1},``0)"/>
        </member>
        <member name="M:Loyc.Collections.DictionaryExt.TryGetValue``2(Loyc.Collections.IDictionaryAndReadOnly{``0,``1},``0)">
            <inheritdoc cref="M:Loyc.Collections.DictionaryExt.TryGetValue``2(System.Collections.Generic.Dictionary{``0,``1},``0,``1)"/>
        </member>
        <member name="M:Loyc.Collections.DictionaryExt.TryGetValue``2(System.Collections.Generic.Dictionary{``0,``1},``0)">
            <inheritdoc cref="M:Loyc.Collections.DictionaryExt.TryGetValue``2(System.Collections.Generic.Dictionary{``0,``1},``0,``1)"/>
        </member>
        <member name="M:Loyc.Collections.DictionaryExt.TryGetValueSafe``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1@)">
            <summary>Same as IDictionary.TryGetValue() except that this method does 
            not throw an exception when <c>key==null</c> (it simply returns false).</summary>
        </member>
        <member name="M:Loyc.Collections.DictionaryExt.AddRange``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}})">
            <summary>Adds data to a dictionary (<c>dict.Add(key, value)</c> for all pairs in a sequence.)</summary>
        </member>
        <member name="M:Loyc.Collections.DictionaryExt.SetRange``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}})">
            <summary>Adds data to a dictionary (<c>dict[key] = value</c> for all pairs in a sequence.)</summary>
        </member>
        <member name="M:Loyc.Collections.DictionaryExt.RemoveRange``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IEnumerable{``0})">
            <summary>Tries to remove a set of key-values from a dictionary based on their keys.</summary>
            <returns>The number of keys that were found and removed.</returns>
        </member>
        <member name="M:Loyc.Collections.DictionaryExt.AddRange``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}},Loyc.Collections.DictEditMode)">
            <summary>Default implementation of <see cref="M:Loyc.Collections.IDictionaryEx`2.AddRange(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},Loyc.Collections.DictEditMode)"/>.
            Merges the contents of the specified sequence into this map.</summary>
        </member>
        <member name="M:Loyc.Collections.DictionaryExt.GetAndRemove``2(System.Collections.Generic.IDictionary{``0,``1},``0)">
            <summary>Default implementation of <see cref="M:Loyc.Collections.IDictionaryEx`2.GetAndRemove(`0)"/>.
            Gets the value associated with the specified key, then removes the 
            pair with that key from the dictionary.</summary>
        </member>
        <member name="T:Loyc.Collections.LCExt">
            <summary>Extension methods for Loyc Collection interfaces 
            (such as <see cref="T:Loyc.Collections.IListSource`1"/>).</summary>
            <remarks>
            The source code for adapter extension methods such as AsReadOnly() is now 
            placed in the source file for each adapter class (e.g. CollectionAsReadOnly.cs)
            to make it easier to use parts of Loyc.Essentials rather than the entire 
            library (other "decoupling" suggestions are welcome.)
            </remarks>
        </member>
        <member name="M:Loyc.Collections.LCExt.AsSparse``1(Loyc.Collections.IListSource{``0})">
            <summary>Treats a non-sparse list as a read-only sparse list with no empty
            spaces.</summary>
        </member>
        <member name="M:Loyc.Collections.LCExt.AsSparse``1(Loyc.Collections.ISparseListSource{``0})">
            <summary>Returns <c>list</c> itself. This overload exists to prevent you from 
            accidentally wrapping a sparse list in <see cref="T:Loyc.Collections.ListSourceAsSparse`1"/>,
            which would block access to knowledge of any empty spaces in the list.</summary>
        </member>
        <member name="M:Loyc.Collections.LCExt.AsListSource``1(System.Collections.Generic.IList{``0})">
            <summary>Adapter: treats any IList{T} object as IListSource{T}.</summary>
            <remarks>This method is named "AsListSource" and not "ToListSource" 
            because, in contrast to methods like ToArray() and ToList(), it does not 
            make a copy of the sequence.</remarks>
        </member>
        <member name="M:Loyc.Collections.LCExt.AsList``1(Loyc.Collections.IListSource{``0})">
            <summary>Converts any IListSource{T} object to a read-only IList{T}.</summary>
            <remarks>This method is named "AsList" and not "ToList" because
            because, in contrast to methods like ToArray(), it does not make a copy
            of the sequence, although it does create a new wrapper object if <c>c</c>
            does not implement <see cref="T:System.Collections.Generic.IList`1"/>.</remarks>
        </member>
        <member name="M:Loyc.Collections.LCExt.AsNegList``1(Loyc.Collections.IListSource{``0},System.Int32)">
            <inheritdoc cref="M:Loyc.Collections.NegListSource`1.#ctor"/>
        </member>
        <member name="M:Loyc.Collections.LCExt.AsCollection``1(System.Collections.Generic.IReadOnlyCollection{``0})">
            <summary>Adapter: treats any IReadOnlyCollection{T} as a read-only ICollection{T}.</summary>
            <remarks>This method is named "AsCollection" and not "ToCollection" 
            because, in contrast to methods like ToArray() and ToList(), it does not 
            make a copy of the sequence, although it does create a new wrapper object.</remarks>
        </member>
        <member name="M:Loyc.Collections.LCExt.Slice``1(Loyc.Collections.INegListSource{``0},System.Int32,System.Int32)">
            <inheritdoc cref="M:Loyc.Collections.NegList`1.#ctor"/>
        </member>
        <member name="T:Loyc.Collections.UpCastSource`2">
            <summary>Helper class for treating a collection of a derived type as a collection of a base type or interface.</summary>
            <see cref="M:Loyc.Collections.LCExt.UpCast``2(Loyc.Collections.IListSource{``0})"/>
        </member>
        <member name="T:Loyc.Collections.UpCastListSource`2">
            <summary>Helper class for treating a collection of a derived type as a collection of a base type or interface.</summary>
            <see cref="M:Loyc.Collections.LCExt.UpCast``2(System.Collections.Generic.IReadOnlyCollection{``0})"/>
        </member>
        <member name="T:Loyc.Collections.ListSourceAsSparse`1">
            <summary>Adapter from <see cref="T:Loyc.Collections.IListSource`1"/> to <see cref="T:Loyc.Collections.ISparseListSource`1"/>.</summary>
            <seealso cref="M:Loyc.Collections.LCExt.AsSparse``1(Loyc.Collections.IListSource{``0})"/>
        </member>
        <member name="T:Loyc.Collections.RangeExt">
            <summary>Extension/helper methods for ranges.</summary>
        </member>
        <member name="M:Loyc.Collections.RangeExt.Skip``2(``0@,System.Int32)">
            <summary>Advances by the specified number of elements.</summary>
            <param name="count">Number of items to remove from the beginning of the
            range. If count is higher than the number of items in the range, no
            exception is thrown but the return value will be less than this value.</param>
            <returns>Returns the number of items skipped.</returns>
        </member>
        <member name="T:Loyc.Collections.ArraySlice`1">
            <summary>Adapter: Provides access to a section of an array.</summary>
        </member>
        <member name="M:Loyc.Collections.ArraySlice`1.#ctor(`0[],System.Int32,System.Int32)">
            <summary>Initializes an array slice.</summary>
            <exception cref="T:System.ArgumentException">The start index was below zero.</exception>
            <remarks>The (start, count) range is allowed to be invalid, as long
            as 'start' is zero or above. 
            <ul>
            <li>If 'count' is below zero, or if 'start' is above the original Length, 
            the Count of the new slice is set to zero.</li>
            <li>if (start + count) is above the original Length, the Count of the new
            slice is reduced to <c>list.Length - start</c>.</li>
            </ul>
            </remarks>
        </member>
        <member name="P:Loyc.Collections.ArraySlice`1.InternalList">
            <summary>Returns the original array.</summary>
            <remarks>Ideally, to protect the array there would be no way to access
            its contents beyond the boundaries of the slice. However, the 
            reality in .NET today is that many methods accept "slices" in the 
            form of a triple (list, start index, count). In order to call such an
            old-style API using a slice, one must be able to extract the internal
            list and start index values.</remarks>
        </member>
        <member name="T:Loyc.Collections.BufferedSequence`1">
            <summary>Adapter: This class wraps an <see cref="T:System.Collections.Generic.IEnumerator`1"/> or 
            <see cref="T:System.Collections.Generic.IEnumerable`1"/> into an <see cref="T:Loyc.Collections.IListSource`1"/>, lazily 
            reading the sequence as <see cref="M:Loyc.Collections.BufferedSequence`1.TryGet(System.Int32,System.Boolean@)"/> is called.</summary>
            <remarks>Avoid calling <see cref="P:Loyc.Collections.BufferedSequence`1.Count"/> if you actually want laziness;
            this property must read and buffer the entire sequence.</remarks>
        </member>
        <member name="T:Loyc.Collections.CollectionAsReadOnly`1">
            <summary>Adapter: a read-only wrapper that implements ICollection(T) and IReadOnlyCollection(T), 
            returned from <see cref="M:Loyc.Collections.EnumerableExt.AsReadOnly``1(System.Collections.Generic.ICollection{``0})"/>.</summary>
        </member>
        <member name="T:Loyc.Collections.EmptyArray`1">
            <summary><see cref="F:Loyc.Collections.EmptyArray`1.Value"/> lets you avoid allocating an empty array on the heap.</summary>
        </member>
        <member name="T:Loyc.Collections.EmptyEnumerator`1">
            <summary>Helper class: an empty enumerator.</summary>
        </member>
        <member name="T:Loyc.Collections.EmptyList`1">
            <summary>Helper class: <see cref="F:Loyc.Collections.EmptyList`1.Value"/> is a read-only empty list.</summary>
        </member>
        <member name="T:Loyc.Collections.ListAsListSource`1">
            <summary>
            Helper type returned from <see cref="M:Loyc.Collections.LCExt.AsListSource``1(System.Collections.Generic.IList{``0})"/>.
            </summary>
            <summary>A read-only wrapper that implements ICollection and ISource.</summary>
        </member>
        <member name="T:Loyc.Collections.ListSlice`1">
            <summary>
            Adapter: a wrapper of a list that provides a view of a range of elements.
            Objects of this type are returned from <see cref="M:Loyc.Collections.ListExt.Slice``1(System.Collections.Generic.IReadOnlyList{``0},System.Int32,System.Int32)"/>
            </summary>
            <remarks>
            ListSlice provides both a <see cref="T:System.Collections.Generic.IList`1"/> interface and a 
            <see cref="T:Loyc.Collections.IRange`1"/> interface, and it is important not to confuse them.
            The <see cref="T:System.Collections.Generic.IList`1"/> interface allows you to insert and remove items
            from both the original list and the slice simultaneously. The 
            <see cref="T:Loyc.Collections.IRange`1"/> interface allows you to "Pop" items from the front
            and back, but this reduces the length of the slice only, not the original
            list.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.ListSlice`1.#ctor(System.Collections.Generic.IList{`0},System.Int32,System.Int32)">
            <summary>Initializes a slice.</summary>
            <exception cref="T:System.ArgumentException">The start index was below zero.</exception>
            <remarks>The (start, count) range is allowed to be invalid, as long
            as 'start' and 'count' are zero or above. 
            <ul>
            <li>If 'start' is above the original Count, the Count of the new slice 
            is set to zero.</li>
            <li>if (start + count) is above the original Count, the Count of the new
            slice is reduced to <c>list.Count - start</c>. Note that the Count of 
            the slice will not increase if the list expands after the slice is 
            created.</li>
            </ul>
            </remarks>
        </member>
        <member name="P:Loyc.Collections.ListSlice`1.InternalList">
            <summary>Returns the original list.</summary>
            <remarks>Ideally, to protect the list there would be no way to access
            its contents beyond the boundaries of the slice. However, the 
            reality in .NET today is that many methods accept "slices" in the 
            form of a triple (list, start index, count). In order to call such an
            old-style API using a slice, one must be able to extract the internal
            list and start index values.</remarks>
        </member>
        <member name="T:Loyc.Collections.ListSourceAsList`1">
            <summary>Adapter: a read-only wrapper that implements IList(T) and 
            IListSource(T), returned from <see cref="M:Loyc.Collections.LCExt.AsList``1(Loyc.Collections.IListSource{``0})"/>.</summary>
        </member>
        <member name="T:Loyc.Collections.NegList`1">
            <summary>
            Adapter: provides a view of an <see cref="T:System.Collections.Generic.IList`1"/> in which the Count is the same, but the 
            minimum index is not necessarily zero. Returned from <see cref="M:Loyc.Collections.LCExt.AsNegList``1(Loyc.Collections.IListSource{``0},System.Int32)"/>.
            </summary>
            <remarks>This wrapper is a structure in order to offer high performance in 
            certain scenarios.</remarks>
        </member>
        <member name="P:Loyc.Collections.NegList`1.OriginalList">
            <summary>Gets the list that was passed to the constructor of this instance.</summary>
        </member>
        <member name="P:Loyc.Collections.NegList`1.Offset">
            <summary>Returns the offset added to indexes in the original list, which equals -Min.</summary>
            <remarks>The 0th item in this list the same as OriginalList[Offset].</remarks>
            <remarks>
            WARNING: this is a value type. Calling the setter may have unexpected
            consequences for people unfamiliar with the .NET type system, because 
            it is easy to make copies accidentally, and changing the Offset in a copy
            does not change the Offset in the original.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.NegList`1.#ctor(System.Collections.Generic.IList{`0},System.Int32)">
            <summary>Initializes a NegListSource wrapper.</summary>
            <param name="list">A list to wrap (must not be null).</param>
            <param name="zeroOffset">An index into the original list. this[0] will refer to that index.</param>
            <remarks>The zeroOffset can be any integer, but if it is not in the range 0 to list.Count-1, this[0] will not be valid.</remarks>
        </member>
        <member name="P:Loyc.Collections.NegList`1.Count">
            <summary>Returns the total number of items in the list (same as OriginalList.Count).</summary>
        </member>
        <member name="P:Loyc.Collections.NegList`1.Min">
            <summary>Returns the minimum valid index.</summary>
        </member>
        <member name="P:Loyc.Collections.NegList`1.Max">
            <summary>Returns the maximum valid index, which is Min + OriginalList.Count - 1.</summary>
        </member>
        <member name="P:Loyc.Collections.NegList`1.Item(System.Int32)">
            <summary>Gets the value of the list at the specified index. In terms 
            of the original list, this is OriginalList[index + Offset]</summary>
            <param name="index">An index in the range Min to Max.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">The index provided is not 
            valid in this list.</exception>
        </member>
        <member name="M:Loyc.Collections.NegList`1.TryGet(System.Int32,System.Boolean@)">
            <inheritdoc/>
        </member>
        <member name="M:Loyc.Collections.NegList`1.TrySet(System.Int32,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Loyc.Collections.NegList`1.Slice(System.Int32,System.Int32)">
            <summary>Returns a sub-range of this list.</summary>
        </member>
        <member name="M:Loyc.Collections.NegList`1.Equals(System.Object)">
            <inheritdoc cref="M:Loyc.WrapperBase`1.Equals(System.Object)"/>
        </member>
        <member name="M:Loyc.Collections.NegList`1.ToString">
            <summary>Returns ToString() of the wrapped list.</summary>
        </member>
        <member name="T:Loyc.Collections.NegListSource`1">
            <summary>
            Adapter: provides a view of an <see cref="T:Loyc.Collections.IListSource`1"/> in which the Count 
            is the same, but the minimum index is not necessarily zero. Returned from 
            <see cref="M:Loyc.Collections.LCExt.AsNegList``1(Loyc.Collections.IListSource{``0},System.Int32)"/>.
            </summary>
            <remarks>
            This wrapper is a structure in order to offer high performance in certain 
            scenarios.
            <para/>
            Like ListSourceSlice, this structure provides a view of another list 
            starting at a certain offset. Unlike ListSourceSlice, however, this 
            structure allows the caller to access the entire original list, not just a 
            slice.
            </remarks>
        </member>
        <member name="P:Loyc.Collections.NegListSource`1.OriginalList">
            <summary>Gets the list that was passed to the constructor of this instance.</summary>
        </member>
        <member name="P:Loyc.Collections.NegListSource`1.Offset">
            <summary>Returns the offset added to indexes in the original list, which equals -Min.</summary>
            <remarks>The 0th item in this list the same as OriginalList[Offset].</remarks>
            <remarks>
            WARNING: this is a value type. Calling the setter may have unexpected
            consequences for people unfamiliar with the .NET type system, because 
            it is easy to make copies accidentally, and changing the Offset in a copy
            does not change the Offset in the original.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.NegListSource`1.#ctor(Loyc.Collections.IListSource{`0},System.Int32)">
            <summary>Initializes a NegListSource wrapper.</summary>
            <param name="list">A list to wrap (must not be null).</param>
            <param name="zeroOffset">An index into the original list. this[0] will refer to that index.</param>
            <remarks>The zeroOffset can be any integer, but if it is not in the 
            range 0 to list.Count-1, this[0] will not be valid. For example, if 
            zeroOffset==-1, this object will have Min==1 and Max==Count.</remarks>
        </member>
        <member name="P:Loyc.Collections.NegListSource`1.Count">
            <summary>Returns the total number of items in the list (same as OriginalList.Count).</summary>
        </member>
        <member name="P:Loyc.Collections.NegListSource`1.Min">
            <summary>Returns the minimum valid index.</summary>
        </member>
        <member name="P:Loyc.Collections.NegListSource`1.Max">
            <summary>Returns the maximum valid index, which is Min + OriginalList.Count - 1.</summary>
        </member>
        <member name="P:Loyc.Collections.NegListSource`1.Item(System.Int32)">
            <summary>Gets the value of the list at the specified index. In terms 
            of the original list, this is OriginalList[index + Offset]</summary>
            <param name="index">An index in the range Min to Max.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">The index provided is not 
            valid in this list.</exception>
        </member>
        <member name="M:Loyc.Collections.NegListSource`1.TryGet(System.Int32,System.Boolean@)">
            <inheritdoc/>
        </member>
        <member name="M:Loyc.Collections.NegListSource`1.Slice(System.Int32,System.Int32)">
            <summary>Returns a sub-range of this list.</summary>
        </member>
        <member name="M:Loyc.Collections.NegListSource`1.Equals(System.Object)">
            <inheritdoc cref="M:Loyc.WrapperBase`1.Equals(System.Object)"/>
        </member>
        <member name="M:Loyc.Collections.NegListSource`1.ToString">
            <summary>Returns ToString() of the wrapped list.</summary>
        </member>
        <member name="T:Loyc.Collections.RangeEnumerator`1">
            <summary>Helper struct: enumerates through a forward range (<see cref="T:Loyc.Collections.IFRange`1"/>).</summary>
            <seealso cref="T:Loyc.Collections.RangeEnumerator`2"/>
        </member>
        <member name="T:Loyc.Collections.ReverseBinumerator`1">
            <summary>Adapter: a <see cref="T:Loyc.Collections.IBinumerator`1"/> that swaps the MoveNext() and MovePrev() methods.</summary>
        </member>
        <member name="T:Loyc.Collections.ReversedList`1">
            <summary>Adapter: a reversed of an <see cref="T:System.Collections.Generic.IList`1"/>. TODO: unit tests.</summary>
        </member>
        <member name="M:Loyc.Collections.ReversedList`1.Equals(System.Object)">
            <summary>Returns true iff the parameter 'obj' is a wrapper around the same object that this object wraps.</summary>
        </member>
        <member name="M:Loyc.Collections.ReversedList`1.GetHashCode">
            <summary>Returns the hashcode of the wrapped object.</summary>
        </member>
        <member name="M:Loyc.Collections.ReversedList`1.ToString">
            <summary>Returns ToString() of the wrapped object.</summary>
        </member>
        <member name="T:Loyc.Collections.ReversedListSource`1">
            <summary>Adapter: reversed view of <see cref="T:Loyc.Collections.IListSource`1"/> returned 
            from <see cref="M:Loyc.Collections.LinqToLists.Reverse``1(Loyc.Collections.IListSource{``0})"/>.</summary>
        </member>
        <member name="T:Loyc.Collections.Slice_`1">
            <summary>Adapter: a random-access range for a slice of an 
            <see cref="T:Loyc.Collections.IListSource`1"/>.</summary>
            <typeparam name="T">Item type in the list</typeparam>
            <remarks>
            This type was supposed to be called simply <c>Slice</c>, but this was not
            allowed because in plain C#, "CS0542: member names cannot be the same as 
            their enclosing type" and of course, this type contains the Slice() method
            from IListSource.
            </remarks>
        </member>
        <member name="M:Loyc.Collections.Slice_`1.#ctor(Loyc.Collections.IListSource{`0},System.Int32,System.Int32)">
            <summary>Initializes a slice.</summary>
            <exception cref="T:System.ArgumentException">The start index was below zero.</exception>
            <remarks>The (start, count) range is allowed to be invalid, as long
            as 'start' and 'count' are zero or above. 
            <ul>
            <li>If 'start' is above the original Count, the Count of the new slice 
            is set to zero.</li>
            <li>if (start + count) is above the original Count, the Count of the new
            slice is reduced to <c>list.Count - start</c>.</li>
            </ul>
            </remarks>
        </member>
        <member name="T:Loyc.Collections.ReadOnlyAsCollection`1">
            <summary>
            A read-only wrapper that implements ICollection(T) and ISource(T),
            returned from <see cref="M:Loyc.Collections.LCExt.AsCollection``1(System.Collections.Generic.IReadOnlyCollection{``0})"/>
            </summary>
        </member>
        <member name="T:Loyc.Collections.NegListSlice`1">
            <summary>Adapter: a random-access range for a slice of an <see cref="T:Loyc.Collections.INegListSource`1"/>.</summary>
            <typeparam name="T">Item type in the list</typeparam>
            <remarks>Although this slices a neg-list, the slice itself is an ordinary zero-indexed 
            <see cref="T:Loyc.Collections.IListSource`1"/>. It implements <see cref="T:Loyc.Collections.INegListSource`1"/> for 
            completeness, but its <c>Min</c> is 0.</remarks>
        </member>
        <member name="M:Loyc.Collections.NegListSlice`1.#ctor(Loyc.Collections.INegListSource{`0},System.Int32,System.Int32)">
            <summary>Initializes a slice.</summary>
            <exception cref="T:System.ArgumentException">The start index was below zero.</exception>
            <remarks>The (start, count) range is allowed to be invalid, as long
            as 'start' is <c>Min</c> or above and 'count' is zero or above. 
            <ul>
            <li>If 'start' is above the original Count, the Count of the new slice 
            is set to zero.</li>
            <li>if (start + count) is above the original Count, the Count of the new
            slice is reduced to <c>list.Count - start</c>.</li>
            </ul>
            </remarks>
        </member>
        <member name="T:Loyc.Collections.DList`1">
            <summary>
            A compact auto-enlarging list that efficiently supports supports insertions 
            at the beginning or end of the list.
            </summary><remarks>
            An <a href="http://core.loyc.net/collections/dlist.html">article</a>
            about this class is available.
            </remarks>
            <seealso cref="T:Loyc.Collections.Impl.InternalDList`1"/>
            <seealso cref="T:Loyc.Collections.DList"/>
        </member>
        <member name="M:Loyc.Collections.DList`1.Add(`0)">
            <summary>An alias for PushLast().</summary>
        </member>
        <member name="T:Loyc.Collections.DList">
            <summary>
            This class is the same as <c>DList{object}</c> except that it 
            also implements the IList interface.
            </summary>
        </member>
        <member name="T:Loyc.Collections.WeakKeyComparer`1">
            <summary>
            Compares objects of the given type or WeakKeyReferences to them
            for equality based on the given comparer. Note that we can only
            implement <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> for T = object as there is no 
            other common base between T and <see cref="T:Loyc.Collections.WeakKeyReference`1"/>. We need a
            single comparer to handle both types because we don't want to
            allocate a new weak reference for every lookup.</summary>
            <remarks>Source: datavault project. License: Apache License 2.0</remarks>
        </member>
        <member name="T:Loyc.Collections.WeakKeyReference`1">
            <summary>Provides a weak reference to an object of the given type to be used 
            in a WeakDictionary along with the given comparer.</summary>
            <remarks>Source: datavault project. License: Apache License 2.0
            <para/>
            DLP Updated 2014-May-21: WeakReference{T} in .NET 4.5 is sealed, but this
            code relied on the ability to derive WeakKeyReference{T} from WeakReference{T}.
            Workaround: derive WeakKeyReference{T} from WeakReference instead.
            </remarks>
        </member>
        <member name="T:Loyc.Collections.WeakKeyDictionary`2">
            <summary>A dictionary with weak keys.</summary>
            <remarks>
            Original source: datavault project. License: Apache License 2.0
            </remarks>
        </member>
        <member name="P:Loyc.Collections.WeakKeyDictionary`2.Count">
            <summary>Number of items in the collection.</summary>
            <remarks>WARNING: The count returned here may include entries for which
            key value objects have already been garbage collected. Call 
            RemoveCollectedEntries to weed out collected entries and update the count 
            accordingly.</remarks>
        </member>
        <member name="T:Loyc.Compatibility.EnumStatic">
            <summary>Implements Enum.TryParse in .NET 3.5</summary>
        </member>
        <member name="T:Loyc.MessageHolder">
            <summary>A message sink that puts the messages it receives in a list.</summary>
        </member>
        <member name="M:Loyc.MessageHolder.IsEnabled(Loyc.Severity)">
            <summary>Always returns true.</summary>
        </member>
        <member name="T:Loyc.LogMessage">
            <summary>Holds an argument list compatible with 
            <see cref="M:Loyc.IMessageSink`1.Write(Loyc.Severity,`0,System.String)"/>.
            Typically used with <see cref="T:Loyc.MessageHolder"/>.</summary>
        </member>
        <member name="T:Loyc.LogException">
            <summary>An exception that includes a "context" object as part of a
            <see cref="T:Loyc.LogMessage"/> structure, typically used to indicate where an 
            error occurred.</summary>
        </member>
        <member name="P:Loyc.LogException.Msg">
            <summary>Contains additional information about the error that occurred.</summary>
        </member>
        <member name="T:Loyc.SeverityMessageFilter`1">
            <summary>A decorator (wrapper) for <see cref="T:Loyc.IMessageSink"/> that filters
            out some messages if their <see cref="T:Loyc.Severity"/> is too low, according
            to the value of the <see cref="P:Loyc.SeverityMessageFilter`1.MinSeverity"/> property.</summary>
        </member>
        <member name="M:Loyc.SeverityMessageFilter`1.#ctor(Loyc.IMessageSink{`0},Loyc.Severity,System.Boolean)">
            <summary>Initializes the filter with a minimum severity.</summary>
            <param name="target">Another sink to which all messages will be written that pass this filter.</param>
            <param name="minSeverity">Minimum severity for which <see cref="M:Loyc.SeverityMessageFilter`1.IsEnabled(Loyc.Severity)"/> returns true,
            possibly modified by <c>includeDetails</c>.</param>
            <param name="includeDetails">Causes <c>minSeverity</c> to be reduced
            by one if <c>minSeverity</c> is an even number. Often when one uses
            a severity like <see cref="F:Loyc.Severity.Warning"/>, one actually intends 
            to also include any associated <see cref="F:Loyc.Severity.WarningDetail"/> 
            messages. This parameter ensures that you do not exclude details 
            accidentally by changing <c>minSeverity</c> for you. To disable 
            this behavior, set this parameter to false.</param>
        </member>
        <member name="P:Loyc.SeverityMessageFilter`1.MinSeverity">
            <summary>Gets or sets the minimum severity that passes the filter. Note:
            usually this property should be set to a detail level such as 
            <see cref="F:Loyc.Severity.InfoDetail"/> rather than a "normal" level such 
            as <see cref="F:Loyc.Severity.Info"/>, which is one higher.</summary>
        </member>
        <member name="T:Loyc.SeverityMessageFilter">
            <summary>Alias for SeverityMessageFilter&lt;object>.</summary>
        </member>
        <member name="M:Loyc.SeverityMessageFilter.#ctor(Loyc.IMessageSink{System.Object},Loyc.Severity,System.Boolean)">
            <inheritdoc cref="M:Loyc.SeverityMessageFilter`1.#ctor(Loyc.IMessageSink{`0},Loyc.Severity,System.Boolean)"/>
        </member>
        <member name="T:Loyc.MessageFilter">
            <summary>A decorator that uses a delegate to accept or ignore messages.</summary>
            <remarks>The filter can accept or reject messages based on both the message 
            type and the actual message (format string). When someone calls 
            <see cref="M:Loyc.MessageFilter.IsEnabled(Loyc.Severity)"/>, the filter is invoked with only the type;
            the message is set to null. Accepted messages are sent to the 
            <see cref="P:Loyc.MessageFilter.Target"/> message sink.</remarks>
        </member>
        <member name="M:Loyc.MessageFilter.IsEnabled(Loyc.Severity)">
            <summary>Returns true if <c>Filter(type, null)</c> and <c>target.IsEnabled(type)</c> are both true.</summary>
        </member>
        <member name="T:Loyc.MessageMulticaster`1">
            <summary>A message sink that sends its messages to a list of other sinks.</summary>
            <remarks>Null elements are allowed in the <see cref="P:Loyc.MessageMulticaster`1.List"/> and are ignored.</remarks>
        </member>
        <member name="M:Loyc.MessageMulticaster`1.IsEnabled(Loyc.Severity)">
            <summary>Returns true if <tt>s.IsEnabled(type)</tt> is true for at least one target message sink 's'.</summary>
        </member>
        <member name="T:Loyc.MessageMulticaster">
            <summary>Alias for MessageSplitter&lt;object>.</summary>
        </member>
        <member name="T:Loyc.MessageSinkWithContext`1">
            <summary>A message sink wrapper that has a default value for the context 
            parameter, which is used when the context provided is null, and an optional 
            message prefix which is inserted at the beginning of the format string.</summary>
        </member>
        <member name="M:Loyc.MessageSinkWithContext`1.#ctor(Loyc.IMessageSink{`0},`0,System.String,System.Boolean)">
            <summary>Initializes the wrapper.</summary>
            <param name="target">Message sink to which all messages are forwarded. If this parameter 
            is null, then messages are written to <see cref="P:Loyc.MessageSink.Default"/>
            <i>at the time a message is written</i>.</param>
            <param name="defaultContext">Default context object, used if Write is called with a context of null.</param>
            <param name="messagePrefix">A prefix to prepend at the beginning of all messages written.</param>
            <param name="scrubPrefix">Whether to replace "{" with ""{{" and "}" with "}}" in 
            <c>messagePrefix</c> to avoid accidental misbehavior when the string is formatted. 
            <b>Note:</b> in fact, <c>messagePrefix</c> should not contain braces at all, 
            because message formatting is optional. <see cref="M:Loyc.MessageSinkWithContext`1.Write(Loyc.Severity,`0,System.String)"/>
            does not perform formatting while <see cref="M:Loyc.MessageSinkWithContext`1.Write(Loyc.Severity,`0,System.String,System.Object[])"/>
            does. Consequently, when calling the first overload, the scrubbing process will 
            cause braces in <c>messagePrefix</c> to be doubled as in "{{" or "}}". We could
            fix this by storing two separate MessagePrefix strings in this object, one
            for each situation, but that's currently not implemented as it is simpler to
            just ask users not to put braces in prefixes.</param>
        </member>
        <member name="T:Loyc.MessageSinkWithContext">
            <summary>Alias for MessageSinkWithContext&lt;object>.</summary>
        </member>
        <member name="T:Loyc.StringBuilderExt">
            <summary>Extension methods that add some functionality of <c>string</c> to <c>StringBuilder</c>.</summary>
        </member>
        <member name="M:Loyc.StringBuilderExt.Substring(System.Text.StringBuilder,System.Int32,System.Int32)">
            <summary>Extracts a substring from the specified StringBuiler.</summary>
        </member>
        <member name="M:Loyc.StringBuilderExt.Last(System.Text.StringBuilder)">
            <summary>Returns the last character of the string</summary>
        </member>
        <member name="M:Loyc.StringBuilderExt.LastOrDefault(System.Text.StringBuilder,System.Char)">
            <summary>Returns the last character of the string, or a default character if the string is empty.</summary>
        </member>
        <member name="M:Loyc.StringBuilderExt.TrimStart(System.Text.StringBuilder)">
            <summary>Removes all leading occurrences of spaces and tabs from the StringBuilder object.</summary>
        </member>
        <member name="M:Loyc.StringBuilderExt.TrimStart(System.Text.StringBuilder,System.Char[])">
            <summary>Removes all leading occurrences of the specified set of characters from the StringBuilder object.</summary>
            <param name="trimChars">An array of Unicode characters to remove.</param>
        </member>
        <member name="M:Loyc.StringBuilderExt.TrimEnd(System.Text.StringBuilder)">
            <summary>Removes all trailing occurrences of spaces and tabs from the StringBuilder object.</summary>
        </member>
        <member name="M:Loyc.StringBuilderExt.TrimEnd(System.Text.StringBuilder,System.Char[])">
            <summary>Removes all trailing occurrences of the specified set of characters from the StringBuilder object.</summary>
            <param name="trimChars">An array of Unicode characters to remove.</param>
        </member>
        <member name="M:Loyc.StringBuilderExt.Trim(System.Text.StringBuilder)">
            <summary>Removes all leading and trailing occurrences of spaces and tabs from the StringBuilder object.</summary>
        </member>
        <member name="M:Loyc.StringBuilderExt.Trim(System.Text.StringBuilder,System.Char[])">
            <summary>Removes all leading and trailing occurrences of the specified set of characters from the StringBuilder object.</summary>
            <param name="trimChars">An array of Unicode characters to remove.</param>
        </member>
        <member name="M:Loyc.StringBuilderExt.FirstIndexOf(System.Text.StringBuilder,System.Char,System.Int32)">
            <summary>Gets the index of a character in a StringBuilder</summary>
            <returns>Index of the first instance of the specified character in the string, or null if not found</returns>
        </member>
        <member name="M:Loyc.StringBuilderExt.IndexOf(System.Text.StringBuilder,System.Char,System.Int32)">
            <summary>Gets the index of a character in a StringBuilder</summary>
            <returns>Index of the first instance of the specified character in the string, or -1 if not found</returns>
        </member>
        <member name="M:Loyc.StringBuilderExt.FirstIndexOf(System.Text.StringBuilder,Loyc.UString,System.Int32,System.Boolean)">
            <summary>Gets the index of a substring in a StringBuilder</summary>
            <returns>Index of the first instance of the specified substring in the StringBuilder, or null if not found</returns>
        </member>
        <member name="M:Loyc.StringBuilderExt.IndexOf(System.Text.StringBuilder,Loyc.UString,System.Int32,System.Boolean)">
            <summary>Gets the index of a substring in a StringBuilder</summary>
            <returns>Index of the first instance of the specified substring in the StringBuilder, or -1 if not found</returns>
        </member>
        <member name="M:Loyc.StringBuilderExt.LastIndexOf(System.Text.StringBuilder,System.Char,System.Int32)">
            <summary>Gets the index of a character in a StringBuilder</summary>
            <returns>Index of the last instance of the specified character in the StringBuilder, or -1 if not found</returns>
        </member>
        <member name="M:Loyc.StringBuilderExt.LastIndexOf(System.Text.StringBuilder,Loyc.UString,System.Int32,System.Boolean)">
            <summary>Gets the index of a substring in a StringBuilder</summary>
            <returns>Index of the last instance of the specified substring in the StringBuilder, or -1 if not found</returns>
        </member>
        <member name="M:Loyc.StringBuilderExt.EndsWith(System.Text.StringBuilder,Loyc.UString,System.Boolean)">
            <summary>Finds out whether the StringBuilder ends with the specified substring.</summary>
        </member>
        <member name="M:Loyc.StringBuilderExt.StartsWith(System.Text.StringBuilder,Loyc.UString,System.Boolean)">
            <summary>Finds out whether the StringBuilder starts with the specified substring.</summary>
        </member>
        <member name="M:Loyc.StringBuilderExt.SubstringEquals(System.Text.StringBuilder,System.Int32,Loyc.UString,System.Boolean)">
            <summary>Checks if the sequences of characters <c>what</c> is equal to
            <c>sb.Substring(start, what.Length)</c>, without actually creating a 
            substring object.</summary>
        </member>
        <member name="M:Loyc.StringBuilderExt.AppendCodePoint(System.Text.StringBuilder,System.Int32)">
            <summary>Appends a unicode code point in the range 0 to 0x10FFFF to StringBuilder in UTF-16.</summary>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid character c</exception>
            <exception cref="T:System.NullReferenceException">null StringBuildre</exception>
        </member>
        <member name="T:Loyc.ByteArrayInString">
            <summary>Encodes and decodes BAIS (Byte Array In String) encoding,
            which preserves runs of ASCII characters unchanged. This encoding is
            useful for debugging (since ASCII runs are visible) and for conversion 
            of bytes to JSON.</summary>
            <remarks>
            Arrays encoded with <see cref="M:Loyc.ByteArrayInString.Convert(Loyc.Collections.ArraySlice{System.Byte},System.Boolean)"/>
            tend to be slightly more compact than standard Uuencoding or Base64, 
            and when you use this encoding in JSON with UTF-8, the output is 
            typically also more compact than yEnc since double-byte characters 
            above 127 are avoided.
            <para/>
            A BAIS string alternates between runs of "direct" bytes (usually bytes
            in the ASCII range that are represented as themselves) and runs of a
            special base-64 encoding. The base-64 encoding is a sequence of 6-bit
            digits with 64 added to them, except for 63 which is mapped to itself.
            This is easier and faster to encode and decode than standard Base64
            and has an interesting property described below.
            <para/>
            A BAIS string begins in ASCII mode and switches to base 64 when the '\b'
            character is encountered. Base-64 mode ends, returning to ASCII, when a 
            '!' character is encountered.
            <para/>
            For example:
            <pre>
              //                    C   a    t       \n  E        A   B   C   D
              var b = new byte[] { 67, 97, 116, 128, 10, 69, 255, 65, 66, 67, 68 };
              Assert.AreEqual(ByteArrayInString.Convert(b), "Cat\b`@iE?tEB!CD");
            </pre>
            A byte sequence such as 128, 10, 69, 255 can be encoded in base 64 as 
            illustrated:
            <pre>
                         ---128---    ---10----    ---69----  ---255---  
              Bytes:     1000 0000    0000 1010    0100 0101  1111 1111  
              Base 64:   100000   000000   101001    000101   111111   110000
              Encoded: 01100000 01000000 01101001  01000101 01111111 01110000
                       ---96--- ---64--- --105---  ---69--- --127--- --112---
                          `        @        i         E        ~        p
            </pre>
            <para/>
            An interesting property of this base-64 encoding is that when it encodes
            bytes between 63 and 126, those bytes appear unchanged at certain 
            offsets (specifically the third, sixth, ninth, etc.) In this example, 
            since the third byte is 'E' (69), it also appears as 'E' in the 
            output.
            <para/>
            When viewing BAIS strings, another thing to keep in mind is that 
            runs of zeroes ('\0') will tend to appear as runs of `@` characters 
            in the base 64 encoding, although a single zero is not always enough 
            to make a `@` appear. Runs of 255 will tend to appear as runs of `?`.
            <para/>
            There are many ways to encode a given byte array as BAIS.
            </remarks>
        </member>
        <member name="M:Loyc.ByteArrayInString.Convert(Loyc.Collections.ArraySlice{System.Byte},System.Boolean)">
            <summary>Encodes a byte array to a string with BAIS encoding, which preserves 
            runs of ASCII characters unchanged.</summary>
            <param name="allowControlChars">If true, control characters under 32 are 
              treated as ASCII (except character 8 '\b').</param>
            <returns>The encoded string.</returns>
            <remarks>
            If the byte array can be interpreted as ASCII, it is returned as characters,
            e.g. <c>Convert(new byte[] { 65,66,67,33 }) == "ABC!"</c>. When non-ASCII
            bytes are encountered, they are encoded as described in the description of
            this class.
            <para/>
            For simplicity, this method's base-64 encoding always encodes groups of 
            three bytes if possible (as four characters). This decision may 
            unfortunately cut off the beginning of some ASCII runs.
            </remarks>
        </member>
        <member name="M:Loyc.ByteArrayInString.Convert(System.String)">
            <summary>Decodes a BAIS string back to a byte array.</summary>
            <param name="s">String to decode.</param>
            <returns>Decoded byte array (use <c>Convert(s).ToArray()</c> 
            if you need a true array).</returns>
        </member>
        <member name="T:Loyc.G">
            <summary>Contains global functions that don't belong in any specific class.</summary>
            <remarks>Note: helper methods for parsing and printing tokens and hex 
            digits have been moved to <see cref="!:Loyc.Syntax.ParseHelpers"/>.</remarks>
        </member>
        <member name="M:Loyc.G.With``1(``0,System.Action{``0})">
            <summary>Calls <c>action(obj)</c>, then returns the same object.</summary>
            <returns>obj</returns>
            <remarks>
            This is the plain-C# equivalent of the <c>with(obj)</c> statement. Compared
            to the Enhanced C# statement, <c>With()</c> is disadvantageous since it 
            requires a memory allocation to create the closure in many cases, as well
            as a delegate invocation that probably will not be inlined.
            <para/>
            Caution: you cannot mutate mutable structs with this method. Call the 
            other overload of this method if you will be modifying a mutable struct.
            </remarks>
            <example>
            Foo(new Person() { Name = "John Doe" }.With(p => p.Commit(dbConnection)));
            </example>
        </member>
        <member name="M:Loyc.G.With``1(``0,System.Func{``0,``0})">
            <summary>Returns <c>action(obj)</c>. This is similar to the other overload 
            of this method, except that the action has a return value.</summary>
        </member>
        <member name="M:Loyc.G.Do``2(``0,System.Func{``0,``1})">
            <summary>Returns <c>action(obj)</c>. This method lets you embed statements 
            in any expression.</summary>
        </member>
        <member name="M:Loyc.G.True``1(``0)">
            <summary>Returns true. This method has no effect; it is used to do an action in a conditional expression.</summary>
            <param name="value">Ignored.</param>
            <returns>True.</returns>
        </member>
        <member name="M:Loyc.G.True(System.Action)">
            <summary>This method simply calls the delegate provided and returns true. It is used to do an action in a conditional expression.</summary>
            <returns>True</returns>
        </member>
        <member name="M:Loyc.G.ToComparison``1">
            <summary>Gets a <see cref="T:System.Comparison`1"/> for the specified type.</summary>
            <remarks>This method is optimized and does not allocate on every call.</remarks>
        </member>
        <member name="M:Loyc.G.ToComparison``1(System.Collections.Generic.IComparer{``0})">
            <summary>Converts an <see cref="T:System.Collections.Generic.IComparer`1"/> to a <see cref="T:System.Comparison`1"/>.</summary>
        </member>
        <member name="M:Loyc.G.ToComparisonFunc``1(System.Collections.Generic.IComparer{``0})">
            <summary>Converts an <see cref="T:System.Collections.Generic.IComparer`1"/> to a Func(T,T,int).</summary>
        </member>
        <member name="M:Loyc.G.MakeValidFileName(System.String,System.Nullable{System.Char},System.Boolean)">
            <summary>Replaces characters in <c>text</c> that are not allowed in 
            file names with the specified replacement character.</summary>
            <param name="text">Text to make into a valid filename. The same string is returned if it is valid already.</param>
            <param name="replacement">Replacement character, or null to simply remove bad characters.</param>
            <param name="fancy">Whether to replace quotes and slashes with the non-ASCII characters  and .</param>
            <returns>A string that can be used as a filename. If the output string would otherwise be empty, returns "_".</returns>
        </member>
        <member name="M:Loyc.G.Verify(System.Boolean)">
            <summary>Same as <c>Debug.Assert</c> except that the argument is 
            evaluated even in a Release build.</summary>
        </member>
        <member name="M:Loyc.G.BareHtmlEntityNameForAscii(System.Char)">
            <summary>Gets a bare HTML entity name for an ASCII character, or null if
            there is no entity name for the given character, e.g. 
            <c>BareHtmlEntityNameForAscii('"') == "quot"</c>.
            </summary><remarks>
            The complete entity name is an ampersand (&amp;) plus <c>BareHtmlEntityNameForAscii(c) + ";"</c>.
            Some HTML entities have multiple names; this function returns one of them.
            There is a name in this table for all ASCII punctuation characters.
            </remarks>
        </member>
        <member name="M:Loyc.G.CountOnes(System.Byte)">
            <summary>Returns the number of bits that are set in the specified integer.</summary>
        </member>
        <member name="M:Loyc.G.CountOnes(System.Int32)">
            <summary>Returns the number of bits that are set in the specified integer.</summary>
            <remarks>This is a duplicate of MathEx.CountOnes() needed by Loyc.Collections,
            which does not have a reference to Loyc.Math.dll which contains MathEx.
            However this uses a compact SWAR implementation, whereas Loyc.Math uses
            a potentially faster lookup table.</remarks>
        </member>
        <member name="M:Loyc.G.CountOnes(System.UInt32)">
            <inheritdoc cref="M:Loyc.G.CountOnes(System.Int32)"/>
        </member>
        <member name="M:Loyc.G.Log2Floor(System.UInt32)">
            <inheritdoc cref="M:Loyc.G.Log2Floor(System.Int32)"/>
        </member>
        <member name="M:Loyc.G.Log2Floor(System.Int32)">
            <summary>
            Returns the floor of the base-2 logarithm of x. e.g. 1024 -> 10, 1000 -> 9
            </summary><remarks>
            The return value is -1 for an input that is zero or negative.
            <para/>
            Some processors have a dedicated instruction for this operation, but
            the .NET framework provides no access to it.
            </remarks>
        </member>
        <member name="M:Loyc.G.IsInRangeExcludeHi(System.Int32,System.Int32,System.Int32)">
            <summary>Returns true if `num` is between `lo` and `hi`, excluding `hi` but not `lo`.</summary>
        </member>
        <member name="M:Loyc.G.IsInRange(System.Int32,System.Int32,System.Int32)">
            <summary>Returns true if `num` is between `lo` and `hi`.</summary>
        </member>
        <member name="M:Loyc.G.PutInRange(System.Int32,System.Int32,System.Int32)">
            <summary>Returns `num` clamped to the range `min` and `max`.</summary>
        </member>
        <member name="M:Loyc.G.IsInRangeExcludeHi(System.UInt32,System.UInt32,System.UInt32)">
            <summary>Returns true if `num` is between `lo` and `hi`, excluding `hi` but not `lo`.</summary>
        </member>
        <member name="M:Loyc.G.IsInRange(System.UInt32,System.UInt32,System.UInt32)">
            <summary>Returns true if `num` is between `lo` and `hi`.</summary>
        </member>
        <member name="M:Loyc.G.PutInRange(System.UInt32,System.UInt32,System.UInt32)">
            <summary>Returns `num` clamped to the range `min` and `max`.</summary>
        </member>
        <member name="M:Loyc.G.IsInRangeExcludeHi(System.Int64,System.Int64,System.Int64)">
            <summary>Returns true if `num` is between `lo` and `hi`, excluding `hi` but not `lo`.</summary>
        </member>
        <member name="M:Loyc.G.IsInRange(System.Int64,System.Int64,System.Int64)">
            <summary>Returns true if `num` is between `lo` and `hi`.</summary>
        </member>
        <member name="M:Loyc.G.PutInRange(System.Int64,System.Int64,System.Int64)">
            <summary>Returns `num` clamped to the range `min` and `max`.</summary>
        </member>
        <member name="M:Loyc.G.IsInRangeExcludeHi(System.UInt64,System.UInt64,System.UInt64)">
            <summary>Returns true if `num` is between `lo` and `hi`, excluding `hi` but not `lo`.</summary>
        </member>
        <member name="M:Loyc.G.IsInRange(System.UInt64,System.UInt64,System.UInt64)">
            <summary>Returns true if `num` is between `lo` and `hi`.</summary>
        </member>
        <member name="M:Loyc.G.PutInRange(System.UInt64,System.UInt64,System.UInt64)">
            <summary>Returns `num` clamped to the range `min` and `max`.</summary>
        </member>
        <member name="M:Loyc.G.IsInRangeExcludeHi(System.Single,System.Single,System.Single)">
            <summary>Returns true if `num` is between `lo` and `hi`, excluding `hi` but not `lo`.</summary>
        </member>
        <member name="M:Loyc.G.IsInRange(System.Single,System.Single,System.Single)">
            <summary>Returns true if `num` is between `lo` and `hi`.</summary>
        </member>
        <member name="M:Loyc.G.PutInRange(System.Single,System.Single,System.Single)">
            <summary>Returns `num` clamped to the range `min` and `max`.</summary>
        </member>
        <member name="M:Loyc.G.IsInRangeExcludeHi(System.Double,System.Double,System.Double)">
            <summary>Returns true if `num` is between `lo` and `hi`, excluding `hi` but not `lo`.</summary>
        </member>
        <member name="M:Loyc.G.IsInRange(System.Double,System.Double,System.Double)">
            <summary>Returns true if `num` is between `lo` and `hi`.</summary>
        </member>
        <member name="M:Loyc.G.PutInRange(System.Double,System.Double,System.Double)">
            <summary>Returns `num` clamped to the range `min` and `max`.</summary>
        </member>
        <member name="T:Loyc.EzStopwatch">
            <summary>
            A wrapper around <see cref="T:System.Diagnostics.Stopwatch"/> with a more convenient interface,
            currently oriented around measuring milliseconds 
            (TODO: increase similarity to <c>Stopwatch</c>)
            </summary>
            <remarks>
            EzStopwatch is a wrapper around the normal <see cref="T:System.Diagnostics.Stopwatch"/> that
            is less clumsy to use: you can get the elapsed time and restart the 
            timer from zero with a single call to Restart(). The Stopwatch class
            (prior to .NET 4, anyway) requires you to make three separate method 
            calls to do the same thing: you have to call ElapsedMilliseconds, then 
            Reset(), then Start().
            <para/>
            Unlike <see cref="!:Loyc.Utilities.SimpleTimer"/>, this class does not start 
            timing when it is created, which allows it to be a struct without a 
            constructor.
            <para/>
            EzStopwatch behaves differently from Stopwatch when restarting, because I
            observed a problem using the timer to measure short time intervals. I ran
            trials of three operations in a loop, and the loop was programmed to run 
            until the total elapsed time for one of the operations exceeded 100 ms. On 
            each iteration I restarted the timer three times because there were three 
            operations to measure, and when I replaced <see cref="!:SimpleTimer"/> with 
            <see cref="T:Loyc.EzStopwatch"/> for greater accuracy, the loop ran forever! The
            problem was that (depending on the benchmark's input parameters) the 
            operation could take less than 1 millisecond to complete, so 
            <see cref="P:Loyc.EzStopwatch.Millisec"/> always returned zero, and the total never reached
            100.
            <para/>
            To solve this problem, when you "<see cref="M:Loyc.EzStopwatch.Restart"/>" the timer, it is
            not completely reset to zero, but rather the current value of Millisec is
            subtracted from the timer. This leaves a fractional amount of time less
            than 1 millisecond in the timer, so that if you take two measurements 
            that each take 0.6 milliseconds, Millisec will return 0 the first time
            and 1 the second time, leaving 0.2 milliseconds on the clock.
            <para/>
            TODO: change interfaces of SimpleTimer and EzStopwatch to better resemble
            Stopwatch, even though the behavior of "Pause" and "Resume" is more obvious
            than "Stop" and "Start".
            </remarks>
        </member>
        <member name="P:Loyc.EzStopwatch.Millisec">
            <summary>Gets or sets the current time on the clock.</summary>
            <remarks>This property can be used whether the timer is running or not,
            and it does not affect the value of <see cref="P:Loyc.EzStopwatch.Paused"/>. It is legal
            to make the current value negative.</remarks>
        </member>
        <member name="M:Loyc.EzStopwatch.Restart">
            <summary>Restarts the timer from zero (unpausing it if it is paused), 
            and returns the number of elapsed milliseconds prior to the reset.</summary>
        </member>
        <member name="M:Loyc.EzStopwatch.Reset">
            <summary>Resets the timer to 0 and pauses it there.</summary>
        </member>
        <member name="M:Loyc.EzStopwatch.ClearAfter(System.Int32)">
            <summary>Restarts the timer from zero if the specified number of 
            milliseconds have passed, and returns the former value of Millisec.</summary>
            <returns>If the timer was restarted, this method returns the number of 
            elapsed milliseconds prior to the reset. Returns 0 if the timer was not 
            reset.</returns>
            <remarks>If this method resets a paused timer, it remains paused but 
            Millisec is set to zero.</remarks>
        </member>
        <member name="T:Loyc.TypeExt">
            <summary>Extension methods for <c>Type</c>.</summary>
        </member>
        <member name="M:Loyc.TypeExt.NameWithGenericArgs(System.Type)">
            <summary>Returns the type with generic parameters in C# style, e.g.
            <c>typeof(List&lt;List&lt;string>>.NameWithGenericArgs()</c> returns
            <c>List&lt;List&lt;String>></c>.</summary>
        </member>
        <member name="T:Loyc.ExceptionExt">
            <summary>Extension methods for exceptions.</summary>
        </member>
        <member name="M:Loyc.ExceptionExt.ExceptionMessageAndType(System.Exception)">
            <summary>Returns a string of the form "{ex.Message} ({ex.GetType().Name})".</summary>
        </member>
        <member name="M:Loyc.ExceptionExt.InnermostException(System.Exception)">
            <summary>Gets the innermost InnerException, or <c>ex</c> itself if there are no inner exceptions.</summary>
            <exception cref="T:System.NullReferenceException">ex is null.</exception>
        </member>
        <member name="M:Loyc.ExceptionExt.Description(System.Exception)">
            <inheritdoc cref="M:Loyc.ExceptionExt.Description(System.Exception,System.Boolean,System.String)"/>
        </member>
        <member name="M:Loyc.ExceptionExt.DescriptionAndStackTrace(System.Exception)">
            <inheritdoc cref="M:Loyc.ExceptionExt.Description(System.Exception,System.Boolean,System.String)"/>
            <remarks>Adds a stack trace.</remarks>
        </member>
        <member name="M:Loyc.ExceptionExt.Description(System.Exception,System.Boolean,System.String)">
            <summary>Gets a description of the exception in the form "{ex.Message} ({ex.GetType().Name})".
            If the exception has InnerExceptions, these are printed afterward in 
            the form "Inner exception: {ex.Message} ({ex.GetType().Name})" and 
            separated from the outer exception by "\n\n" (or a string of your 
            choosing).</summary>
            <param name="addStackTrace">If true, the stack trace of the outermost
            exception is added to the end of the message (not the innermost 
            exception, because the inner stack trace gets truncated. TODO: 
            investigate whether the full stack trace can be reconstructed).</param>
            <param name="lineSeparator">Separator between different exceptions and 
            before the stack trace.</param>
        </member>
        <member name="M:Loyc.ExceptionExt.ToDetailedString(System.Exception)">
            <summary>Returns a string containing the exception type, message, 
            Data pairs (if any) and stack strace, followed by the type, message and 
            stack strace of inner exceptions, if any.</summary>
            <remarks>If <c>maxInnerExceptions</c> is not given, the default is 3.</remarks>
        </member>
        <member name="M:Loyc.ExceptionExt.DataList(System.Exception)">
            <summary>Converts <c>Exception.Data</c> to a string, separating each key-value
            pair by a newline.</summary>
        </member>
        <member name="M:Loyc.ExceptionExt.DataList(System.Exception,System.String,System.String,System.String)">
            <summary>Converts <c>Exception.Data</c> to a string, separating each key
            from each value with <c>keyValueSeparator</c>, prepending each line by
            <c>linePrefix</c>, and separating each pair with <c>newLine</c>, which
            may or may not be "\n", your choice.</summary>
        </member>
        <member name="M:Loyc.ExceptionExt.PreserveStackTrace(System.Exception)">
            <summary>Calls an internal method of <see cref="T:System.Exception"/> that records 
            an exception's stack trace so that the stack trace does not change if 
            the exception is rethrown (e.g. on another thread).</summary>
            <remarks>
            <example>
            	Exception ex = null;
            	var thread = new ThreadEx(() => {
            		try { 
            			SomethingThatMightThrowOrTakeForever(); 
            		} catch (Exception e) { 
            			ex = e; 
            			ex.PreserveStackTrace();
            		}
            	});
            	thread.Start();
            	if (!thread.Join(timeout)) {
            		thread.Abort();
            		thread.Join(timeout);
            	}
            	if (ex != null)
            		throw ex; // includes stack trace from the other thread
            </example>
            Note: when rethrowing an exception that was just caught, you
            should always use "catch;" instead of calling this method.
            </remarks>
        </member>
        <member name="T:Loyc.HashTags`1">
            <summary>
            An implementation of IAttributes that can hold one attribute before
            allocating any memory for a hashtable. It is intended to be used as
            a base class but can be used on its own.
            </summary>
        </member>
        <member name="T:Loyc.Holder`1">
            <summary>A trivial class that holds a single value of type T in the 
            <see cref="F:Loyc.Holder`1.Value"/> property.
            </summary><remarks>
            This class is useful mainly as an alternative to standard boxing. When you 
            box a structure in C#, you lose access to the members of that structure.
            This class, in contrast, provides access to the "boxed" value.
            This type is different from the standard <c>Tuple{T}</c> in that the 
            <see cref="F:Loyc.Holder`1.Value"/> is a mutable field.
            </remarks>
        </member>
        <member name="F:Loyc.Holder`1.Value">
            <summary>Any value of type T.</summary>
        </member>
        <member name="T:Loyc.ServiceProvider">
            <summary>Adds extension methods to modernize .NET's simple built-in service locator.</summary>
            <remarks>
            .NET has had a litte-known built-in simple service locator since .NET 1.1 called
            <see cref="T:System.ComponentModel.Design.ServiceContainer"/>, which implements both 
            <see cref="T:System.ComponentModel.Design.IServiceContainer"/> and <see cref="T:System.IServiceProvider"/>. 
            IServiceContainer lets you add services (associating a Type object with a factory or 
            a singleton):
            <pre>
            interface IServiceContainer {
                void AddService(Type serviceType, object serviceInstance);
                void AddService(Type serviceType, ServiceCreatorCallback callback);
                ...
            }
            delegate object ServiceCreatorCallback(IServiceContainer container, Type serviceType);
            </pre>
            
            Meanwhile, IServiceProvider is a simple service locator:
            <pre>
            public interface IServiceProvider
            {
            	object GetService(Type serviceType);
            }
            </pre>
            
            This class adds three extension methods to make IServiceContainer and IServiceProvider 
            generic, so you can write code like
            <pre>
               var services = new ServiceContainer();
               services.AddService&lt;IFoo>(p => new Foo());
               
               // elsewhere in your code...
               IFoo newFoo = services.GetService&lt;IFoo>();
            </pre>
            
            Remember that service locators are generally an antipattern! However, if you have one
            of those rare, legitimate needs to use one, you should prefer the IServiceProvider 
            interface built into .NET (if it is enough for your needs) so that your lower-level 
            code avoids taking an unnecessary dependency on an IoC framework.
            <para/>
            See also: http://core.loyc.net/essentials/ambient-service-pattern.html
            <para/>
            Thanks to <a href="http://blog.differentpla.net/blog/2011/12/20/did-you-know-that-net-already-had-an-ioc-container">
            Roger's blog</a> for the idea of these extension methods.
            </remarks>
        </member>
        <member name="T:Loyc.MessageSink">
            <summary>Keeps track of the default message sink (<see cref="P:Loyc.MessageSink.Default"/>); 
            contains a series of helper methods; and contains extension methods 
            modeled after log4net: Fatal, Error, Warn, Info, Debug.</summary>
            <remarks>Helpful article: http://core.loyc.net/essentials/messagesink.html </remarks>
            <seealso cref="T:Loyc.IMessageSink"/>
        </member>
        <member name="M:Loyc.MessageSink.SetDefault(Loyc.IMessageSink)">
            <summary>Used to change the <see cref="P:Loyc.MessageSink.Default"/> property temporarily.</summary>
            <example><code>
            using (MessageSink.SetDefault(ConsoleMessageSink.Value))
                MessageSink.Default.Write(Severity.Warning, null, "This prints on the console.")
            </code></example>
            <remarks>This method sets a thread-local value, but it also sets the
            global default used by threads on which this method was never called.
            <para/>
            This property follows the Ambient Service Pattern:
            http://core.loyc.net/essentials/ambient-service-pattern.html
            </remarks>
        </member>
        <member name="T:Loyc.MessageSink.PushedCurrent">
            <summary>Returned by <see cref="M:Loyc.MessageSink.PushCurrent(Loyc.IMessageSink)"/>.</summary>
        </member>
        <member name="M:Loyc.MessageSink.LocationOf(System.Object)">
            <summary>Returns context.Location if context implements 
            <see cref="T:Loyc.IHasLocation"/>; otherwise, returns context itself.</summary>
        </member>
        <member name="M:Loyc.MessageSink.GetLocationString(System.Object)">
            <summary>Gets the location information from the specified object, or
            converts the object to a string. This is the default method returned
            from <see cref="P:Loyc.MessageSink.ContextToString"/>.</summary>
            <param name="context">A value whose string representation you want to get.</param>
            <returns>
            If <c>context</c> implements <see cref="T:Loyc.IHasLocation"/>,
            this converts <see cref="P:Loyc.IHasLocation.Location"/> to a string; 
            if <c>context</c> is null, this method returns <c>null</c>; otherwise 
            it returns <c>context.ToString()</c>.
            </returns>
        </member>
        <member name="P:Loyc.MessageSink.ContextToString">
            <summary>Gets the strategy that message sinks should use to convert 
            a context object to a string.</summary>
            <remarks>
            Message sinks are commonly used to display error and warning 
            messages, and when you write a message with <c>IMessageSink.Write()</c>, 
            the second parameter is a "context" argument which specifies the object
            to which the message is related (for example, when writing compiler 
            output, the context might be a node in a syntax tree). Most message 
            sinks display the message in text form (in a log file or terminal), and 
            in that case the best option is to display the location information 
            associated with the context object (e.g. Foo.cpp:45), rather than a 
            string representation of the object itself.
            <para/>
            Therefore, message sinks that display a message in text form will call
            this delegate to convert the context object to a string.
            <para/>
            See <see cref="M:Loyc.MessageSink.GetLocationString(System.Object)"/> to learn how the 
            default strategy works, but message sinks should call this delegate 
            rather than GetLocationString().
            </remarks>
        </member>
        <member name="M:Loyc.MessageSink.SetContextToString(System.Func{System.Object,System.String})">
            <summary>Sets the strategy that message sinks should use to convert 
            a context object to a string.</summary>
            <remarks><see cref="P:Loyc.MessageSink.ContextToString"/> is a thread-local value, but since
            .NET does not support inheritance of thread-local values, this method
            also sets the global default used by threads on which this method was 
            never called.
            <para/>
            This property follows the Ambient Service Pattern:
            http://core.loyc.net/essentials/ambient-service-pattern.html
            </remarks>
        </member>
        <member name="M:Loyc.MessageSink.FormatMessage(Loyc.Severity,System.Object,System.String,System.Object[])">
            <summary>Converts a quadruplet (type, context, format, args) to a single 
            string containing all that information. The format string and the Severity
            are localized with <see cref="M:Loyc.Localize.Localized(System.String,System.Object[])"/>.</summary>
            <remarks>For example, <c>FormatMessage(Severity.Error, "context", "Something happened!")</c>
            comes out as "Error: context: Something happened!".</remarks>
        </member>
        <member name="F:Loyc.MessageSink.Trace">
            <summary>Sends all messages to <see cref="M:System.Diagnostics.Trace.WriteLine(System.String)"/>.</summary>
        </member>
        <member name="F:Loyc.MessageSink.Console">
            <summary>Sends all messages to the <see cref="M:System.Console.WriteLine(System.String)"/>.</summary>
        </member>
        <member name="F:Loyc.MessageSink.Null">
            <summary>The message sink that discards all messages.</summary>
        </member>
        <member name="M:Loyc.MessageSink.FromDelegate(Loyc.WriteMessageFn,System.Func{Loyc.Severity,System.Boolean})">
            <summary>Sends all messages to a user-defined method.</summary>
        </member>
        <member name="M:Loyc.MessageSink.WithContext(System.Object,System.String)">
            <summary>Creates a message sink that writes to <see cref="P:Loyc.MessageSink.Default"/> with a default context to be used
            when <c>Write</c> is called with <c>context: null</c>, so that you 
            can use extension methods like <c>Error(string)</c> that do not 
            have any context parameter.</summary>
        </member>
        <member name="M:Loyc.MessageSink.WithContext``1(Loyc.IMessageSink{``0},``0,System.String)">
            <summary>Creates a message sink with a default context to be used
            when <c>Write</c> is called with <c>context: null</c>, so that you 
            can use extension methods like <c>Error(string)</c> that do not 
            have any context parameter.</summary>
        </member>
        <member name="T:Loyc.ConsoleMessageSink">
            <summary>Sends all messages to <see cref="M:System.Console.WriteLine"/>, 
            with hard-coded colors for Error, Warning, Note, Verbose, and Detail.</summary>
        </member>
        <member name="P:Loyc.ConsoleMessageSink.PrintSeverityAt">
            <summary>Minimum severity level at which the severity level is printed.
            For example, if set to Severity.Error, then the prefix "Error:" is printed
            for errors but the prefix "Warning:" is not printed for warnings.</summary>
            <remarks>Initial value: Severity.Warning</remarks>
        </member>
        <member name="M:Loyc.ConsoleMessageSink.IsEnabled(Loyc.Severity)">
            <summary>Always returns true.</summary>
        </member>
        <member name="T:Loyc.NullMessageSink">
            <summary>Discards all messages. However, there is a Count property that 
            increases by one with each message received, as well as an ErrorCount.</summary>
        </member>
        <member name="P:Loyc.NullMessageSink.Count">
            <summary>Total number of messages that have been discarded.</summary>
        </member>
        <member name="P:Loyc.NullMessageSink.ErrorCount">
            <summary>Number of errors sent to this object so far, not including detail messages.</summary>
        </member>
        <member name="M:Loyc.NullMessageSink.IsEnabled(Loyc.Severity)">
            <summary>Always returns false.</summary>
        </member>
        <member name="T:Loyc.TraceMessageSink">
            <summary>Sends all messages to <see cref="M:System.Diagnostics.Trace.WriteLine(System.String)"/>.</summary>
        </member>
        <member name="M:Loyc.TraceMessageSink.IsEnabled(Loyc.Severity)">
            <summary>Always returns true.</summary>
        </member>
        <member name="T:Loyc.MessageSinkFromDelegate">
            <summary>This helper class lets you implement <see cref="T:Loyc.IMessageSink"/> 
            with one or two delegates (a writer method, and an optional severity filter).</summary>
        </member>
        <member name="M:Loyc.MessageSinkFromDelegate.#ctor(Loyc.WriteMessageFn,System.Func{Loyc.Severity,System.Boolean})">
            <summary>Initializes this object.</summary>
            <param name="writer">Required. A method that accepts output.</param>
            <param name="isEnabled">Optional. A method that decides whether to 
            output based on the message type. If this parameter is provided,
            then <see cref="M:Loyc.MessageSinkFromDelegate.Write(Loyc.Severity,System.Object,System.String)"/>() will not invoke the writer when isEnabled
            returns false. This delegate is also called by <see cref="M:Loyc.MessageSinkFromDelegate.IsEnabled(Loyc.Severity)"/>().</param>
        </member>
        <member name="T:Loyc.MiniTest.TestFixtureAttribute">
            <summary>Identifies a class that contains unit tests, or methods that 
            return other tests or test fixtures.</summary> 
            <remarks>
            The MiniTest runner will ignore any class that does not have the 
            [TestFixture] attribute and is not named according to a recognized pattern,
            such as My_TestFixture.
            </remarks>
            <example>
            [TestFixture]
            public class ExampleClass {...}
            </example>
        </member>
        <member name="P:Loyc.MiniTest.TestFixtureAttribute.Description">
            <summary>
            Descriptive text for this fixture
            </summary>
        </member>
        <member name="T:Loyc.MiniTest.TestAttribute">
            <summary>Identifies a method that contains a unit test, or that
            returns other tests or test fixtures.</summary> 
            <remarks>
            In addition to standard tests (which return void), the MiniTest runner
            is planned to support [Test] methods with other return values:
            <ul>
            <li>A test can return a string, which describes the result of the test.</li>
            <li>A test can return an Action (or any other delegate that takes no 
            arguments), which is treated as a sub-test and executed. Sub-tests are 
            run without set-up or tear-down steps.</li>
            <li>A test can return an object that does not implement IEnumerable, which 
            the test runner will assume is a test fixture. The object will be scanned
            for test methods to execute.</li>
            <li>A test can return an object that implements IEnumerable, which the 
            test runner will scan to find tests and test fixtures to execute.</li>
            <li>A test can return a KeyValuePair(TKey, TValue) or DictionaryEntry.
            In that case pair's Value is processed as though it were the return value,
            and the key is a status message.</li>
            </ul>
            These features give the MiniTest runner powerful capabilities while keeping
            it simple. However, please note that NUnit doesn't offer this feature.
            <para/>
            MiniTest allows tests to be static methods if they are inside a test 
            fixture. However, when test objects are returned from a [Test] method, 
            they are not scanned for static methods.
            <para/>
            If multiple tests return the same test fixture instance, directly or 
            indirectly, MiniTest runner will avoid running the test fixture instance 
            multiple times, but it can show the results at multiple places in the 
            result tree, which can be used to construct multiple "views" of the test 
            results.  However, if a test fixture is nested within itself, the nested
            instance is excluded from the result tree.
            <para/>
            If a TestFixture class contains only a single "test suite" method (a
            method that returns tests), MiniTest merges that method with the class in 
            the tree view. For example, if the class "MyTests" has a single method 
            "GetTests", the tree view will use one line for "MyTests.GetTests" rather 
            than separating out GetTests as a child of MyTests.
            </remarks>
            <example>
            [Test]
            public void MyTest() {...}
            </example>
        </member>
        <member name="P:Loyc.MiniTest.TestAttribute.Description">
            <summary>
            Descriptive text for this test
            </summary>
        </member>
        <member name="P:Loyc.MiniTest.TestAttribute.AllowParallel">
            <summary>
            Indicates whether this test can be run in parallel with other tests
            in different test fixtures.
            </summary>
            <remarks>This property does not exist in NUnit.</remarks>
        </member>
        <member name="P:Loyc.MiniTest.TestAttribute.Fails">
            <summary>Setting this property is used to indicate that the test is 
            known to fail. It is used to mark tests that should be fixed eventually, 
            but will not be fixed immediately.</summary>
            <remarks>If you are new to a codebase, it helps to be able to tell the
            difference between new problems that need to be investigated and 
            addressed immediately, and old problems that have been placed on the 
            backburner to be fixed "someday", or feature requests that have not
            yet been addressed. Setting this property suggests that a failure may 
            be low-priority and may be an old issue.</remarks>
        </member>
        <member name="T:Loyc.MiniTest.SetUpAttribute">
            <summary>
            Marks a method that is to be called prior to each test in a test fixture.
            </summary>
        </member>
        <member name="T:Loyc.MiniTest.TearDownAttribute">
            <summary>
            Marks a method that is to be called after each test in a test fixture.
            </summary>
        </member>
        <member name="T:Loyc.MiniTest.BenchmarkAttribute">
            <summary>
            Marks a benchmark test, which exists to test performance. Benchmark tests
            are often run multiple times to obtain an average running time.
            </summary>
            <remarks>This attribute does not exist in NUnit.</remarks>
        </member>
        <member name="P:Loyc.MiniTest.BenchmarkAttribute.RepeatForMs">
            <summary>Gets or sets the recommended minimum length of time to
            run the test. The test runner will run the test repeatedly until
            the total time elapsed exceeds this number.</summary>
        </member>
        <member name="P:Loyc.MiniTest.BenchmarkAttribute.MinTrials">
            <summary>Gets or sets the recommended minimum number of times to run 
            the benchmark in order to get an average. If this property is left
            at the default value (null), the test runner can decide.</summary>
            <remarks>If RepeatForMs is also specified, the number of trials can
            be increased to reach the requested running time.</remarks>
        </member>
        <member name="T:Loyc.MiniTest.ExpectedExceptionAttribute">
            <summary>
            Marks a test that is expected to throw an exception of a particular type.
            The test fails if the expected exception is not thrown.
            </summary>
        </member>
        <member name="T:Loyc.MiniTest.TestException">
            <summary>An exception thrown when a method of <see cref="T:Loyc.MiniTest.Assert"/> fails.</summary>
        </member>
        <member name="T:Loyc.MiniTest.AssertionException">
            <summary>
            Thrown when an assertion fails during a call to a method of <see cref="T:Loyc.MiniTest.Assert"/>.
            </summary>
        </member>
        <member name="T:Loyc.MiniTest.IgnoreException">
            <summary>Thrown by <see cref="M:Loyc.MiniTest.Assert.Ignore"/>.</summary>
        </member>
        <member name="T:Loyc.MiniTest.InconclusiveException">
            <summary>Thrown by <see cref="M:Loyc.MiniTest.Assert.Inconclusive"/>.</summary>
        </member>
        <member name="T:Loyc.MiniTest.SuccessException">
            <summary>Thrown by <see cref="M:Loyc.MiniTest.Assert.Success"/>.</summary>
        </member>
        <member name="T:Loyc.MiniTest.Assert">
            <summary>
            The Assert class contains a collection of static methods that mirror
            the most common assertions used in NUnit.
            </summary>
            <remarks>
            This class is mostly a drop-in replacement for "old-style" NUnit tests, 
            i.e. those that do not use constraint classes or the "Is" class.
            <para/>
            Some methods were dropped to keep this class small. Use the full NUnit 
            framework if the remaining methods are not sufficient for you.
            <ul>
            <li>When the same assertion was known by multiple similar names (e.g. 
            True and IsTrue), I kept only one of the names. However, I did keep 
            That(), Expect() and IsTrue() even though they all do the same thing.</li>
            <li>Some less-common overloads that take a format string and arguments 
            were dropped.</li>
            <li>Some overloads were dropped when the compiler can automatically
            select a different overload instead. In particular, most overloads that 
            take a message string (without arguments) were dropped. Code that relied
            on those overloads will still compile, because the compiler will 
            construct an empty argument list and call the overload that takes a
            variable argument list.</li>
            </ul>
            </remarks>
        </member>
        <member name="M:Loyc.MiniTest.Assert.#ctor">
            <summary>
            You may find it useful to derive a test fixture from Assert so that 
            you do not need to prefix every test with "Assert."
            </summary>
        </member>
        <member name="M:Loyc.MiniTest.Assert.Fail(System.String,System.Object[])">
            <summary>Fails a test by invoking <see cref="F:Loyc.MiniTest.Assert.StopTestHandler"/>.Value(), 
            which, by default, throws an AssertionException.</summary>
        </member>
        <member name="M:Loyc.MiniTest.Assert.Ignore(System.String,System.Object[])">
            <summary>Stops a test via StopTestHandler, which, by default, throws
            an IgnoreException. This causes the test to be reported as ignored.</summary>
        </member>
        <member name="M:Loyc.MiniTest.Assert.Inconclusive(System.String,System.Object[])">
            <summary>Stops a test via StopTestHandler, which, by default, throws 
            an InconclusiveException. This causes the test to be reported as 
            inconclusive.</summary>
        </member>
        <member name="M:Loyc.MiniTest.Assert.Success(System.String,System.Object[])">
            <summary>Stops a test via StopTestHandler, which, by default, 
            throws a SuccessException.</summary>
        </member>
        <member name="M:Loyc.MiniTest.Assert.Fail">
            <summary>Short for Fail("").</summary>
        </member>
        <member name="M:Loyc.MiniTest.Assert.Ignore">
            <summary>Short for Ignore("").</summary>
        </member>
        <member name="M:Loyc.MiniTest.Assert.Inconclusive">
            <summary>Short for Inconclusive("").</summary>
        </member>
        <member name="M:Loyc.MiniTest.Assert.Success">
            <summary>Short for Success("").</summary>
        </member>
        <member name="M:Loyc.MiniTest.Assert.Equals(System.Object,System.Object)">
            <summary>
            Equals() is inherited from object; you probably want to call AreEqual instead.
            </summary>
        </member>
        <member name="M:Loyc.MiniTest.Assert.ReferenceEquals(System.Object,System.Object)">
            <summary>
            Verifies that two references are equal.
            </summary>
        </member>
        <member name="M:Loyc.MiniTest.Assert.That(System.Boolean,System.String,System.Object[])">
            <summary>Calls Fail(message, args) if condition is false.</summary>
        </member>
        <member name="M:Loyc.MiniTest.Assert.That(System.Boolean,System.String)">
            <summary>Calls Fail(message) if condition is false.</summary>
        </member>
        <member name="M:Loyc.MiniTest.Assert.That(System.Boolean)">
            <summary>Calls Fail() if condition is false.</summary>
        </member>
        <member name="M:Loyc.MiniTest.Assert.Expect(System.Boolean)">
            <summary>Calls Fail() if condition is false.</summary>
        </member>
        <member name="M:Loyc.MiniTest.Assert.ThrowsAny(System.Type,System.Action,System.String,System.Object[])">
            <summary>
            Verifies that a delegate throws a particular exception when called.
            </summary>
            <param name="expectedExceptionType">The exception Type expected</param>
            <param name="code">A method to run</param>
            <param name="message">The message that will be displayed on failure</param>
            <param name="args">Arguments to be used in formatting the message</param>
        </member>
        <member name="M:Loyc.MiniTest.Assert.Catch(System.Action,System.String,System.Object[])">
            <summary>
            Verifies that a delegate throws an exception when called and returns it.
            </summary>
            <param name="code">A method to run</param>
            <param name="message">The message that will be displayed on failure</param>
            <param name="args">Arguments to be used in formatting the message</param>
        </member>
        <member name="M:Loyc.MiniTest.Assert.Catch(System.Action)">
            <summary>
            Verifies that a delegate throws an exception when called
            and returns it.
            </summary>
            <param name="code">A TestDelegate</param>
        </member>
        <member name="M:Loyc.MiniTest.Assert.DoesNotThrow(System.Action,System.String,System.Object[])">
            <summary>
            Verifies that a delegate does not throw an exception
            </summary>
            <param name="code">Code to run</param>
            <param name="message">The message that will be displayed on failure</param>
        </member>
        <member name="M:Loyc.MiniTest.Assert.DoesNotThrow(System.Action)">
            <summary>
            Verifies that a delegate does not throw an exception.
            </summary>
            <param name="code">Code to run</param>
        </member>
        <member name="M:Loyc.MiniTest.Assert.Contains(System.Object,System.Collections.IEnumerable,System.String,System.Object[])">
            <summary>
            Asserts that an object is contained in a list.
            </summary>
            <param name="expected">The expected object</param>
            <param name="actual">The list to be examined</param>
            <param name="message">The message to display in case of failure</param>
            <param name="args">Array of objects to be used in formatting the message</param>
        </member>
        <member name="M:Loyc.MiniTest.Assert.Contains(System.Object,System.Collections.IEnumerable)">
            <summary>
            Asserts that an object is contained in a list.
            </summary>
            <param name="expected">The expected object</param>
            <param name="actual">The list to be examined</param>
        </member>
        <member name="T:Loyc.MiniTest.RunTests">
            <summary>
            Searches for test methods and runs them, printing the name of each test to
            the console followed by errors (if any) produced by the test.
            </summary>
            <remarks>
            This class finds tests by looking for custom attributes by their string
            name (e.g. "TestAttribute"), so it is compatible with both NUnit.Framework
            and Loyc.MiniTest.
            <para/>
            RunTests is a stripped-down subset of the functionality supported by
            MiniTestRunner.
            </remarks>
        </member>
        <member name="M:Loyc.MiniTest.RunTests.Run(System.Object)">
            <summary>Runs all test methods on the given object (public methods 
            that have a TestAttribute).</summary>
            <returns>The number of tests that failed unexpectedly (where the 
            <see cref="P:Loyc.MiniTest.TestAttribute.Fails"/> property is unset).</returns>
        </member>
        <member name="M:Loyc.MiniTest.RunTests.RunMany(System.Object[])">
            <summary>Runs all tests in an array of test objects.</summary>
            <returns>The total number of tests that unexpectedly failed.</returns>
        </member>
        <member name="T:Loyc.Syntax.PrintHelpers">
            <summary>Static methods that help to print literals, such as 
            <see cref="M:Loyc.Syntax.PrintHelpers.EscapeCStyle(Loyc.UString,Loyc.Syntax.EscapeC)"/> which escapes special characters with backslashes.</summary>
        </member>
        <member name="M:Loyc.Syntax.PrintHelpers.HexDigitChar(System.Int32)">
            <summary>Gets the hex digit character for the specified value, 
            or '?' if the value is not in the range 0...15. Uses uppercase.</summary>
        </member>
        <member name="M:Loyc.Syntax.PrintHelpers.EscapeCStyle(Loyc.UString,Loyc.Syntax.EscapeC)">
            <summary>Escapes characters in a string using C style, e.g. the string 
            <c>"Foo\"\n"</c> maps to <c>"Foo\\\"\\\n"</c> by default.</summary>
        </member>
        <member name="M:Loyc.Syntax.PrintHelpers.EscapeCStyle(Loyc.UString,Loyc.Syntax.EscapeC,System.Char)">
            <summary>Escapes characters in a string using C style.</summary>
            <param name="flags">Specifies which characters should be escaped.</param>
            <param name="quoteType">Specifies a character that should always be 
            escaped (typically one of <c>' " `</c>)</param>
        </member>
        <member name="M:Loyc.Syntax.PrintHelpers.EscapeCStyle(System.Int32,System.Text.StringBuilder,Loyc.Syntax.EscapeC,System.Char)">
            <summary>Writes a character <c>c</c> to a StringBuilder, either as a normal 
            character or as a C-style escape sequence.</summary>
            <param name="flags">Specifies which characters should be escaped.</param>
            <param name="quoteType">Specifies a character that should always be 
            escaped (typically one of <c>' " `</c>)</param>
            <returns>true if an escape sequence was emitted, false if not.</returns>
            <remarks><see cref="F:Loyc.Syntax.EscapeC.HasLongEscape"/> can be used to force a 6-digit 
            unicode escape; this may be needed if the next character after this one 
            is a digit.</remarks>
        </member>
        <member name="M:Loyc.Syntax.PrintHelpers.IntegerToString(System.Int64,System.String,System.Int32,System.Int32,System.Char)">
            <summary>Converts an integer to a string, optionally with separator characters for readability.</summary>
            <param name="value">Integer to be converted</param>
            <param name="prefix">A prefix to insert before the number, but after the '-' sign, if any (e.g. "0x" for hex). Use "" for no prefix.</param>
            <param name="base">Number base (e.g. 10 for decimal, 2 for binary, 16 for hex). Must be in the range 2 to 36.</param>
            <param name="separatorInterval">Number of digits in a group</param>
            <param name="separatorChar">Digit group separator</param>
            <returns>The number as a string.</returns>
            <remarks>Example: <c>IntegerToString(-1234567, "0", 10, 3, '\'') == "-01'234'567"</c></remarks>
        </member>
        <member name="M:Loyc.Syntax.PrintHelpers.AppendIntegerTo(System.Text.StringBuilder,System.Int64,System.String,System.Int32,System.Int32,System.Char)">
            <summary>Same as <see cref="M:Loyc.Syntax.PrintHelpers.IntegerToString(System.Int64,System.String,System.Int32,System.Int32,System.Char)"/> 
            except that the target StringBuilder must be provided as a parameter.</summary>
            <param name="value">Integer to be converted</param>
            <param name="prefix">A prefix to insert before the number, but after the '-' sign, if any (e.g. "0x" for hex). Use "" for no prefix.</param>
            <param name="base">Number base (e.g. 10 for decimal, 2 for binary, 16 for hex). Must be in the range 2 to 36.</param>
            <param name="separatorInterval">Number of digits in a group (use 0 or less to disable digit separators)</param>
            <param name="separatorChar">Digit group separator</param>
            <returns>The target StringBuilder.</returns>
        </member>
        <member name="T:Loyc.Syntax.EscapeC">
            <summary>Flags to control <seealso cref="M:Loyc.Syntax.PrintHelpers.EscapeCStyle(Loyc.UString,Loyc.Syntax.EscapeC)"/>
            and the reverse operation in ParseHelpers.</summary>
        </member>
        <member name="F:Loyc.Syntax.EscapeC.Minimal">
            <summary>Only \r, \n, \0 and backslash are escaped.</summary>
        </member>
        <member name="F:Loyc.Syntax.EscapeC.Default">
            <summary>Default option for escaping</summary>
        </member>
        <member name="F:Loyc.Syntax.EscapeC.NonAscii">
            <summary>Escape ALL characters with codes above 127 as \xNN or \uNNNN</summary>
        </member>
        <member name="F:Loyc.Syntax.EscapeC.BackslashX">
            <summary>Use \xNN instead of \u00NN for characters 1-31 and 127-255</summary>
        </member>
        <member name="F:Loyc.Syntax.EscapeC.Control">
            <summary>Escape all characters with codes below 32, including \t</summary>
        </member>
        <member name="F:Loyc.Syntax.EscapeC.ABFV">
            <summary>Use \a \b \f and \v (rather than \xNN or \xNN)</summary>
        </member>
        <member name="F:Loyc.Syntax.EscapeC.DoubleQuotes">
            <summary>Escape double quotes as \"</summary>
        </member>
        <member name="F:Loyc.Syntax.EscapeC.SingleQuotes">
            <summary>Escape single quotes as \'</summary>
        </member>
        <member name="F:Loyc.Syntax.EscapeC.Quotes">
            <summary>Escape single and double quotes</summary>
        </member>
        <member name="F:Loyc.Syntax.EscapeC.UnicodeNonCharacters">
            <summary>Escape non-character unicode code points such as the Byte Order Mark 
            and unpaired surrogate pair characters.</summary>
        </member>
        <member name="F:Loyc.Syntax.EscapeC.UnicodePrivateUse">
            <summary>Escape unicode private-use code points.</summary>
        </member>
        <member name="F:Loyc.Syntax.EscapeC.HasEscapes">
            <summary>While unescaping, a backslash was encountered.</summary>
        </member>
        <member name="F:Loyc.Syntax.EscapeC.Unrecognized">
            <summary>While unescaping, an unrecognized escape was encountered .</summary>
        </member>
        <member name="F:Loyc.Syntax.EscapeC.HasLongEscape">
            <summary>While unescaping, a valid \u escape was encountered with more than 4 digits.
            To detect whether the value was above 0xFFFF, however, one must check the output.</summary>
        </member>
        <member name="F:Loyc.Syntax.EscapeC.HasInvalid6DigitEscape">
            <summary>While unescaping, a valid \u escape was encountered with 6 digits, but the
            number was more than 0x10FFFF and had to be treated as 5 digits to make it valid.</summary>
            <remarks>Always appears with HasLongEscape | HasEscapes</remarks>
        </member>
        <member name="T:Loyc.Threading.SavedValue`1">
            <summary>
            Designed to be used in a "using" statement to temporarily alter a 
            <see cref="T:Loyc.Threading.ThreadLocalVariable`1"/> or <see cref="T:Loyc.Holder`1"/>
            or something else implementing <see cref="T:Loyc.IHasMutableValue`1"/>.
            </summary>
        </member>
        <member name="T:Loyc.Threading.ThreadEx">
            <summary>Creates and controls a thread, and fills in a gap in the
            .NET framework by propagating thread-local variables from parent
            to child threads, and by providing a ThreadStarting event.</summary>
            <remarks>
            This class is a decorator for the Thread class and thus a 
            drop-in replacement, except that only the most common methods and
            properties (both static and non-static) are provided.
            <para/>
            .NET itself has no support whatsoever from inheriting thread-local 
            variables. Not only are thread locals not inherited from the parent
            thread, .NET fires no event when a thread starts and a child thread
            cannot get the thread ID of the thread that created it.
            <para/>
            ThreadEx helps work around this problem by automatically propagating
            <see cref="T:Loyc.Threading.ThreadLocalVariable`1"/> values, and providing the 
            <see cref="E:Loyc.Threading.ThreadEx.ThreadStarting"/> event, which blocks the parent thread but
            is called in the child thread. This only works if you use <see cref="T:Loyc.Threading.ThreadEx"/>
            to start the child thread; when using other mechanisms such as
            <see cref="T:System.Threading.Tasks.Task"/>, it is possible to copy thread-
            local variables from the parent thread using code like this:
            <code>
            int parentThreadId = Thread.CurrentThread.ManagedThreadId;
            var task = System.Threading.Tasks.Task.Factory.StartNew(() => {
            	using (ThreadEx.PropagateVariables(parentThreadId))
            		DoSomethingOnChildThread();
            });
            task.Wait();
            </code>
            Be careful, however: you should guarantee that, while you copy the 
            variables, the parent thread is blocked, or that the parent thread will not 
            modify any of them (which may be difficult since variables might exist that
            you are unaware of, that you do not control).
            <para/>
            TLV (thread-local variable) inheritance is needed to use the 
            <a href="http://www.codeproject.com/Articles/101411/DI-and-Pervasive-services">
            Ambient Service Pattern</a>
            </remarks>
        </member>
        <member name="E:Loyc.Threading.ThreadEx.ThreadStarting">
            <summary>
            This event is called in the context of a newly-started thread, provided
            that the thread is started by the Start() method of this class (rather
            than Thread.Start()).
            </summary>
            <remarks>The Start() method blocks until this event completes.</remarks>
        </member>
        <member name="E:Loyc.Threading.ThreadEx.ThreadStopping">
            <summary>
            This event is called when a thread is stopping, if the thread is stopping
            gracefully and provided that it was started by the Start() method of this 
            class (rather than Thread.Start()).
            </summary>
        </member>
        <member name="M:Loyc.Threading.ThreadEx.Start">
            <summary>
            Causes the operating system to change the state of the current instance to
            System.Threading.ThreadState.Running.
            </summary>
        </member>
        <member name="M:Loyc.Threading.ThreadEx.Start(System.Object)">
            <summary>
            Causes the operating system to change the state of the current instance to
            System.Threading.ThreadState.Running. Start() does not return until the
            ThreadStarted event is handled.
            </summary><remarks>
            Once the thread terminates, it CANNOT be restarted with another call to Start.
            </remarks>
        </member>
        <member name="T:Loyc.Threading.ThreadEx.ThreadDestructor">
            <summary>See <see cref="M:Loyc.Threading.ThreadEx.PropagateVariables(System.Int32)"/> for more information.</summary>
        </member>
        <member name="M:Loyc.Threading.ThreadEx.PropagateVariables(System.Int32)">
            <summary>
            Manually initializes <see cref="T:Loyc.Threading.ThreadLocalVariable`1"/> objects in a
            thread that may not have been started via ThreadEx, propagating values
            from the parent thread. Returns an object for uninitializing the thread.
            </summary>
            <param name="parentThreadId">Id of parent thread. The .NET framework
            does not make this information available so you must somehow pass this 
            value manually from the parent thread to the child thread.</param>
            <returns>An object to be disposed at the end of the thread. This method
            can be called in a using statement so that this happens automatically:
            <c>using(ThreadEx.PropagateVariables(parentThreadId)) { ... }</c>. It is
            important to dispose the returned object so that thread-local values can
            be released to prevent a memory leak.
            </returns>
            <remarks>It is safe to call this method if the thread has already been
            initialized. In that case, the thread will not be initialized a second 
            time, and the returned value will do nothing when it is disposed.
            <para/>
            Be careful with this method: you should guarantee that, while you copy the 
            variables, the parent thread is blocked, or that the parent thread will not 
            modify any of them during the copying process (which may be difficult 
            since variables might exist that you are unaware of, that you do not 
            control).
            </remarks>
        </member>
        <member name="P:Loyc.Threading.ThreadEx.CurrentThread">
            <summary>
            Gets the currently running thread.
            </summary>
        </member>
        <member name="P:Loyc.Threading.ThreadEx.IsBackground">
            <summary>
            Gets or sets a value indicating whether or not a thread is a background thread.
            </summary>
        </member>
        <member name="P:Loyc.Threading.ThreadEx.ManagedThreadId">
            <summary>
            Gets a unique identifier for the current managed thread.
            </summary>
        </member>
        <member name="P:Loyc.Threading.ThreadEx.Name">
            <summary>
            Gets or sets the name of the thread.
            </summary>
        </member>
        <member name="P:Loyc.Threading.ThreadEx.Priority">
            <summary>
            Gets or sets a value indicating the scheduling priority of a thread.
            </summary>
        </member>
        <member name="P:Loyc.Threading.ThreadEx.ThreadState">
            <summary>
            Gets a value containing the states of the current thread.
            </summary>
        </member>
        <member name="M:Loyc.Threading.ThreadEx.Abort(System.Object)">
            <summary>
            Raises a System.Threading.ThreadAbortException in the thread on which it
            is invoked, to begin the process of terminating the thread while also providing
            exception information about the thread termination. Calling this method usually
            terminates the thread.
            </summary>
        </member>
        <member name="M:Loyc.Threading.ThreadEx.Abort">
            <inheritdoc cref="M:Loyc.Threading.ThreadEx.Abort"/>
        </member>
        <member name="M:Loyc.Threading.ThreadEx.GetDomain">
            <summary>
            Returns the current domain in which the current thread is running.
            </summary>
        </member>
        <member name="M:Loyc.Threading.ThreadEx.GetHashCode">
            <summary>
            Returns a hash code for the current thread.
            </summary>
        </member>
        <member name="M:Loyc.Threading.ThreadEx.Join">
            <summary>
            Blocks the calling thread until a thread terminates, while continuing to
            perform standard COM and SendMessage pumping.
            </summary>
        </member>
        <member name="M:Loyc.Threading.ThreadEx.Join(System.Int32)">
            <summary>
            Blocks the calling thread until a thread terminates or the specified time 
            elapses, while continuing to perform standard COM and SendMessage pumping. 
            </summary>
        </member>
        <member name="M:Loyc.Threading.ThreadEx.Sleep(System.Int32)">
            <summary>
            Suspends the current thread for a specified time.
            </summary>
        </member>
        <member name="T:Loyc.Threading.ThreadStartEventArgs">
            <summary>Used by the <see cref="E:Loyc.Threading.ThreadEx.ThreadStarting"/> and <see cref="E:Loyc.Threading.ThreadEx.ThreadStopping"/> events.</summary>
        </member>
        <member name="T:Loyc.Threading.TinyReaderWriterLock">
            <summary>
            A fast, tiny 4-byte lock to support multiple readers or a single writer.
            Designed for low-contention, high-performance scenarios where reading is 
            common and writing is rare.
            </summary>
            <remarks>
            Do not use the default constructor! Use TinyReaderWriterLock.New as the
            initial value of the lock.
            <para/>
            Recursive locking is not supported: the same lock cannot be acquired twice 
            for writing on the same thread, nor can a reader lock be acquired after 
            the writer lock was acquired on the same thread. If you make either of 
            these mistakes, the lock will throw an NotSupportedException.
            <para/>
            You also cannot acquire a read lock followed recursively by a write lock,
            either. Attempting to do so will self-deadlock the thread, bacause 
            TinyReaderWriterLock does not track the identity of each reader and is not
            aware that it is waiting for the current thread to finish reading.
            <para/>
            However, multiple reader locks can be acquired on the same thread, just as
            multiple reader locks can be acquired by different threads.
            <para/>
            Make sure you call ExitRead() or ExitWrite() in a finally block! When 
            compiled in debug mode, TinyReaderWriterLock will make sure you don't mix
            up ExitRead() and ExitWrite().
            <para/>
            The range of Thread.CurrentThread.ManagedThreadId is undocumented. I have
            assumed they don't use IDs close to int.MinValue, so I use values near
            int.MinValue to indicate the number of readers holding the lock.
            </remarks>
        </member>
        <member name="M:Loyc.Threading.TinyReaderWriterLock.EnterReadLock">
            <summary>Acquires the lock to protect read access to a shared resource.</summary>
        </member>
        <member name="M:Loyc.Threading.TinyReaderWriterLock.ExitReadLock">
            <summary>Releases a read lock that was acquired with EnterRead().</summary>
        </member>
        <member name="M:Loyc.Threading.TinyReaderWriterLock.EnterWriteLock">
            <summary>Acquires the lock to protect write access to a shared resource.</summary>
        </member>
        <member name="M:Loyc.Threading.TinyReaderWriterLock.EnterWriteLock(System.Int32)">
            <summary>Acquires the lock to protect write access to a shared resource.</summary>
            <param name="threadID">Reports the value of Thread.CurrentThread.ManagedThreadId</param>
        </member>
        <member name="M:Loyc.Threading.TinyReaderWriterLock.ExitWriteLock">
            <summary>Releases a write lock that was acquired with EnterWrite().</summary>
        </member>
        <member name="T:Loyc.Threading.ThreadLocalVariableBase">
            <summary>When used with ThreadEx, implementing this base class allows you to 
            be notified when a child thread is created or terminates.</summary>
        </member>
        <member name="T:Loyc.Threading.ThreadLocalVariable`1">
            <summary>Provides access to a thread-local variable through a dictionary 
            that maps thread IDs to values.</summary>
            <typeparam name="T">Type of variable to wrap</typeparam>
            <remarks>
            Note: this was written before .NET 4 (which has ThreadLocal{T}). Unlike
            <see cref="T:System.Threading.ThreadLocal`1"/>, this class supports propagation from parent
            to child threads when used with <see cref="T:Loyc.Threading.ThreadEx"/>.
            <para/>
            This class exists to solve two problems. First, the [ThreadStatic] 
            attribute is not supported in the .NET Compact Framework. Second, and
            more importantly, .NET does not propagate thread-local variables when 
            creating new threads, which is a huge problem if you want to implement
            the <a href="http://loyc-etc.blogspot.com/2010/08/pervasive-services-and-di.html">
            Ambient Service Pattern</a>. This class copies the T value from a parent
            thread to a child thread, but because .NET provides no way to hook into
            thread creation, it only works if you use <see cref="T:Loyc.Threading.ThreadEx"/> instead 
            of standard threads.
            <para/>
            TODO: figure out how to support .NET's ExecutionContext
            <para/>
            ThreadLocalVariable implements thread-local variables using a dictionary 
            that maps thread IDs to values.
            <para/>
            Variables of this type are typically static and they must NOT be marked
            with the [ThreadStatic] attribute.
            <para/>
            ThreadLocalVariable(of T) is less convenient than the [ThreadStatic]
            attribute, but ThreadLocalVariable works with ThreadEx to propagate the 
            value of the variable from parent threads to child threads, and you can
            install a propagator function to customize the way the variable is 
            copied (e.g. in case you need a deep copy).
            <para/>
            Despite my optimizations, ThreadLocalVariable is just over half as fast 
            as a ThreadStatic variable in CLR 2.0, in a test with no thread 
            contention. Access to the dictionary accounts for almost half of the 
            execution time; try-finally (needed in case of asyncronous exceptions) 
            blocks use up 11%; calling Thread.CurrentThread.ManagedThreadId takes 
            about 9%; and the rest, I presume, is used up by the TinyReaderWriterLock.
            <para/>
            TODO: consider switching from TinyReaderWriterLock+Dictionary to 
            ConcurrentDictionary which has fine-grained locking (.NET 4 only).
            </remarks>
        </member>
        <member name="M:Loyc.Threading.ThreadLocalVariable`1.#ctor(`0,System.Boolean)">
            <summary>Constructs a ThreadLocalVariable.</summary>
            <param name="initialValue">Initial value on the current thread;
            also used as the FallbackValue in threads that are not created
            via ThreadEx and in other threads that are already running.</param>
            <param name="autoFallback">Sets the <see cref="P:Loyc.Threading.ThreadLocalVariable`1.AutoFallbackMode"/> property</param>
        </member>
        <member name="M:Loyc.Threading.ThreadLocalVariable`1.#ctor(`0,`0,System.Func{`0,`0})">
            <summary>Constructs a ThreadLocalVariable.</summary>
            <param name="initialValue">Initial value on the current thread. 
            Does not affect other threads that are already running.</param>
            <param name="fallbackValue">Value to use when a given thread 
            doesn't have an associated value.</param>
            <param name="propagator">A function that copies (and possibly 
            modifies) the Value from a parent thread when starting a new 
            thread.</param>
        </member>
        <member name="P:Loyc.Threading.ThreadLocalVariable`1.Value">
            <summary>Value of the thread-local variable.</summary>
            <remarks>
            This property returns FallbackValue if no value exists for this thread.
            </remarks>
        </member>
        <member name="P:Loyc.Threading.ThreadLocalVariable`1.FallbackValue">
            <summary>
            When a thread is not created using ThreadEx, the value of your
            ThreadLocalVariable fails to propagate from the parent thread to the 
            child thread. In that case, Value takes on the value of FallbackValue
            the first time it is called.
            </summary>
            <remarks>
            By default, the FallbackValue is the initialValue passed to the 
            constructor.
            </remarks>
        </member>
        <member name="P:Loyc.Threading.ThreadLocalVariable`1.AutoFallbackMode">
            <summary>Returns true if this variable was created in "auto-fallback" 
            mode, which means that setting the <see cref="P:Loyc.Threading.ThreadLocalVariable`1.Value"/> property will 
            simultaneously set the <see cref="P:Loyc.Threading.ThreadLocalVariable`1.FallbackValue"/> to the same value 
            at the same time.</summary>
        </member>
        <member name="T:Loyc.StringExt">
            <summary>Extension methods for strings, such as <see cref="M:Loyc.StringExt.SplitAt(System.String,System.Char)"/>, 
            <see cref="M:Loyc.StringExt.Left(System.String,System.Int32)"/>, <see cref="M:Loyc.StringExt.Right(System.String,System.Int32)"/>, <see cref="M:Loyc.StringExt.FormatCore(System.String,System.Object[])"/> and <see cref="M:Loyc.StringExt.Slice(System.String,System.Int32,System.Int32)"/>.</summary>
        </member>
        <member name="M:Loyc.StringExt.WithoutPrefix(System.String,System.String)">
            <summary>Returns a version of the string without the specified prefix.
            If the string does not have the specified prefix, it is returned unchanged.
            The prefix check is case-sensitive.</summary>
        </member>
        <member name="M:Loyc.StringExt.WithoutSuffix(System.String,System.String)">
            <summary>Returns a version of the string without the specified suffix.
            If the string does not have the specified suffix, it is returned unchanged.
            The suffix check is case-sensitive.</summary>
        </member>
        <member name="M:Loyc.StringExt.SplitAt(System.String,System.Char)">
            <summary>Gets the substrings to the left and right of a dividing character.</summary>
            <param name="s">String to split</param>
            <param name="delimiter">Dividing character.</param>
            <returns>Returns the string to the left and to the right of the
            first occurance of 'c' in the string, not including 'c' itself.
            If 'c' was not found in 's', the pair (s, null) is returned.</returns>
        </member>
        <member name="M:Loyc.StringExt.Right(System.String,System.Int32)">
            <summary>Returns the rightmost 'count' characters of 's', or s itself if count > s.Length.</summary>
        </member>
        <member name="M:Loyc.StringExt.Left(System.String,System.Int32)">
            <summary>Returns the leftmost 'count' characters of 's', or s itself if count > s.Length.</summary>
        </member>
        <member name="M:Loyc.StringExt.SafeSubstring(System.String,System.Int32,System.Int32)">
            <summary>A variation on String.Substring() that never throws.</summary>
            <remarks>This is best explained by examples:
            <example>
            "Hi everybody!".SafeSubstring(8, 500) == "body!"
            "Hi everybody!".SafeSubstring(-3, 5) == "Hi"
            "Hi everybody!".SafeSubstring(-5, 5) == ""
            "Hi everybody!".SafeSubstring(8, -5) == ""
            "Hi everybody!".SafeSubstring(500, 8) == ""
            "Hi everybody!".SafeSubstring(int.MinValue + 500, int.MaxValue) == "Hi everybody!"
            ((string)null).SafeSubstring(0, 1) == null
            </example>
            </remarks>
        </member>
        <member name="M:Loyc.StringExt.Join(System.String,System.Collections.IEnumerable)">
            <summary>Converts a series of values to strings, and concatenates them 
            with a given separator between them.</summary>
            <example>Join(" + ", new[] { 1,2,3 }) returns "1 + 2 + 3".</example>
            <remarks>This method (but taking IEnumerable{T}) exists in the BCL starting in .NET 4</remarks>
        </member>
        <member name="M:Loyc.StringExt.Join(System.String,System.Collections.IEnumerator)">
            <inheritdoc cref="M:Loyc.StringExt.Join(System.String,System.Collections.IEnumerable)"/>
        </member>
        <member name="M:Loyc.StringExt.FormatCore(System.String,System.Object[])">
            <summary>
            This formatter works like string.Format, except that named 
            placeholders accepted as well as numeric placeholders. This method
            replaces named placeholders with numbers, then calls string.Format.
            </summary>
            <remarks>
            Named placeholders are useful for communicating information about a
            placeholder to a human translator. Here is an example:
            <code>
            Not enough memory to {load/parse} '{filename}'.
            </code>
            In some cases a translator might have difficulty translating a phrase
            without knowing what a numeric placeholder ({0} or {1}) refers to, so 
            a named placeholder can provide an important clue. The localization  
            system is invoked as follows:
            <code>
            string msg = "{man's name} meets {woman's name}.".Localized(
            	"man's name", mansName, "woman's name", womansName);
            </code>
            The placeholder names are not case sensitive.
            
            You can use numeric placeholders, alignment and formatting codes also:
            <code>
            string msg = "You need to run {dist,6:###.00} km to reach {0}".Localized(
            	cityName, "dist", 2.9);
            </code>
            It is assumed that the placeholder name ends at the first comma or colon; 
            hence the placeholder in this example is called "dist", not "dist,6:###.00".
            <para/>
            Typically, the named arguments are expected to start at index N+1 in the 
            variable argument array, where {N} is the largest numeric placeholder, and 
            if there are no numeric placeholders then the named arguments should begin 
            at index 0. In this example there is a {0}, so the named arguments should
            start at index 1. However, since named arguments always come in pairs, an 
            extra rule increments the N if the number of remaining arguments starting
            at N is not an even number. For example, in
            <code>
            string msg = "Hello {0}, you'll go to {school name} next year.".Localized(
            	firstName, lastName, "school name", schoolName);
            </code>
            There are three args left after the numeric ones, so the first remaining
            argument is ignored to make it an even number.
            <para/>
            If a placeholder name is not found in the argument list then it is not
            replaced with a number before the call to string.Format, so a 
            FormatException will occur.
            </remarks>
        </member>
        <member name="M:Loyc.StringExt.EliminateNamedArgs(System.String,System.Object[])">
            <summary>Called by Format to replace named placeholders with numeric
            placeholders in format strings.</summary>
            <returns>A format string that can be used to call string.Format.</returns>
            <seealso cref="M:Loyc.StringExt.FormatCore(System.String,System.Object[])"/>
        </member>
        <member name="T:Loyc.Triplet`3">
            <summary>A tuple of three values (<c>A</c>, <c>B</c> and <c>C</c>) in a struct.</summary>
            <remarks>
            For compatibility with <see cref="T:System.Tuple`3"/>, it has <c>Item1</c>, 
            <c>Item2</c> and <c>Item3</c> properties, which refer to the A, B and 
            C fields, respectively.
            </remarks>
        </member>
        <member name="T:Loyc.ValueComparer`1">
            <summary>You'd think the .NET framework would have a built-in method--even
            a CIL opcode--to bitwise-compare two values. Not supporting bitwise compare
            is, in my opinion, one of several mind-bogglingly dumb decisions in the
            CLR. Instead, all you can do is call ValueComparer.Default.Equals(a, b).
            </summary>
            <remarks>
            The Default.Equals method is a virtual function call, but as far as I know,
            in generic code there is no way to avoid this while supporting any type T.
            <para/>
            If T is a reference type, it compares the two references using
            ReferenceComparer. If T is a struct then this class does not currently
            perform a bitwise comparison, as it just uses EqualityComparer(T).Default.
            In the future somebody should write a fast "unsafe" bitwise comparer for 
            value types that do not implement IEquatable, because the default 
            implementation of Equals is documented to use reflection, so we can expect 
            that it is extremely slow.
            </remarks>
        </member>
        <member name="T:Loyc.ReferenceComparer`1">
            <summary>An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> based on reference equality</summary>
        </member>
        <member name="T:Loyc.WeakReferenceExt">
            <summary>The new <see cref="T:System.WeakReference`1"/> type in .NET 4.5 removes
            the <c>Target</c> and <c>IsAlive</c> properties. These extension methods 
            restore that traditional functionality, making it easier to transition
            from the old <c>WeakReference</c> to the new one.</summary>
        </member>
        <member name="T:Loyc.WrapperBase`1">
            <summary>Abstract class that helps you implement wrappers by automatically
            forwarding calls to Equals(), GetHashCode() and ToString().</summary>
        </member>
        <member name="M:Loyc.WrapperBase`1.Equals(System.Object)">
            <summary>Returns true iff the parameter 'obj' is a wrapper around the same object that this object wraps.</summary>
            <param name="obj">The object to compare with the current object.</param>
            <remarks>If obj actually refers to the wrapped object, this method returns false to preserve commutativity of the "Equals" relation.</remarks>
        </member>
        <member name="M:Loyc.WrapperBase`1.GetHashCode">
            <summary>Returns the hashcode of the wrapped object.</summary>
        </member>
        <member name="M:Loyc.WrapperBase`1.ToString">
            <summary>Returns ToString() of the wrapped object.</summary>
        </member>
        <member name="T:Loyc.void">
            <summary><c>@void.Value</c> represents the sole value of <c>System.Void</c>
            (called "void" in C#).</summary>
            <remarks>.NET unfortunately treats void as something that is not a real 
            type; for example you cannot use <c>new void()</c> or <c>default(void)</c>
            in C#. This was a dumb decision because it means that some generic code
            must be duplicated for void and non-void types. A good example is the fact
            that when you have a <see cref="T:System.Collections.Generic.Dictionary`2"/>, TVal cannot be 
            void, so you cannot use <c>Dictionary(string,void)</c> to express the idea 
            of "a set of strings with no associated values". The <see cref="T:System.Collections.Generic.HashSet`1"/> 
            class uses a completely separate implementation and cannot just be an
            alias for <c>Dictionary{T,void}</c> (actually they could share 
            implementations using a dummy type like this one, but unfortunately .NET
            made another dumb decision that all types must consume at least one byte,
            so <c>HashSet</c> sharing code with <c>Dictionary</c> would make 
            <c>HashSet</c> less efficient.)
            <para/>
            Defining a @void type allows you to use it when it makes conceptual sense,
            although we cannot avoid .NET's requirement to waste at least one byte.
            </remarks>
        </member>
    </members>
</doc>
