using Loyc;
using Loyc.Collections;
using Loyc.Collections.Impl;
using Loyc.SyncLib.Impl;
using Loyc.Collections.MutableListExtensionMethods;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Diagnostics.CodeAnalysis;
using System.Numerics;
using System.Reflection;

#nullable enable

//##unroll(($T, $Capitalized) in ((byte, Byte), (char, Char), (bool, Bool), (bool, Bool)
//[Passive] define NameWithType($Prefix, byte, $(..Suffix)) { concatId($Prefix, Byte, $(..Suffix)); }
//[Passive] define NameWithType($Prefix, char, $(..Suffix)) { concatId($Prefix, Char, $(..Suffix)); }
//[Passive] define NameWithType($Prefix, bool, $(..Suffix)) { concatId($Prefix, Bool, $(..Suffix)); }
//[Passive] define NameWithType($Prefix, bool, $(..Suffix)) { concatId($Prefix, Bool, $(..Suffix)); }
macro NameWithType($Prefix, $prim, $(..Suffix)) {
	string capitalized;
	matchCode(prim) {
		case bool:    capitalized = "Bool";
		case char:    capitalized = "Char";
		case sbyte:   capitalized = "SByte";
		case byte:    capitalized = "Byte";
		case short:   capitalized = "Short";
		case ushort:  capitalized = "UShort";
		case int:     capitalized = "Int";
		case uint:    capitalized = "UInt";
		case long:    capitalized = "Long";
		case ulong:   capitalized = "ULong";
		case float:   capitalized = "Float";
		case double:  capitalized = "Double";
		case decimal: capitalized = "Decimal";
		case string:  capitalized = "String";
		// This case matches type `string?` (the syntax `string?` is not accepted in this context)
		case @`'of`(@`'?`, string): capitalized = "String";
		case BigInteger: capitalized = prim.Name.Name;
		default:
			return null;
	}
	return quote(concatId($Prefix, $(LNode.Id(capitalized, prim)), $(..Suffix)));
}

namespace Loyc.SyncLib
{
	public delegate T SyncObjectFunc<in SyncManager, T>(SyncManager sync, [AllowNull] T value);
	public delegate T SyncFieldFunc<T>(FieldId name, [AllowNull] T value);

	// in certain cases it is not possible to directly use a type in a 
	// location where an expression is expected, either because the type 
	// is not a valid expression (e.g. `int?` is not a valid expression) 
	// or because the syntax tree of the type is different from the syntax 
	// tree of an expression that looks just like it. Because of this, when 
	// you want to use a type in a context where an expression was expected,
	// it is sometimes necessary to use this macro to indicate that a type 
	// was intended. For example, `Foo[]` is not considered to be an array;
	// it is considered to be a call to an indexer with no arguments. 
	// However, `#type<Foo[]>` is considered to be an array of `Foo`.
	[Passive]
	define (#type<$T>) { $T; }

	// Primitive types that a synchronizer must support "out of the box"
	define basicTypes => #splice(bool, sbyte, byte, short, ushort, int, uint, long, ulong, float, double, decimal, BigInteger, char);

	define standardTypes => #splice(bool, sbyte, byte, short, ushort, int, uint, long, ulong, float, double, decimal, BigInteger, char, #type<string? >);

	// Bitfield types include a size-in-bits parameter and a signedness boolean
	define bitfieldTypes => #splice(int, long, BigInteger);

	/// <summary>This is the central interface of Loyc.SyncLib. To learn more, please 
	/// visit the web site: http://loyc.net/serialization </summary>
	/// <remarks>
	/// Note: it is recommended (but not required) that Sync() methods in reader 
	/// implementations support the following implicit type conversions:
	/// <ul>
	/// <li>Boolean to byte (false => 0, true => 1)</li>
	/// <li>Byte to integer</li>
	/// <li>Integer to Float</li>
	/// <li>Float to String</li>
	/// <li>Char to String</li>
	/// </ul>
	/// </remarks>
	public interface ISyncManager
	{
		/// <summary>Indicates what kind of synchronizer this is: one that saves
		/// data, one that loads data, or one that saves a schema.</summary>
		SyncMode Mode { get; }
		
		/// <summary>Returns true if the current <see cref="Mode"/> is 
		/// <see cref="SyncMode.Reading"/>, <see cref="SyncMode.Schema"/> or 
		/// <see cref="SyncMode.Merge"/>. If your synchronizer method behaves 
		/// differently when it is loading than when it is saving, it's often
		/// more appropriate to get this property rather than testing whether 
		/// <c>Mode == SyncMode.Loading</c>, because if the current mode is 
		/// Schema or Merge, your synchronizer method should do most of its 
		/// "loading" behavior.</summary>
		bool IsReading { get; }

		/// <summary>Returns true if the current <see cref="Mode"/> is 
		/// <see cref="SyncMode.Writing"/>, <see cref="SyncMode.Query"/> or 
		/// <see cref="SyncMode.Merge"/>. If your synchronizer method behaves 
		/// differently when it is loading than when it is saving, you should
		/// almost always get this property rather than testing whether 
		/// <c>Mode == SyncMode.Saving</c>, because if the current mode is 
		/// Query or Merge, your synchronizer method should usually do the same
		/// thing it does when saving.</summary>
		bool IsWriting { get; }

		/// <summary>Indicates that the serialized format has some kind of schema that 
		///   enables fields to be read in a different order than they were written
		///   (e.g. JSON, Protobuf). If this field is false, fields must be read in
		///   the same order they were written, and omitting fields is not allowed
		///   (e.g. you cannot skip over a null field without saving it, nor skip
		///   over a field and then read it later).</summary>
		/// <remarks>If this property is false, the data may not have any recorded 
		///   structure, and failure to read the correct fields in the correct order 
		///   tends to give you "garbage" results.
		///   <para/>
		///   This property should be false for incomplete reader implementations in
		///   which the data format can support reordering physically, but the reader 
		///   does not.
		/// </remarks>
		bool SupportsReordering { get; }

		/// <summary>Indicates that this implementation of <see cref="ISyncManager"/>
		///   supports the <see cref="NextField"/> property. (This property must be
		///   false when <see cref="IsReading"/> is false.)</summary>
		/// <remarks>All implementations where <see cref="SupportsReordering"/> is 
		///   true should also return true for this property.</remarks>
		bool SupportsNextField { get; }

		/// <summary>Returns true if the <see cref="ISyncManager"/> supports 
		/// deduplication of objects and cyclic object graphs. Note: all standard 
		/// implementations of this interface do support deduplication and cyclic
		/// object graphs.</summary>
		bool SupportsDeduplication { get; }

		/// <summary>Indicates that the properties of the current sub-object do not
		/// have names because the basic <see cref="ObjectMode"/> is either
		/// <see cref="ObjectMode.Tuple"/> or <see cref="ObjectMode.List"/>.
		/// In this case, <see cref="SupportsReordering"/> is irrelevant, since 
		/// fields do not have names or ID numbers.</summary>
		bool IsInsideList { get; }

		/// <summary>Indicates that the serialized format uses field ID numbers rather 
		/// than field names (e.g. Protocol Buffers). When using strings or global 
		/// symbols, the ID is indicated implcitly via field order: the first field 
		/// read or written has ID=1, the second has ID=2, etc. If you need to 
		/// customize the field numbers, you can do so by creating a private 
		/// <see cref="Loyc.SymbolPool"/> and creating symbols with custom ID numbers.
		/// </summary>
		bool NeedsIntegerIds { get; }

		/// <summary>
		///   This is a low-level property that most code should not call directly.
		///   If a list is being scanned and the current object can detect
		///   the end of the list (e.g. the mode is <see cref="SyncMode.Loading"/> and
		///   BeginSubObject returned a length of int.MaxValue), this property returns 
		///   a boolean value: true at the end of the list and false otherwise. In all 
		///   other cases, null is returned.</summary>
		/// <remarks>
		/// <ul>
		/// <li>In Loading mode, the manager may detect when the end of the list is 
		///     reached (e.g. in JSON it looks for a closing brace '}'), so true or 
		///     false is returned if a list is being scanned. However, in certain data
		///     formats (e.g. SyncBinary) the data stream uses a length prefix at the 
		///     beginning of the list and doesn't contain a clear indication when the 
		///     list ends, so BeginSubObject returns the Length and this property 
		///     returns null.</li>
		/// <li>In Saving mode, the caller knows the list length but the manager does 
		///     not, so this property always returns null.</li>
		/// <li>In Schema mode, no list actually exists, but the manager typically 
		///     pretends that the list's length is 1.</li>
		/// <li>In Query mode, the manager doesn't know the list length but it may 
		///     have a maximum list length. In this case, this property returns
		///     null at the beginning, then true when the limit is reached.</li>
		/// <li>In Merge mode... this needs some thought; TODO</li>
		/// </ul>
		/// </remarks>
		bool? ReachedEndOfList { get; }

		/// <summary>If a variable-length list is being scanned in Loading mode, this 
		/// property returns either the list length (if known) or the minimum list 
		/// length (if the total length is not known before reading the list).
		/// This property is null in Saving mode, or when a variable-length list is not 
		/// being scanned.</summary>
		/// <remarks>
		/// Some data formats use length-prefixed lists, in which case the list length 
		/// is known from the begining. Other formats (such as JSON) use a delimiter to 
		/// mark the end of the list, so the list length is not known until the end
		/// is reached. In that case, this property should return 0.
		/// </remarks>
		int? MinimumListLength { get; }

		/// <summary>Returns the number of objects for which <see cref="BeginSubObject"/>
		///   opened an object, list or tuple that was not closed <see cref="EndSubObject"/>.
		///   This property is zero if <see cref="BeginSubObject"/> was never called to 
		///   start a subobject.</summary>
		/// <remarks>
		///   If you use a helper method designed to write a single object, such as 
		///   <see cref="SyncJson.Write{T, SyncObject}(T, SyncObject, SyncJson.Options?)"/>
		///   or <see cref="SyncBinary.Write{T, SyncObject}(T, SyncObject, SyncBinary.Options?)"/>,
		///   these helper methods call <see cref="BeginSubObject"/> so the Depth will be 
		///   1 inside the synchronizer for your root object.
		/// <para/>
		///   Typically it is allowed, but not recommended, to write fields at depth 0. 
		///   For example, this code writes two JSON primitives at depth 0:
		/// <pre><![CDATA[
		///     var writer = SyncJson.NewWriter();
		///     writer.Sync("a", 1234.5);
		///     writer.Sync("b", "Hello\t!");
		///     
		///     var output = (ArrayBufferWriter<byte>) writer.Flush();
		///     Console.WriteLine(Encoding.UTF8.GetString(output.WrittenSpan));
		///     Console.WriteLine();
		///     
		///     // Read the data that was just written
		///     var reader = SyncJson.NewReader(output.WrittenMemory);
		///     var a = reader.Sync(null, 0.0);
		///     var b = reader.Sync(null, "");
		///     Console.WriteLine($"a = {a}, b = {b}");
		/// ]]></pre>
		///   The output is pseudo-JSON, formatted like a list without square brackets:
		///   <pre>
		///   1234.5,
		///   "Hello\t!"
		///   </pre>
		///   Officially this is not valid JSON, but as the example shows, it is understood 
		///   by <see cref="SyncJson.Reader"/> which successfully reads it back:
		///   <pre>
		///   a = 1234.5, b = Hello	!
		///   </pre>
		/// </remarks>
		int Depth { get; }

		/// <summary>If <see cref="SupportsNextField"/> is true, the end of the current
		///   object has not been reached, and <see cref="IsInsideList"/> is false, 
		///   this property returns the name or integer ID of the next field in the 
		///   input stream. Otherwise, it returns <see cref="FieldId.Missing"/>.</summary>
		/// <remarks>
		///   Even if a data stream supports reordering (<see cref="SupportsReordering"/>),
		///   it may be inefficient to read fields out-of-order. Therefore, if your
		///   code wants to read as efficiently as possible, and it expects to receive
		///   data out of order, it can use this property to read the fields in the order 
		///   they appear. Another reason you might read data this way is if you expect
		///   to read an extremely large object (e.g. 1 GB or more) and you want to avoid
		///   the extra memory allocations that occur when reading data out of order.
		///   <para/>
		///   Here is an example:
		///   <example>
		///       public MyObject Sync(ISyncManager sm, MyObject? obj)
		///       {
		///           obj ??= new MyObject();
		///           if (!sm.SupportsNextField || sm.NeedsIntegerIds) {
		///               // Synchronize in the normal way
		///               obj.Field1 = sm.Sync("Field1", obj.Field1);
		///               obj.Field2 = sm.Sync("Field2", obj.Field2);
		///               obj.Field3 = sm.Sync("Field3", obj.Field3);
		///           } else {
		///               // Synchronize fields in the order they appear in the input.
		///               FieldId name;
		///               while ((name = sm.NextField) != FieldId.Missing) {
		///                   if (name.Name == "Field1") {
		///                       obj.Field1 = sm.Sync(null, obj.Field1);
		///                   } else if (name.Name == "Field2") {
		///                       obj.Field2 = sm.Sync(null, obj.Field2);
		///                   } else if (name.Name == "Field3") {
		///                       obj.Field3 = sm.Sync(null, obj.Field3);
		///                   } else {
		///                       throw new Exception("Unexpected field: " + name.Name);
		///                   }
		///               }
		///           }
		///           return obj;
		///       }
		///   </example>
		///   <b>Warning</b>: some readers support name conversion, so that the name 
		///   passed to the Sync methods is not the same as the name used in the data 
		///   stream. For example, when <see cref="SyncJson.Options.NameConverter"/> 
		///   is <see cref="SyncJson.ToCamelCase"/>, a name like "Field1" is stored 
		///   as "field1". But NextField may report the actual string from the 
		///   datastream ("field1") which will cause code written this way to fail.
		///   If the camelcase conversion is the only one you intend to support, you
		///   can work around this problem in your synchronizer with uppercase 
		///   comparisons:
		///   <para/>
		///       string? name;
		///       while ((name = sm.NextField.Name?.ToUpperInvariant()) != null) {
		///           if (name == "FIELD1") {
		///               obj.Field1 = sm.Sync(null, obj.Field1);
		///           } else if (name == "FIELD2") {
		///               obj.Field2 = sm.Sync(null, obj.Field2);
		///           } else if (name == "FIELD3") {
		///               obj.Field3 = sm.Sync(null, obj.Field3);
		///           } else {
		///               throw new Exception("Unexpected field: " + name);
		///           }
		///       }
		///   <para/>
		///   However, this workaround reduces the performance advantage of reading 
		///   fields in order.
		///   <para/>
		///   There are three other things worth noticing about this example.
		///   <para/>
		///   First, this example is only designed to support string field names, so it
		///   checks the <see cref="NeedsIntegerIds"/> property and falls back on the
		///   "normal" synchronization style if it is true. You also need a block of
		///   "normal" synchronization code when writing an object to an output stream.
		///   <para/>
		///   Second, notice that this style of reading also allows you to detect
		///   unexpected field names and respond to them (in this example, an exception
		///   is thrown when an unexpected field is encountered).
		///   <para/>
		///   Third, notice the use of null field names (sm.Sync(null, ...)). This is
		///   how you ask <see cref="ISyncManager"/> to synchronize the next field
		///   without regard for the name of that field.
		///   <para/>
		///   Another potential use of this property is to save or load a string 
		///   dictionary:
		///   <example><![CDATA[
		///   public IDictionary<string, string?> Sync(
		///          ISyncManager sm, IDictionary<string, string?>? dict)
		///   {
		///       dict ??= new Dictionary<string, string?>();
		///       if (sm.IsReading) {
		///           if (!sm.SupportsNextField || sm.NeedsIntegerIds || sm.IsWriting)
		///               throw new NotSupportedException(
		///                   "StringDictionarySync is incompatible with this " + sm.GetType().Name);
		///           
		///           string? name;
		///           while ((name = sm.NextField.Name) != null) {
		///               dict[name] = sm.Sync(null, "");
		///           }
		///       } else { // Writing
		///           foreach (var pair in dict)
		///               sm.Sync(pair.Key, pair.Value);
		///       }
		///       return dict;
		///   }
		///   ]]></example>
		///   However, loading/storing a dictionary this way is not compatible with data 
		///   formats that don't use string field names, such as protocol buffers.
		/// </remarks>
		FieldId NextField { get; }

		/// <summary>Some serializers do not support this method (see remarks).
		///   If the method is supported, it determines whether a field with a specific
		///   name exists, and if so, what type it has.</summary>
		/// <param name="name">Name to search for in the current stream. If this 
		///   parameter is <see cref="FieldId.Missing"/> it is interpreted as a request 
		///   to get the type of the next field or the next list item, which is only 
		///   supported if (1) <see cref="SupportsNextField"/> or (2) 
		///   <see cref="SupportsReordering"/> and <see	cref="IsInsideList"/>. If 
		///   <see cref="NeedsIntegerIds"/> is true then the FieldId needs an id number 
		///   to search for. </param>
		/// <param name="expectedType">The type that the caller expects to encounter,
		///   or SyncType.Unknown if the caller has no preference.</param>
		/// <returns>
		///   Returns <see cref="SyncType.Missing"/> if the field does not exist, or
		///   if the field exists but the field's type is not implicitly convertible
		///   to the expected type.
		///   <para/>
		///   Returns <see cref="SyncType.Unknown"/> if it cannot be determined whether
		///   the field exists, or if this ISyncManager is not a reader (Mode != 
		///   SyncMode.Loading), or if <see cref="IsInsideList"/> is true.
		///   <para/>
		///   Otherwise, an appropriate value of <see cref="SyncType"/> is returned 
		///   according to the data in the data stream.
		/// </returns>
		/// <remarks>
		///   Generally, this method can provide useful information only if 
		///   <see cref="IsReading"/>, when (1) <see cref="SupportsReordering"/> is true or
		///   (2) name is <see cref="FieldId.Missing"/> and <see cref="SupportsNextField"/>.
		///   If these conditions are not met, the method normally returns SyncType.Unknown.
		///   <para/>
		///   The <see cref="SyncType"/> enumeration has a collection of common types that 
		///   are supported by most data formats. However, some formats may not support all 
		///   types, or may store data in a different form than you might reasonably expect. 
		///   For example, when a byte array is stored in JSON, it is stored as a string by
		///   default. When reading a byte array from JSON, GetFieldType will report that  
		///   the type is SyncType.String because even though the reader is capable of 
		///   decoding the string as a byte array, it cannot know that the string 
		///   represents a byte array. For this reason, the expectedType parameter exists
		///   as a filtering technique. You can set this parameter to SyncType.ByteList 
		///   to indicate that you expect to read a byte array. If the JSON data type is 
		///   boolean, which cannot be interpreted as a byte array, GetFieldType() returns 
		///   SyncType.Missing. But if the JSON data type is string, GetFieldType() returns 
		///   SyncType.String. This indicates that the data tream contains a String that 
		///   is potentially convertible to SyncType.ByteList, although the conversion is 
		///   not guaranteed to work. If you then read this field by calling
		///   <c>Sync(name, (byte[]) null)</c> and it turns out that the string cannot be 
		///   interpreted as a byte array, an exception will be thrown. After catching
		///   this exception, it may or may not be possible to continue reading from the 
		///   stream, depending on whether the <see cref="ISyncManager"/> was designed to
		///   keep working after that kind of failure.
		///   <para/>
		///   If a value is not implicitly convertible to the expectedType, GetFieldType
		///   should return SyncType.Missing even if the conversion is supported.
		///   For example, if the actual type is Char but a Byte was expected, the
		///   ISyncManager implementation may support this conversion by masking off 
		///   the lowest 8 bits, but it should return SyncType.Missing because this 
		///   kind of conversion loses information and may not be what the user 
		///   intended. (It may seem like this is somewhat in contradiction with the
		///   previous paragraph, because JSON pretends String matches ByteList even 
		///   though the conversion may fail. However, the fact that a ByteList is 
		///   stored as a String is an implementation detail that your code should
		///   not explicitly deal with, so GetFieldType must report that the conversion
		///   is supported in order not to confuse code that is unaware of the 
		///   implementation detail.)
		///   <para/>
		///   It is recommended that implementations of ISyncManager support an 
		///   implicit conversion from boolean to number, as well as conversions from 
		///   "smaller" to "bigger" number types.
		/// </remarks>
		SyncType GetFieldType(FieldId name, SyncType expectedType = SyncType.Unknown);

		/// <summary>Reads or writes a "type tag" for the current object. This method
		///   can only be called once after BeginSubObject returns true, and can only
		///   be called before synchronizing the first subfield (i.e. before calling
		///   any of the Sync() methods).</summary>
		/// <param name="tag">The type tag to write. If <see cref="IsWriting"/> is 
		///   false, this parameter is ignored.</param>
		/// <returns>When <see cref="IsReading"/> is true, the return value is the 
		///   tag stored in the data stream, or null if there is no tag. When 
		///   <see cref="IsReading"/> is false, the return value is <c>tag</c>.
		/// <remarks>
		///   If <see cref="SupportsNextField"/> is false, in order to read a data stream 
		///   correctly, you must call this method if and only if this method was called 
		///   when writing the stream.
		///   <para/>
		///   No behavior has been defined for this method in <see cref="SyncMode.Merge"/>
		///   mode, when <see cref="IsReading"/> and <see cref="IsWriting"/> are both true.
		/// </remarks>
		string? SyncTypeTag(string? tag);

		##unroll($T in basicTypes)
		{
			/// <summary>Reads or writes a value of a field on the current object.</summary>
			$T Sync(FieldId name, $T savable);
		}

		/// <summary>Reads or writes a value of a field on the current object.</summary>
		/// <remarks>Set mode to ObjectMode.Deduplicate to deduplicate the string, if supported 
		///   by the current instance of ISyncManager.</remarks>
		string? Sync(FieldId name, string? savablem, ObjectMode mode = ObjectMode.Normal);

		##unroll($T in bitfieldTypes)
		{
			/// <summary>Reads or writes a value of an integer bitfield on the current object.</summary>
			$T Sync(FieldId name, $T savable, int bits, bool signed = true);
		}
		
		##unroll($T in basicTypes)
		{
			/// <summary>Reads or writes a value of a nullable field on the current object.</summary>
			$T? Sync(FieldId name, $T? savable);
		}

		// This loop defines SyncListBoolImpl, SyncListCharImpl, and SyncListByteImpl.
		//
		// The design of these methods was a difficult compromise. On the one hand,
		// it would be nice to give ISyncManager the flexibility to use a special mode
		// or data format for any kind of list. For example, in JSON, byte arrays are 
		// commonly read or written as strings in Base64 or BAIS format, so ISyncManager 
		// needs to be able to read/write a list of bytes as a string.
		// 
		// However, I couldn't think of a way to allow this efficiently for any type.
		// I wanted to define methods like this:
		// 
		//     List<T>? SyncList<T, SyncField>(FieldId name, List<T>? savable, SyncField syncItem,
		//       ObjectMode listMode = ObjectMode.List, int tupleLength = -1)
		//         where SyncField : ISyncField<SyncManager, T>;
		//
		// This way, the ISyncManager would be able to inject special behavior for 
		// specific types fairly easily. Unfortunately, the constraint 
		// `SyncField : ISyncField<SyncManager, T>` is invalid since the concrete 
		// `SyncManager` type is not known in the context of `ISyncManager`. It would 
		// be *possible* to give `ISyncManager` its own type as a type parameter
		// (so SyncJson.Writer would implement `ISyncManager<SyncJson.Writer>`), but 
		// it wouldn't be reasonable to expect users of SyncLib to deal with this type 
		// parameter.
		// 
		// Instead I decided that there would be special Sync methods for lists of bytes,
		// characters, and booleans specifically, since these types are the most likely 
		// ones to benefit from special treatment: lists of characters and bytes can be
		// encoded as strings in JSON, and lists of booleans might be packed into 8 
		// booleans per byte in some output formats.
		//
		// These interface methods have type parameters, and interface methods with type 
		// parameters are normally slow (~3-4x slower than normal interface calls).
		// However, users can avoid this performance penalty by writing synchronizers in
		// a generic sync class like this:
		// 
		//     class MySynchronizers<SM> where SM : ISyncManager {
		//         public MyClass Sync(SM sm, MyClass data) { ... }
		//     }
		//
		// To write an implementation of `ISyncManager` that treats lists of bytes, bools
		// and chars like any other kind of list, please use the following code if `Mode` 
		// is `SyncMode.Writing`, replacing `Writer` with the name of your writer type:
		//
		//  public List? SyncListBoolImpl<Scanner, List, ListBuilder>(
		//  	FieldId name, Scanner scanner, List? saving, ListBuilder builder, ObjectMode mode, int tupleOrListLength = -1)
		//  	where Scanner : IScanner<bool>
		//  	where ListBuilder : IListBuilder<List, bool>
		//  {
		//  	var saver = new ScannerSaver<Writer, Scanner, bool, SyncPrimitive<Writer>>(new SyncPrimitive<Writer>(), mode);
		//  	saver.Write(ref this, name, scanner!, saving, tupleOrListLength);
		//  	return saving;
		//  }
		//  
		//  public List? SyncListByteImpl<Scanner, List, ListBuilder>(
		//  	FieldId name, Scanner scanner, List? saving, ListBuilder builder, ObjectMode mode, int tupleOrListLength = -1)
		//  	where Scanner : IScanner<byte>
		//  	where ListBuilder : IListBuilder<List, byte>
		//  {
		//  	var saver = new ScannerSaver<Writer, Scanner, byte, SyncPrimitive<Writer>>(new SyncPrimitive<Writer>(), mode);
		//  	saver.Write(ref this, name, scanner!, saving, tupleOrListLength);
		//  	return saving;
		//  }
		//  
		//  public List? SyncListCharImpl<Scanner, List, ListBuilder>(
		//  	FieldId name, Scanner scanner, List? saving, ListBuilder builder, ObjectMode mode, int tupleOrListLength = -1)
		//  	where Scanner : IScanner<char>
		//  	where ListBuilder : IListBuilder<List, char>
		//  {
		//  	var saver = new ScannerSaver<Writer, Scanner, char, SyncPrimitive<Writer>>(new SyncPrimitive<Writer>(), mode);
		//  	saver.Write(ref this, name, scanner!, saving, tupleOrListLength);
		//  	return saving;
		//  }
		//
		// Or use the following code if `Mode` is `SyncMode.Reading`, replacing `Reader`
		// with the name of your reader type:
		// 
		//  public List? SyncListBoolImpl<Scanner, List, ListBuilder>(
		//  	FieldId name, Scanner scanner, List? saving, ListBuilder builder, ObjectMode mode, int tupleLength = -1)
		//  	where Scanner : IScanner<bool>
		//  	where ListBuilder : IListBuilder<List, bool>
		//  {
		//  	var loader = new ListLoader<Reader, List, bool, ListBuilder, SyncPrimitive<Reader>>(new SyncPrimitive<Reader>(), builder, mode, tupleLength);
		//  	return loader.Sync(ref this, name, saving);
		//  }
		//  
		//  public List? SyncListByteImpl<Scanner, List, ListBuilder>(
		//  	FieldId name, Scanner scanner, List? saving, ListBuilder builder, ObjectMode mode, int tupleLength = -1)
		//  	where Scanner : IScanner<byte>
		//  	where ListBuilder : IListBuilder<List, byte>
		//  {
		//  	var loader = new ListLoader<Reader, List, byte, ListBuilder, SyncPrimitive<Reader>>(new SyncPrimitive<Reader>(), builder, mode, tupleLength);
		//  	return loader.Sync(ref this, name, saving);
		//  }
		//  
		//  public List? SyncListCharImpl<Scanner, List, ListBuilder>(
		//  	FieldId name, Scanner scanner, List? saving, ListBuilder builder, ObjectMode mode, int tupleLength = -1)
		//  	where Scanner : IScanner<char>
		//  	where ListBuilder : IListBuilder<List, char>
		//  {
		//  	var loader = new ListLoader<Reader, List, char, ListBuilder, SyncPrimitive<Reader>>(new SyncPrimitive<Reader>(), builder, mode, tupleLength);
		//  	return loader.Sync(ref this, name, saving);
		//  }
		##unroll($T in (bool, char, byte))
		{
			/// <summary>This method is used by SyncList() extension methods to read 
			///   or write an array. Users don't need to call it.</summary>
			/// <param name="list">The list that the caller wants to save.
			///   This parameter is ignored when not saving.</param>
			/// <param name="saving">The object being saved. This parameter is used to 
			///   produce an object ID for deduplication, and it can be null if the user 
			///   actually provided a null reference, or if the mode includes
			///   ObjectMode.NotNull and not ObjectMode.Deduplicate.</param>
			/// <param name="builder">A builder used to construct a new list when loading.
			///   This parameter is ignored when not loading.</param>
			/// <param name="tupleOrListLength">When `mode` includes `ObjectMode.Tuple`, this
			///   is a constant specifying the tuple length (which, if <see cref="IsWriting"/>,
			///   must match the list length). Otherwise, if `IsWriting`, this parameter must 
			///   specify the number of items that the `scanner` will return (i.e.
			///   `saving.Count`). Otherwise, this parameter is ignored.</param>
			/// <returns>Returns default(TList) in Saving, Query and Schema modes. 
			///   Otherwise, the data that was loaded via the builder is returned.</returns>
			/// <remarks>If you're trying to implement `ISyncManager`, please see the extra 
			///   documentation above this method in ISyncManager.ecs in SyncLib's GitHub 
			///   repo.</remarks>
			List? $(out NameWithType(SyncList, $T, Impl))<Scanner, List, ListBuilder>
				(FieldId name, Scanner scanner, List? saving, ListBuilder builder, ObjectMode mode, int tupleOrListLength = -1)
				where Scanner : IScanner<$T>
				where ListBuilder : IListBuilder<List, $T>;
		}

		/// <summary>Sets the "current object" reference. This property must be set
		///   when deserializing object graphs with cycles (see remarks).</summary>
		/// <remarks>
		///   To understand why this property is needed, consider a Person class that 
		///   has a reference to all the Siblings of the person:
		///   <code>
		///     class Person
		///     {
		///         public string Name;
		///         public int Age;
		///         public Person[] Siblings;
		///     }
		///   </code>
		///   If Jack and Jill are siblings then Jack has a reference to Jill, and Jill 
		///   has a reference back to Jack. A naive implementation of a synchronization 
		///   function for Person might look like this:
		///   <code>
		///     public Person SyncPerson(ISyncManager sync, Person obj)
		///     {
		///         obj ??= new Person();
		///         obj.Name     = sync.SyncNullable("Name", obj.Name);
		///         obj.Age      = sync.Sync("Age", obj.Age);
		///         obj.Siblings = sync.SyncList("Siblings", obj.Siblings, SyncPerson);
		///     }
		///   </code>
		///   But it's impossible for this function to load a Person correctly! To 
		///   understand why, let's think about what <c>SyncList</c> does: it reads a 
		///   list of Persons (synchronously), and returns a <c>Person[]</c>. But each 
		///   Person in that array contains a reference back to the current person. If 
		///   Jack is being loaded, then the <c>Person[]</c> contains Jill, which has a 
		///   reference back to Jack.
		///   <para/>
		///   But <c>SyncList</c> can't return an array that has a reference to Jack, 
		///   because the reference to Jack only exists in the local variable <c>obj</c>.
		///   So as the <c>SyncList</c> method deserializes Jill, Jill's synchronizer 
		///   must fail while reading Jill's list of siblings.
		///   <para/>
		///   To fix this, set <c>CurrentObject</c> before calling <c>SyncList</c>:
		///   <code>
		///     public Person SyncPerson(ISyncManager sync, Person obj)
		///     {
		///         sync.CurrentObject = obj ??= new Person();
		///         obj.Name     = sync.SyncNullable("Name", obj.Name);
		///         obj.Age      = sync.Sync("Age", obj.Age);
		///         obj.Siblings = sync.SyncList("Siblings", obj.Siblings, SyncPerson);
		///     }
		///   </code>
		///   If the current type cannot contain any objects that may refer back to 
		///   itself, then setting <see cref="CurrentObject"/> is optional.
		/// </remarks>
		object CurrentObject { set; }

		/// <summary>Attempts to begin reading or writing a sub-object. This is a
		///   low-level method; end-users normally should not call it! Be sure to 
		///   fully read the documentation before use.</summary>
		/// <param name="name">The name of the property being loaded or saved in
		///   the current object.</param>
		/// <param name="childKey">If the current Mode is Saving or Query, this 
		///   must be a reference that represents the object being saved, or null 
		///   if the object is null. In Loading mode (and sometimes in Schema mode), 
		///   <see cref="ISyncManager"/> ignores this parameter. If a value type is
		///   being read/written, you can set this parameter to null to avoid a
		///   memory allocation for boxing, but only if you use a mode that includes 
		///   ObjectMode.NotNull and not ObjectMode.Deduplicate.</param>
		/// <param name="mode">See <see cref="ObjectMode"/> for information 
		///   about the possible modes. When ObjectMode.NotNull is present and
		///   ObjectMode.Deduplicate is absent, the value of childKey is ignored.</param>
		/// <param name="listLength">If a variable-length list is being written
		///   (i.e. <c>(mode & ObjectMode.List) != 0 && Mode is SyncMode.Saving 
		///   or SyncMode.Query</c>), this must specify the list length. 
		///   Implementations of this interface that use delimiters (e.g. JSON) 
		///   will ignore this parameter, but others will write the length to the 
		///   output stream at the beginning of the list.</param>
		/// <returns>
		///   The boolean value is true if the request to read/write is approved.
		///   In this case you are expected to write the contents of the object and 
		///   then call <see cref="EndSubObject()"/>. If the boolean is false, 
		///   the request was declined and you MUST NOT write the fields of the 
		///   sub-object, and you MUST NOT call <see cref="EndSubObject()"/>.
		///   <para/>
		///   The second return value, the Length, is relevant only when reading,
		///   and only when Begun is true. If Begun is false, you should always
		///   ignore the value. When reading a normal object, Length will be 1.
		///   When reading a tuple, Length will be equal to the listLength parameter 
		///   that the caller provided. When reading a list, the return value is 
		///   either 
		///   (1) int.MaxValue, if the list length is unknown when the process of 
		///       reading the list begins (e.g. JSON).
		///   (2) some other value indicating the list length that was read from 
		///       the input stream (e.g. SyncBinary).
		///   <para/>
		///   The third return value is a reference to a deduplicated object,
		///   a reference to childKey, or null, depending on the situation (see
		///   remarks).
		///   <para/>
		///   When calling <see cref="BeginList"/> with a <c>listLength</c> parameter,
		///   there is a third return value, the list length, which is the number 
		///   of elements you are expected to read or write. 
		/// </returns>
		/// <exception cref="ArgumentException">
		///   <c>mode</c> includes <c>ObjectMode.List</c>, <c>listLength</c> was 
		///   negative, and <c>Mode is SyncMode.Saving or SyncMode.Query</c>.
		///   Implementations that don't require the list length in advance do not
		///   necessarily throw this exception.
		/// </exception>
		/// <exception cref="FormatException">
		///   The <see cref="Mode"/> is Reading or Merge and the input stream is 
		///   invalid or does not contain an object or list by the specified name,
		///   so it is impossible to fulfill the request.
		/// </exception>
		/// <remarks>
		///   Typical implementations of <see cref="ISyncManager"/> are used via helper
		///   methods that call this method and write a single object. For example,
		///   <see cref="SyncJson.Write"/> and <see cref="SyncManagerExt.Sync{SM, SyncField, T}(SM, FieldId, T?, SyncField)"/>
		///   call both BeginSubObject and EndSubObject for you automatically.
		///   Please see the remarks of <see cref="Depth"/> about what happens when 
		///   this method is <b>not</b> called.
		///   <para/>
		///   This method has six possible outcomes:
		///   (1) The request to read/write is approved. In this case, this method
		///       returns (true, childKey) and <see cref="Depth"/> increases by one.
		///       childKey is the same reference you passed to this method.
		///   (2) You set childKey = null and <see cref="Mode"/> is not Loading.
		///       (also, <c>(mode & (ObjectMode.NotNull | ObjectMode.Deduplicate)) 
		///       != ObjectMode.NotNull</c>). This indicates that no child object 
		///       exists, so this method returns (false, null).
		///   (3) The <see cref="Mode"/> is Loading and the input stream contains a 
		///       representation of null, so this method returns (false, null).
		///   (4) The list/tuple being read/write has already been read/written 
		///       earlier, and you enabled deduplication, so the request to 
		///       read/write is declined. In this case, this method returns false 
		///       with a reference to the object that was loaded or saved earlier.
		///   (5) The <see cref="Mode"/> is Query, Schema or Merge and the current 
		///       <see cref="ISyncManager"/> has decided not to traverse into the 
		///       current field. In this case, this method returns (false, childKey).
		///   (6) An exception is thrown if the input stream doesn't contain a 
		///       list/object as expected, or if you're writing a list without 
		///       providing <c>listLength</c>.
		///   <para/>
		///   In Saving mode, and in every case except 4, the returned Object is 
		///   the same as childKey.
		/// </remarks>
		(bool Begun, int Length, object? Object) BeginSubObject(FieldId name, object? childKey, ObjectMode mode, int listLength = -1);

		/// <summary>
		/// If you called <see cref="BeginSubObject"/> and it returned true, you 
		/// must call this method when you're done loading/saving the sub-object. 
		/// Do not call this method otherwise.
		/// </summary>
		void EndSubObject();

		/// <summary>If the current mode is Query or Merge, this method may add
		/// constraints to a query according to the scope of the query being 
		/// processed.</summary>
		//IQueryable<T>? QueryFilter(FieldId name, IQueryable<T> list);
	}

	public static partial class SyncManagerExt
	{
		##unroll($T in standardTypes)
		{
			public static $T SyncRef<SyncManager>(this SyncManager sync, FieldId name, ref $T field) 
				where SyncManager : ISyncManager
				=> field = sync.Sync(name, field);
		}

		##unroll($T in standardTypes)
		{
			// Generate a call to SyncListByteImpl, SyncListBoolImpl or SyncListCharImpl if 
			// applicable; otherwise sync using SyncList<SM, $T, SyncPrimitive<SM>>.
			static if ($T `staticMatches` byte || $T `staticMatches` char || $T `staticMatches` bool) {

				[@`%newline`, @`%SLComment`(concat(NameWithType(" SyncList methods for ", $T)))]
				public static $T[]? SyncList<SyncManager>(this SyncManager sync,
					FieldId name, $T[]? savable, ObjectMode listMode = ObjectMode.List, int tupleOrListLength = -1)
					where SyncManager : ISyncManager
				{
					InternalList.Scanner<$T> scanner = default;
					if (savable != null) {
						scanner = new InternalList.Scanner<$T>(savable.AsMemory());
						tupleOrListLength = savable.Length;
					}
					return sync.$(out NameWithType(SyncList, $T, Impl))<InternalList.Scanner<$T>, $T[], ArrayBuilder<$T>>(
						name, scanner, savable, new ArrayBuilder<$T>(), listMode, tupleOrListLength);
				}
				##unroll(($List, $SyncList) in (
					(#type<List<$T>? >, SyncList),
					(#type<IList<$T>? >, SyncList),
					(#type<IReadOnlyList<$T>? >, SyncList),
					(#type<ICollection<$T>? >, SyncColl),
					(#type<IReadOnlyCollection<$T>? >, SyncColl)
				)) {
					public static $List SyncList<SyncManager>(this SyncManager sync,
						FieldId name, $List savable, ObjectMode listMode = ObjectMode.List, int tupleOrListLength = -1)
						where SyncManager : ISyncManager
					{
						var scanner = default(ScannableEnumerable<$T>.Scanner<IEnumerator<$T>>);
						if (savable != null && sync.IsWriting) {
							scanner = new ScannableEnumerable<$T>.Scanner<IEnumerator<$T>>(savable.GetEnumerator());
							tupleOrListLength = savable.Count;
						}
						return sync.$(out NameWithType(SyncList, $T, Impl))<ScannableEnumerable<$T>.Scanner<IEnumerator<$T>>, $List, ListBuilder<$T>>(
							name, scanner, savable, new ListBuilder<$T>(), listMode, tupleOrListLength);
					}
				}
				public static Memory<$T> SyncList<SyncManager>(this SyncManager sync,
					FieldId name, Memory<$T> savable, ObjectMode listMode = ObjectMode.List, int tupleOrListLength = -1)
					where SyncManager : ISyncManager
				{
					if ((listMode & ObjectMode.Deduplicate) != 0)
						throw new ArgumentException("ObjectMode.Deduplicate is incompatible with Memory<T>");
					if (tupleOrListLength <= -1)
						tupleOrListLength = savable.Length;
					var scanner = new InternalList.Scanner<$T>(savable);
					return sync.$(out NameWithType(SyncList, $T, Impl))<InternalList.Scanner<$T>, Memory<$T>, MemoryBuilder<$T>>(
						name, scanner, null, new MemoryBuilder<$T>(), listMode | ObjectMode.NotNull, tupleOrListLength);
				}
				public static ReadOnlyMemory<$T> SyncList<SyncManager>(this SyncManager sync,
					FieldId name, ReadOnlyMemory<$T> savable, ObjectMode listMode = ObjectMode.List, int tupleOrListLength = -1)
					where SyncManager : ISyncManager
				{
					if ((listMode & ObjectMode.Deduplicate) != 0)
						throw new ArgumentException("ObjectMode.Deduplicate is incompatible with ReadOnlyMemory<T>");
					if (tupleOrListLength <= -1)
						tupleOrListLength = savable.Length;
					var scanner = new InternalList.Scanner<$T>(savable);
					return sync.$(out NameWithType(SyncList, $T, Impl))<InternalList.Scanner<$T>, ReadOnlyMemory<$T>, MemoryBuilder<$T>>(
						name, scanner, null, new MemoryBuilder<$T>(), listMode | ObjectMode.NotNull, tupleOrListLength);
				}
				public static IListSource<$T> SyncList<SyncManager>(this SyncManager sync,
					FieldId name, IListSource<$T> savable, ObjectMode listMode = ObjectMode.List, int tupleOrListLength = -1)
					where SyncManager : ISyncManager
				{
					var scanner = default(ScannableEnumerable<$T>.Scanner<IEnumerator<$T>>);
					if (savable != null && sync.IsWriting) {
						scanner = new ScannableEnumerable<$T>.Scanner<IEnumerator<$T>>(savable.GetEnumerator());
						tupleOrListLength = savable.Count;
					}
					var builder = new CollectionBuilder<DList<$T>, $T>(minLen => minLen > 0 ? new DList<$T>(minLen) : new DList<$T>());
					return sync.$(out NameWithType(SyncList, $T, Impl))<ScannableEnumerable<$T>.Scanner<IEnumerator<$T>>, IListSource<$T>, CollectionBuilder<DList<$T>, $T>>(
						name, scanner, savable, builder, listMode, tupleOrListLength);
				}
			} else {
				[@`%newline`, @`%SLComment`(concat(NameWithType(" SyncList methods for ", $T)))] #rawText("");
				##unroll(($List, $SyncList) in (
				    (#type<$T[]? >, SyncList),
				    (#type<List<$T>? >, SyncList), (#type<IList<$T>? >, SyncList),
				    (#type<IReadOnlyList<$T>? >, SyncList), (#type<IListSource<$T>? >, SyncList),
				    (#type<ICollection<$T>? >, SyncColl), (#type<IReadOnlyCollection<$T>? >, SyncColl),
				    (#type<HashSet<$T>? >, SyncColl), 
				    (ReadOnlyMemory<$T>, SyncMemory), (Memory<$T>, SyncMemory)
				)) {
					public static $List SyncList<SM>(this SM sync,
						FieldId name, $List savable,
						ObjectMode listMode = ObjectMode.List, int tupleOrListLength = -1)
							where SM : ISyncManager
						=> new SyncList<SM, $T, SyncPrimitive<SM>>(new SyncPrimitive<SM>(), listMode, tupleOrListLength)
						    .Sync(ref sync, name, savable);
				}
			}
		}
	}

	##unroll($T in standardTypes)
	{
		/// <summary>The methods in this class belong in <see cref="SyncManagerExt"/> but they 
		/// must be put in a different class to avoid C# compiler error CS0111, 
		/// "Type 'SyncManagerExt' already defines a member called 'SyncList' with the same parameter types".</summary>
		public static partial class $(out NameWithType(SyncManagerExt, $T)) {
			static if ($T `staticMatches` byte || $T `staticMatches` char || $T `staticMatches` bool) {
				public static List? SyncColl<SyncManager, List>(this SyncManager sync,
					FieldId name, List? savable, Func<int, List> alloc, ObjectMode listMode = ObjectMode.List, int tupleLength = -1)
					where SyncManager : ISyncManager
					where List : ICollection<$T>, IReadOnlyCollection<$T>
				{
					InternalList.Scanner<$T> scanner = Empty<$T>.Scanner;
					if (savable != null)
						scanner = Loyc.Collections.MutableListExtensionMethods.LinqToLists.ToArray(savable).Slice(0).Scan();
					return sync.$(out NameWithType(SyncList, $T, Impl))(name, scanner, savable, new CollectionBuilder<List, $T>(alloc), listMode, tupleLength);
				}
			} else {
				public static Coll? SyncColl<SM, Coll, SyncField>(this SM sync,
					FieldId name, Coll? savable, SyncField syncItem, Func<int, Coll> alloc,
					ObjectMode listMode = ObjectMode.List, int tupleLength = -1)
						where SM : ISyncManager
						where Coll : ICollection<$T>
						where SyncField : ISyncField<SM, $T>
					=> new SyncList<SM, $T, Coll, SyncField>(syncItem, listMode, tupleLength, alloc).Sync(ref sync, name, savable);
			}
		}
	}
}
